@Test { » Default Advisor Auto Proxy Creator « aapc = ( » Default Advisor Auto Proxy Creator « ) » get Bean Factory « ( ) . » get Bean « ( » ADVISOR _ APC _ BEAN _ NAME « ) ; » assert That « ( aapc . » get Advisor Bean Name Prefix « ( ) ) . » is Equal To « ( ( » ADVISOR _ APC _ BEAN _ NAME « + » Default Advisor Auto Proxy Creator « . SEPARATOR ) ) ; » assert That « ( aapc . » is Use Prefix « ( ) ) . » is False « ( ) ; }
@Test { » Bean Factory « bf = » get Bean Factory « ( ) ; Object o = bf . » get Bean « ( " » no Setters « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( o ) ) . » is False « ( ) ; }
@Test { » Bean Factory « bf = » get Bean Factory « ( ) ; » I Test Bean « test = ( » I Test Bean « ) bf . » get Bean « ( " test " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( test ) ) . » is True « ( ) ; }
@Test { » Bean Factory « bf = » get Bean Factory « ( ) ; » I Test Bean « test = ( » I Test Bean « ) bf . » get Bean « ( " test " ) ; » Method Counter « counter = ( » Method Counter « ) bf . » get Bean « ( " » counting Advice « " ) ; » assert That « ( counter . » get Calls « ( ) ) . » is Equal To « ( 0 ) ; test . » get Name « ( ) ; » assert That « ( counter . » get Calls « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Component cp = » get Bionic Family « ( ) ; » assert That « ( " Bionic - 1 " ) . » is Equal To « ( cp . » get Name « ( ) ) ; }
@Test { Component cp = » get Bionic Family « ( ) ; List < Component > components = cp . » get Components « ( ) ; » assert That « ( 2 ) . » is Equal To « ( components . size ( ) ) ; » assert That « ( " Mother - 1 " ) . » is Equal To « ( components . get ( 0 ) . » get Name « ( ) ) ; » assert That « ( " Rock - 1 " ) . » is Equal To « ( components . get ( 1 ) . » get Name « ( ) ) ; }
@Test { Component cp = » get Bionic Family « ( ) ; List < Component > components = cp . » get Components « ( ) . get ( 0 ) . » get Components « ( ) ; » assert That « ( 2 ) . » is Equal To « ( components . size ( ) ) ; » assert That « ( " Karate - 1 " ) . » is Equal To « ( components . get ( 0 ) . » get Name « ( ) ) ; » assert That « ( " Sport - 1 " ) . » is Equal To « ( components . get ( 1 ) . » get Name « ( ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class , » Proxy Target Class Caching Config « . class ) ; ctx . refresh ( ) ; » assert Cache Proxying « ( ctx ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( ctx . » get Bean « ( » Foo Repository « . class ) ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class , » Aspect J Cache Config « . class ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ctx :: refresh ) . » with Message Containing « ( " » Aspect J Caching Configuration « " ) ; }
@Test { » Application Context « context = » create Context « ( » Scoped Proxy Mode « . NO ) ; » Scoped Test Bean « bean = ( » Scoped Test Bean « ) context . » get Bean « ( " prototype " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » assert That « ( context . » is Prototype « ( " prototype " ) ) . » is True « ( ) ; » assert That « ( context . » is Singleton « ( " prototype " ) ) . » is False « ( ) ; }
@Test { » Configurable Application Context « ctx = new » Generic Application Context « ( » new Bean Factory With Environment Aware Bean « ( ) ) ; ctx . refresh ( ) ; » assert Has Standard Environment « ( ctx ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , ctx . » get Environment « ( ) ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( » new Bean Factory With Environment Aware Bean « ( ) ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . refresh ( ) ; » assert Has Environment « ( ctx , » prod Env « ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , » prod Env « ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( ) ; ctx . » set Environment « ( » prod Env « ) ; new » Xml Bean Definition Reader « ( ctx ) . » load Bean Definitions « ( » XML _ PATH « ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » PROD _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( ) ; ctx . » set Environment « ( » prod Env « ) ; new » Annotated Bean Definition Reader « ( ctx ) . register ( Config . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » PROD _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( ) ; ctx . » set Environment « ( » prod Env « ) ; » Class Path Bean Definition Scanner « scanner = new » Class Path Bean Definition Scanner « ( ctx ) ; scanner . scan ( " org . springframework . core . env . » scan 1 « " ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » PROD _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Configurable Application Context « ctx = new » Class Path Xml Application Context « ( » XML _ PATH « ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . refresh ( ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Has Environment « ( ctx , » prod Env « ) ; » assert Environment Aware Invoked « ( ctx , ctx . » get Environment « ( ) ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » PROD _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; » assert Has Standard Environment « ( ctx ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . register ( » Environment Aware Bean « . class ) ; ctx . refresh ( ) ; » assert Environment Aware Invoked « ( ctx , » prod Env « ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; » assert Has Standard Environment « ( ctx ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . register ( » Prod Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » PROD _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; » assert Has Standard Environment « ( ctx ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . register ( » Dev Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » TRANSITIVE _ BEAN _ NAME « ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; » assert Has Standard Environment « ( ctx ) ; ctx . » set Environment « ( » dev Env « ) ; ctx . register ( » Dev Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( » TRANSITIVE _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » set Environment « ( » dev Env « ) ; ctx . register ( » Derived Dev Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » DERIVED _ DEV _ BEAN _ NAME « ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( » TRANSITIVE _ BEAN _ NAME « ) ) . » is False « ( ) ; }
@Test { » test Profile Expression « ( true , " » p 3 « " ) ; }
@Test { » test Profile Expression « ( true , " » p 1 « " , " » p 2 « " ) ; }
@Test { » test Profile Expression « ( false , " » p 1 « " ) ; }
@Test { » test Profile Expression « ( false , " » p 4 « " ) ; }
@Test { » Generic Web Application Context « ctx = new » Generic Web Application Context « ( » new Bean Factory With Environment Aware Bean « ( ) ) ; » assert Has Standard Servlet Environment « ( ctx ) ; ctx . » set Environment « ( » prod Web Env « ) ; ctx . refresh ( ) ; » assert Has Environment « ( ctx , » prod Web Env « ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , » prod Web Env « ) ; }
@Test { » Static Application Context « ctx = new » Static Application Context « ( ) ; » assert Has Standard Environment « ( ctx ) ; » register Environment Bean Definition « ( ctx ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . refresh ( ) ; » assert Has Environment « ( ctx , » prod Env « ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , » prod Env « ) ; }
@Test { » Static Web Application Context « ctx = new » Static Web Application Context « ( ) ; » assert Has Standard Servlet Environment « ( ctx ) ; » register Environment Bean Definition « ( ctx ) ; ctx . » set Environment « ( » prod Web Env « ) ; ctx . refresh ( ) ; » assert Has Environment « ( ctx , » prod Web Env « ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , » prod Web Env « ) ; }
@Test { » Annotation Config Web Application Context « ctx = new » Annotation Config Web Application Context « ( ) ; ctx . » set Environment « ( » prod Web Env « ) ; ctx . » set Config Location « ( » Environment Aware Bean « . class . » get Name « ( ) ) ; ctx . refresh ( ) ; » assert Has Environment « ( ctx , » prod Web Env « ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , » prod Web Env « ) ; }
@Test { » Resource Adapter Application Context « ctx = new » Resource Adapter Application Context « ( new » Simple Bootstrap Context « ( new » Simple Task Work Manager « ( ) ) ) ; » assert Has Standard Environment « ( ctx ) ; » register Environment Bean Definition « ( ctx ) ; ctx . » set Environment « ( » prod Env « ) ; ctx . refresh ( ) ; » assert Has Environment « ( ctx , » prod Env « ) ; » assert Environment Bean Registered « ( ctx ) ; » assert Environment Aware Invoked « ( ctx , » prod Env « ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( ) ; ctx . » register Bean Definition « ( " ppc " , » root Bean Definition « ( org . springframework . beans . factory . config . » Property Placeholder Configurer « . class ) . » add Property Value « ( " » search System Environment « " , false ) . » get Bean Definition « ( ) ) ; ctx . refresh ( ) ; ctx . » get Bean « ( " ppc " ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class , » Jdk Proxy Tx Config « . class , » Repo Config A « . class ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ctx :: refresh ) . satisfies ( ex -> » assert That « ( ex . » get Root Cause « ( ) ) . » is Instance Of « ( » Illegal State Exception « . class ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Aspect Config « . class , » My Repository With Scheduled Method Impl « . class ) ; ctx . refresh ( ) ; Thread . sleep ( 100 ) ; » My Repository With Scheduled Method « repository = ctx . » get Bean « ( » My Repository With Scheduled Method « . class ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( repository ) ) . » is True « ( ) ; » assert That « ( repository . » get Invocation Count « ( ) ) . » is Greater Than « ( 0 ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( Config . class ) ; » assert That « ( » is Tx Proxy « ( ctx . » get Bean « ( » Foo Repository « . class ) ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( Config . class , » Default Tx Manager Name Config « . class ) ; » assert Tx Proxying « ( ctx ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( Config . class , » Custom Tx Manager Name Config « . class ) ; » assert Tx Proxying « ( ctx ) ; }
@Test { » assert Tx Proxying « ( new » Annotation Config Application Context « ( Config . class , » Non Conventional Tx Manager Name Config « . class ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( Config . class , » Proxy Target Class Tx Config « . class ) ; » assert Tx Proxying « ( ctx ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( ctx . » get Bean « ( » Foo Repository « . class ) ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class , » Aspect J Tx Config « . class ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ctx :: refresh ) . » with Message Containing « ( " » Aspect J Jta Transaction Management Configuration « " ) ; }
@Test { new » Annotation Config Application Context « ( » Enable Tx And Caching Config « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » PTC True « . class , » Annotated Service Without Interface « . class ) ; ctx . refresh ( ) ; » Annotated Service Without Interface « s = ctx . » get Bean « ( » Annotated Service Without Interface « . class ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( s ) ) . » is True « ( ) ; » assert That « ( s ) . » is Instance Of « ( » Annotated Service Without Interface « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » PTC False « . class , » Annotated Service Without Interface « . class ) ; ctx . refresh ( ) ; » Annotated Service Without Interface « s = ctx . » get Bean « ( » Annotated Service Without Interface « . class ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( s ) ) . » is True « ( ) ; » assert That « ( s ) . » is Instance Of « ( » Annotated Service Without Interface « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » PTC True « . class , » Annotated Service Impl « . class ) ; ctx . refresh ( ) ; » Non Annotated Service « s = ctx . » get Bean « ( » Non Annotated Service « . class ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( s ) ) . » is True « ( ) ; » assert That « ( s ) . » is Instance Of « ( » Annotated Service Impl « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » PTC False « . class , » Annotated Service Impl « . class ) ; ctx . refresh ( ) ; » Non Annotated Service « s = ctx . » get Bean « ( » Non Annotated Service « . class ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( s ) ) . » is True « ( ) ; » assert That « ( s ) . » is Not Instance Of « ( » Annotated Service Impl « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » PTC True « . class , » Non Annotated Service Impl « . class ) ; ctx . refresh ( ) ; » Annotated Service « s = ctx . » get Bean « ( » Annotated Service « . class ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( s ) ) . » is True « ( ) ; » assert That « ( s ) . » is Instance Of « ( » Non Annotated Service Impl « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » PTC False « . class , » Non Annotated Service Impl « . class ) ; ctx . refresh ( ) ; » Annotated Service « s = ctx . » get Bean « ( » Annotated Service « . class ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( s ) ) . » is True « ( ) ; » assert That « ( s ) . » is Not Instance Of « ( » Non Annotated Service Impl « . class ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » pjp And An Annotation « " ) , " execution ( * * ( . . ) ) && @ annotation ( ann ) " , new String [ ] { " » this Join Point « " , " ann " } ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Type Pattern Class Filter « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Type Pattern Class Filter « ( " - " ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Type Pattern Class Filter « ( ) . matches ( String . class ) ) ; }
@Test { » Type Pattern Class Filter « » filter 1 « = new » Type Pattern Class Filter « ( " org . springframework . beans . testfixture . beans . * " ) ; » Type Pattern Class Filter « » filter 2 « = new » Type Pattern Class Filter « ( " org . springframework . beans . testfixture . beans . * " ) ; » Type Pattern Class Filter « » filter 3 « = new » Type Pattern Class Filter « ( " org . springframework . tests . * " ) ; » assert That « ( » filter 1 « ) . » is Equal To « ( » filter 2 « ) ; » assert That « ( » filter 1 « ) . » is Not Equal To « ( » filter 3 « ) ; }
@Test { » Test Service « target = new » Test Service Impl « ( ) ; » Log User Advice « » log Advice « = new » Log User Advice « ( ) ; » test Advice « ( new » Default Pointcut Advisor « ( » log Advice « ) , » log Advice « , target , " » Test Service Impl « " ) ; }
@Test { » Test Service « target = new » Test Service Impl « ( ) ; » Log User Advice « » log Advice « = new » Log User Advice « ( ) ; » Aspect J Expression Pointcut « pointcut = new » Aspect J Expression Pointcut « ( ) ; pointcut . » set Expression « ( String . format ( " execution ( * % s . » Test Service « . * ( . . ) ) " , » get Class « ( ) . » get Name « ( ) ) ) ; » test Advice « ( new » Default Pointcut Advisor « ( pointcut , » log Advice « ) , » log Advice « , target , " » Test Service Impl « " ) ; }
@Test { » Test Service « target = new » Test Service Impl « ( ) ; » Log User Advice « » log Advice « = new » Log User Advice « ( ) ; » Aspect J Expression Pointcut « pointcut = new » Aspect J Expression Pointcut « ( ) ; pointcut . » set Expression « ( String . format ( " @ within ( % s . Log ) " , » get Class « ( ) . » get Name « ( ) ) ) ; » test Advice « ( new » Default Pointcut Advisor « ( pointcut , » log Advice « ) , » log Advice « , target , " » Test Service Impl « " ) ; }
@Test { » Test Service « target = new » Test Service Impl « ( ) ; » Log User Advice « » log Advice « = new » Log User Advice « ( ) ; » Aspect J Expression Pointcut « pointcut = new » Aspect J Expression Pointcut « ( ) ; pointcut . » set Expression « ( String . format ( " @ within ( % s . Log ) " , » get Class « ( ) . » get Name « ( ) ) ) ; » test Advice « ( new » Default Pointcut Advisor « ( pointcut , » log Advice « ) , » log Advice « , target , " » Test Service Impl « " , true ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » Abstract Aspect J Advice « :: » current Join Point « ) ; }
@Test { String expression = " @ within ( test . annotation . transaction . Tx ) " ; » test Match Annotation On Class « ( expression ) ; }
@Test { String expression = " within ( @ test . annotation . transaction . Tx * ) " ; » test Match Annotation On Class « ( expression ) ; }
@Test { String expression = " within ( @ ( test . annotation . transaction . * ) * ) " ; » test Match Annotation On Class « ( expression ) ; }
@Test { String expression = " @ annotation ( test . annotation . transaction . Tx ) " ; » Aspect J Expression Pointcut « ajexp = new » Aspect J Expression Pointcut « ( ) ; ajexp . » set Expression « ( expression ) ; » Proxy Factory « factory = new » Proxy Factory « ( new » Bean A « ( ) ) ; factory . » set Proxy Target Class « ( true ) ; » Bean A « proxy = ( » Bean A « ) factory . » get Proxy « ( ) ; » assert That « ( ajexp . matches ( » Bean A « . class . » get Method « ( " » get Age « " ) , proxy . » get Class « ( ) ) ) . » is True « ( ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » no Args « " ) , " execution ( * * ( . . ) ) " , new String [ 0 ] ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " tjp " ) , " execution ( * * ( . . ) ) " , new String [ ] { " » this Join Point « " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " tjpsp " ) , " execution ( * * ( . . ) ) " , new String [ ] { " » this Join Point Static Part « " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » two Join Points « " ) , " foo ( ) " , » Illegal State Exception « . class , " Failed to bind all argument names : 1 argument ( s ) could not be bound " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Throwable « " ) , " foo ( ) " , null , " ex " , new String [ ] { " ex " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » jp And One Throwable « " ) , " foo ( ) " , null , " ex " , new String [ ] { " » this Join Point « " , " ex " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » jp And Two Throwables « " ) , " foo ( ) " , null , " ex " , » Ambiguous Binding Exception « . class , " Binding of throwing parameter 'ex' is ambiguous : could be bound to argument 1 or argument 2 " ) ; }
@Test { » assert Exception « ( » get Method « ( " » no Args « " ) , " foo ( ) " , null , " ex " , » Illegal State Exception « . class , " Not enough arguments in method to satisfy binding of returning and throwing variables " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Object « " ) , " foo ( ) " , " obj " , null , new String [ ] { " obj " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » two Objects « " ) , " foo ( ) " , " obj " , null , » Ambiguous Binding Exception « . class , " Binding of returning parameter 'obj' is ambiguous , there are 2 candidates . " ) ; }
@Test { » assert Exception « ( » get Method « ( " » no Args « " ) , " foo ( ) " , " obj " , null , » Illegal State Exception « . class , " Not enough arguments in method to satisfy binding of returning and throwing variables " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Object « " ) , " this ( x ) " , new String [ ] { " x " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Object « " ) , " this ( x ) || this ( y ) " , » Ambiguous Binding Exception « . class , " Found 2 candidate this ( ) , target ( ) or args ( ) variables but only one unbound argument slot " ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Object « " ) , " this ( " , » Illegal State Exception « . class , " Failed to bind all argument names : 1 argument ( s ) could not be bound " ) ; » assert Exception « ( » get Method « ( " » one Object « " ) , " this ( x && foo ( ) " , » Illegal State Exception « . class , " Failed to bind all argument names : 1 argument ( s ) could not be bound " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Object « " ) , " target ( x ) " , new String [ ] { " x " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Object « " ) , " target ( x ) || target ( y ) " , » Ambiguous Binding Exception « . class , " Found 2 candidate this ( ) , target ( ) or args ( ) variables but only one unbound argument slot " ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Object « " ) , " target ( " , » Illegal State Exception « . class , " Failed to bind all argument names : 1 argument ( s ) could not be bound " ) ; » assert Exception « ( » get Method « ( " » one Object « " ) , " target ( x && foo ( ) " , » Illegal State Exception « . class , " Failed to bind all argument names : 1 argument ( s ) could not be bound " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Object « " ) , " args ( x ) " , new String [ ] { " x " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Object « " ) , " args ( x , y ) " , » Ambiguous Binding Exception « . class , " Found 2 candidate this ( ) , target ( ) or args ( ) variables but only one unbound argument slot " ) ; }
@Test { » assert Exception « ( » get Method « ( " » two Objects « " ) , " args ( x , y ) " , » Ambiguous Binding Exception « . class , " Still 2 unbound args at this ( ) , target ( ) , args ( ) binding stage , with no way to determine between them " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Primitive « " ) , " args ( count ) " , new String [ ] { " count " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Object One Primitive « " ) , " args ( count , obj ) " , » Ambiguous Binding Exception « . class , " Found 2 candidate variable names but only one candidate binding slot when matching primitive args " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Object One Primitive « " ) , " args ( count ) && this ( obj ) " , new String [ ] { " obj " , " count " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Object One Primitive « " ) , " args ( count ) && target ( obj ) " , new String [ ] { " obj " , " count " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Throwable One Primitive « " ) , " args ( count ) " , null , " ex " , new String [ ] { " ex " , " count " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » the Big One « " ) , " this ( foo ) && args ( x ) " , null , " ex " , new String [ ] { " » this Join Point « " , " ex " , " x " , " foo " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Primitive « " ) , " somepc ( foo ) " , new String [ ] { " foo " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Primitive « " ) , " call ( bar * ) && somepc ( foo ) " , new String [ ] { " foo " } ) ; » assert Parameter Names « ( » get Method « ( " » one Primitive « " ) , " somepc ( foo ) " , new String [ ] { " foo " } ) ; » assert Parameter Names « ( » get Method « ( " » one Primitive « " ) , " somepc ( foo ) " , new String [ ] { " foo " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Annotation « " ) , " @ this ( a ) " , new String [ ] { " a " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Annotation « " ) , " @ target ( a ) " , new String [ ] { " a " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Annotation « " ) , " @ args ( a ) " , new String [ ] { " a " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Annotation « " ) , " @ within ( a ) " , new String [ ] { " a " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Annotation « " ) , " @ withincode ( a ) " , new String [ ] { " a " } ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » one Annotation « " ) , " @ annotation ( a ) " , new String [ ] { " a " } ) ; }
@Test { » assert Exception « ( » get Method « ( " » two Annotations « " ) , " @ annotation ( a ) && @ this ( x ) " , » Ambiguous Binding Exception « . class , " Found 2 potential annotation variable ( s ) , and 2 potential argument slots " ) ; }
@Test { » assert Exception « ( » get Method « ( " » one Annotation « " ) , " @ annotation ( a ) && @ this ( x ) " , » Illegal Argument Exception « . class , " Found 2 candidate annotation binding variables but only one potential argument binding slot " ) ; }
@Test { » assert Parameter Names « ( » get Method « ( " » annotation Medley « " ) , " @ annotation ( a ) && args ( count ) && this ( foo ) " , null , " ex " , new String [ ] { " ex " , " foo " , " count " , " a " } ) ; }
@Test { » test This Or Target « ( " this " ) ; }
@Test { » test This Or Target « ( " target " ) ; }
@Test { » test Within Package « ( false ) ; }
@Test { » test Within Package « ( true ) ; }
@Test { » Aspect J Expression Pointcut « pc = new » Aspect J Expression Pointcut « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> pc . matches ( » I Test Bean « . class ) ) . » with Message Containing « ( " expression " ) ; }
@Test { » Aspect J Expression Pointcut « pc = new » Aspect J Expression Pointcut « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> pc . matches ( » get Age « , » I Test Bean « . class ) ) . » with Message Containing « ( " expression " ) ; }
@Test { » Aspect J Expression Pointcut « pc = new » Aspect J Expression Pointcut « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> pc . matches ( » get Age « , » I Test Bean « . class , ( Object [ ] ) null ) ) . » with Message Containing « ( " expression " ) ; }
@Test { String expression = " execution ( void org . springframework . beans . testfixture . beans . » Test Bean « . » set Some Number « ( Number ) && args ( Double ) " ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » get Pointcut « ( expression ) :: » get Class Filter « ) ; }
@Test { String expression = " call ( int org . springframework . beans . testfixture . beans . » Test Bean « . » get Age « ( ) ) " ; » assert That Exception Of Type « ( » Unsupported Pointcut Primitive Exception « . class ) . » is Thrown By « ( ( ) -> » get Pointcut « ( expression ) . » get Class Filter « ( ) ) . satisfies ( ex -> » assert That « ( ex . » get Unsupported Primitive « ( ) ) . » is Equal To « ( » Pointcut Primitive « . CALL ) ) ; }
@Test { Pointcut pc = » get Pointcut « ( " execution ( * * ( . . ) ) and args ( String ) " ) ; » Pointcut Expression « expr = ( ( » Aspect J Expression Pointcut « ) pc ) . » get Pointcut Expression « ( ) ; » assert That « ( expr . » get Pointcut Expression « ( ) ) . » is Equal To « ( " execution ( * * ( . . ) ) && args ( String ) " ) ; }
@Test { Pointcut pc = » get Pointcut « ( " execution ( * * ( . . ) ) and args ( String ) and this ( Object ) " ) ; » Pointcut Expression « expr = ( ( » Aspect J Expression Pointcut « ) pc ) . » get Pointcut Expression « ( ) ; » assert That « ( expr . » get Pointcut Expression « ( ) ) . » is Equal To « ( " execution ( * * ( . . ) ) && args ( String ) && this ( Object ) " ) ; }
@Test { » assert That Exception Of Type « ( » Aop Config Exception « . class ) . » is Thrown By « ( ( ) -> » get Fixture « ( ) . » get Advisors « ( new » Singleton Metadata Aware Aspect Instance Factory « ( new » Per Cflow Aspect « ( ) , " » some Bean « " ) ) ) . » with Message Containing « ( " PERCFLOW " ) ; }
@Test { » assert That Exception Of Type « ( » Aop Config Exception « . class ) . » is Thrown By « ( ( ) -> » get Fixture « ( ) . » get Advisors « ( new » Singleton Metadata Aware Aspect Instance Factory « ( new » Per Cflow Below Aspect « ( ) , " » some Bean « " ) ) ) . » with Message Containing « ( " PERCFLOWBELOW " ) ; }
@Test { » test Named Pointcuts « ( new » Named Pointcut Aspect With FQN « ( ) ) ; }
@Test { » test Named Pointcuts « ( new » Named Pointcut Aspect Without FQN « ( ) ) ; }
@Test { » test Named Pointcuts « ( new » Named Pointcut Aspect From Library « ( ) ) ; }
@Test { » Linked List « < Object > target = new » Linked List « < > ( ) ; List < ? > proxy = ( List < ? > ) » create Proxy « ( target , » Aop Utils « . » find Advisors That Can Apply « ( » get Fixture « ( ) . » get Advisors « ( new » Singleton Metadata Aware Aspect Instance Factory « ( new » Make Lockable « ( ) , " » some Bean « " ) ) , List . class ) , List . class ) ; » assert That « ( proxy instanceof Lockable ) . as ( " Type pattern must have excluded mixin " ) . » is False « ( ) ; }
@Test { » Annotated Target « target = new » Annotated Target Impl « ( ) ; List < Advisor > advisors = » get Fixture « ( ) . » get Advisors « ( new » Singleton Metadata Aware Aspect Instance Factory « ( new » Make Annotated Type Modifiable « ( ) , " » some Bean « " ) ) ; Object proxy = » create Proxy « ( target , advisors , » Annotated Target « . class ) ; System . out . println ( advisors . get ( 1 ) ) ; » assert That « ( proxy instanceof Lockable ) . » is True « ( ) ; Lockable lockable = ( Lockable ) proxy ; lockable . locked ( ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » Metadata Aware Aspect Instance Factory « » aspect Instance Factory « = new » Singleton Metadata Aware Aspect Instance Factory « ( new » No Declare Precedence Should Fail « ( ) , " » some Bean « " ) ; » I Test Bean « itb = ( » I Test Bean « ) » create Proxy « ( target , » get Fixture « ( ) . » get Advisors « ( » aspect Instance Factory « ) , » I Test Bean « . class ) ; itb . » get Age « ( ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { » Metadata Aware Aspect Instance Factory « » aspect Instance Factory « = new » Singleton Metadata Aware Aspect Instance Factory « ( new » Declare Precedence Should Succeed « ( ) , " » some Bean « " ) ; » create Proxy « ( target , » get Fixture « ( ) . » get Advisors « ( » aspect Instance Factory « ) , » I Test Bean « . class ) ; } ) ; }
@Test { » assert That Exception Of Type « ( » Aop Config Exception « . class ) . » is Thrown By « ( ( ) -> » test Illegal Instantiation Model « ( » Abstract Aspect J Advisor Factory Tests « . » Per Cflow Aspect « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Aop Config Exception « . class ) . » is Thrown By « ( ( ) -> » test Illegal Instantiation Model « ( » Abstract Aspect J Advisor Factory Tests « . » Per Cflow Below Aspect « . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Aspect Metadata « ( String . class , " » some Bean « " ) ) ; }
@Test { » Aspect Metadata « am = new » Aspect Metadata « ( » Exception Aspect « . class , " » some Bean « " ) ; » assert That « ( am . » is Per This Or Per Target « ( ) ) . » is False « ( ) ; » assert That « ( am . » get Per Clause Pointcut « ( ) ) . » is Same As « ( Pointcut . TRUE ) ; » assert That « ( am . » get Aj Type « ( ) . » get Per Clause « ( ) . » get Kind « ( ) ) . » is Equal To « ( » Per Clause Kind « . SINGLETON ) ; }
@Test { » Aspect J Proxy Factory « » proxy Factory « = new » Aspect J Proxy Factory « ( new » Test Bean « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » proxy Factory « . » add Aspect « ( » Test Bean « . class ) ) ; }
@Test { » Test Bean « bean = new » Test Bean « ( ) ; bean . » set Age « ( 2 ) ; » Aspect J Proxy Factory « » proxy Factory « = new » Aspect J Proxy Factory « ( bean ) ; » proxy Factory « . » add Aspect « ( » Multiply Return Value « . class ) ; » I Test Bean « proxy = » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . » get Age « ( ) ) . as ( " Multiplication did not occur " ) . » is Equal To « ( ( bean . » get Age « ( ) * 2 ) ) ; }
@Test { » Aspect J Proxy Factory « pf = new » Aspect J Proxy Factory « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> pf . » add Aspect « ( new » Test Bean « ( ) ) ) ; }
@Test { » Aspect J Proxy Factory « pf = new » Aspect J Proxy Factory « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> pf . » add Aspect « ( new » Per This Aspect « ( ) ) ) ; }
@Test { » Aspect J Proxy Factory « » proxy Factory « = new » Aspect J Proxy Factory « ( new » Test Bean « ( ) ) ; » proxy Factory « . » add Aspect « ( » Logging Aspect On Varargs « . class ) ; » I Test Bean « proxy = » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . » do With Varargs « ( » My Enum « . A , » My Other Enum « . C ) ) . » is True « ( ) ; }
@Test { » Aspect J Proxy Factory « » proxy Factory « = new » Aspect J Proxy Factory « ( new » Test Bean « ( ) ) ; » proxy Factory « . » add Aspect « ( » Logging Aspect On Setter « . class ) ; » I Test Bean « proxy = » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . » do With Varargs « ( » My Enum « . A , » My Other Enum « . C ) ) . » is True « ( ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; » Aspect J Proxy Factory « » proxy Factory « = new » Aspect J Proxy Factory « ( tb ) ; » proxy Factory « . » add Aspect « ( » Named Pointcut With Args « . class ) ; » I Test Bean « » proxied Test Bean « = » proxy Factory « . » get Proxy « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » proxied Test Bean « . » set Name « ( " Supercalifragalisticexpialidocious " ) ) ; }
@Test { » Transactional Bean « tb = new » Transactional Bean « ( ) ; » Aspect J Proxy Factory « » proxy Factory « = new » Aspect J Proxy Factory « ( tb ) ; » proxy Factory « . » add Aspect « ( » Pointcut With Annotation Argument « . class ) ; » I Transactional Bean « » proxied Test Bean « = » proxy Factory « . » get Proxy « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( » proxied Test Bean « :: » do In Transaction « ) ; }
@Test { » Aop Namespace Utils « . » register Auto Proxy Creator If Necessary « ( this . » parser Context « , null ) ; » assert That « ( registry . » get Bean Definition Count « ( ) ) . as ( " Incorrect number of definitions registered " ) . » is Equal To « ( 1 ) ; » Aop Namespace Utils « . » register Aspect J Auto Proxy Creator If Necessary « ( this . » parser Context « , null ) ; » assert That « ( registry . » get Bean Definition Count « ( ) ) . as ( " Incorrect number of definitions registered " ) . » is Equal To « ( 1 ) ; }
@Test { Advisor » advisor 1 « = » create Aspect J After Advice « ( » HIGH _ PRECEDENCE _ ADVISOR _ ORDER « , » EARLY _ ADVICE _ DECLARATION _ ORDER « , " » some Aspect « " ) ; Advisor » advisor 2 « = » create Aspect J Before Advice « ( » HIGH _ PRECEDENCE _ ADVISOR _ ORDER « , » LATE _ ADVICE _ DECLARATION _ ORDER « , " » some Aspect « " ) ; » assert That « ( this . comparator . compare ( » advisor 1 « , » advisor 2 « ) ) . as ( " » advisor 1 « and » advisor 2 « not comparable " ) . » is Equal To « ( 1 ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( » qualified Resource « ( » get Class « ( ) , " » pointcut Duplication « . xml " ) ) ) . satisfies ( ex -> ex . contains ( » Bean Definition Parsing Exception « . class ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( » qualified Resource « ( » get Class « ( ) , " » pointcut Missing « . xml " ) ) ) . satisfies ( ex -> ex . contains ( » Bean Definition Parsing Exception « . class ) ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( » bean Factory « ) . » load Bean Definitions « ( » qualified Resource « ( » Top Level Aop Tag Tests « . class , " context . xml " ) ) ; » assert That « ( » bean Factory « . » contains Bean Definition « ( " » test Pointcut « " ) ) . » is True « ( ) ; }
@Test { » Advised Support « as = new » Advised Support « ( ) ; Class < ? > [ ] » completed Interfaces « = » Aop Proxy Utils « . » complete Proxied Interfaces « ( as ) ; » assert That « ( » completed Interfaces « . length ) . » is Equal To « ( 2 ) ; List < ? > ifaces = Arrays . » as List « ( » completed Interfaces « ) ; » assert That « ( ifaces . contains ( Advised . class ) ) . » is True « ( ) ; » assert That « ( ifaces . contains ( » Spring Proxy « . class ) ) . » is True « ( ) ; }
@Test { » Advised Support « as = new » Advised Support « ( ) ; as . » set Opaque « ( true ) ; Class < ? > [ ] » completed Interfaces « = » Aop Proxy Utils « . » complete Proxied Interfaces « ( as ) ; » assert That « ( » completed Interfaces « . length ) . » is Equal To « ( 1 ) ; }
@Test { » Proxy Factory « pf = new » Proxy Factory « ( ) ; pf . » set Target « ( new » Test Bean « ( ) ) ; pf . » add Interface « ( » I Test Bean « . class ) ; Object proxy = pf . » get Proxy « ( ) ; Class < ? > [ ] » user Interfaces « = » Aop Proxy Utils « . » proxied User Interfaces « ( proxy ) ; » assert That « ( » user Interfaces « . length ) . » is Equal To « ( 1 ) ; » assert That « ( » user Interfaces « [ 0 ] ) . » is Equal To « ( » I Test Bean « . class ) ; }
@Test { Object proxy = Proxy . » new Proxy Instance « ( » get Class « ( ) . » get Class Loader « ( ) , new Class [ 0 ] , ( » proxy 1 « , method , args ) -> null ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Aop Proxy Utils « . » proxied User Interfaces « ( proxy ) ) ; }
@Test { » Time Stamped « tst = ( ) -> { throw new » Unsupported Operation Exception « ( " » get Time Stamp « " ) ; } ; » Proxy Factory « pf = new » Proxy Factory « ( tst ) ; pf . » add Interface « ( » Time Stamped « . class ) ; » assert That « ( pf . » get Proxy « ( ) ) . » is Instance Of « ( » Time Stamped « . class ) ; }
@Test { » J Frame « frame = new » J Frame « ( ) ; » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( frame ) ; Object proxy = » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy instanceof » Root Pane Container « ) . » is True « ( ) ; » assert That « ( proxy instanceof Accessible ) . » is True « ( ) ; }
@Test { final » Test Bean « target = new » Test Bean « ( " tb " ) ; » I Test Bean « proxy = » Proxy Factory « . » get Proxy « ( » I Test Bean « . class , ( » Method Interceptor « ) invocation -> { » assert That « ( invocation . » get This « ( ) ) . » is Null « ( ) ; return invocation . » get Method « ( ) . invoke ( target , invocation . » get Arguments « ( ) ) ; } ) ; » assert That « ( proxy . » get Name « ( ) ) . » is Equal To « ( " tb " ) ; }
@Test { Method method = Object . class . » get Method « ( " » hash Code « " ) ; Object proxy = new Object ( ) ; Object » return Value « = new Object ( ) ; List < Object > interceptors = Collections . » singleton List « ( ( » Method Interceptor « ) invocation -> » return Value « ) ; » Reflective Method Invocation « invocation = new » Reflective Method Invocation « ( proxy , null , method , null , null , interceptors ) ; Object rv = invocation . proceed ( ) ; » assert That « ( rv ) . as ( " correct response " ) . » is Same As « ( » return Value « ) ; }
@Test { Object target = new » Test Bean « ( ) { @ Override public String » to String « ( ) { throw new » Unsupported Operation Exception « ( " » to String « " ) ; } } ; List < Object > interceptors = Collections . » empty List « ( ) ; Method m = Object . class . » get Method « ( " » hash Code « " ) ; Object proxy = new Object ( ) ; » Reflective Method Invocation « invocation = new » Reflective Method Invocation « ( proxy , target , m , null , null , interceptors ) ; invocation . » to String « ( ) ; }
@Test { class » Simple Foo « implements Foo { @ Override public int » get Value « ( ) { return 100 ; } } » Simple Foo « target = new » Simple Foo « ( ) ; » Proxy Factory « factory = new » Proxy Factory « ( target ) ; factory . » add Advice « ( ( » Method Interceptor « ) invocation -> null ) ; Foo foo = ( Foo ) factory . » get Proxy « ( ) ; » assert That Exception Of Type « ( » Aop Invocation Exception « . class ) . » is Thrown By « ( ( ) -> foo . » get Value « ( ) ) . » with Message Containing « ( " Foo . » get Value « ( ) " ) ; }
@Test { Bar target = new Bar ( ) ; » Proxy Factory « factory = new » Proxy Factory « ( target ) ; factory . » add Advice « ( ( » Method Interceptor « ) invocation -> null ) ; Bar bar = ( Bar ) factory . » get Proxy « ( ) ; » assert That Exception Of Type « ( » Aop Invocation Exception « . class ) . » is Thrown By « ( ( ) -> bar . » get Value « ( ) ) . » with Message Containing « ( " Bar . » get Value « ( ) " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Throws Advice Interceptor « ( new Object ( ) ) ) ; }
@Test { » My Throws Handler « th = new » My Throws Handler « ( ) ; » Throws Advice Interceptor « ti = new » Throws Advice Interceptor « ( th ) ; Object ret = new Object ( ) ; » Method Invocation « mi = mock ( » Method Invocation « . class ) ; given ( mi . proceed ( ) ) . » will Return « ( ret ) ; » assert That « ( ti . invoke ( mi ) ) . » is Equal To « ( ret ) ; » assert That « ( th . » get Calls « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » test Multiple Threads « ( 1 ) ; }
@Test { » test Multiple Threads « ( 10 ) ; }
@Test { » Method Invocation « » method Invocation « = mock ( » Method Invocation « . class ) ; Log log = mock ( Log . class ) ; given ( log . » is Trace Enabled « ( ) ) . » will Return « ( true ) ; » Debug Interceptor « interceptor = new » Stub Debug Interceptor « ( log ) ; interceptor . invoke ( » method Invocation « ) ; » check Call Count Total « ( interceptor ) ; verify ( log , times ( 2 ) ) . trace ( » any String « ( ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( » qualified Resource « ( » Expose Invocation Interceptor Tests « . class , " context . xml " ) ) ; » I Test Bean « tb = ( » I Test Bean « ) bf . » get Bean « ( " proxy " ) ; String name = " tony " ; tb . » set Name « ( name ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( name ) ; }
@Test { given ( mi . » get Method « ( ) ) . » will Return « ( String . class . » get Method « ( " » to String « " ) ) ; interceptor . » invoke Under Trace « ( mi , log ) ; » assert That « ( » Monitor Factory « . » get Num Rows « ( ) > 0 ) . as ( " jamon must track the method being invoked " ) . » is True « ( ) ; » assert That « ( » Monitor Factory « . » get Report « ( ) . contains ( " » to String « " ) ) . as ( " The jamon report must contain the » to String « method that was invoked " ) . » is True « ( ) ; }
@Test { » Method Invocation « mi = mock ( » Method Invocation « . class ) ; given ( mi . » get Method « ( ) ) . » will Return « ( String . class . » get Method « ( " » to String « " ) ) ; given ( mi . » get This « ( ) ) . » will Return « ( this ) ; Log log = mock ( Log . class ) ; » Simple Trace Interceptor « interceptor = new » Simple Trace Interceptor « ( true ) ; interceptor . » invoke Under Trace « ( mi , log ) ; verify ( log , times ( 2 ) ) . trace ( » any String « ( ) ) ; }
@Test { » Performance Monitor Interceptor « interceptor = new » Performance Monitor Interceptor « ( ) ; » assert That « ( interceptor . » get Prefix « ( ) ) . » is Not Null « ( ) ; » assert That « ( interceptor . » get Suffix « ( ) ) . » is Not Null « ( ) ; interceptor . » set Prefix « ( null ) ; interceptor . » set Suffix « ( null ) ; » assert That « ( interceptor . » get Prefix « ( ) ) . » is Not Null « ( ) ; » assert That « ( interceptor . » get Suffix « ( ) ) . » is Not Null « ( ) ; }
@Test { » Method Invocation « mi = mock ( » Method Invocation « . class ) ; given ( mi . » get Method « ( ) ) . » will Return « ( String . class . » get Method « ( " » to String « " , new Class [ 0 ] ) ) ; Log log = mock ( Log . class ) ; » Performance Monitor Interceptor « interceptor = new » Performance Monitor Interceptor « ( true ) ; interceptor . » invoke Under Trace « ( mi , log ) ; verify ( log ) . trace ( » any String « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Enter Message « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Enter Message « ( » Customizable Trace Interceptor « . » PLACEHOLDER _ RETURN _ VALUE « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Enter Message « ( » Customizable Trace Interceptor « . » PLACEHOLDER _ EXCEPTION « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Enter Message « ( » Customizable Trace Interceptor « . » PLACEHOLDER _ INVOCATION _ TIME « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Exit Message « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Exit Message « ( » Customizable Trace Interceptor « . » PLACEHOLDER _ EXCEPTION « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Exception Message « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Customizable Trace Interceptor « ( ) . » set Exception Message « ( » Customizable Trace Interceptor « . » PLACEHOLDER _ RETURN _ VALUE « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Default Scoped Object « ( null , » GOOD _ BEAN _ NAME « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » test Bad Target Bean Name « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » test Bad Target Bean Name « ( " " ) ) ; }
@Test { String » original Bean Name « = " » my Bean « " ; String » target Bean Name « = » Scoped Proxy Utils « . » get Target Bean Name « ( » original Bean Name « ) ; » assert That « ( » target Bean Name « ) . » is Not Equal To « ( » original Bean Name « ) . » ends With « ( » original Bean Name « ) ; » assert That « ( » Scoped Proxy Utils « . » is Scoped Target « ( » target Bean Name « ) ) . » is True « ( ) ; » assert That « ( » Scoped Proxy Utils « . » is Scoped Target « ( » original Bean Name « ) ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Scoped Proxy Utils « . » get Original Bean Name « ( null ) ) . » with Message « ( " bean name 'null' does not refer to the target of a scoped proxy " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Scoped Proxy Utils « . » get Original Bean Name « ( " » my Bean « " ) ) . » with Message « ( " bean name 'myBean' does not refer to the target of a scoped proxy " ) ; }
@Test { » no Pattern Supplied Tests « ( rpc ) ; }
@Test { rpc = ( » Abstract Regexp Method Pointcut « ) » Serialization Test Utils « . » serialize And Deserialize « ( rpc ) ; » no Pattern Supplied Tests « ( rpc ) ; }
@Test { rpc . » set Pattern « ( " java . lang . Object . » hash Code « " ) ; » exact Match Tests « ( rpc ) ; rpc = ( » Abstract Regexp Method Pointcut « ) » Serialization Test Utils « . » serialize And Deserialize « ( rpc ) ; » exact Match Tests « ( rpc ) ; }
@Test { rpc . » set Pattern « ( " java . lang . String . » hash Code « " ) ; » assert That « ( rpc . matches ( Object . class . » get Method « ( " » hash Code « " ) , String . class ) ) . » is True « ( ) ; » assert That « ( rpc . matches ( Object . class . » get Method « ( " » hash Code « " ) , Object . class ) ) . » is False « ( ) ; }
@Test { rpc . » set Pattern « ( " . * Object . » hash Code « " ) ; » assert That « ( rpc . matches ( Object . class . » get Method « ( " » hash Code « " ) , Object . class ) ) . » is True « ( ) ; » assert That « ( rpc . matches ( Object . class . » get Method « ( " wait " ) , Object . class ) ) . » is False « ( ) ; }
@Test { rpc . » set Pattern « ( " java . lang . Object . * " ) ; » assert That « ( rpc . matches ( Object . class . » get Method « ( " » hash Code « " ) , String . class ) ) . » is True « ( ) ; » assert That « ( rpc . matches ( Object . class . » get Method « ( " wait " ) , String . class ) ) . » is True « ( ) ; }
@Test { rpc . » set Pattern « ( " java . lang . Object . * " ) ; » assert That « ( rpc . matches ( Exception . class . » get Method « ( " » hash Code « " ) , » IO Exception « . class ) ) . » is True « ( ) ; » assert That « ( rpc . matches ( Exception . class . » get Method « ( " » get Message « " ) , Exception . class ) ) . » is False « ( ) ; }
@Test { this . rpc . » set Pattern « ( " . * get . * " ) ; this . rpc . » set Excluded Pattern « ( " . * Age . * " ) ; » assert That « ( this . rpc . matches ( » Test Bean « . class . » get Method « ( " » get Name « " ) , » Test Bean « . class ) ) . » is True « ( ) ; » assert That « ( this . rpc . matches ( » Test Bean « . class . » get Method « ( " » get Age « " ) , » Test Bean « . class ) ) . » is False « ( ) ; }
@Test { class » Test Pointcut « extends » Static Method Matcher Pointcut « { @ Override public boolean matches ( Method method , @ Nullable Class < ? > clazzy ) { return false ; } } Pointcut no = new » Test Pointcut « ( ) ; » assert That « ( » Aop Utils « . » can Apply « ( no , Object . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Aop Utils « . » can Apply « ( new » Default Pointcut Advisor « ( new » Nop Interceptor « ( ) ) , Object . class ) ) . » is True « ( ) ; » assert That « ( » Aop Utils « . » can Apply « ( new » Default Pointcut Advisor « ( new » Nop Interceptor « ( ) ) , » Test Bean « . class ) ) . » is True « ( ) ; }
@Test { class » Test Pointcut « extends » Static Method Matcher Pointcut « { @ Override public boolean matches ( Method method , @ Nullable Class < ? > clazz ) { return method . » get Name « ( ) . equals ( " » hash Code « " ) ; } } Pointcut pc = new » Test Pointcut « ( ) ; » assert That « ( » Aop Utils « . » can Apply « ( pc , Object . class ) ) . » is True « ( ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; » Proxy Factory « pf = new » Proxy Factory « ( ) ; pf . » set Target « ( tb ) ; pf . » set Proxy Target Class « ( true ) ; » Test Bean « proxy = ( » Test Bean « ) pf . » get Proxy « ( ) ; String » class Name « = » Class Utils « . » get Short Name « ( proxy . » get Class « ( ) ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " » Test Bean « " ) ; }
@Test { Pointcut pc = new » Composable Pointcut « ( ) ; » assert That « ( pc . » get Class Filter « ( ) . matches ( Object . class ) ) . » is True « ( ) ; » assert That « ( pc . » get Method Matcher « ( ) . matches ( Object . class . » get Method « ( " » hash Code « " ) , Exception . class ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Delegating Introduction Interceptor « ( null ) ) ; }
@Test { » assert That « ( nop . » get Count « ( ) ) . » is Equal To « ( 0 ) ; proxied . » get Name « ( ) ; proxied . » set Name « ( " " ) ; proxied . echo ( null ) ; » assert That « ( nop . » get Count « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { pc . » set Mapped Names « ( " set * " , " echo " ) ; » assert That « ( nop . » get Count « ( ) ) . » is Equal To « ( 0 ) ; proxied . » get Name « ( ) ; proxied . » set Name « ( " " ) ; » assert That « ( nop . » get Count « ( ) ) . » is Equal To « ( 1 ) ; proxied . echo ( null ) ; » assert That « ( nop . » get Count « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { Pointcut union = Pointcuts . union ( » all Class Getter Pointcut « , » all Class Setter Pointcut « ) ; » assert That « ( Pointcuts . matches ( union , » TEST _ BEAN _ SET _ AGE « , » Test Bean « . class , new Integer ( 6 ) ) ) . » is True « ( ) ; » assert That « ( Pointcuts . matches ( union , » TEST _ BEAN _ GET _ AGE « , » Test Bean « . class ) ) . » is True « ( ) ; » assert That « ( Pointcuts . matches ( union , » TEST _ BEAN _ ABSQUATULATE « , » Test Bean « . class ) ) . » is False « ( ) ; }
@Test { Pointcut intersection = Pointcuts . intersection ( » all Class Getter Pointcut « , » all Class Setter Pointcut « ) ; » assert That « ( Pointcuts . matches ( intersection , » TEST _ BEAN _ SET _ AGE « , » Test Bean « . class , new Integer ( 6 ) ) ) . » is False « ( ) ; » assert That « ( Pointcuts . matches ( intersection , » TEST _ BEAN _ GET _ AGE « , » Test Bean « . class ) ) . » is False « ( ) ; » assert That « ( Pointcuts . matches ( intersection , » TEST _ BEAN _ ABSQUATULATE « , » Test Bean « . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » filter 1 « . matches ( Exception . class ) ) . » is True « ( ) ; » assert That « ( » filter 1 « . matches ( » Runtime Exception « . class ) ) . » is True « ( ) ; » assert That « ( » filter 1 « . matches ( Error . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » filter 1 « ) . » is Equal To « ( » filter 2 « ) ; » assert That « ( » filter 1 « ) . » is Not Equal To « ( » filter 3 « ) ; }
@Test { » assert That « ( » filter 1 « . » hash Code « ( ) ) . » is Equal To « ( » filter 2 « . » hash Code « ( ) ) ; » assert That « ( » filter 1 « . » hash Code « ( ) ) . » is Not Equal To « ( » filter 3 « . » hash Code « ( ) ) ; }
@Test { » assert That « ( » filter 1 « . » to String « ( ) ) . » is Equal To « ( " org . springframework . aop . support . » Root Class Filter « : java . lang . Exception " ) ; » assert That « ( » filter 1 « . » to String « ( ) ) . » is Equal To « ( » filter 2 « . » to String « ( ) ) ; }
@Test { » Method Matcher « » default Mm « = » Method Matcher « . TRUE ; » assert That « ( » default Mm « . matches ( » EXCEPTION _ GETMESSAGE « , Exception . class ) ) . » is True « ( ) ; » assert That « ( » default Mm « . matches ( » ITESTBEAN _ SETAGE « , » Test Bean « . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Method Matcher « . TRUE ) . » is Same As « ( » Serialization Test Utils « . » serialize And Deserialize « ( » Method Matcher « . TRUE ) ) ; }
@Test { » Method Matcher « first = » Method Matchers « . union ( » Method Matcher « . TRUE , » Method Matcher « . TRUE ) ; » Method Matcher « second = new » Composable Pointcut « ( » Method Matcher « . TRUE ) . union ( new » Composable Pointcut « ( » Method Matcher « . TRUE ) ) . » get Method Matcher « ( ) ; » assert That « ( first . equals ( second ) ) . » is True « ( ) ; » assert That « ( second . equals ( first ) ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( » bean Factory « ) ; reader . » load Bean Definitions « ( CONTEXT ) ; » bean Factory « . » pre Instantiate Singletons « ( ) ; » I Test Bean « bean = ( » I Test Bean « ) » bean Factory « . » get Bean « ( " » test Bean « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . » is True « ( ) ; }
@Test { » Hot Swappable Target Source « swapper = ( » Hot Swappable Target Source « ) » bean Factory « . » get Bean « ( " swapper " ) ; » assert That Illegal Argument Exception « ( ) . as ( " Should » n ' t « be able to swap to invalid value " ) . » is Thrown By « ( ( ) -> swapper . swap ( null ) ) . » with Message Containing « ( " null " ) ; » test Basic Functionality « ( ) ; }
@Test { » Thread Local Target Source « source = ( » Thread Local Target Source « ) this . » bean Factory « . » get Bean « ( " » thread Local Ts « " ) ; source . » get Target « ( ) ; source . destroy ( ) ; source . » get Target « ( ) ; }
@Test { » Counting Refreshable Target Source « ts = new » Counting Refreshable Target Source « ( ) ; ts . » set Refresh Check Delay « ( 0 ) ; Object a = ts . » get Target « ( ) ; Thread . sleep ( 1 ) ; Object b = ts . » get Target « ( ) ; » assert That « ( ts . » get Call Count « ( ) ) . as ( " Should be one call to » fresh Target « to get initial target " ) . » is Equal To « ( 1 ) ; » assert That « ( b ) . as ( " Returned objects should be the same - no refresh should occur " ) . » is Same As « ( a ) ; }
@Test { » Counting Refreshable Target Source « ts = new » Counting Refreshable Target Source « ( true ) ; ts . » set Refresh Check Delay « ( 0 ) ; Object a = ts . » get Target « ( ) ; Thread . sleep ( 100 ) ; Object b = ts . » get Target « ( ) ; » assert That « ( ts . » get Call Count « ( ) ) . as ( " Should have called » fresh Target « twice " ) . » is Equal To « ( 2 ) ; » assert That « ( b ) . as ( " Should be different objects " ) . » is Not Same As « ( a ) ; }
@Test { » Counting Refreshable Target Source « ts = new » Counting Refreshable Target Source « ( true ) ; ts . » set Refresh Check Delay « ( - 1 ) ; Object a = ts . » get Target « ( ) ; Object b = ts . » get Target « ( ) ; » assert That « ( ts . » get Call Count « ( ) ) . as ( " Refresh target should only be called once " ) . » is Equal To « ( 1 ) ; » assert That « ( b ) . as ( " Objects should be the same - refresh check delay not elapsed " ) . » is Same As « ( a ) ; }
@Test { new » Class Path Xml Application Context « ( " org / springframework / aop / aspectj / autoproxy / » ajc Autoproxy Tests « . xml " ) ; }
@Test { new » Class Path Xml Application Context « ( " org / springframework / beans / factory / aspectj / » spring Configured « . xml " ) ; }
@Test { try ( » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " org / springframework / beans / factory / aspectj / » bean Configurer Tests « . xml " ) ) { » Should Be Configured By Spring « » my Object « = new » Should Be Configured By Spring « ( ) ; » assert That « ( » my Object « . » get Name « ( ) ) . » is Equal To « ( " Rod " ) ; } }
@Test { » test Cacheable « ( this . cs ) ; }
@Test { » test Cacheable Null « ( this . cs ) ; }
@Test { » test Cacheable Sync « ( this . cs ) ; }
@Test { » test Cacheable Sync Null « ( this . cs ) ; }
@Test { » test Evict « ( this . cs , true ) ; }
@Test { » test Evict Early « ( this . cs ) ; }
@Test { » test Evict Exception « ( this . cs ) ; }
@Test { » test Evict All « ( this . cs , true ) ; }
@Test { » test Evict All Early « ( this . cs ) ; }
@Test { » test Evict With Key « ( this . cs ) ; }
@Test { » test Evict With Key Early « ( this . cs ) ; }
@Test { » test Conditional Expression « ( this . cs ) ; }
@Test { » test Conditional Expression Sync « ( this . cs ) ; }
@Test { » test Unless Expression « ( this . cs ) ; }
@Test { » test Key Expression « ( this . cs ) ; }
@Test { » test Var Args Key « ( this . cs ) ; }
@Test { » test Cacheable « ( this . ccs ) ; }
@Test { » test Evict « ( this . ccs , true ) ; }
@Test { » test Evict Early « ( this . ccs ) ; }
@Test { » test Evict All « ( this . ccs , true ) ; }
@Test { » test Evict Exception « ( this . ccs ) ; }
@Test { » test Evict With Key « ( this . ccs ) ; }
@Test { » test Evict With Key Early « ( this . ccs ) ; }
@Test { » test Null Value « ( this . cs ) ; }
@Test { » test Method Name « ( this . cs , " name " ) ; }
@Test { » test Method Name « ( this . ccs , " » nametest Cache « " ) ; }
@Test { » test Root Vars « ( this . cs ) ; }
@Test { » test Root Vars « ( this . ccs ) ; }
@Test { Object param = new Object ( ) ; Object » r 1 « = this . cs . » custom Key Generator « ( param ) ; » assert That « ( this . cs . » custom Key Generator « ( param ) ) . » is Same As « ( » r 1 « ) ; Cache cache = this . cm . » get Cache « ( " » test Cache « " ) ; Object » expected Key « = » Some Custom Key Generator « . » generate Key « ( " » custom Key Generator « " , param ) ; » assert That « ( cache . get ( » expected Key « ) ) . » is Not Null « ( ) ; }
@Test { Object param = new Object ( ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> this . cs . » unknown Custom Key Generator « ( param ) ) ; }
@Test { » Cache Manager « » custom Cm « = this . ctx . » get Bean « ( " » custom Cache Manager « " , » Cache Manager « . class ) ; Object key = new Object ( ) ; Object » r 1 « = this . cs . » custom Cache Manager « ( key ) ; » assert That « ( this . cs . » custom Cache Manager « ( key ) ) . » is Same As « ( » r 1 « ) ; Cache cache = » custom Cm « . » get Cache « ( " » test Cache « " ) ; » assert That « ( cache . get ( key ) ) . » is Not Null « ( ) ; }
@Test { Object param = new Object ( ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> this . cs . » unknown Custom Cache Manager « ( param ) ) ; }
@Test { » test Null Arg « ( this . cs ) ; }
@Test { » test Null Arg « ( this . ccs ) ; }
@Test { » test Checked Throwable « ( this . cs ) ; }
@Test { » test Checked Throwable « ( this . ccs ) ; }
@Test { » test Checked Throwable Sync « ( this . cs ) ; }
@Test { » test Checked Throwable Sync « ( this . ccs ) ; }
@Test { » test Unchecked Throwable « ( this . cs ) ; }
@Test { » test Unchecked Throwable « ( this . ccs ) ; }
@Test { » test Unchecked Throwable Sync « ( this . cs ) ; }
@Test { » test Unchecked Throwable Sync « ( this . ccs ) ; }
@Test { » test Cache Update « ( this . cs ) ; }
@Test { » test Cache Update « ( this . ccs ) ; }
@Test { » test Conditional Cache Update « ( this . cs ) ; }
@Test { » test Conditional Cache Update « ( this . ccs ) ; }
@Test { » test Multi Cache « ( this . cs ) ; }
@Test { » test Multi Cache « ( this . ccs ) ; }
@Test { » test Multi Evict « ( this . cs ) ; }
@Test { » test Multi Evict « ( this . ccs ) ; }
@Test { » test Multi Put « ( this . cs ) ; }
@Test { » test Multi Put « ( this . ccs ) ; }
@Test { » test Put Refers To Result « ( this . cs ) ; }
@Test { » test Put Refers To Result « ( this . ccs ) ; }
@Test { » test Multi Cache And Evict « ( this . cs ) ; }
@Test { » test Multi Cache And Evict « ( this . ccs ) ; }
@Test { » test Multi Conditional Cache And Evict « ( this . cs ) ; }
@Test { » test Multi Conditional Cache And Evict « ( this . ccs ) ; }
@Test { » Annotation Cache Aspect « aspect = ctx . » get Bean « ( " org . springframework . cache . config . » internal Cache Aspect « " , » Annotation Cache Aspect « . class ) ; » assert That « ( aspect . » get Key Generator « ( ) ) . » is Same As « ( ctx . » get Bean « ( " » key Generator « " ) ) ; }
@Test { load ( » Enable Caching Config « . class ) ; » Annotation Cache Aspect « aspect = this . ctx . » get Bean « ( » Annotation Cache Aspect « . class ) ; » assert That « ( aspect . » get Key Generator « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » key Generator « " , » Key Generator « . class ) ) ; }
@Test { load ( » Enable Caching Config « . class ) ; » Annotation Cache Aspect « aspect = this . ctx . » get Bean « ( » Annotation Cache Aspect « . class ) ; » assert That « ( aspect . » get Error Handler « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » error Handler « " , » Cache Error Handler « . class ) ) ; }
@Test { load ( » Single Cache Manager Config « . class ) ; }
@Test { try { load ( » Multi Cache Manager Config « . class ) ; } catch ( » Illegal State Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " bean of type » Cache Manager « " ) ) . » is True « ( ) ; } }
@Test { load ( » Multi Cache Manager Configurer « . class ) ; }
@Test { try { load ( » Multi Cache Manager Configurer « . class , » Enable Caching Config « . class ) ; } catch ( » Bean Creation Exception « ex ) { Throwable root = ex . » get Root Cause « ( ) ; boolean condition = root instanceof » Illegal State Exception « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ex . » get Message « ( ) . contains ( " implementations of » Caching Configurer « " ) ) . » is True « ( ) ; } }
@Test { try { load ( » Empty Config « . class ) ; } catch ( » Illegal State Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " no bean of type » Cache Manager « " ) ) . » is True « ( ) ; } }
@Test { load ( » Full Caching Config « . class ) ; » Annotation Cache Aspect « aspect = this . ctx . » get Bean « ( » Annotation Cache Aspect « . class ) ; » assert That « ( aspect . » get Cache Resolver « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » cache Resolver « " ) ) ; » assert That « ( aspect . » get Key Generator « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » key Generator « " ) ) ; }
@Test { try ( » Annotation Config Application Context « context = new » Annotation Config Application Context « ( Config . class ) ) { » Should Be Configured By Spring « » my Object « = new » Should Be Configured By Spring « ( ) ; » assert That « ( » my Object « . » get Name « ( ) ) . » is Equal To « ( " Rod " ) ; } }
@Test { » Class Without Async Annotation « obj = new » Class Without Async Annotation « ( ) ; obj . » increment Async « ( ) ; executor . » wait For Completion « ( ) ; » assert That « ( obj . counter ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Start Counter « ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Complete Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » Class Without Async Annotation « obj = new » Class Without Async Annotation « ( ) ; Future < Integer > future = obj . » increment Returning A Future « ( ) ; » assert That « ( future . get ( ) . » int Value « ( ) ) . » is Equal To « ( 5 ) ; » assert That « ( obj . counter ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Start Counter « ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Complete Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » Class Without Async Annotation « obj = new » Class Without Async Annotation « ( ) ; obj . increment ( ) ; » assert That « ( obj . counter ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Start Counter « ) . » is Equal To « ( 0 ) ; » assert That « ( executor . » submit Complete Counter « ) . » is Equal To « ( 0 ) ; }
@Test { » Class With Async Annotation « obj = new » Class With Async Annotation « ( ) ; obj . increment ( ) ; executor . » wait For Completion « ( ) ; » assert That « ( obj . counter ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Start Counter « ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Complete Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » Class With Async Annotation « obj = new » Class With Async Annotation « ( ) ; Future < Integer > future = obj . » increment Returning A Future « ( ) ; » assert That « ( future . get ( ) . » int Value « ( ) ) . » is Equal To « ( 5 ) ; » assert That « ( obj . counter ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Start Counter « ) . » is Equal To « ( 1 ) ; » assert That « ( executor . » submit Complete Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( context . » contains Bean « ( » Task Management Config Utils « . » ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { Object executor = context . » get Bean « ( " » test Executor « " ) ; Object aspect = context . » get Bean « ( » Task Management Config Utils « . » ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME « ) ; » assert That « ( ( ( Supplier ) new » Direct Field Accessor « ( aspect ) . » get Property Value « ( " » default Executor « " ) ) . get ( ) ) . » is Same As « ( executor ) ; }
@Test { Object » exception Handler « = context . » get Bean « ( " » test Exception Handler « " ) ; Object aspect = context . » get Bean « ( » Task Management Config Utils « . » ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME « ) ; » assert That « ( ( ( Supplier ) new » Direct Field Accessor « ( aspect ) . » get Property Value « ( " » exception Handler « " ) ) . get ( ) ) . » is Same As « ( » exception Handler « ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Jta Annotation Public Annotated Member « ( ) . echo ( null ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » Interrupted Exception « test = new » Interrupted Exception « ( ) ; » assert That Exception Of Type « ( » Interrupted Exception « . class ) . » is Thrown By « ( ( ) -> new » Jta Annotation Public Annotated Member « ( ) . echo ( test ) ) . » is Same As « ( test ) ; » assert That « ( this . » tx Manager « . rollbacks ) . » is Equal To « ( 1 ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » IO Exception « test = new » IO Exception « ( ) ; » assert That IO Exception « ( ) . » is Thrown By « ( ( ) -> new » Jta Annotation Public Annotated Member « ( ) . echo ( test ) ) . » is Same As « ( test ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 1 ) ; » assert That « ( this . » tx Manager « . rollbacks ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Jta Annotation Protected Annotated Member « ( ) . » do In Transaction « ( ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Jta Annotation Protected Annotated Member « ( ) . » do Something « ( ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Jta Annotation Private Annotated Member « ( ) . » do In Transaction « ( ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Jta Annotation Private Annotated Member « ( ) . » do Something « ( ) ; » assert That « ( this . » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Transaction Aspect Tests « . » Not Transactional « ( ) . noop ( ) ; » assert That « ( this . » tx Manager « . begun ) . » is Equal To « ( 0 ) ; }
@Test { » tx Manager « . clear ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » annotation Only On Class With No Interface « . echo ( null ) ; » assert That « ( » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » tx Manager « . clear ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » bean With Annotated Protected Method « . » do In Transaction « ( ) ; » assert That « ( » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » tx Manager « . clear ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » bean With Annotated Private Method « . » do Something « ( ) ; » assert That « ( » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » tx Manager « . clear ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » annotation Only On Class With No Interface « . » non Transactional Method « ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; }
@Test { » tx Manager « . clear ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » method Annotation Only « . echo ( null ) ; » assert That « ( » tx Manager « . commits ) . » is Equal To « ( 1 ) ; }
@Test { » tx Manager « . clear ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; new » Not Transactional « ( ) . noop ( ) ; » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; }
@Test { Exception ex = new Exception ( ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> » test Rollback « ( ( ) -> » annotation Only On Class With No Interface « . echo ( ex ) , false ) ) . » is Same As « ( ex ) ; }
@Test { » Runtime Exception « ex = new » Runtime Exception « ( ) ; » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> » test Rollback « ( ( ) -> » annotation Only On Class With No Interface « . echo ( ex ) , true ) ) . » is Same As « ( ex ) ; }
@Test { Exception ex = new Exception ( ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> » test Rollback « ( ( ) -> new » Subclass Of Class With Transactional Annotation « ( ) . echo ( ex ) , false ) ) . » is Same As « ( ex ) ; }
@Test { Exception ex = new Exception ( ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> » test Rollback « ( ( ) -> new » Subclass Of Class With Transactional Method Annotation « ( ) . echo ( ex ) , false ) ) . » is Same As « ( ex ) ; }
@Test { final Exception ex = new Exception ( ) ; » test Not Transactional « ( ( ) -> new » Implements Annotated Interface « ( ) . echo ( ex ) , ex ) ; }
@Test { final Exception » rollback Provoking Exception « = new » Runtime Exception « ( ) ; » test Not Transactional « ( ( ) -> new » Implements Annotated Interface « ( ) . echo ( » rollback Provoking Exception « ) , » rollback Provoking Exception « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Accessor « ( null ) ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new Simple ( " John " , 2 ) ) ; » assert That « ( accessor . » is Readable Property « ( " name " ) ) . » is True « ( ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new » No Read « ( ) ) ; » assert That « ( accessor . » is Readable Property « ( " age " ) ) . » is False « ( ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new » No Read « ( ) ) ; » assert That « ( accessor . » is Readable Property « ( " xxxxx " ) ) . » is False « ( ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new » No Read « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> accessor . » is Readable Property « ( null ) ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new Simple ( " John " , 2 ) ) ; » assert That « ( accessor . » is Writable Property « ( " name " ) ) . » is True « ( ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new » No Read « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> accessor . » is Writable Property « ( null ) ) ; }
@Test { » Abstract Property Accessor « accessor = » create Accessor « ( new » No Read « ( ) ) ; » assert That « ( accessor . » is Writable Property « ( " xxxxx " ) ) . » is False « ( ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Value « ( " name " ) ) . » is Equal To « ( " John " ) ; }
@Test { Person target = » create Person « ( " John " , " London " , " UK " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Value « ( " address . city " ) ) . » is Equal To « ( " London " ) ; }
@Test { Person target = » create Person « ( " John " , " London " , " UK " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Value « ( " address . country . name " ) ) . » is Equal To « ( " UK " ) ; }
@Test { Person target = » create Person « ( " John " , " London " , " UK " ) ; target . address = null ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Auto Grow Nested Paths « ( true ) ; » assert That « ( accessor . » get Property Value « ( " address . country . name " ) ) . » is Equal To « ( " » Default Country « " ) ; }
@Test { Foo target = new Foo ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Conversion Service « ( new » Default Conversion Service « ( ) ) ; accessor . » set Auto Grow Nested Paths « ( true ) ; accessor . » set Property Value « ( " » list Of Maps « [ 0 ] [ 'luckyNumber' ] " , " 9 " ) ; » assert That « ( target . » list Of Maps « . get ( 0 ) . get ( " » lucky Number « " ) ) . » is Equal To « ( " 9 " ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Not Readable Property Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » get Property Value « ( " foo " ) ) . satisfies ( ex -> { » assert That « ( ex . » get Bean Class « ( ) ) . » is Equal To « ( Simple . class ) ; » assert That « ( ex . » get Property Name « ( ) ) . » is Equal To « ( " foo " ) ; } ) ; }
@Test { Person target = » create Person « ( " John " , " London " , " UK " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Not Readable Property Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » get Property Value « ( " address . bar " ) ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " name " , " » Some Value « " ) ; » assert That « ( target . name ) . » is Equal To « ( " » Some Value « " ) ; » assert That « ( target . » get Name « ( ) ) . » is Equal To « ( " » Some Value « " ) ; }
@Test { Person target = » create Person « ( " John " , " Paris " , " FR " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " address . city " , " London " ) ; » assert That « ( target . address . city ) . » is Equal To « ( " London " ) ; }
@Test { Person target = » create Person « ( " John " , " Paris " , " FR " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " address . country . name " , " UK " ) ; » assert That « ( target . address . country . name ) . » is Equal To « ( " UK " ) ; }
@Test { » I Test Bean « target = new » Test Bean « ( ) ; » I Test Bean « child = new » Different Test Bean « ( ) ; child . » set Name « ( " test " ) ; target . » set Spouse « ( child ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; try { accessor . » get Property Value « ( " spouse . bla " ) ; } catch ( » Not Readable Property Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( » Test Bean « . class . » get Name « ( ) ) ) . » is True « ( ) ; } }
@Test { » I Test Bean « target = new » Test Bean « ( " rod " , 31 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Null Value In Nested Path Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " spouse . age " , new Integer ( 31 ) ) ) . satisfies ( ex -> » assert That « ( ex . » get Property Name « ( ) ) . » is Equal To « ( " spouse " ) ) ; }
@Test { Person target = » create Person « ( " John " , " Paris " , " FR " ) ; target . address . country = null ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Auto Grow Nested Paths « ( true ) ; accessor . » set Property Value « ( " address . country . name " , " UK " ) ; » assert That « ( target . address . country . name ) . » is Equal To « ( " UK " ) ; }
@Test { Foo target = new Foo ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Conversion Service « ( new » Default Conversion Service « ( ) ) ; accessor . » set Auto Grow Nested Paths « ( true ) ; Map < String , String > map = new » Hash Map « < > ( ) ; map . put ( " » favorite Number « " , " 9 " ) ; accessor . » set Property Value « ( " list [ 0 ] " , map ) ; » assert That « ( target . list . get ( 0 ) ) . » is Equal To « ( map ) ; }
@Test { Foo target = new Foo ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Auto Grow Nested Paths « ( true ) ; accessor . » set Property Value « ( " » list Of Maps « [ 0 ] [ 'luckyNumber' ] " , " 9 " ) ; » assert That « ( target . » list Of Maps « . get ( 0 ) . get ( " » lucky Number « " ) ) . » is Equal To « ( " 9 " ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; int » new Age « = 33 ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; target . » set Age « ( » new Age « ) ; Object » bw Age « = accessor . » get Property Value « ( " age " ) ; » assert That « ( » bw Age « instanceof Integer ) . as ( " Age is an integer " ) . » is True « ( ) ; » assert That « ( » bw Age « ) . as ( " Bean wrapper must pick up changes " ) . » is Equal To « ( » new Age « ) ; }
@Test { » Mutable Property Values « values = new » Mutable Property Values « ( ) ; values . add ( " » to Be Ignored « [ 0 ] " , 42 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( new Object ( ) ) ; accessor . » set Property Values « ( values , true ) ; }
@Test { » Mutable Property Values « values = new » Mutable Property Values « ( ) ; values . add ( " name " , 42 ) ; » Test Bean « target = new » Test Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Values « ( values ) ; » assert That « ( target . » get Name « ( ) ) . » is Equal To « ( " 42 " ) ; }
@Test { » Enum Consumer « target = new » Enum Consumer « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " » enum Value « " , » Test Enum « . class . » get Name « ( ) + " . » TEST _ VALUE « " ) ; » assert That « ( target . » get Enum Value « ( ) ) . » is Equal To « ( » Test Enum « . » TEST _ VALUE « ) ; }
@Test { » Wildcard Enum Consumer « target = new » Wildcard Enum Consumer « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " » enum Value « " , » Test Enum « . class . » get Name « ( ) + " . » TEST _ VALUE « " ) ; » assert That « ( target . » get Enum Value « ( ) ) . » is Equal To « ( » Test Enum « . » TEST _ VALUE « ) ; }
@Test { » Props Tester « target = new » Props Tester « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » use Config Value Editors « ( ) ; accessor . » set Property Value « ( " » int Array « " , " 4 , 5 " ) ; » assert That « ( target . » int Array « . length == 2 ) . as ( " » int Array « length = 2 " ) . » is True « ( ) ; » assert That « ( target . » int Array « [ 0 ] == 4 && target . » int Array « [ 1 ] == 5 ) . as ( " correct values " ) . » is True « ( ) ; }
@Test { » Primitive Array Bean « target = new » Primitive Array Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " array " , new String [ ] { " 1 " , " 2 " } ) ; » assert That « ( target . » get Array « ( ) . length ) . » is Equal To « ( 2 ) ; » assert That « ( target . » get Array « ( ) [ 0 ] ) . » is Equal To « ( 1 ) ; » assert That « ( target . » get Array « ( ) [ 1 ] ) . » is Equal To « ( 2 ) ; }
@Test { » Array To Object « target = new » Array To Object « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; Object [ ] array = new Object [ ] { " 1 " , " 2 " } ; accessor . » set Property Value « ( " object " , array ) ; » assert That « ( target . » get Object « ( ) ) . » is Equal To « ( array ) ; array = new Object [ ] { " 1 " } ; accessor . » set Property Value « ( " object " , array ) ; » assert That « ( target . » get Object « ( ) ) . » is Equal To « ( array ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Not Writable Property Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " foo " , " value " ) ) . satisfies ( ex -> { » assert That « ( ex . » get Bean Class « ( ) ) . » is Equal To « ( Simple . class ) ; » assert That « ( ex . » get Property Name « ( ) ) . » is Equal To « ( " foo " ) ; } ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » Property Value « value = new » Property Value « ( " foo " , " value " ) ; value . » set Optional « ( true ) ; accessor . » set Property Value « ( value ) ; }
@Test { » Derived From Protected Base Bean « target = new » Derived From Protected Base Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " » some Property « " , " » some Value « " ) ; » assert That « ( accessor . » get Property Value « ( " » some Property « " ) ) . » is Equal To « ( " » some Value « " ) ; » assert That « ( target . » get Some Property « ( ) ) . » is Equal To « ( " » some Value « " ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Type Mismatch Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " age " , " foobar " ) ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Type Mismatch Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " age " , " " ) ) ; }
@Test { Person target = » create Person « ( " John " , " Paris " , " FR " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Not Writable Property Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " address . bar " , " value " ) ) ; }
@Test { Person target = » create Person « ( " John " , " Paris " , " FR " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Type « ( " address . city " ) ) . » is Equal To « ( String . class ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Type « ( " foo " ) ) . » is Null « ( ) ; }
@Test { Person target = » create Person « ( " John " , " Paris " , " FR " ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Type Descriptor « ( " address . city " ) ) . » is Not Null « ( ) ; }
@Test { Simple target = new Simple ( " John " , 2 ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; » assert That « ( accessor . » get Property Type Descriptor « ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Spr 10115 Bean « target = new » Spr 10115 Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " » prop 1 « " , " » val 1 « " ) ; » assert That « ( » Spr 10115 Bean « . » prop 1 « ) . » is Equal To « ( " » val 1 « " ) ; }
@Test { » Spr 13837 Bean « target = new » Spr 13837 Bean « ( ) ; » Abstract Property Accessor « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " something " , 42 ) ; » assert That « ( target . something ) . » is Equal To « ( Integer . » value Of « ( 42 ) ) ; }
@Test { » assert That « ( wrapper . » get Property Value « ( " nested . prop " ) ) . » is Null « ( ) ; }
@Test { wrapper . » set Property Value « ( " nested . prop " , " test " ) ; » assert That « ( bean . » get Nested « ( ) . » get Prop « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » assert That Exception Of Type « ( » Null Value In Nested Path Exception « . class ) . » is Thrown By « ( ( ) -> wrapper . » get Property Value « ( " » nested No Constructor « . prop " ) ) ; }
@Test { » assert Not Null « ( wrapper . » get Property Value « ( " array [ 0 ] " ) ) ; » assert That « ( bean . » get Array « ( ) . length ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » get Array « ( ) [ 0 ] ) . » is Instance Of « ( Bean . class ) ; }
@Test { wrapper . » set Property Value « ( " array [ 0 ] . prop " , " test " ) ; » assert That « ( bean . » get Array « ( ) [ 0 ] . » get Prop « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » assert Not Null « ( wrapper . » get Property Value « ( " » multi Array « [ 0 ] [ 0 ] " ) ) ; » assert That « ( bean . » get Multi Array « ( ) [ 0 ] . length ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » get Multi Array « ( ) [ 0 ] [ 0 ] ) . » is Instance Of « ( Bean . class ) ; }
@Test { » assert Not Null « ( wrapper . » get Property Value « ( " list [ 0 ] " ) ) ; » assert That « ( bean . » get List « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » get List « ( ) . get ( 0 ) ) . » is Instance Of « ( Bean . class ) ; }
@Test { wrapper . » set Property Value « ( " list [ 0 ] . prop " , " test " ) ; » assert That « ( bean . » get List « ( ) . get ( 0 ) . » get Prop « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { wrapper . » set Auto Grow Collection Limit « ( 2 ) ; » assert That Exception Of Type « ( » Invalid Property Exception « . class ) . » is Thrown By « ( ( ) -> » assert Not Null « ( wrapper . » get Property Value « ( " list [ 4 ] " ) ) ) . » with Root Cause Instance Of « ( » Index Out Of Bounds Exception « . class ) ; }
@Test { » assert Not Null « ( wrapper . » get Property Value « ( " » multi List « [ 0 ] [ 0 ] " ) ) ; » assert That « ( bean . » get Multi List « ( ) . get ( 0 ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » get Multi List « ( ) . get ( 0 ) . get ( 0 ) ) . » is Instance Of « ( Bean . class ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Property Exception « . class ) . » is Thrown By « ( ( ) -> wrapper . » get Property Value « ( " » list Not Parameterized « [ 0 ] " ) ) ; }
@Test { wrapper . » set Property Value « ( " map [ A ] " , new Bean ( ) ) ; » assert That « ( bean . » get Map « ( ) . get ( " A " ) ) . » is Instance Of « ( Bean . class ) ; }
@Test { wrapper . » set Property Value « ( " map [ A ] . nested " , new Bean ( ) ) ; » assert That « ( bean . » get Map « ( ) . get ( " A " ) . » get Nested « ( ) ) . » is Instance Of « ( Bean . class ) ; }
@Test { » Bean Utils « . » get Property Descriptors « ( » Array List « . class ) ; » assert That « ( » Cached Introspection Results « . » strong Class Cache « . » contains Key « ( » Array List « . class ) ) . » is True « ( ) ; » Cached Introspection Results « . » clear Class Loader « ( » Array List « . class . » get Class Loader « ( ) ) ; » assert That « ( » Cached Introspection Results « . » strong Class Cache « . » contains Key « ( » Array List « . class ) ) . » is False « ( ) ; }
@Test { for ( int i = 0 ; i < 100 ; i ++ ) { » perform Set « ( ) ; } }
@Test { final » String Builder « sb = new » String Builder « ( ) ; » Test Bean « target = new » Test Bean « ( ) { @ » Suppress Warnings « ( " unused " ) » String Builder « name = sb ; } ; » Direct Field Accessor « dfa = » create Accessor « ( target ) ; » assert That « ( dfa . » get Property Type « ( " name " ) ) . » is Equal To « ( » String Builder « . class ) ; » assert That « ( dfa . » get Property Value « ( " name " ) ) . » is Equal To « ( sb ) ; }
@Test { » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; Iterator < » Property Value « > it = pvs . iterator ( ) ; » assert That « ( it . » has Next « ( ) ) . » is False « ( ) ; }
@Test { » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; » assert That « ( pvs . stream ( ) ) . » is Not Null « ( ) ; » assert That « ( pvs . stream ( ) . count ( ) ) . » is Equal To « ( 0L ) ; }
@Test { » assert That « ( » Property Accessor Utils « . » get Property Name « ( " " ) ) . » is Equal To « ( " " ) ; » assert That « ( » Property Accessor Utils « . » get Property Name « ( " [ user ] " ) ) . » is Equal To « ( " " ) ; » assert That « ( » Property Accessor Utils « . » get Property Name « ( " user " ) ) . » is Equal To « ( " user " ) ; }
@Test { » assert That « ( » Property Accessor Utils « . » get First Nested Property Separator Index « ( " [ user ] " ) ) . » is Equal To « ( - 1 ) ; » assert That « ( » Property Accessor Utils « . » get First Nested Property Separator Index « ( " user . name " ) ) . » is Equal To « ( 4 ) ; }
@Test { » assert That « ( » Property Accessor Utils « . » get Last Nested Property Separator Index « ( " [ user ] " ) ) . » is Equal To « ( - 1 ) ; » assert That « ( » Property Accessor Utils « . » get Last Nested Property Separator Index « ( " user . address . street " ) ) . » is Equal To « ( 12 ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » custom Enum « " , " » VALUE _ 1 « " ) ; » assert That « ( gb . » get Custom Enum « ( ) ) . » is Equal To « ( » Custom Enum « . » VALUE _ 1 « ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » custom Enum « " , null ) ; » assert That « ( gb . » get Custom Enum « ( ) ) . » is Equal To « ( null ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » custom Enum « " , " " ) ; » assert That « ( gb . » get Custom Enum « ( ) ) . » is Equal To « ( null ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » custom Enum Array « " , " » VALUE _ 1 « " ) ; » assert That « ( gb . » get Custom Enum Array « ( ) . length ) . » is Equal To « ( 1 ) ; » assert That « ( gb . » get Custom Enum Array « ( ) [ 0 ] ) . » is Equal To « ( » Custom Enum « . » VALUE _ 1 « ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » custom Enum Set « " , " » VALUE _ 1 « " ) ; » assert That « ( gb . » get Custom Enum Set « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( gb . » get Custom Enum Set « ( ) . contains ( » Custom Enum « . » VALUE _ 1 « ) ) . » is True « ( ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Auto Grow Nested Paths « ( true ) ; » assert That « ( gb . » get Standard Enum Set « ( ) ) . » is Null « ( ) ; bw . » get Property Value « ( " » standard Enum Set « . class " ) ; » assert That « ( gb . » get Standard Enum Set « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Non Public Enum Holder « holder = new » Non Public Enum Holder « ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( holder ) ; bw . » set Property Value « ( " » non Public Enum « " , " » VALUE _ 1 « " ) ; » assert That « ( holder . » get Non Public Enum « ( ) ) . » is Equal To « ( » Non Public Enum « . » VALUE _ 1 « ) ; }
@Test { » Getter Bean « target = new » Getter Bean « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " name " , " tom " ) ; » assert That « ( target . » get Aliased Name « ( ) ) . » is Equal To « ( " tom " ) ; » assert That « ( accessor . » get Property Value « ( " » aliased Name « " ) ) . » is Equal To « ( " tom " ) ; }
@Test { » Getter Bean « target = new » Getter Bean « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; accessor . » set Extract Old Value For Editor « ( true ) ; accessor . » set Property Value « ( " name " , " tom " ) ; » assert That « ( target . » get Aliased Name « ( ) ) . » is Equal To « ( " tom " ) ; » assert That « ( accessor . » get Property Value « ( " » aliased Name « " ) ) . » is Equal To « ( " tom " ) ; }
@Test { » Getter Bean « target = new » Getter Bean « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " » aliased Name « " , " tom " ) ; » assert That « ( target . » get Aliased Name « ( ) ) . » is Equal To « ( " tom " ) ; » assert That « ( accessor . » get Property Value « ( " » aliased Name « " ) ) . » is Equal To « ( " tom " ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Not Writable Property Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " ag " , " foobar " ) ) . satisfies ( ex -> » assert That « ( ex . » get Possible Matches « ( ) ) . » contains Exactly « ( " age " ) ) ; }
@Test { » Typed Read Only Map « map = new » Typed Read Only Map « ( Collections . » singleton Map « ( " key " , new » Test Bean « ( ) ) ) ; » Typed Read Only Map Client « target = new » Typed Read Only Map Client « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " map " , map ) ; }
@Test { » Intelli Bean « target = new » Intelli Bean « ( ) ; » Bean Wrapper « bw = » create Accessor « ( target ) ; try { bw . » set Property Value « ( " names " , " Alef " ) ; } catch ( » Not Writable Property Exception « ex ) { » assert That « ( ex . » get Possible Matches « ( ) ) . as ( " Possible matches not determined " ) . » is Not Null « ( ) ; » assert That « ( ex . » get Possible Matches « ( ) . length ) . as ( " Invalid amount of alternatives " ) . » is Equal To « ( 1 ) ; } }
@Test { » Intelli Bean « target = new » Intelli Bean « ( ) ; » Bean Wrapper « bw = » create Accessor « ( target ) ; try { bw . » set Property Value « ( " mystring " , " Arjen " ) ; } catch ( » Not Writable Property Exception « ex ) { » assert That « ( ex . » get Possible Matches « ( ) ) . as ( " Possible matches not determined " ) . » is Not Null « ( ) ; » assert That « ( ex . » get Possible Matches « ( ) . length ) . as ( " Invalid amount of alternatives " ) . » is Equal To « ( 3 ) ; } }
@Test { » Property Type Mismatch « target = new » Property Type Mismatch « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; accessor . » set Property Value « ( " object " , " a String " ) ; » assert That « ( target . value ) . » is Equal To « ( " a String " ) ; » assert That « ( target . » get Object « ( ) == 8 ) . » is True « ( ) ; » assert That « ( accessor . » get Property Value « ( " object " ) ) . » is Equal To « ( 8 ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » Bean Wrapper « accessor = » create Accessor « ( target ) ; » assert That Exception Of Type « ( » Not Writable Property Exception « . class ) . » is Thrown By « ( ( ) -> accessor . » set Property Value « ( " [ ' ] " , " foobar " ) ) . satisfies ( ex -> » assert That « ( ex . » get Possible Matches « ( ) ) . » is Null « ( ) ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { public void » set Foo « ( String s ) { } } » assert That « ( factory . » get Bean Info « ( C . class ) ) . » is Null « ( ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { public C » set Foo « ( String s ) { return this ; } } » assert That « ( factory . » get Bean Info « ( C . class ) ) . » is Not Null « ( ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { public C » set Foo « ( int i , String s ) { return this ; } } » assert That « ( factory . » get Bean Info « ( C . class ) ) . » is Not Null « ( ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { void » set Bar « ( String s ) { } } » assert That « ( factory . » get Bean Info « ( C . class ) ) . » is Null « ( ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { C » set Bar « ( ) { return this ; } } » assert That « ( factory . » get Bean Info « ( C . class ) ) . » is Null « ( ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { C set ( String s ) { return this ; } } » assert That « ( factory . » get Bean Info « ( C . class ) ) . » is Null « ( ) ; }
@Test { final class Bean implements » Spr 9453 « < Class < ? > > { @ Override public Class < ? > » get Prop « ( ) { return null ; } } { » Bean Info « info = Introspector . » get Bean Info « ( Bean . class ) ; » assert That « ( info . » get Property Descriptors « ( ) . length ) . » is Equal To « ( 2 ) ; } { » Bean Info « info = new » Extended Bean Info « ( Introspector . » get Bean Info « ( Bean . class ) ) ; » assert That « ( info . » get Property Descriptors « ( ) . length ) . » is Equal To « ( 2 ) ; } }
@Test { new » Extended Bean Info « ( Introspector . » get Bean Info « ( » Big Decimal « . class ) ) ; }
@Test { @ » Suppress Warnings « ( " unused " ) class C { public Object set ( Object o ) { return null ; } public Object set ( int i , Object o ) { return null ; } } » Bean Info « bi = Introspector . » get Bean Info « ( C . class ) ; » Bean Info « ebi = new » Extended Bean Info « ( bi ) ; » assert That « ( ebi . » get Property Descriptors « ( ) ) . » is Equal To « ( bi . » get Property Descriptors « ( ) ) ; }
@Test { » Bean Info « bi = Introspector . » get Bean Info « ( » Test Bean « . class ) ; » Bean Info « ebi = new » Extended Bean Info « ( bi ) ; » assert That « ( ebi . » get Property Descriptors « ( ) . length ) . » is Equal To « ( bi . » get Property Descriptors « ( ) . length ) ; }
@Test { » Bean Info « bi = Introspector . » get Bean Info « ( » Test Bean « . class ) ; » Bean Info « ebi = new » Extended Bean Info « ( bi ) ; for ( int i = 0 ; i < bi . » get Property Descriptors « ( ) . length ; i ++ ) { » assert That « ( ebi . » get Property Descriptors « ( ) [ i ] . » get Name « ( ) ) . » is Equal To « ( bi . » get Property Descriptors « ( ) [ i ] . » get Name « ( ) ) ; } }
@Test { Introspector . » get Bean Info « ( » Law Library « . class ) ; new » Extended Bean Info « ( Introspector . » get Bean Info « ( » Law Library « . class ) ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Property « ( " naem " , » Sample Bean Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " name " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Property « ( " desriptn " , » Sample Bean Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . » is Empty « ( ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Property « ( " unknown " , » Sample Bean Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . » is Empty « ( ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Property « ( " counter " , » Sample Bean Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " » counter 1 « " ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " » counter 2 « " ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " » counter 3 « " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Property « ( " naem " , » Sample Bean Properties « . class ) ; String msg = matches . » build Error Message « ( ) ; » assert That « ( msg ) . contains ( " naem " ) ; » assert That « ( msg ) . contains ( " name " ) ; » assert That « ( msg ) . contains ( " setter " ) ; » assert That « ( msg ) . » does Not Contain « ( " field " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Property « ( " counter " , » Sample Bean Properties « . class ) ; String msg = matches . » build Error Message « ( ) ; » assert That « ( msg ) . contains ( " counter " ) ; » assert That « ( msg ) . contains ( " » counter 1 « " ) ; » assert That « ( msg ) . contains ( " » counter 2 « " ) ; » assert That « ( msg ) . contains ( " » counter 3 « " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Field « ( " naem " , » Sample Field Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " name " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Field « ( " desriptn " , » Sample Field Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . » is Empty « ( ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Field « ( " unknown " , » Sample Field Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . » is Empty « ( ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Field « ( " counter " , » Sample Field Properties « . class ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " » counter 1 « " ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " » counter 2 « " ) ; » assert That « ( matches . » get Possible Matches « ( ) ) . contains ( " » counter 3 « " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Field « ( " naem " , » Sample Field Properties « . class ) ; String msg = matches . » build Error Message « ( ) ; » assert That « ( msg ) . contains ( " naem " ) ; » assert That « ( msg ) . contains ( " name " ) ; » assert That « ( msg ) . contains ( " field " ) ; » assert That « ( msg ) . » does Not Contain « ( " setter " ) ; }
@Test { » Property Matches « matches = » Property Matches « . » for Field « ( " counter " , » Sample Field Properties « . class ) ; String msg = matches . » build Error Message « ( ) ; » assert That « ( msg ) . contains ( " counter " ) ; » assert That « ( msg ) . contains ( " » counter 1 « " ) ; » assert That « ( msg ) . contains ( " » counter 2 « " ) ; » assert That « ( msg ) . contains ( " » counter 3 « " ) ; }
@Test { » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( ( ) -> » Bean Utils « . » instantiate Class « ( List . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( ( ) -> » Bean Utils « . » instantiate Class « ( » Custom Date Editor « . class ) ) ; }
@Test { Constructor < » Bean With Nullable Types « > ctor = » Bean With Nullable Types « . class . » get Declared Constructor « ( Integer . class , Boolean . class , String . class ) ; » Bean With Nullable Types « bean = » Bean Utils « . » instantiate Class « ( ctor , null , null , " foo " ) ; » assert That « ( bean . » get Counter « ( ) ) . » is Null « ( ) ; » assert That « ( bean . » is Flag « ( ) ) . » is Null « ( ) ; » assert That « ( bean . » get Value « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { Constructor < » Bean With Primitive Types « > ctor = » Bean With Primitive Types « . class . » get Declared Constructor « ( int . class , boolean . class , String . class ) ; » Bean With Primitive Types « bean = » Bean Utils « . » instantiate Class « ( ctor , null , null , " foo " ) ; » assert That « ( bean . » get Counter « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( bean . » is Flag « ( ) ) . » is Equal To « ( false ) ; » assert That « ( bean . » get Value « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { Constructor < » Bean With Primitive Types « > ctor = » Bean With Primitive Types « . class . » get Declared Constructor « ( int . class , boolean . class , String . class ) ; » assert That Exception Of Type « ( » Bean Instantiation Exception « . class ) . » is Thrown By « ( ( ) -> » Bean Utils « . » instantiate Class « ( ctor , null , null , " foo " , null ) ) ; }
@Test { » Property Descriptor « [ ] actual = Introspector . » get Bean Info « ( » Test Bean « . class ) . » get Property Descriptors « ( ) ; » Property Descriptor « [ ] descriptors = » Bean Utils « . » get Property Descriptors « ( » Test Bean « . class ) ; » assert That « ( descriptors ) . as ( " Descriptors should not be null " ) . » is Not Null « ( ) ; » assert That « ( descriptors . length ) . as ( " Invalid number of descriptors returned " ) . » is Equal To « ( actual . length ) ; }
@Test { » Property Descriptor « [ ] descriptors = » Bean Utils « . » get Property Descriptors « ( » Container Bean « . class ) ; for ( » Property Descriptor « descriptor : descriptors ) { if ( " » contained Beans « " . equals ( descriptor . » get Name « ( ) ) ) { » assert That « ( descriptor . » get Property Type « ( ) . » is Array « ( ) ) . as ( " Property should be an array " ) . » is True « ( ) ; » assert That « ( » Contained Bean « . class ) . » is Equal To « ( descriptor . » get Property Type « ( ) . » get Component Type « ( ) ) ; } } }
@Test { » assert That « ( » Bean Utils « . » find Editor By Convention « ( Resource . class ) . » get Class « ( ) ) . » is Equal To « ( » Resource Editor « . class ) ; }
@Test { » Name And Special Property « source = new » Name And Special Property « ( ) ; source . » set Name « ( " name " ) ; » Test Bean « target = new » Test Bean « ( ) ; » Bean Utils « . » copy Properties « ( source , target , " » special Property « " ) ; » assert That « ( " name " ) . » is Equal To « ( target . » get Name « ( ) ) ; }
@Test { Method » desired Method « = » Method Signature Bean « . class . » get Method « ( " » do Something « " ) ; » assert Signature Equals « ( » desired Method « , " » do Something « " ) ; » assert Signature Equals « ( » desired Method « , " » do Something « ( ) " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Bean Utils « . » resolve Signature « ( " » do Something « ( " , » Method Signature Bean « . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Bean Utils « . » resolve Signature « ( " » do Something « ) " , » Method Signature Bean « . class ) ) ; }
@Test { Method » desired Method « = » Method Signature Bean « . class . » get Method « ( " » do Something Else « " , String . class , int . class ) ; » assert Signature Equals « ( » desired Method « , " » do Something Else « " ) ; » assert That « ( » Bean Utils « . » resolve Signature « ( " » do Something Else « ( ) " , » Method Signature Bean « . class ) ) . » is Null « ( ) ; }
@Test { Method » desired Method « = » Method Signature Bean « . class . » get Method « ( " » do Something Else « " , String . class , int . class ) ; » assert Signature Equals « ( » desired Method « , " » do Something Else « ( java . lang . String , int ) " ) ; }
@Test { Method » desired Method « = » Method Signature Bean « . class . » get Method « ( " » do Something With An Array « " , String [ ] . class ) ; » assert Signature Equals « ( » desired Method « , " » do Something With An Array « ( java . lang . String [ ] ) " ) ; » desired Method « = » Method Signature Bean « . class . » get Method « ( " » do Something With A Multi Dimensional Array « " , String [ ] [ ] . class ) ; » assert Signature Equals « ( » desired Method « , " » do Something With A Multi Dimensional Array « ( java . lang . String [ ] [ ] ) " ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; Set < » Test Bean « > input = new » Hash Set « < > ( ) ; input . add ( new » Test Bean « ( ) ) ; » assert That Exception Of Type « ( » Type Mismatch Exception « . class ) . » is Thrown By « ( ( ) -> bw . » set Property Value « ( " » integer Set « " , input ) ) . » with Message Containing « ( " java . lang . Integer " ) ; }
@Test { » Generic Bean « < ? > gb = new » Generic Bean « < > ( ) ; gb . » set Resource List « ( new » Array List « < > ( ) ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » resource List « [ 0 ] " , " http : » // localhost : 8080 « " ) ; » assert That « ( gb . » get Resource List « ( ) . get ( 0 ) ) . » is Equal To « ( new » Url Resource « ( " http : » // localhost : 8080 « " ) ) ; }
@Test { Map < String , String > map = new » Hash Map « < > ( ) ; map . put ( " » test Key « " , " 100 " ) ; » Nested Generic Collection Bean « gb = new » Nested Generic Collection Bean « ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( gb ) ; bw . » set Property Value « ( " » map Of Integer « " , map ) ; Object obj = gb . » get Map Of Integer « ( ) . get ( " » test Key « " ) ; boolean condition = obj instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { Bar bar = new Bar ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( bar ) ; bw . » set Property Value « ( " version " , " 10 " ) ; » assert That « ( bar . » get Version « ( ) ) . » is Equal To « ( new Double ( 10.0 ) ) ; }
@Test { Promotion bean = new Promotion ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( bean ) ; bw . » set Property Value « ( " id " , " 10 " ) ; » assert That « ( bean . » get Id « ( ) ) . » is Equal To « ( new Long ( 10 ) ) ; }
@Test { » Static Listable Bean Factory « lbf = new » Static Listable Bean Factory « ( ) ; lbf . » add Bean « ( " » t 1 « " , new » Test Bean « ( ) ) ; lbf . » add Bean « ( " » t 2 « " , new » Test Bean « ( ) ) ; » assert That « ( » Bean Factory Utils « . » count Beans Including Ancestors « ( lbf ) == 2 ) . » is True « ( ) ; }
@Test { » assert That « ( this . » listable Bean Factory « . » get Bean Definition Count « ( ) == 1 ) . » is True « ( ) ; » assert That « ( » Bean Factory Utils « . » count Beans Including Ancestors « ( this . » listable Bean Factory « ) == 8 ) . as ( " Should count 8 beans , not " + » Bean Factory Utils « . » count Beans Including Ancestors « ( this . » listable Bean Factory « ) ) . » is True « ( ) ; }
@Test { List < String > names = Arrays . » as List « ( » Bean Factory Utils « . » bean Names For Type Including Ancestors « ( this . » listable Bean Factory « , » No Op « . class ) ) ; » assert That « ( names . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { List < String > names = Arrays . » as List « ( » Bean Factory Utils « . » bean Names For Type Including Ancestors « ( this . » listable Bean Factory « , » Indexed Test Bean « . class ) ) ; » assert That « ( names . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( names . contains ( " » indexed Bean « " ) ) . » is True « ( ) ; » assert That « ( » listable Bean Factory « . » get Bean Names For Type « ( » Indexed Test Bean « . class ) . length == 0 ) . » is True « ( ) ; }
@Test { » Static Listable Bean Factory « lbf = new » Static Listable Bean Factory « ( ) ; lbf . » add Bean « ( " foo " , new Object ( ) ) ; Map < String , ? > beans = » Bean Factory Utils « . » beans Of Type Including Ancestors « ( lbf , » I Test Bean « . class , true , false ) ; » assert That « ( beans . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { List < String > names = Arrays . » as List « ( » Bean Factory Utils « . » bean Names For Annotation Including Ancestors « ( this . » listable Bean Factory « , Override . class ) ) ; » assert That « ( names . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { List < String > names = Arrays . » as List « ( » Bean Factory Utils « . » bean Names For Annotation Including Ancestors « ( this . » listable Bean Factory « , » Test Annotation « . class ) ) ; » assert That « ( names . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( names . contains ( " » annotated Bean « " ) ) . » is True « ( ) ; » assert That « ( » listable Bean Factory « . » get Bean Names For Annotation « ( » Test Annotation « . class ) . length == 0 ) . » is True « ( ) ; }
@Test { String [ ] deps = this . » dependent Beans Factory « . » get Dependent Beans « ( " a " ) ; » assert That « ( » Object Utils « . » is Empty « ( deps ) ) . » is True « ( ) ; }
@Test { String [ ] deps = this . » dependent Beans Factory « . » get Dependent Beans « ( " b " ) ; » assert That « ( Arrays . equals ( new String [ ] { " c " } , deps ) ) . » is True « ( ) ; }
@Test { String [ ] deps = this . » dependent Beans Factory « . » get Dependent Beans « ( " c " ) ; » assert That « ( Arrays . equals ( new String [ ] { " int " , " long " } , deps ) ) . » is True « ( ) ; }
@Test { String [ ] deps = this . » dependent Beans Factory « . » get Dependent Beans « ( " int " ) ; » assert That « ( Arrays . equals ( new String [ ] { " buffer " } , deps ) ) . » is True « ( ) ; }
@Test { for ( int i = 0 ; i < 100 ; i ++ ) { » perform Test « ( ) ; } }
@Test { Object » foo Factory « = » bean Factory « . » get Bean « ( " & » foo Factory « " ) ; » assert That « ( » foo Factory « ) . » is Instance Of « ( » Foo Factory Bean « . class ) ; }
@Test { » Foo Factory Bean « » foo Factory « = » bean Factory « . » get Bean « ( » Foo Factory Bean « . class ) ; » assert That « ( » foo Factory « ) . » is Not Null « ( ) ; }
@Test { » Foo Factory Bean « » foo Factory « = » bean Factory « . » get Bean « ( " & » foo Factory « " , » Foo Factory Bean « . class ) ; » assert That « ( » foo Factory « ) . » is Not Null « ( ) ; }
@Test { Object » foo Factory « = » bean Factory « . » get Bean « ( " » foo Factory « " ) ; » assert That « ( » foo Factory « ) . » is Instance Of « ( Foo . class ) ; }
@Test { Foo foo = » bean Factory « . » get Bean « ( " » foo Factory « " , Foo . class ) ; » assert That « ( foo ) . » is Not Null « ( ) ; }
@Test { » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( factory ) . » load Bean Definitions « ( » RETURNS _ NULL _ CONTEXT « ) ; » assert That « ( factory . » get Bean « ( " » factory Bean « " ) . » to String « ( ) ) . » is Equal To « ( " null " ) ; }
@Test { » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( factory ) . » load Bean Definitions « ( » ABSTRACT _ CONTEXT « ) ; factory . » get Beans With Annotation « ( Component . class ) ; }
@Test { » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( factory ) . » load Bean Definitions « ( » ABSTRACT _ CONTEXT « ) ; factory . » get Beans Of Type « ( » Abstract Factory Bean « . class ) ; }
@Test { » assert Exception Message For Misconfigured Factory Method « ( » root Bean Definition « ( Foo . class ) . » set Factory Method « ( " » no Arg Factory « " ) . » add Constructor Arg Value « ( " » bogus Arg « " ) . » get Bean Definition « ( ) , " Error creating bean with name 'foo' : No matching factory method found : factory method 'noArgFactory(String)' . " + " Check that a method with the specified name and arguments exists and that it is static . " ) ; }
@Test { » assert Exception Message For Misconfigured Factory Method « ( » root Bean Definition « ( Foo . class ) . » set Factory Method « ( " » no Arg Factory « " ) . » add Constructor Arg Value « ( " » bogus Arg 1 « " ) . » add Constructor Arg Value « ( " » bogus Arg 2 « " . » get Bytes « ( ) ) . » get Bean Definition « ( ) , " Error creating bean with name 'foo' : No matching factory method found : factory method 'noArgFactory(String,byte[])' . " + " Check that a method with the specified name and arguments exists and that it is static . " ) ; }
@Test { » assert Exception Message For Misconfigured Factory Method « ( » root Bean Definition « ( Foo . class ) . » set Factory Method « ( " » single Arg Factory « " ) . » get Bean Definition « ( ) , " Error creating bean with name 'foo' : " + " Unsatisfied dependency expressed through method 'singleArgFactory' parameter 0 : " + " Ambiguous argument values for parameter of type [ java . lang . String ] - " + " did you specify the correct bean references as arguments ? " ) ; }
@Test { » Listable Bean Factory « lbf = new » Default Listable Bean Factory « ( ) ; » assert That « ( lbf . » get Bean Definition Names « ( ) != null ) . as ( " No beans defined -- > array != null " ) . » is True « ( ) ; » assert That « ( lbf . » get Bean Definition Names « ( ) . length == 0 ) . as ( " No beans defined after no arg constructor " ) . » is True « ( ) ; » assert That « ( lbf . » get Bean Definition Count « ( ) == 0 ) . as ( " No beans defined after no arg constructor " ) . » is True « ( ) ; }
@Test { Properties p = new Properties ( ) ; ( new » Properties Bean Definition Reader « ( lbf ) ) . » register Bean Definitions « ( p ) ; » assert That « ( lbf . » get Bean Definition Count « ( ) == 0 ) . as ( " No beans defined after ignorable invalid " ) . » is True « ( ) ; }
@Test { Properties p = new Properties ( ) ; p . » set Property « ( " foo " , " bar " ) ; p . » set Property « ( " qwert " , " er " ) ; ( new » Properties Bean Definition Reader « ( lbf ) ) . » register Bean Definitions « ( p , " test " ) ; » assert That « ( lbf . » get Bean Definition Count « ( ) == 0 ) . as ( " No beans defined after harmless ignorable rubbish " ) . » is True « ( ) ; }
@Test { Properties p = new Properties ( ) ; p . » set Property « ( " test . ( class ) " , » Test Bean « . class . » get Name « ( ) ) ; p . » set Property « ( " test . name " , " Tony " ) ; p . » set Property « ( " test . age " , " 48 " ) ; int count = ( new » Properties Bean Definition Reader « ( lbf ) ) . » register Bean Definitions « ( p ) ; » assert That « ( count == 1 ) . as ( " 1 beans registered , not " + count ) . » is True « ( ) ; » single Test Bean « ( lbf ) ; }
@Test { » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . add ( " spouse " , new » Runtime Bean Reference « ( " self " ) ) ; » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; bd . » set Property Values « ( pvs ) ; lbf . » register Bean Definition « ( " self " , bd ) ; » Test Bean « self = ( » Test Bean « ) lbf . » get Bean « ( " self " ) ; » assert That « ( self . » get Spouse « ( ) ) . » is Equal To « ( self ) ; }
@Test { Properties p = new Properties ( ) ; p . » set Property « ( " kerry . ( class ) " , » Test Bean « . class . » get Name « ( ) ) ; p . » set Property « ( " kerry . age " , " 35 " ) ; ( new » Properties Bean Definition Reader « ( lbf ) ) . » register Bean Definitions « ( p ) ; try { ( new » Properties Bean Definition Reader « ( lbf ) ) . » register Bean Definitions « ( p ) ; } catch ( » Bean Definition Store Exception « ex ) { » assert That « ( ex . » get Bean Name « ( ) ) . » is Equal To « ( " kerry " ) ; } }
@Test { lbf . » register Alias « ( " test " , " » test 2 « " ) ; lbf . » register Alias « ( " » test 2 « " , " » test 3 « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » register Alias « ( " » test 3 « " , " » test 2 « " ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » register Alias « ( " » test 3 « " , " test " ) ) ; lbf . » register Alias « ( " test " , " » test 3 « " ) ; }
@Test { final int MAX = 200 ; lbf . » set Allow Bean Definition Overriding « ( false ) ; » Int Stream « . range ( 0 , MAX ) . » for Each « ( this :: » register Test Bean « ) ; lbf . » pre Instantiate Singletons « ( ) ; » Int Stream « . range ( 0 , MAX ) . parallel ( ) . » for Each « ( this :: » remove Test Bean « ) ; }
@Test { String name = " * name " ; Properties p = new Properties ( ) ; p . » set Property « ( " r . ( class ) " , » Test Bean « . class . » get Name « ( ) ) ; p . » set Property « ( " r . name " , " * " + name ) ; ( new » Properties Bean Definition Reader « ( lbf ) ) . » register Bean Definitions « ( p ) ; » Test Bean « r = ( » Test Bean « ) lbf . » get Bean « ( " r " ) ; » assert That « ( r . » get Name « ( ) . equals ( name ) ) . » is True « ( ) ; }
@Test { Object » singleton Object « = new » Test Bean « ( ) ; lbf . » register Singleton « ( " » singleton Object « " , » singleton Object « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » register Singleton « ( " » singleton Object « " , » singleton Object « ) ) ; }
@Test { » Root Bean Definition « rbd = new » Root Bean Definition « ( » Array Bean « . class ) ; rbd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ BY _ TYPE « ) ; lbf . » register Bean Definition « ( " » array Bean « " , rbd ) ; » Array Bean « ab = ( » Array Bean « ) lbf . » get Bean « ( " » array Bean « " ) ; » assert That « ( ab . » get Resource Array « ( ) ) . » is Null « ( ) ; }
@Test { » Root Bean Definition « rbd = new » Root Bean Definition « ( » Array Bean « . class ) ; rbd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; lbf . » register Bean Definition « ( " » array Bean « " , rbd ) ; » Array Bean « ab = ( » Array Bean « ) lbf . » get Bean « ( " » array Bean « " ) ; » assert That « ( ab . » get Integer Array « ( ) ) . » is Null « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " rod " , bd ) ; » assert That « ( lbf . » get Bean Definition Count « ( ) ) . » is Equal To « ( 1 ) ; Object registered = lbf . autowire ( » No Dependencies « . class , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , false ) ; » assert That « ( lbf . » get Bean Definition Count « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( registered instanceof » No Dependencies « ) . » is True « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " spous " , bd ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> lbf . autowire ( » Dependencies Bean « . class , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ NAME « , true ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " spous " , bd ) ; » Dependencies Bean « bean = ( » Dependencies Bean « ) lbf . autowire ( » Dependencies Bean « . class , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ NAME « , false ) ; » assert That « ( bean . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » Default Listable Bean Factory « lbf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » Default Listable Bean Factory « parent = new » Default Listable Bean Factory « ( ) ; » Root Bean Definition « » bd 1 « = new » Root Bean Definition « ( » Test Bean « . class ) ; parent . » register Bean Definition « ( " » bd 1 « " , » bd 1 « ) ; » Default Listable Bean Factory « lbf = new » Default Listable Bean Factory « ( parent ) ; » Test Bean « bean = lbf . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean . » get Bean Name « ( ) ) . » is Equal To « ( " » bd 1 « " ) ; }
@Test { » Root Bean Definition « » bd 1 « = new » Root Bean Definition « ( » Test Bean « . class ) ; » Root Bean Definition « » bd 2 « = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " » bd 1 « " , » bd 1 « ) ; lbf . » register Bean Definition « ( " » bd 2 « " , » bd 2 « ) ; » assert That Exception Of Type « ( » No Unique Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » get Bean « ( ( Class < ? > ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » get Bean Provider « ( ( Class < ? > ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » resolve Named Bean « ( ( Class < ? > ) null ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » Dependencies Bean « bean = ( » Dependencies Bean « ) lbf . autowire ( » Dependencies Bean « . class , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , true ) ; » Test Bean « test = ( » Test Bean « ) lbf . » get Bean « ( " test " ) ; » assert That « ( bean . » get Spouse « ( ) ) . » is Equal To « ( test ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Factory Bean That Shouldnt Be Called « . class ) ; bd . » set Abstract « ( true ) ; lbf . » register Bean Definition « ( " » factory Bean « " , bd ) ; » assert That « ( lbf . » get Type « ( " » factory Bean « " ) ) . » is Null « ( ) ; }
@Test { » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> lbf . autowire ( » Dependencies Bean « . class , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , true ) ) ; }
@Test { » Dependencies Bean « bean = ( » Dependencies Bean « ) lbf . autowire ( » Dependencies Bean « . class , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , false ) ; » assert That « ( bean . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " spous " , bd ) ; » Dependencies Bean « » existing Bean « = new » Dependencies Bean « ( ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » autowire Bean Properties « ( » existing Bean « , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ NAME « , true ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " spous " , bd ) ; » Dependencies Bean « » existing Bean « = new » Dependencies Bean « ( ) ; lbf . » autowire Bean Properties « ( » existing Bean « , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ NAME « , false ) ; » assert That « ( » existing Bean « . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Test Bean « . class ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » Dependencies Bean « » existing Bean « = new » Dependencies Bean « ( ) ; lbf . » autowire Bean Properties « ( » existing Bean « , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , true ) ; » Test Bean « test = ( » Test Bean « ) lbf . » get Bean « ( " test " ) ; » assert That « ( test ) . » is Equal To « ( » existing Bean « . » get Spouse « ( ) ) ; }
@Test { » Dependencies Bean « » existing Bean « = new » Dependencies Bean « ( ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » autowire Bean Properties « ( » existing Bean « , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , true ) ) ; }
@Test { » Dependencies Bean « » existing Bean « = new » Dependencies Bean « ( ) ; lbf . » autowire Bean Properties « ( » existing Bean « , » Autowire Capable Bean Factory « . » AUTOWIRE _ BY _ TYPE « , false ) ; » assert That « ( » existing Bean « . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lbf . » autowire Bean Properties « ( new » Test Bean « ( ) , » Autowire Capable Bean Factory « . » AUTOWIRE _ CONSTRUCTOR « , false ) ) ; }
@Test { » Test Bean « tb = lbf . » create Bean « ( » Test Bean « . class ) ; » assert That « ( tb . » get Bean Factory « ( ) ) . » is Same As « ( lbf ) ; lbf . » destroy Bean « ( tb ) ; }
@Test { » Derived Test Bean « tb = lbf . » create Bean « ( » Derived Test Bean « . class ) ; » assert That « ( tb . » get Bean Factory « ( ) ) . » is Same As « ( lbf ) ; lbf . » destroy Bean « ( tb ) ; » assert That « ( tb . » was Destroyed « ( ) ) . » is True « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Constructor Dependency Bean « . class ) ; bd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( lbf :: » pre Instantiate Singletons « ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Constructor Dependency Factory Bean « . class ) ; bd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( lbf :: » pre Instantiate Singletons « ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Constructor Dependency Factory Bean « . class ) ; bd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » get Beans Of Type « ( String . class ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Constructor Dependency Factory Bean « . class ) ; bd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » Root Bean Definition « » bd 2 « = new » Root Bean Definition « ( String . class ) ; » bd 2 « . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; lbf . » register Bean Definition « ( " string " , » bd 2 « ) ; lbf . » pre Instantiate Singletons « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Constructor Dependency With Class Resolution « . class ) ; bd . » get Constructor Argument Values « ( ) . » add Generic Argument Value « ( " java . lang . String " ) ; lbf . » register Bean Definition « ( " test " , bd ) ; lbf . » pre Instantiate Singletons « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Constructor Dependency With Class Resolution « . class ) ; bd . » get Constructor Argument Values « ( ) . » add Generic Argument Value « ( " java . lang . Strin " ) ; lbf . » register Bean Definition « ( " test " , bd ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( lbf :: » pre Instantiate Singletons « ) ; }
@Test { lbf . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » I Test Bean « . class ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » get Bean « ( " test " ) ) . » with Message Containing « ( " interface " ) . satisfies ( ex -> » assert That « ( ex . » get Bean Name « ( ) ) . » is Equal To « ( " test " ) ) ; }
@Test { lbf . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » Abstract Bean Factory « . class ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> lbf . » get Bean « ( " test " ) ) . » with Message Containing « ( " abstract " ) . satisfies ( ex -> » assert That « ( ex . » get Bean Name « ( ) ) . » is Equal To « ( " test " ) ) ; }
@Test { lbf . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » Factory Bean That Shouldnt Be Called « . class ) ) ; lbf . » pre Instantiate Singletons « ( ) ; }
@Test { lbf . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » Lazy Init Factory « . class ) ) ; lbf . » pre Instantiate Singletons « ( ) ; » Lazy Init Factory « factory = ( » Lazy Init Factory « ) lbf . » get Bean « ( " & test " ) ; » assert That « ( factory . initialized ) . » is False « ( ) ; }
@Test { lbf . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » Eager Init Factory « . class ) ) ; lbf . » pre Instantiate Singletons « ( ) ; » Eager Init Factory « factory = ( » Eager Init Factory « ) lbf . » get Bean « ( " & test " ) ; » assert That « ( factory . initialized ) . » is True « ( ) ; }
@Test { lbf . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » Factory Bean That Shouldnt Be Called « . class . » get Name « ( ) , null , null ) ) ; lbf . » pre Instantiate Singletons « ( ) ; }
@Test { » find Type Of Prototype Factory Method On Bean Instance « ( true ) ; }
@Test { » find Type Of Prototype Factory Method On Bean Instance « ( false ) ; }
@Test { » Bean Definition Builder « builder = » Bean Definition Builder « . » root Bean Definition « ( » Test Bean « . class ) ; » Abstract Bean Definition « » bean Definition « = builder . » get Bean Definition « ( ) ; » bean Definition « . » set Scope « ( " he put himself so low could hardly look me in the face " ) ; » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; factory . » register Bean Definition « ( " » test Bean « " , » bean Definition « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> factory . » get Bean « ( " » test Bean « " ) ) ; }
@Test { » do Test Field Setting With Instantiation Aware Post Processor « ( false ) ; }
@Test { » do Test Field Setting With Instantiation Aware Post Processor « ( true ) ; }
@Test { lbf . » register Bean Definition « ( " abs " , » Bean Definition Builder « . » root Bean Definition « ( » Test Bean « . class ) . » set Abstract « ( true ) . » get Bean Definition « ( ) ) ; » assert That « ( lbf . » contains Bean « ( " abs " ) ) . » is Equal To « ( true ) ; » assert That « ( lbf . » contains Bean « ( " bogus " ) ) . » is Equal To « ( false ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( Optional . class ) ; bd . » set Factory Method Name « ( " of " ) ; bd . » get Constructor Argument Values « ( ) . » add Generic Argument Value « ( " CONTENT " ) ; lbf . » register Bean Definition « ( " » optional Bean « " , bd ) ; » assert That « ( ( Optional < ? > ) lbf . » get Bean « ( Optional . class ) ) . » is Equal To « ( Optional . of ( " CONTENT " ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( Optional . class ) ; bd . » set Factory Method Name « ( " empty " ) ; lbf . » register Bean Definition « ( " » optional Bean « " , bd ) ; » assert That « ( ( Optional < ? > ) lbf . » get Bean « ( Optional . class ) ) . » is Same As « ( Optional . empty ( ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Non Public Enum Holder « . class ) ; bd . » get Constructor Argument Values « ( ) . » add Generic Argument Value « ( " » VALUE _ 1 « " ) ; lbf . » register Bean Definition « ( " » holder Bean « " , bd ) ; » Non Public Enum Holder « holder = ( » Non Public Enum Holder « ) lbf . » get Bean « ( " » holder Bean « " ) ; » assert That « ( holder . » get Non Public Enum « ( ) ) . » is Equal To « ( » Non Public Enum « . » VALUE _ 1 « ) ; }
@Test { for ( int i = 0 ; i < 1000 ; i ++ ) { lbf . » register Bean Definition « ( " a " + i , new » Root Bean Definition « ( A . class ) ) ; } lbf . » register Bean Definition « ( " b " , new » Root Bean Definition « ( B . class ) ) ; lbf . » freeze Configuration « ( ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { lbf . » get Bean « ( B . class ) ; } }
@Test { lbf . » register Bean Definition « ( " b " , new » Root Bean Definition « ( B . class ) ) ; for ( int i = 0 ; i < 100000 ; i ++ ) { lbf . » register Bean Definition « ( " a " + i , new » Root Bean Definition « ( A . class ) ) ; } }
@Test { lbf . » register Bean Definition « ( " b " , new » Root Bean Definition « ( B . class ) ) ; for ( int i = 0 ; i < 100000 ; i ++ ) { lbf . » register Singleton « ( " a " + i , new A ( ) ) ; } }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Annotation Bean Wiring Info Resolver « ( ) . » resolve Wiring Info « ( null ) ) ; }
@Test { » Annotation Bean Wiring Info Resolver « resolver = new » Annotation Bean Wiring Info Resolver « ( ) ; » Bean Wiring Info « info = resolver . » resolve Wiring Info « ( " java . lang . String is not @ Configurable " ) ; » assert That « ( info ) . as ( " Must be returning null for a non - @ Configurable class instance " ) . » is Null « ( ) ; }
@Test { » Annotation Bean Wiring Info Resolver « resolver = new » Annotation Bean Wiring Info Resolver « ( ) ; » Bean Wiring Info « info = resolver . » resolve Wiring Info « ( new Soap ( ) ) ; » assert That « ( info ) . as ( " Must * not * be returning null for a non - @ Configurable class instance " ) . » is Not Null « ( ) ; }
@Test { » Annotation Bean Wiring Info Resolver « resolver = new » Annotation Bean Wiring Info Resolver « ( ) ; » Bean Wiring Info « info = resolver . » resolve Wiring Info « ( new » Wireless Soap « ( ) ) ; » assert That « ( info ) . as ( " Must * not * be returning null for an @ Configurable class instance even when autowiring is NO " ) . » is Not Null « ( ) ; » assert That « ( info . » indicates Autowiring « ( ) ) . » is False « ( ) ; » assert That « ( info . » get Bean Name « ( ) ) . » is Equal To « ( » Wireless Soap « . class . » get Name « ( ) ) ; }
@Test { » Annotation Bean Wiring Info Resolver « resolver = new » Annotation Bean Wiring Info Resolver « ( ) ; » Bean Wiring Info « info = resolver . » resolve Wiring Info « ( new » Named Wireless Soap « ( ) ) ; » assert That « ( info ) . as ( " Must * not * be returning null for an @ Configurable class instance even when autowiring is NO " ) . » is Not Null « ( ) ; » assert That « ( info . » indicates Autowiring « ( ) ) . » is False « ( ) ; » assert That « ( info . » get Bean Name « ( ) ) . » is Equal To « ( " » Der Big Stick « " ) ; }
@Test { bf . » register Bean Definition « ( " » test Bean « " , new » Generic Bean Definition « ( ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » test Bean « " ) ) . » with Root Cause Instance Of « ( » Illegal State Exception « . class ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Constructor Without Fallback Bean « . class ) ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » annotated Bean « " ) ) . satisfies ( » method Parameter Declared On « ( » Constructor Without Fallback Bean « . class ) ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Single Constructor Optional Collection Bean « . class ) ) ; » Test Bean « tb = new » Test Bean « ( ) ; bf . » register Singleton « ( " » test Bean « " , tb ) ; » Single Constructor Optional Collection Bean « bean = ( » Single Constructor Optional Collection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Same As « ( tb ) ; » assert That « ( bean . » get Nested Test Beans « ( ) ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Single Constructor Optional Collection Bean « . class ) ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » annotated Bean « " ) ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Single Constructor Optional Collection Bean « . class ) ) ; » Root Bean Definition « tb = new » Root Bean Definition « ( » Null Factory Methods « . class ) ; tb . » set Factory Method Name « ( " » create Test Bean « " ) ; bf . » register Bean Definition « ( " » test Bean « " , tb ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » annotated Bean « " ) ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Constructors Resource Injection Bean « . class ) ) ; » Test Bean « tb = new » Test Bean « ( ) ; bf . » register Singleton « ( " » test Bean « " , tb ) ; » Constructors Resource Injection Bean « bean = ( » Constructors Resource Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean 3 « ( ) ) . » is Same As « ( tb ) ; » assert That « ( bean . » get Test Bean 4 « ( ) ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Constructors Resource Injection Bean « . class ) ) ; » Constructors Resource Injection Bean « bean = ( » Constructors Resource Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean 3 « ( ) ) . » is Null « ( ) ; » assert That « ( bean . » get Test Bean 4 « ( ) ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Map Method Injection Bean « . class ) ) ; » Map Method Injection Bean « bean = ( » Map Method Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean Map « ( ) ) . » is Null « ( ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Self Injection Bean « . class ) ) ; » Self Injection Bean « bean = ( » Self Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . reference ) . » is Same As « ( bean ) ; » assert That « ( bean . » reference Collection « ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Self Injection Collection Bean « . class ) ) ; » Self Injection Collection Bean « bean = ( » Self Injection Collection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . reference ) . » is Same As « ( bean ) ; » assert That « ( bean . » reference Collection « ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Object Factory Field Injection Bean « . class ) ) ; bf . » register Bean Definition « ( " » test Bean « " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » Object Factory Field Injection Bean « bean = ( » Object Factory Field Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Same As « ( bf . » get Bean « ( " » test Bean « " ) ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Object Factory Constructor Injection Bean « . class ) ) ; bf . » register Bean Definition « ( " » test Bean « " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » Object Factory Constructor Injection Bean « bean = ( » Object Factory Constructor Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Same As « ( bf . » get Bean « ( " » test Bean « " ) ) ; }
@Test { bpp . » set Autowired Annotation Type « ( » My Autowired « . class ) ; bpp . » set Required Parameter Name « ( " optional " ) ; bpp . » set Required Parameter Value « ( false ) ; bf . » register Bean Definition « ( " » custom Bean « " , new » Root Bean Definition « ( » Custom Annotation Required Field Resource Injection Bean « . class ) ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » custom Bean « " ) ) . satisfies ( » field Declared On « ( » Custom Annotation Required Field Resource Injection Bean « . class ) ) ; }
@Test { bpp . » set Autowired Annotation Type « ( » My Autowired « . class ) ; bpp . » set Required Parameter Name « ( " optional " ) ; bpp . » set Required Parameter Value « ( false ) ; bf . » register Bean Definition « ( " » custom Bean « " , new » Root Bean Definition « ( » Custom Annotation Required Method Resource Injection Bean « . class ) ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » custom Bean « " ) ) . satisfies ( » method Parameter Declared On « ( » Custom Annotation Required Method Resource Injection Bean « . class ) ) ; }
@Test { bf . » register Bean Definition « ( " » bean 1 « " , new » Root Bean Definition « ( » My Callable « . class ) ) ; bf . » register Bean Definition « ( " » bean 2 « " , new » Root Bean Definition « ( » Second Callable « . class ) ) ; bf . » register Bean Definition « ( " » bean 3 « " , new » Root Bean Definition « ( » Foo Bar « . class ) ) ; » assert That « ( bf . » get Bean « ( » Foo Bar « . class ) ) . » is Not Null « ( ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Provided Argument Bean « . class ) ; bd . » get Constructor Argument Values « ( ) . » add Generic Argument Value « ( Collections . » singleton List « ( " value " ) ) ; bf . » register Bean Definition « ( " » bean With Args « " , bd ) ; » assert That « ( bf . » get Bean « ( » Provided Argument Bean « . class ) ) . » is Not Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Annotated Default Constructor Bean « . class ) ) ; » assert That « ( bf . » get Bean « ( " » annotated Bean « " ) ) . » is Not Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Self Injecting Factory Bean « . class ) ) ; » Self Injecting Factory Bean « bean = bf . » get Bean « ( » Self Injecting Factory Bean « . class ) ; » assert That « ( bean . » test Bean « ) . » is Same As « ( bf . » get Bean « ( " » annotated Bean « " ) ) ; }
@Test { » Root Bean Definition « bd = new » Root Bean Definition « ( » Self Injecting Factory Bean « . class ) ; bd . » set Factory Method Name « ( " create " ) ; bf . » register Bean Definition « ( " » annotated Bean « " , bd ) ; » Self Injecting Factory Bean « bean = bf . » get Bean « ( » Self Injecting Factory Bean « . class ) ; » assert That « ( bean . » test Bean « ) . » is Same As « ( bf . » get Bean « ( " » annotated Bean « " ) ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; Object expected = bean . get ( ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( » bean Factory « . » get Bean « ( » Bean Consumer « . class ) . » abstract Bean « ) . » is Same As « ( bean ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » assert That Exception Of Type « ( » Abstract Method Error « . class ) . as ( " » Test Bean « has no three arg constructor " ) . » is Thrown By « ( ( ) -> bean . » get Three Arguments « ( " name " , 1 , 2 ) ) ; » assert That « ( » bean Factory « . » get Bean « ( » Bean Consumer « . class ) . » abstract Bean « ) . » is Same As « ( bean ) ; }
@Test { » Abstract Bean « bean = » bean Factory « . » get Bean « ( " » bean Consumer « " , » Bean Consumer « . class ) . » abstract Bean « ; » assert That « ( bean ) . » is Not Null « ( ) ; Object expected = bean . get ( ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( » bean Factory « . » get Bean « ( » Bean Consumer « . class ) . » abstract Bean « ) . » is Same As « ( bean ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Parameter Resolution Delegate « . » is Autowirable « ( null , 0 ) ) . » with Message Containing « ( " Parameter must not be null " ) ; }
@Test { Method method = » get Class « ( ) . » get Declared Method « ( " » autowirable Method « " , String . class , String . class , String . class , String . class ) ; » assert Autowirable Parameters « ( method ) ; }
@Test { Constructor < ? > constructor = » Autowirable Class « . class . » get Constructor « ( String . class , String . class , String . class , String . class ) ; » assert Autowirable Parameters « ( constructor ) ; }
@Test { Class < ? > » inner Class « = » Autowirable Class « . » Inner Autowirable Class « . class ; » assert That « ( » Class Utils « . » is Inner Class « ( » inner Class « ) ) . » is True « ( ) ; Constructor < ? > constructor = » inner Class « . » get Constructor « ( » Autowirable Class « . class , String . class , String . class ) ; » assert Autowirable Parameters « ( constructor ) ; }
@Test { Constructor < ? > » not Autowirable Constructor « = » Autowirable Class « . class . » get Constructor « ( String . class ) ; Parameter [ ] parameters = » not Autowirable Constructor « . » get Parameters « ( ) ; for ( int » parameter Index « = 0 ; » parameter Index « < parameters . length ; » parameter Index « ++ ) { Parameter parameter = parameters [ » parameter Index « ] ; » assert That « ( » Parameter Resolution Delegate « . » is Autowirable « ( parameter , » parameter Index « ) ) . as ( " Parameter " + parameter + " must not be autowirable " ) . » is False « ( ) ; } }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Parameter Resolution Delegate « . » resolve Dependency « ( null , 0 , null , mock ( » Autowire Capable Bean Factory « . class ) ) ) . » with Message Containing « ( " Parameter must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Parameter Resolution Delegate « . » resolve Dependency « ( » get Parameter « ( ) , 0 , null , null ) ) . » with Message Containing « ( " Containing class must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Parameter Resolution Delegate « . » resolve Dependency « ( » get Parameter « ( ) , 0 , » get Class « ( ) , null ) ) . » with Message Containing « ( " » Autowire Capable Bean Factory « must not be null " ) ; }
@Test { bf . » register Bean Definition « ( " » test Bean « " , new » Generic Bean Definition « ( ) ) ; try { bf . » get Bean « ( " » test Bean « " ) ; } catch ( » Bean Creation Exception « ex ) { boolean condition = ex . » get Root Cause « ( ) instanceof » Illegal State Exception « ; » assert That « ( condition ) . » is True « ( ) ; } }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Nullable Field Injection Bean « . class ) ) ; bf . » register Bean Definition « ( " » test Bean « " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » Nullable Field Injection Bean « bean = ( » Nullable Field Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Same As « ( bf . » get Bean « ( " » test Bean « " ) ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Nullable Field Injection Bean « . class ) ) ; » Nullable Field Injection Bean « bean = ( » Nullable Field Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Nullable Method Injection Bean « . class ) ) ; bf . » register Bean Definition « ( " » test Bean « " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » Nullable Method Injection Bean « bean = ( » Nullable Method Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Same As « ( bf . » get Bean « ( " » test Bean « " ) ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Nullable Method Injection Bean « . class ) ) ; » Nullable Method Injection Bean « bean = ( » Nullable Method Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Null « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Optional Field Injection Bean « . class ) ) ; » Optional Field Injection Bean « bean = ( » Optional Field Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) . » is Present « ( ) ) . » is False « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Optional Method Injection Bean « . class ) ) ; » Optional Method Injection Bean « bean = ( » Optional Method Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) . » is Present « ( ) ) . » is False « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Optional List Field Injection Bean « . class ) ) ; » Optional List Field Injection Bean « bean = ( » Optional List Field Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) . » is Present « ( ) ) . » is False « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Optional List Method Injection Bean « . class ) ) ; » Optional List Method Injection Bean « bean = ( » Optional List Method Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) . » is Present « ( ) ) . » is False « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Provider Of Optional Field Injection Bean « . class ) ) ; » Provider Of Optional Field Injection Bean « bean = ( » Provider Of Optional Field Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) . » is Present « ( ) ) . » is False « ( ) ; }
@Test { bf . » register Bean Definition « ( " » annotated Bean « " , new » Root Bean Definition « ( » Provider Of Optional Method Injection Bean « . class ) ) ; » Provider Of Optional Method Injection Bean « bean = ( » Provider Of Optional Method Injection Bean « ) bf . » get Bean « ( " » annotated Bean « " ) ; » assert That « ( bean . » get Test Bean « ( ) . » is Present « ( ) ) . » is False « ( ) ; }
@Test { this . processor . » set Resources « ( new » Byte Array Resource « ( " foo # a document that is a literal " . » get Bytes « ( ) ) ) ; this . processor . process ( ( properties , map ) -> » assert That « ( map . get ( " document " ) ) . » is Equal To « ( " foo " ) ) ; }
@Test { this . processor . » set Resources « ( new » Byte Array Resource « ( " foo # a document \n bar : baz " . » get Bytes « ( ) ) ) ; » assert That Exception Of Type « ( » Parser Exception « . class ) . » is Thrown By « ( ( ) -> this . processor . process ( ( properties , map ) -> { } ) ) . » with Message Containing « ( " line 2 , column 1 " ) ; }
@Test { this . processor . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n cd \n spam : \n foo : baz " . » get Bytes « ( ) ) ) ; » assert That Exception Of Type « ( » Scanner Exception « . class ) . » is Thrown By « ( ( ) -> this . processor . process ( ( properties , map ) -> { } ) ) . » with Message Containing « ( " line 3 , column 1 " ) ; }
@Test { this . processor . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n bar : \n spam : bucket " . » get Bytes « ( ) ) ) ; this . processor . process ( ( properties , map ) -> { » assert That « ( properties . get ( " bar . spam " ) ) . » is Equal To « ( " bucket " ) ; » assert That « ( properties ) . » has Size « ( 2 ) ; } ) ; }
@Test { this . processor . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n 1 : bar " . » get Bytes « ( ) ) ) ; this . processor . process ( ( properties , map ) -> { » assert That « ( properties . get ( " [ 1 ] " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( properties ) . » has Size « ( 2 ) ; } ) ; }
@Test { this . processor . » set Resources « ( new » Byte Array Resource « ( " foo : \n 1 : bar " . » get Bytes « ( ) ) ) ; this . processor . process ( ( properties , map ) -> { » assert That « ( properties . get ( " foo [ 1 ] " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( properties ) . » has Size « ( 1 ) ; } ) ; }
@Test { » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » post Process Bean Factory « ( factory ) ; }
@Test { Scope scope = mock ( Scope . class ) ; factory . » register Scope « ( » FOO _ SCOPE « , scope ) ; Map < String , Object > scopes = new » Hash Map « < > ( ) ; scopes . put ( » FOO _ SCOPE « , scope ) ; » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » set Scopes « ( scopes ) ; figurer . » post Process Bean Factory « ( factory ) ; }
@Test { Map < String , Object > scopes = new » Hash Map « < > ( ) ; scopes . put ( » FOO _ SCOPE « , » No Op Scope « . class ) ; » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » set Scopes « ( scopes ) ; figurer . » post Process Bean Factory « ( factory ) ; boolean condition = factory . » get Registered Scope « ( » FOO _ SCOPE « ) instanceof » No Op Scope « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { Map < String , Object > scopes = new » Hash Map « < > ( ) ; scopes . put ( » FOO _ SCOPE « , » No Op Scope « . class . » get Name « ( ) ) ; » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » set Scopes « ( scopes ) ; figurer . » post Process Bean Factory « ( factory ) ; boolean condition = factory . » get Registered Scope « ( » FOO _ SCOPE « ) instanceof » No Op Scope « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { Map < String , Object > scopes = new » Hash Map « < > ( ) ; scopes . put ( » FOO _ SCOPE « , null ) ; » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » set Scopes « ( scopes ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> figurer . » post Process Bean Factory « ( factory ) ) ; }
@Test { Map < String , Object > scopes = new » Hash Map « < > ( ) ; scopes . put ( » FOO _ SCOPE « , this ) ; » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » set Scopes « ( scopes ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> figurer . » post Process Bean Factory « ( factory ) ) ; }
@Test { Map scopes = new » Hash Map « ( ) ; scopes . put ( this , new » No Op Scope « ( ) ) ; » Custom Scope Configurer « figurer = new » Custom Scope Configurer « ( ) ; figurer . » set Scopes « ( scopes ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> figurer . » post Process Bean Factory « ( factory ) ) ; }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Static Field « ( " java . sql . Connection . » TRANSACTION _ SERIALIZABLE « " ) ; fr . » after Properties Set « ( ) ; » assert That « ( fr . » get Object « ( ) ) . » is Equal To « ( new Integer ( Connection . » TRANSACTION _ SERIALIZABLE « ) ) ; }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Target Class « ( Connection . class ) ; fr . » set Target Field « ( " » TRANSACTION _ SERIALIZABLE « " ) ; fr . » after Properties Set « ( ) ; » assert That « ( fr . » get Object « ( ) ) . » is Equal To « ( new Integer ( Connection . » TRANSACTION _ SERIALIZABLE « ) ) ; }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; » Public Field Holder « target = new » Public Field Holder « ( ) ; fr . » set Target Object « ( target ) ; fr . » set Target Field « ( " » public Field « " ) ; fr . » after Properties Set « ( ) ; » assert That « ( fr . » get Object « ( ) ) . » is Equal To « ( target . » public Field « ) ; }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Bean Name « ( " java . sql . Connection . » TRANSACTION _ SERIALIZABLE « " ) ; fr . » after Properties Set « ( ) ; » assert That « ( fr . » get Object « ( ) ) . » is Equal To « ( new Integer ( Connection . » TRANSACTION _ SERIALIZABLE « ) ) ; }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Target Field « ( " » TRANSACTION _ SERIALIZABLE « " ) ; try { fr . » after Properties Set « ( ) ; } catch ( » Illegal Argument Exception « expected ) { } }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Target Class « ( Connection . class ) ; try { fr . » after Properties Set « ( ) ; } catch ( » Illegal Argument Exception « expected ) { } }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Target Object « ( new » Public Field Holder « ( ) ) ; try { fr . » after Properties Set « ( ) ; } catch ( » Illegal Argument Exception « expected ) { } }
@Test { » Field Retrieving Factory Bean « fr = new » Field Retrieving Factory Bean « ( ) ; fr . » set Bean Name « ( " org . springframework . beans . testfixture . beans . » Package Level Visible Bean « . CONSTANT " ) ; fr . » after Properties Set « ( ) ; » assert That « ( fr . » get Object « ( ) ) . » is Equal To « ( " Wuby " ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Class « ( » Test Class 1 « . class ) ; » method Invoker « . » set Target Method « ( " » null Argument « " ) ; » method Invoker « . » set Arguments « ( new Object [ ] { null } ) ; » method Invoker « . prepare ( ) ; » method Invoker « . invoke ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; bf . » register Bean Definition « ( " » test Bean « " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " name " , " $ { my . name } " ) . » get Bean Definition « ( ) ) ; » Property Placeholder Configurer « pc = new » Property Placeholder Configurer « ( ) ; Resource resource = new » Class Path Resource « ( " » Property Placeholder Configurer Tests « . properties " , this . » get Class « ( ) ) ; pc . » set Location « ( resource ) ; pc . » post Process Bean Factory « ( bf ) ; }
@Test { System . » clear Property « ( » P 1 « ) ; » register With Generated Name « ( » p 1 Bean Def « , bf ) ; ppc . » post Process Bean Factory « ( bf ) ; » Test Bean « bean = bf . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( » P 1 _ LOCAL _ PROPS _ VAL « ) ; }
@Test { » register With Generated Name « ( » p 1 Bean Def « , bf ) ; ppc . » post Process Bean Factory « ( bf ) ; » Test Bean « bean = bf . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( » P 1 _ LOCAL _ PROPS _ VAL « ) ; }
@Test { » register With Generated Name « ( » p 1 Bean Def « , bf ) ; ppc . » set System Properties Mode « ( » Property Placeholder Configurer « . » SYSTEM _ PROPERTIES _ MODE _ OVERRIDE « ) ; ppc . » post Process Bean Factory « ( bf ) ; » Test Bean « bean = bf . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( » P 1 _ SYSTEM _ PROPS _ VAL « ) ; }
@Test { » register With Generated Name « ( » p 1 Bean Def « , bf ) ; System . » clear Property « ( » P 1 « ) ; ppc . » set Search System Environment « ( false ) ; ppc . » set System Properties Mode « ( » Property Placeholder Configurer « . » SYSTEM _ PROPERTIES _ MODE _ OVERRIDE « ) ; ppc . » post Process Bean Factory « ( bf ) ; » Test Bean « bean = bf . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( » P 1 _ LOCAL _ PROPS _ VAL « ) ; }
@Test { » Test Bean « » tb 1 « = ( » Test Bean « ) » bean Factory « . » get Bean « ( " » uses Scope « " ) ; » Test Bean « » tb 2 « = ( » Test Bean « ) » bean Factory « . » get Bean « ( " » uses Scope « " ) ; » assert That « ( » tb 2 « ) . » is Not Same As « ( » tb 1 « ) ; » Test Bean « » tb 3 « = ( » Test Bean « ) » bean Factory « . » get Bean « ( " » uses Scope « " ) ; » assert That « ( » tb 1 « ) . » is Same As « ( » tb 3 « ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( CONTEXT ) ; » assert That « ( xbf . » get Type « ( " tb . spouse . spouse " ) ) . » is Null « ( ) ; » assert That « ( xbf . » get Bean « ( " tb . spouse . spouse " ) . » to String « ( ) ) . » is Equal To « ( " null " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( CONTEXT ) ; » assert That « ( xbf . » get Bean « ( " » tb With Null Reference « " , » Test Bean « . class ) . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( CONTEXT ) ; » assert That « ( xbf . » get Bean « ( " » tb With Inner Null « " , » Test Bean « . class ) . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n spam : \n foo : baz " . » get Bytes « ( ) ) ) ; Properties properties = factory . » get Object « ( ) ; » assert That « ( properties . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( properties . » get Property « ( " spam . foo " ) ) . » is Equal To « ( " baz " ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n cd \n spam : \n foo : baz " . » get Bytes « ( ) ) ) ; » assert That Exception Of Type « ( » Scanner Exception « . class ) . » is Thrown By « ( factory :: » get Object « ) . » with Message Containing « ( " line 3 , column 1 " ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n spam : \n foo : baz \n foo : bucket " . » get Bytes « ( ) ) ) ; » assert That Exception Of Type « ( » Duplicate Key Exception « . class ) . » is Thrown By « ( factory :: » get Object « ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " foo : \n bar : spam \n foo : baz \n break : it \n foo : bucket " . » get Bytes « ( ) ) ) ; » assert That Exception Of Type « ( » Duplicate Key Exception « . class ) . » is Thrown By « ( factory :: » get Object « ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n spam : baz \n -- - \n foo : bag " . » get Bytes « ( ) ) ) ; Properties properties = factory . » get Object « ( ) ; » assert That « ( properties . » get Property « ( " foo " ) ) . » is Equal To « ( " bag " ) ; » assert That « ( properties . » get Property « ( " spam " ) ) . » is Equal To « ( " baz " ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resolution Method « ( » Resolution Method « . » OVERRIDE _ AND _ IGNORE « ) ; factory . » set Resources « ( new » Class Path Resource « ( " no - such - file . yml " ) ) ; Properties properties = factory . » get Object « ( ) ; » assert That « ( properties ) . » is Empty « ( ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " foo : bar \n spam : " . » get Bytes « ( ) ) ) ; Properties properties = factory . » get Object « ( ) ; » assert That « ( properties . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( properties . » get Property « ( " spam " ) ) . » is Equal To « ( " " ) ; }
@Test { » Yaml Properties Factory Bean « factory = new » Yaml Properties Factory Bean « ( ) ; factory . » set Resources « ( new » Byte Array Resource « ( " a : alpha \n test : [ ] " . » get Bytes « ( ) ) ) ; Properties properties = factory . » get Object « ( ) ; » assert That « ( properties . » get Property « ( " a " ) ) . » is Equal To « ( " alpha " ) ; » assert That « ( properties . » get Property « ( " test " ) ) . » is Equal To « ( " " ) ; }
@Test { Yaml yaml = new Yaml ( ) ; Map < String , ? > map = yaml . » load As « ( " foo : bar \n spam : \n foo : baz " , Map . class ) ; » assert That « ( map . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ( ( Map < String , Object > ) map . get ( " spam " ) ) . get ( " foo " ) ) . » is Equal To « ( " baz " ) ; }
@Test { this . factory . » set Resolution Method « ( » Yaml Map Factory Bean « . » Resolution Method « . » OVERRIDE _ AND _ IGNORE « ) ; this . factory . » set Resources « ( new » File System Resource « ( " non - exsitent - file . yml " ) ) ; » assert That « ( this . factory . » get Object « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> { this . factory . » set Resources « ( new » File System Resource « ( " non - exsitent - file . yml " ) ) ; this . factory . » get Object « ( ) . size ( ) ; } ) ; }
@Test { this . factory . » set Resources « ( new » Byte Array Resource « ( " foo : bar " . » get Bytes « ( ) ) ) ; » assert That « ( this . factory . » get Object « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { this . factory . » set Resources « ( new » Byte Array Resource « ( " foo : \n bar : spam " . » get Bytes « ( ) ) , new » Byte Array Resource « ( " foo : \n spam : bar " . » get Bytes « ( ) ) ) ; » assert That « ( this . factory . » get Object « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( ( ( Map < String , Object > ) this . factory . » get Object « ( ) . get ( " foo " ) ) . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { this . factory . » set Resources « ( new » Byte Array Resource « ( " mymap : \n foo : bar \n mymap : \n bar : foo " . » get Bytes « ( ) ) ) ; » assert That Exception Of Type « ( » Duplicate Key Exception « . class ) . » is Thrown By « ( ( ) -> this . factory . » get Object « ( ) . get ( " mymap " ) ) ; }
@Test { » do Test Property Placeholder Configurer « ( false ) ; }
@Test { » do Test Property Placeholder Configurer « ( true ) ; }
@Test { factory . » register Bean Definition « ( " tb " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " country " , " $ { os . name } " ) . » get Bean Definition « ( ) ) ; » Property Placeholder Configurer « ppc = new » Property Placeholder Configurer « ( ) ; ppc . » post Process Bean Factory « ( factory ) ; » Test Bean « tb = ( » Test Bean « ) factory . » get Bean « ( " tb " ) ; » assert That « ( tb . » get Country « ( ) ) . » is Equal To « ( System . » get Property « ( " os . name " ) ) ; }
@Test { factory . » register Bean Definition « ( " tb " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " name " , " $ { ref } " ) . » get Bean Definition « ( ) ) ; » Property Placeholder Configurer « ppc = new » Property Placeholder Configurer « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> ppc . » post Process Bean Factory « ( factory ) ) . » with Message Containing « ( " ref " ) ; }
@Test { factory . » register Bean Definition « ( " tb " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " name " , " $ { ref } " ) . » get Bean Definition « ( ) ) ; » Property Placeholder Configurer « ppc = new » Property Placeholder Configurer « ( ) ; ppc . » set Ignore Unresolvable Placeholders « ( true ) ; ppc . » post Process Bean Factory « ( factory ) ; » Test Bean « tb = ( » Test Bean « ) factory . » get Bean « ( " tb " ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( " $ { ref } " ) ; }
@Test { factory . » register Bean Definition « ( " tb " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " name " , " " ) . » get Bean Definition « ( ) ) ; » Property Placeholder Configurer « ppc = new » Property Placeholder Configurer « ( ) ; ppc . » set Null Value « ( " " ) ; ppc . » post Process Bean Factory « ( factory ) ; » Test Bean « tb = ( » Test Bean « ) factory . » get Bean « ( " tb " ) ; » assert That « ( tb . » get Name « ( ) ) . » is Null « ( ) ; }
@Test { factory . » register Bean Definition « ( " tb " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " touchy " , " $ { test : mytest } " ) . » get Bean Definition « ( ) ) ; » Property Placeholder Configurer « ppc = new » Property Placeholder Configurer « ( ) ; ppc . » post Process Bean Factory « ( factory ) ; » Test Bean « tb = ( » Test Bean « ) factory . » get Bean « ( " tb " ) ; » assert That « ( tb . » get Touchy « ( ) ) . » is Equal To « ( " mytest " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( new » Service Locator Factory Bean « ( ) :: » after Properties Set « ) ; }
@Test { » Service Locator Factory Bean « factory = new » Service Locator Factory Bean « ( ) ; factory . » set Service Locator Interface « ( » get Class « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( factory :: » after Properties Set « ) ; }
@Test { » Service Locator Factory Bean « factory = new » Service Locator Factory Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Service Locator Exception Class « ( » Exception Class With Only Zero Arg Ctor « . class ) ) ; }
@Test { » Service Locator Factory Bean « factory = new » Service Locator Factory Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Service Locator Exception Class « ( ( Class ) » get Class « ( ) ) ) ; }
@Test { » Service Locator Factory Bean « factory = new » Service Locator Factory Bean « ( ) ; factory . » set Service Locator Interface « ( » Service Locator Interface With Extra Non Compliant Method « . class ) ; factory . » after Properties Set « ( ) ; » Service Locator Interface With Extra Non Compliant Method « locator = ( » Service Locator Interface With Extra Non Compliant Method « ) factory . » get Object « ( ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> locator . » get Test Service « ( " not " , " allowed " ) ) ; }
@Test { » Bean Factory « » bean Factory « = mock ( » Bean Factory « . class ) ; try { » Service Locator Factory Bean « factory = new » Service Locator Factory Bean « ( ) ; factory . » set Bean Factory « ( » bean Factory « ) ; } catch ( » Fatal Bean Exception « ex ) { } }
@Test { » Factory Test Bean « » test Bean « = » bean Factory « . » get Bean « ( " » factory Test Bean « " , » Factory Test Bean « . class ) ; » Object Factory « < ? > » object Factory « = » test Bean « . » get Object Factory « ( ) ; Date » date 1 « = ( Date ) » object Factory « . » get Object « ( ) ; Date » date 2 « = ( Date ) » object Factory « . » get Object « ( ) ; » assert That « ( » date 1 « != » date 2 « ) . » is True « ( ) ; }
@Test { » Provider Test Bean « » test Bean « = » bean Factory « . » get Bean « ( " » provider Test Bean « " , » Provider Test Bean « . class ) ; Provider < ? > provider = » test Bean « . » get Provider « ( ) ; Date » date 1 « = ( Date ) provider . get ( ) ; Date » date 2 « = ( Date ) provider . get ( ) ; » assert That « ( » date 1 « != » date 2 « ) . » is True « ( ) ; }
@Test { » Provider Test Bean « » test Bean « = » bean Factory « . » get Bean « ( " » provider Test Bean « " , » Provider Test Bean « . class ) ; Provider < ? > provider = » test Bean « . » get Provider « ( ) ; provider = ( Provider ) » Serialization Test Utils « . » serialize And Deserialize « ( provider ) ; Date » date 1 « = ( Date ) provider . get ( ) ; Date » date 2 « = ( Date ) provider . get ( ) ; » assert That « ( » date 1 « != » date 2 « ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . as ( " 'targetBeanName' property not set " ) . » is Thrown By « ( new » Object Factory Creating Factory Bean « ( ) :: » after Properties Set « ) ; }
@Test { » Object Factory Creating Factory Bean « factory = new » Object Factory Creating Factory Bean « ( ) ; factory . » set Target Bean Name « ( " " ) ; » assert That Illegal Argument Exception « ( ) . as ( " 'targetBeanName' property set to ( invalid ) empty string " ) . » is Thrown By « ( factory :: » after Properties Set « ) ; }
@Test { » Object Factory Creating Factory Bean « factory = new » Object Factory Creating Factory Bean « ( ) ; factory . » set Target Bean Name « ( " \t " ) ; » assert That Illegal Argument Exception « ( ) . as ( " 'targetBeanName' property set to ( invalid ) only - whitespace string " ) . » is Thrown By « ( factory :: » after Properties Set « ) ; }
@Test { » assert That « ( new » Object Factory Creating Factory Bean « ( ) . » get Object Type « ( ) ) . as ( " Must be reporting that it creates » Object Factory « instances ( as per class contract ) . " ) . » is Equal To « ( » Object Factory « . class ) ; }
@Test { » Properties Factory Bean « pfb = new » Properties Factory Bean « ( ) ; pfb . » set Location « ( » TEST _ PROPS « ) ; pfb . » after Properties Set « ( ) ; Properties props = pfb . » get Object « ( ) ; » assert That « ( props . » get Property « ( " tb . array [ 0 ] . age " ) ) . » is Equal To « ( " 99 " ) ; }
@Test { » Properties Factory Bean « pfb = new » Properties Factory Bean « ( ) ; pfb . » set Location « ( » TEST _ PROPS _ XML « ) ; pfb . » after Properties Set « ( ) ; Properties props = pfb . » get Object « ( ) ; » assert That « ( props . » get Property « ( " tb . array [ 0 ] . age " ) ) . » is Equal To « ( " 99 " ) ; }
@Test { » Properties Factory Bean « pfb = new » Properties Factory Bean « ( ) ; Properties » local Props « = new Properties ( ) ; » local Props « . » set Property « ( " » key 2 « " , " » value 2 « " ) ; pfb . » set Properties « ( » local Props « ) ; pfb . » after Properties Set « ( ) ; Properties props = pfb . » get Object « ( ) ; » assert That « ( props . » get Property « ( " » key 2 « " ) ) . » is Equal To « ( " » value 2 « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Constructor Argument Entry « ( - 1 ) ) ; }
@Test { this . reader . » load Bean Definitions « ( » qualified Resource « ( » Custom Problem Reporter Tests « . class , " context . xml " ) ) ; » assert That « ( this . » problem Reporter « . » get Errors « ( ) . length ) . as ( " Incorrect number of errors collated " ) . » is Equal To « ( 4 ) ; » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » valid Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; }
@Test { » Fail Fast Problem Reporter « reporter = new » Fail Fast Problem Reporter « ( ) ; » assert That Exception Of Type « ( » Bean Definition Parsing Exception « . class ) . » is Thrown By « ( ( ) -> reporter . error ( new Problem ( " VGER " , new Location ( new » Descriptive Resource « ( " here " ) ) , null , new » Illegal Argument Exception « ( ) ) ) ) ; }
@Test { Problem problem = new Problem ( " VGER " , new Location ( new » Descriptive Resource « ( " here " ) ) , null , new » Illegal Argument Exception « ( ) ) ; Log log = mock ( Log . class ) ; » Fail Fast Problem Reporter « reporter = new » Fail Fast Problem Reporter « ( ) ; reporter . » set Logger « ( log ) ; reporter . warning ( problem ) ; verify ( log ) . warn ( any ( ) , » is A « ( » Illegal Argument Exception « . class ) ) ; }
@Test { Object source = new Object ( ) ; Object » extracted Source « = new » Null Source Extractor « ( ) . » extract Source « ( source , null ) ; » assert That « ( » extracted Source « ) . as ( " The contract of » Null Source Extractor « states that the extraction * always * return null " ) . » is Null « ( ) ; }
@Test { Object » extracted Source « = new » Null Source Extractor « ( ) . » extract Source « ( null , null ) ; » assert That « ( » extracted Source « ) . as ( " The contract of » Null Source Extractor « states that the extraction * always * return null " ) . » is Null « ( ) ; }
@Test { » Mock Entry « entry = new » Mock Entry « ( ) ; » Parse State « » parse State « = new » Parse State « ( ) ; » parse State « . push ( entry ) ; » assert That « ( » parse State « . peek ( ) ) . as ( " Incorrect peek value . " ) . » is Equal To « ( entry ) ; » parse State « . pop ( ) ; » assert That « ( » parse State « . peek ( ) ) . as ( " Should get null on peek ( ) " ) . » is Null « ( ) ; }
@Test { » Mock Entry « entry = new » Mock Entry « ( ) ; » Parse State « original = new » Parse State « ( ) ; original . push ( entry ) ; » Parse State « snapshot = original . snapshot ( ) ; original . push ( new » Mock Entry « ( ) ) ; » assert That « ( snapshot . peek ( ) ) . as ( " Snapshot should not have been modified . " ) . » is Equal To « ( entry ) ; }
@Test { Object source = new Object ( ) ; Object » extracted Source « = new » Pass Through Source Extractor « ( ) . » extract Source « ( source , null ) ; » assert That « ( » extracted Source « ) . as ( " The contract of » Pass Through Source Extractor « states that the supplied " + " source object * must * be returned as - is " ) . » is Same As « ( source ) ; }
@Test { Object » extracted Source « = new » Pass Through Source Extractor « ( ) . » extract Source « ( null , null ) ; » assert That « ( » extracted Source « ) . as ( " The contract of » Pass Through Source Extractor « states that the supplied " + " source object * must * be returned as - is ( even if null ) " ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Property Entry « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Property Entry « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Property Entry « ( " \t " ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Root Bean Definition « bd = new » Root Bean Definition « ( » Service Factory Bean « . class ) ; bd . » get Property Values « ( ) . add ( " » service Type « " , » Document Builder Factory « . class . » get Name « ( ) ) ; bf . » register Bean Definition « ( " service " , bd ) ; boolean condition = bf . » get Bean « ( " service " ) instanceof » Document Builder Factory « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Bean Definition Builder « bdb = » Bean Definition Builder « . » root Bean Definition « ( » Test Bean « . class , " create " ) ; » Root Bean Definition « rbd = ( » Root Bean Definition « ) bdb . » get Bean Definition « ( ) ; » assert That « ( rbd . » has Bean Class « ( ) ) . » is True « ( ) ; » assert That « ( rbd . » get Bean Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( rbd . » get Factory Method Name « ( ) ) . » is Equal To « ( " create " ) ; }
@Test { » Bean Definition Builder « bdb = » Bean Definition Builder « . » root Bean Definition « ( » Test Bean « . class . » get Name « ( ) ) ; » Root Bean Definition « rbd = ( » Root Bean Definition « ) bdb . » get Bean Definition « ( ) ; » assert That « ( rbd . » has Bean Class « ( ) ) . » is False « ( ) ; » assert That « ( rbd . » get Bean Class Name « ( ) ) . » is Equal To « ( » Test Bean « . class . » get Name « ( ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Generic Bean « . class ) ; rbd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ BY _ TYPE « ) ; bf . » register Bean Definition « ( " » generic Bean « " , rbd ) ; » Generic Bean « < ? > gb = ( » Generic Bean « < ? > ) bf . » get Bean « ( " » generic Bean « " ) ; » assert That « ( gb . » get Resource List « ( ) ) . » is Null « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Generic Bean « . class ) ; rbd . » set Autowire Mode « ( » Root Bean Definition « . » AUTOWIRE _ CONSTRUCTOR « ) ; bf . » register Bean Definition « ( " » generic Bean « " , rbd ) ; » Generic Bean « < ? > gb = ( » Generic Bean « < ? > ) bf . » get Bean « ( " » generic Bean « " ) ; » assert That « ( gb . » get Integer Set « ( ) ) . » is Null « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » generic Bean Tests « . xml " , » get Class « ( ) ) ) ; List < ? > list = ( List < ? > ) bf . » get Bean « ( " list " ) ; » assert That « ( list . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( new URL ( " http : » // localhost : 8080 « " ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » generic Bean Tests « . xml " , » get Class « ( ) ) ) ; Set < ? > set = ( Set < ? > ) bf . » get Bean « ( " set " ) ; » assert That « ( set . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( set . iterator ( ) . next ( ) ) . » is Equal To « ( new URL ( " http : » // localhost : 8080 « " ) ) ; }
@Test { » Child Bean Definition « master = new » Child Bean Definition « ( " foo " ) ; » Child Bean Definition « equal = new » Child Bean Definition « ( " foo " ) ; » Child Bean Definition « » not Equal « = new » Child Bean Definition « ( " bar " ) ; » Child Bean Definition « subclass = new » Child Bean Definition « ( " foo " ) { } ; » set Base Properties « ( master ) ; » set Base Properties « ( equal ) ; » set Base Properties « ( » not Equal « ) ; » set Base Properties « ( subclass ) ; » assert Equals And Hash Code Contracts « ( master , equal , » not Equal « , subclass ) ; }
@Test { » Runtime Bean Reference « master = new » Runtime Bean Reference « ( " name " ) ; » Runtime Bean Reference « equal = new » Runtime Bean Reference « ( " name " ) ; » Runtime Bean Reference « » not Equal « = new » Runtime Bean Reference « ( " » some Other Name « " ) ; » Runtime Bean Reference « subclass = new » Runtime Bean Reference « ( " name " ) { } ; » assert Equals And Hash Code Contracts « ( master , equal , » not Equal « , subclass ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; Object expected = bean . get ( ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » Test Bean « expected = bean . get ( " haha " ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( expected . » get Name « ( ) ) . » is Equal To « ( " haha " ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » Test Bean « expected = bean . » get One Argument « ( " haha " ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( expected . » get Name « ( ) ) . » is Equal To « ( " haha " ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » Test Bean « expected = bean . » get Two Arguments « ( " haha " , 72 ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( expected . » get Name « ( ) ) . » is Equal To « ( " haha " ) ; » assert That « ( expected . » get Age « ( ) ) . » is Equal To « ( 72 ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » abstract Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » assert That Exception Of Type « ( » Abstract Method Error « . class ) . as ( " does not have a three arg constructor " ) . » is Thrown By « ( ( ) -> bean . » get Three Arguments « ( " name " , 1 , 2 ) ) ; }
@Test { » Abstract Bean « bean = ( » Abstract Bean « ) » bean Factory « . » get Bean « ( " » extended Bean « " ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » Test Bean « expected = bean . » get One Argument « ( " haha " ) ; » assert That « ( expected . » get Class « ( ) ) . » is Equal To « ( » Test Bean « . class ) ; » assert That « ( expected . » get Name « ( ) ) . » is Equal To « ( " haha " ) ; » assert That « ( expected . » is Jedi « ( ) ) . » is True « ( ) ; }
@Test { » Managed List « parent = new » Managed List « ( ) ; parent . add ( " one " ) ; parent . add ( " two " ) ; » Managed List « child = new » Managed List « ( ) ; child . add ( " three " ) ; child . » set Merge Enabled « ( true ) ; List » merged List « = child . merge ( parent ) ; » assert That « ( » merged List « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 3 ) ; }
@Test { » Managed List « child = new » Managed List « ( ) ; child . add ( " one " ) ; child . » set Merge Enabled « ( true ) ; » assert That « ( child . merge ( null ) ) . » is Same As « ( child ) ; }
@Test { » Managed List « child = new » Managed List « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> child . merge ( null ) ) ; }
@Test { » Managed List « child = new » Managed List « ( ) ; child . add ( " one " ) ; child . » set Merge Enabled « ( true ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> child . merge ( " hello " ) ) ; }
@Test { » Managed List « parent = new » Managed List « ( ) ; parent . add ( " one " ) ; parent . add ( " two " ) ; » Managed List « child = new » Managed List « ( ) ; child . » set Merge Enabled « ( true ) ; List » merged List « = child . merge ( parent ) ; » assert That « ( » merged List « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 2 ) ; }
@Test { » Managed List « parent = new » Managed List « ( ) ; parent . add ( " one " ) ; parent . add ( " two " ) ; » Managed List « child = new » Managed List « ( ) ; child . add ( " one " ) ; child . » set Merge Enabled « ( true ) ; List » merged List « = child . merge ( parent ) ; » assert That « ( » merged List « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 3 ) ; }
@Test { » Managed Map « parent = new » Managed Map « ( ) ; parent . put ( " one " , " one " ) ; parent . put ( " two " , " two " ) ; » Managed Map « child = new » Managed Map « ( ) ; child . put ( " three " , " three " ) ; child . » set Merge Enabled « ( true ) ; Map » merged Map « = ( Map ) child . merge ( parent ) ; » assert That « ( » merged Map « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 3 ) ; }
@Test { » Managed Map « child = new » Managed Map « ( ) ; child . » set Merge Enabled « ( true ) ; » assert That « ( child . merge ( null ) ) . » is Same As « ( child ) ; }
@Test { » Managed Map « map = new » Managed Map « ( ) ; map . » set Merge Enabled « ( true ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> map . merge ( " hello " ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Managed Map « ( ) . merge ( null ) ) ; }
@Test { » Managed Map « parent = new » Managed Map « ( ) ; parent . put ( " one " , " one " ) ; parent . put ( " two " , " two " ) ; » Managed Map « child = new » Managed Map « ( ) ; child . » set Merge Enabled « ( true ) ; Map » merged Map « = ( Map ) child . merge ( parent ) ; » assert That « ( » merged Map « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 2 ) ; }
@Test { this . reader . » load Bean Definitions « ( new » Class Path Resource « ( " » simple Constructor Arg « . properties " , » get Class « ( ) ) ) ; » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( " Rob Harrop " ) ; }
@Test { this . reader . » load Bean Definitions « ( new » Class Path Resource « ( " » ref Constructor Arg « . properties " , » get Class « ( ) ) ) ; » Test Bean « rob = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " rob " ) ; » Test Bean « sally = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " sally " ) ; » assert That « ( rob . » get Spouse « ( ) ) . » is Equal To « ( sally ) ; }
@Test { this . reader . » load Bean Definitions « ( new » Class Path Resource « ( " » multi Constructor Args « . properties " , » get Class « ( ) ) ) ; » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( " Rob Harrop " ) ; » assert That « ( bean . » get Age « ( ) ) . » is Equal To « ( 23 ) ; }
@Test { String [ ] names = bf . » get Bean Names For Type « ( » An Interface « . class , false , false ) ; » assert That « ( Arrays . » as List « ( names ) ) . contains ( " & foo " ) ; Map < String , » An Interface « > beans = bf . » get Beans Of Type « ( » An Interface « . class , false , false ) ; » assert That « ( beans ) . » has Size « ( 1 ) ; » assert That « ( beans . » key Set « ( ) ) . contains ( " & foo " ) ; }
@Test { » Managed Set « parent = new » Managed Set « ( ) ; parent . add ( " one " ) ; parent . add ( " two " ) ; » Managed Set « child = new » Managed Set « ( ) ; child . add ( " three " ) ; child . » set Merge Enabled « ( true ) ; Set » merged Set « = child . merge ( parent ) ; » assert That « ( » merged Set « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 3 ) ; }
@Test { » Managed Set « child = new » Managed Set « ( ) ; child . add ( " one " ) ; child . » set Merge Enabled « ( true ) ; » assert That « ( child . merge ( null ) ) . » is Same As « ( child ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Managed Set « ( ) . merge ( null ) ) ; }
@Test { » Managed Set « child = new » Managed Set « ( ) ; child . add ( " one " ) ; child . » set Merge Enabled « ( true ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> child . merge ( " hello " ) ) ; }
@Test { » Managed Set « parent = new » Managed Set « ( ) ; parent . add ( " one " ) ; parent . add ( " two " ) ; » Managed Set « child = new » Managed Set « ( ) ; child . » set Merge Enabled « ( true ) ; Set » merged Set « = child . merge ( parent ) ; » assert That « ( » merged Set « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 2 ) ; }
@Test { » Managed Set « parent = new » Managed Set « ( ) ; parent . add ( " one " ) ; parent . add ( " two " ) ; » Managed Set « child = new » Managed Set « ( ) ; child . add ( " one " ) ; child . » set Merge Enabled « ( true ) ; Set » merged Set « = child . merge ( parent ) ; » assert That « ( » merged Set « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 2 ) ; }
@Test { » Managed Properties « parent = new » Managed Properties « ( ) ; parent . » set Property « ( " one " , " one " ) ; parent . » set Property « ( " two " , " two " ) ; » Managed Properties « child = new » Managed Properties « ( ) ; child . » set Property « ( " three " , " three " ) ; child . » set Merge Enabled « ( true ) ; Map » merged Map « = ( Map ) child . merge ( parent ) ; » assert That « ( » merged Map « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 3 ) ; }
@Test { » Managed Properties « child = new » Managed Properties « ( ) ; child . » set Merge Enabled « ( true ) ; » assert That « ( child . merge ( null ) ) . » is Same As « ( child ) ; }
@Test { » Managed Properties « map = new » Managed Properties « ( ) ; map . » set Merge Enabled « ( true ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> map . merge ( " hello " ) ) ; }
@Test { » Managed Properties « map = new » Managed Properties « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> map . merge ( null ) ) ; }
@Test { » Managed Properties « parent = new » Managed Properties « ( ) ; parent . » set Property « ( " one " , " one " ) ; parent . » set Property « ( " two " , " two " ) ; » Managed Properties « child = new » Managed Properties « ( ) ; child . » set Merge Enabled « ( true ) ; Map » merged Map « = ( Map ) child . merge ( parent ) ; » assert That « ( » merged Map « . size ( ) ) . as ( " merge ( ) obviously did not work . " ) . » is Equal To « ( 2 ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " spring - init " ) ) . » with Cause Instance Of « ( » Security Exception « . class ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " custom - init " ) ) . » with Cause Instance Of « ( » Security Exception « . class ) ; }
@Test { » bean Factory « . » get Bean « ( " spring - destroy " ) ; » bean Factory « . » destroy Singletons « ( ) ; » assert That « ( System . » get Property « ( " security . destroy " ) ) . » is Null « ( ) ; }
@Test { » bean Factory « . » get Bean « ( " custom - destroy " ) ; » bean Factory « . » destroy Singletons « ( ) ; » assert That « ( System . » get Property « ( " security . destroy " ) ) . » is Null « ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " spring - factory " ) ) . » with Cause Instance Of « ( » Security Exception « . class ) ; }
@Test { » assert That « ( » bean Factory « . » get Type « ( " spring - factory " ) ) . » is Null « ( ) ; » assert That « ( System . » get Property « ( " factory . object . type " ) ) . » is Null « ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " custom - static - factory - method " ) ) . satisfies ( ex -> » assert That « ( ex . » get Most Specific Cause « ( ) ) . » is Instance Of « ( » Security Exception « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " custom - factory - method " ) ) . satisfies ( ex -> » assert That « ( ex . » get Most Specific Cause « ( ) ) . » is Instance Of « ( » Security Exception « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " privileged - static - factory - method " ) ) . satisfies ( » most Specific Cause Of « ( » Security Exception « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " constructor " ) ) . satisfies ( » most Specific Cause Of « ( » Security Exception « . class ) ) ; }
@Test { » Access Control Context « acc = provider . » get Access Control Context « ( ) ; » Access Controller « . » do Privileged « ( new » Privileged Exception Action « < Object > ( ) { @ Override public Object run ( ) throws Exception { » bean Factory « . » get Bean « ( " working - factory - method " ) ; » bean Factory « . » get Bean « ( " container - execution " ) ; return null ; } } , acc ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » bean Factory « . » get Bean « ( " property - injection " ) ) . » with Message Containing « ( " security " ) ; » bean Factory « . » get Bean « ( " working - property - injection " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Stub Bean Configurer Support « ( ) . » set Bean Factory « ( mock ( » Bean Factory « . class ) ) ) ; }
@Test { » Test Bean « » bean Instance « = new » Test Bean « ( ) ; » Bean Wiring Info Resolver « resolver = mock ( » Bean Wiring Info Resolver « . class ) ; » Bean Configurer Support « configurer = new » Stub Bean Configurer Support « ( ) ; configurer . » set Bean Wiring Info Resolver « ( resolver ) ; configurer . » set Bean Factory « ( new » Default Listable Bean Factory « ( ) ) ; configurer . » configure Bean « ( » bean Instance « ) ; verify ( resolver ) . » resolve Wiring Info « ( » bean Instance « ) ; » assert That « ( » bean Instance « . » get Name « ( ) ) . » is Null « ( ) ; }
@Test { » Test Bean « » bean Instance « = new » Test Bean « ( ) ; » Bean Configurer Support « configurer = new » Stub Bean Configurer Support « ( ) ; configurer . » configure Bean « ( » bean Instance « ) ; » assert That « ( » bean Instance « . » get Name « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Class Name Bean Wiring Info Resolver « ( ) . » resolve Wiring Info « ( null ) ) ; }
@Test { » Class Name Bean Wiring Info Resolver « resolver = new » Class Name Bean Wiring Info Resolver « ( ) ; Long » bean Instance « = new Long ( 1 ) ; » Bean Wiring Info « info = resolver . » resolve Wiring Info « ( » bean Instance « ) ; » assert That « ( info ) . » is Not Null « ( ) ; » assert That « ( info . » get Bean Name « ( ) ) . as ( " Not resolving bean name to the class name of the supplied bean instance as per class contract . " ) . » is Equal To « ( » bean Instance « . » get Class « ( ) . » get Name « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bean Wiring Info « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bean Wiring Info « ( " \t " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bean Wiring Info « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bean Wiring Info « ( - 1 , true ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bean Wiring Info « ( 123871 , true ) ) ; }
@Test { » Bean Wiring Info « info = new » Bean Wiring Info « ( » Bean Wiring Info « . » AUTOWIRE _ BY _ NAME « , true ) ; » assert That « ( info . » indicates Autowiring « ( ) ) . » is True « ( ) ; }
@Test { » Bean Wiring Info « info = new » Bean Wiring Info « ( " » foo Service « " ) ; » assert That « ( info . » indicates Autowiring « ( ) ) . » is False « ( ) ; }
@Test { » Bean Wiring Info « info = new » Bean Wiring Info « ( » Bean Wiring Info « . » AUTOWIRE _ BY _ NAME « , true ) ; » assert That « ( info . » get Dependency Check « ( ) ) . » is True « ( ) ; }
@Test { » Bean Wiring Info « info = new » Bean Wiring Info « ( » Bean Wiring Info « . » AUTOWIRE _ BY _ TYPE « , false ) ; » assert That « ( info . » get Dependency Check « ( ) ) . » is False « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( XML ) ; Object foo = bf . » get Bean « ( " foo " ) ; » assert That « ( foo ) . » is Instance Of « ( String . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » bean Factory For « ( » PROD _ ELIGIBLE _ XML « , » NULL _ ACTIVE « ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( bf ) ; » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> reader . » load Bean Definitions « ( new » Class Path Resource « ( " » invalid Per Schema « . xml " , » get Class « ( ) ) ) ) . » with Cause Instance Of « ( » SAX Parse Exception « . class ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( bf ) ; reader . » set Validation Mode « ( » Xml Bean Definition Reader « . » VALIDATION _ XSD « ) ; » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> reader . » load Bean Definitions « ( new » Class Path Resource « ( " » invalid Per Schema « . xml " , » get Class « ( ) ) ) ) . » with Cause Instance Of « ( » SAX Parse Exception « . class ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » create Factory « ( " » simple Constructor Namespace Handler Tests « . xml " ) ; String name = " simple " ; » Dummy Bean « » name Value « = » bean Factory « . » get Bean « ( name , » Dummy Bean « . class ) ; » assert That « ( » name Value « . » get Value « ( ) ) . » is Equal To « ( " simple " ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » create Factory « ( " » simple Constructor Namespace Handler Tests « . xml " ) ; String name = " simple - ref " ; » Dummy Bean « » name Value « = » bean Factory « . » get Bean « ( name , » Dummy Bean « . class ) ; » assert That « ( » name Value « . » get Value « ( ) ) . » is Equal To « ( » bean Factory « . » get Bean « ( " name " ) ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » create Factory « ( " » simple Constructor Namespace Handler Tests « . xml " ) ; String name = " name - value " ; » Test Bean « » name Value « = » bean Factory « . » get Bean « ( name , » Test Bean « . class ) ; » assert That « ( » name Value « . » get Name « ( ) ) . » is Equal To « ( name ) ; » assert That « ( » name Value « . » get Age « ( ) ) . » is Equal To « ( 10 ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » create Factory « ( " » simple Constructor Namespace Handler Tests « . xml " ) ; » Dummy Bean « » type Ref « = » bean Factory « . » get Bean « ( " indexed - value " , » Dummy Bean « . class ) ; » assert That « ( » type Ref « . » get Name « ( ) ) . » is Equal To « ( " at " ) ; » assert That « ( » type Ref « . » get Value « ( ) ) . » is Equal To « ( " austria " ) ; » assert That « ( » type Ref « . » get Age « ( ) ) . » is Equal To « ( 10 ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » create Factory « ( " » simple Constructor Namespace Handler Tests « . xml " ) ; » Dummy Bean « » type Ref « = » bean Factory « . » get Bean « ( " indexed - ref " , » Dummy Bean « . class ) ; » assert That « ( » type Ref « . » get Name « ( ) ) . » is Equal To « ( " some - name " ) ; » assert That « ( » type Ref « . » get Spouse « ( ) ) . » is Equal To « ( » bean Factory « . » get Bean « ( " name - value " ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » simple Constructor Namespace Handler Tests With Errors « . xml " , » get Class « ( ) ) ) ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » create Factory « ( " » simple Constructor Namespace Handler Tests « . xml " ) ; » Dummy Bean « » derived Bean « = » bean Factory « . » get Bean « ( " » bean With Ref Constructor Arg « " , » Dummy Bean « . class ) ; » assert That « ( » derived Bean « . » get Age « ( ) ) . » is Equal To « ( 10 ) ; » assert That « ( » derived Bean « . » get Name « ( ) ) . » is Equal To « ( " silly name " ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( » bean Factory « ) . » load Bean Definitions « ( new » Class Path Resource « ( " » simple Property Namespace Handler Tests With Errors « . xml " , » get Class « ( ) ) ) ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( » bean Factory « ) . » load Bean Definitions « ( new » Class Path Resource « ( " » simple Property Namespace Handler Tests « . xml " , » get Class « ( ) ) ) ; » I Test Bean « sally = ( » Test Bean « ) » bean Factory « . » get Bean « ( " » derived Sally « " ) ; » assert That « ( sally . » get Spouse « ( ) . » get Name « ( ) ) . » is Equal To « ( " r " ) ; }
@Test { » assert Count « ( 24 ) ; }
@Test { » assert Test Bean Count « ( 13 ) ; }
@Test { » Lifecycle Bean « bean = ( » Lifecycle Bean « ) » get Bean Factory « ( ) . » get Bean « ( " lifecycle " ) ; bean . » business Method « ( ) ; }
@Test { » Protected Lifecycle Bean « bean = ( » Protected Lifecycle Bean « ) » get Bean Factory « ( ) . » get Bean « ( " » protected Lifecycle « " ) ; bean . » business Method « ( ) ; }
@Test { » Test Bean « » valid Empty « = ( » Test Bean « ) » get Bean Factory « ( ) . » get Bean « ( " » valid Empty With Description « " ) ; » assert That « ( » valid Empty « . » get Age « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Test Bean « rod = ( » Test Bean « ) » get Bean Factory « ( ) . » get Bean « ( " rod " ) ; » Test Bean « kerry = ( » Test Bean « ) » get Bean Factory « ( ) . » get Bean « ( " kerry " ) ; » assert That « ( " " . equals ( rod . » get Touchy « ( ) ) ) . as ( " Touchy is empty " ) . » is True « ( ) ; » assert That « ( " " . equals ( kerry . » get Touchy « ( ) ) ) . as ( " Touchy is empty " ) . » is True « ( ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) » get Bean Factory « ( ) . » get Bean « ( " » comments In Value « " ) ; » assert That « ( bean . » get Name « ( ) ) . as ( " Failed to handle comments and CDATA properly " ) . » is Equal To « ( " this is a < ! -- comment -- > " ) ; }
@Test { » Counting Factory « . reset ( ) ; » Default Listable Bean Factory « » bean Factory « = » get Bean Factory « ( " autowire - with - exclusion . xml " ) ; » bean Factory « . » pre Instantiate Singletons « ( ) ; » Test Bean « rob = ( » Test Bean « ) » bean Factory « . » get Bean « ( " rob " ) ; » assert That « ( rob . » get Some Properties « ( ) . » get Property « ( " name " ) ) . » is Equal To « ( " » props 1 « " ) ; » assert That « ( » Counting Factory « . » get Factory Bean Instance Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Counting Factory « . reset ( ) ; » Default Listable Bean Factory « » bean Factory « = » get Bean Factory « ( " autowire - with - inclusion . xml " ) ; » bean Factory « . » pre Instantiate Singletons « ( ) ; » Test Bean « rob = ( » Test Bean « ) » bean Factory « . » get Bean « ( " rob " ) ; » assert That « ( rob . » get Some Properties « ( ) . » get Property « ( " name " ) ) . » is Equal To « ( " » props 1 « " ) ; » assert That « ( » Counting Factory « . » get Factory Bean Instance Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Default Listable Bean Factory « » bean Factory « = » get Bean Factory « ( " autowire - constructor - with - exclusion . xml " ) ; » Test Bean « rob = ( » Test Bean « ) » bean Factory « . » get Bean « ( " rob " ) ; » assert That « ( rob . » get Some Properties « ( ) . » get Property « ( " name " ) ) . » is Equal To « ( " » props 1 « " ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » child With List Of Refs « " ) ; List < ? > list = bean . » get Some List « ( ) ; » assert That « ( list ) . » is Not Null « ( ) ; » assert That « ( list . size ( ) ) . » is Equal To « ( 3 ) ; » assert That « ( list . get ( 2 ) ) . » is Not Null « ( ) ; boolean condition = list . get ( 2 ) instanceof » Test Bean « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » child With Set « " ) ; Set set = bean . » get Some Set « ( ) ; » assert That « ( set . size ( ) ) . as ( " Incorrect size " ) . » is Equal To « ( 2 ) ; » assert That « ( set . contains ( " Rob Harrop " ) ) . » is True « ( ) ; » assert That « ( set . contains ( " Sally Greenwood " ) ) . » is True « ( ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » child With List Of Refs In Constructor « " ) ; List < ? > list = bean . » get Some List « ( ) ; » assert That « ( list ) . » is Not Null « ( ) ; » assert That « ( list . size ( ) ) . » is Equal To « ( 3 ) ; » assert That « ( list . get ( 2 ) ) . » is Not Null « ( ) ; boolean condition = list . get ( 2 ) instanceof » Test Bean « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » child With Set In Constructor « " ) ; Set set = bean . » get Some Set « ( ) ; » assert That « ( set . size ( ) ) . as ( " Incorrect size " ) . » is Equal To « ( 2 ) ; » assert That « ( set . contains ( " Rob Harrop " ) ) . » is True « ( ) ; » assert That « ( set . contains ( " Sally Greenwood " ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Delegating Entity Resolver « ( null , new » No Op Entity Resolver « ( ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Delegating Entity Resolver « ( new » No Op Entity Resolver « ( ) , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Delegating Entity Resolver « ( null , null ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( bf ) ; » assert That Exception Of Type « ( Exception . class ) . as ( " duplicate ids in same nesting level " ) . » is Thrown By « ( ( ) -> reader . » load Bean Definitions « ( new » Class Path Resource « ( " » Duplicate Bean Id Tests « - » same Level « - context . xml " , this . » get Class « ( ) ) ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( bf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " » Duplicate Bean Id Tests « - » multi Level « - context . xml " , this . » get Class « ( ) ) ) ; » Test Bean « » test Bean « = bf . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " nested " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " factory - methods . xml " , » get Class « ( ) ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » default Test Bean With Invalid Destroy Method « " ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " factory - methods . xml " , » get Class « ( ) ) ) ; » Test Bean « tb = ( » Test Bean « ) xbf . » get Bean « ( " » default Test Bean « . protected " ) ; » assert That « ( tb . » get Age « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " factory - methods . xml " , » get Class « ( ) ) ) ; » Test Bean « tb = ( » Test Bean « ) xbf . » get Bean « ( " » default Test Bean « . private " ) ; » assert That « ( tb . » get Age « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " factory - methods . xml " , » get Class « ( ) ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . as ( " No static method matched " ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » no Match Prototype « " ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " factory - methods . xml " , » get Class « ( ) ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » invalid Prototype « " ) ) . » with Message Containing « ( " » non Existing « ( » Test Bean « ) " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( new » Class Path Resource « ( " factory - methods . xml " , » get Class « ( ) ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » invalid Prototype « " , new » Test Bean « ( ) ) ) . » with Message Containing « ( " » non Existing « ( » Test Bean « ) " ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; for ( Object o : bean . » get Some List « ( ) ) { » assert That « ( o . » get Class « ( ) ) . as ( " Value type is incorrect " ) . » is Equal To « ( Integer . class ) ; } }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; for ( Object o : bean . » get Some Set « ( ) ) { » assert That « ( o . » get Class « ( ) ) . as ( " Value type is incorrect " ) . » is Equal To « ( Integer . class ) ; } }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; » assert Map « ( bean . » get Some Map « ( ) ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean 2 « " ) ; » assert Map « ( bean . » get Some Map « ( ) ) ; }
@Test { List imports = this . » event Listener « . » get Imports « ( ) ; » assert That « ( imports . size ( ) ) . » is Equal To « ( 1 ) ; » Import Definition « » import Definition « = ( » Import Definition « ) imports . get ( 0 ) ; » assert That « ( » import Definition « . » get Imported Resource « ( ) ) . » is Equal To « ( " » bean Events Imported « . xml " ) ; boolean condition = » import Definition « . » get Source « ( ) instanceof Element ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; new » Xml Bean Definition Reader « ( registry ) . » set Document Reader Class « ( » Default Bean Definition Document Reader « . class ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; Resource resource = new » Input Stream Resource « ( » get Class « ( ) . » get Resource As Stream « ( " test . xml " ) ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( registry ) . » load Bean Definitions « ( resource ) ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; Resource resource = new » Input Stream Resource « ( » get Class « ( ) . » get Resource As Stream « ( " test . xml " ) ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( registry ) ; reader . » set Validation Mode « ( » Xml Bean Definition Reader « . » VALIDATION _ DTD « ) ; reader . » load Bean Definitions « ( resource ) ; » test Bean Definitions « ( registry ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; Resource resource = new » Class Path Resource « ( " import . xml " , » get Class « ( ) ) ; new » Xml Bean Definition Reader « ( registry ) . » load Bean Definitions « ( resource ) ; » test Bean Definitions « ( registry ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; Resource resource = new » Class Path Resource « ( " » import Pattern « . xml " , » get Class « ( ) ) ; new » Xml Bean Definition Reader « ( registry ) . » load Bean Definitions « ( resource ) ; » test Bean Definitions « ( registry ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Input Source « resource = new » Input Source « ( » get Class « ( ) . » get Resource As Stream « ( " test . xml " ) ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( registry ) . » load Bean Definitions « ( resource ) ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Input Source « resource = new » Input Source « ( » get Class « ( ) . » get Resource As Stream « ( " test . xml " ) ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( registry ) ; reader . » set Validation Mode « ( » Xml Bean Definition Reader « . » VALIDATION _ DTD « ) ; reader . » load Bean Definitions « ( resource ) ; » test Bean Definitions « ( registry ) ; }
@Test { » Simple Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; Resource resource = new » Class Path Resource « ( " test . xml " , » get Class « ( ) ) ; new » Xml Bean Definition Reader « ( registry ) . » load Bean Definitions « ( resource ) ; » test Bean Definitions « ( registry ) ; }
@Test { » do Test Validation « ( " » validate With Dtd « . xml " ) ; }
@Test { » do Test Validation « ( " » validate With Xsd « . xml " ) ; }
@Test { » Bean Definition « » bean Definition 1 « = this . » bean Factory « . » get Merged Bean Definition « ( " » test Bean 1 « " ) ; » assert That « ( » bean Definition 1 « . » get Attribute « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " » test Bean 2 « " ) ; » assert That « ( » bean Definition « . » get Attribute « ( " foo " ) ) . as ( " Metadata not inherited " ) . » is Equal To « ( " bar " ) ; » assert That « ( » bean Definition « . » get Attribute « ( " abc " ) ) . as ( " Child metdata not attached " ) . » is Equal To « ( " 123 " ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " » test Bean 3 « " ) ; » Property Value « pv = » bean Definition « . » get Property Values « ( ) . » get Property Value « ( " name " ) ; » assert That « ( pv . » get Attribute « ( " surname " ) ) . » is Equal To « ( " Harrop " ) ; }
@Test { Integer min = ( Integer ) this . » bean Factory « . » get Bean « ( " min " ) ; » assert That « ( min . » int Value « ( ) ) . » is Equal To « ( Integer . » MIN _ VALUE « ) ; }
@Test { Integer max = ( Integer ) this . » bean Factory « . » get Bean « ( " java . lang . Integer . » MAX _ VALUE « " ) ; » assert That « ( max . » int Value « ( ) ) . » is Equal To « ( Integer . » MAX _ VALUE « ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; Properties props = bean . » get Some Properties « ( ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " bar " ) ; }
@Test { String name = ( String ) this . » bean Factory « . » get Bean « ( " name " ) ; » assert That « ( name ) . » is Equal To « ( " Rob Harrop " ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( " Rob Harrop " ) ; }
@Test { Map map = ( Map ) this . » bean Factory « . » get Bean « ( " » simple Map « " ) ; » assert That « ( map . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; Map » map 2 « = ( Map ) this . » bean Factory « . » get Bean « ( " » simple Map « " ) ; » assert That « ( map == » map 2 « ) . » is True « ( ) ; }
@Test { Map map = ( Map ) this . » bean Factory « . » get Bean « ( " » scoped Map « " ) ; » assert That « ( map . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; Map » map 2 « = ( Map ) this . » bean Factory « . » get Bean « ( " » scoped Map « " ) ; » assert That « ( » map 2 « . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( map != » map 2 « ) . » is True « ( ) ; }
@Test { List list = ( List ) this . » bean Factory « . » get Bean « ( " » simple List « " ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( " Rob Harrop " ) ; List » list 2 « = ( List ) this . » bean Factory « . » get Bean « ( " » simple List « " ) ; » assert That « ( list == » list 2 « ) . » is True « ( ) ; }
@Test { List list = ( List ) this . » bean Factory « . » get Bean « ( " » scoped List « " ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( " Rob Harrop " ) ; List » list 2 « = ( List ) this . » bean Factory « . » get Bean « ( " » scoped List « " ) ; » assert That « ( » list 2 « . get ( 0 ) ) . » is Equal To « ( " Rob Harrop " ) ; » assert That « ( list != » list 2 « ) . » is True « ( ) ; }
@Test { Set set = ( Set ) this . » bean Factory « . » get Bean « ( " » simple Set « " ) ; » assert That « ( set . contains ( " Rob Harrop " ) ) . » is True « ( ) ; Set » set 2 « = ( Set ) this . » bean Factory « . » get Bean « ( " » simple Set « " ) ; » assert That « ( set == » set 2 « ) . » is True « ( ) ; }
@Test { Set set = ( Set ) this . » bean Factory « . » get Bean « ( " » scoped Set « " ) ; » assert That « ( set . contains ( " Rob Harrop " ) ) . » is True « ( ) ; Set » set 2 « = ( Set ) this . » bean Factory « . » get Bean « ( " » scoped Set « " ) ; » assert That « ( » set 2 « . contains ( " Rob Harrop " ) ) . » is True « ( ) ; » assert That « ( set != » set 2 « ) . » is True « ( ) ; }
@Test { Map map = ( Map ) this . » bean Factory « . » get Bean « ( " » map With Ref « " ) ; boolean condition = map instanceof » Tree Map « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( map . get ( " bean " ) ) . » is Equal To « ( this . » bean Factory « . » get Bean « ( " » test Bean « " ) ) ; }
@Test { Map map = ( Map ) this . » bean Factory « . » get Bean « ( " » map With Types « " ) ; boolean condition = map instanceof » Linked Case Insensitive Map « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( map . get ( " bean " ) ) . » is Equal To « ( this . » bean Factory « . » get Bean « ( " » test Bean « " ) ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » constructed Test Bean « " ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( " Rob Harrop " ) ; }
@Test { Properties props = ( Properties ) this . » bean Factory « . » get Bean « ( " » my Properties « " ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " bar " ) ; » assert That « ( props . get ( " » foo 2 « " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( null ) ; Properties » props 2 « = ( Properties ) this . » bean Factory « . » get Bean « ( " » my Properties « " ) ; » assert That « ( props == » props 2 « ) . » is True « ( ) ; }
@Test { Properties props = ( Properties ) this . » bean Factory « . » get Bean « ( " » my Local Properties « " ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( null ) ; » assert That « ( props . get ( " » foo 2 « " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " » bar 2 « " ) ; }
@Test { Properties props = ( Properties ) this . » bean Factory « . » get Bean « ( " » my Merged Properties « " ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " bar " ) ; » assert That « ( props . get ( " » foo 2 « " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " » bar 2 « " ) ; }
@Test { Properties props = ( Properties ) this . » bean Factory « . » get Bean « ( " » default Local Override Properties « " ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " bar " ) ; » assert That « ( props . get ( " » foo 2 « " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " » local 2 « " ) ; }
@Test { Properties props = ( Properties ) this . » bean Factory « . » get Bean « ( " » false Local Override Properties « " ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " bar " ) ; » assert That « ( props . get ( " » foo 2 « " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " » local 2 « " ) ; }
@Test { Properties props = ( Properties ) this . » bean Factory « . » get Bean « ( " » true Local Override Properties « " ) ; » assert That « ( props . get ( " foo " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " local " ) ; » assert That « ( props . get ( " » foo 2 « " ) ) . as ( " Incorrect property value " ) . » is Equal To « ( " » local 2 « " ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » Nested Beans Element Attribute Recursion Tests « - lazy - context . xml " , this . » get Class « ( ) ) ) ; » assert Lazy Inits « ( bf ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « » xml Bean Definition Reader « = new » Xml Bean Definition Reader « ( bf ) ; » xml Bean Definition Reader « . » set Validating « ( false ) ; » xml Bean Definition Reader « . » load Bean Definitions « ( new » Class Path Resource « ( " » Nested Beans Element Attribute Recursion Tests « - lazy - context . xml " , this . » get Class « ( ) ) ) ; » assert Lazy Inits « ( bf ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » Nested Beans Element Attribute Recursion Tests « - merge - context . xml " , this . » get Class « ( ) ) ) ; » assert Merge « ( bf ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « » xml Bean Definition Reader « = new » Xml Bean Definition Reader « ( bf ) ; » xml Bean Definition Reader « . » set Validating « ( false ) ; » xml Bean Definition Reader « . » load Bean Definitions « ( new » Class Path Resource « ( " » Nested Beans Element Attribute Recursion Tests « - merge - context . xml " , this . » get Class « ( ) ) ) ; » assert Merge « ( bf ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » Nested Beans Element Attribute Recursion Tests « - autowire - candidates - context . xml " , this . » get Class « ( ) ) ) ; » assert Autowire Candidates « ( bf ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « » xml Bean Definition Reader « = new » Xml Bean Definition Reader « ( bf ) ; » xml Bean Definition Reader « . » set Validating « ( false ) ; » xml Bean Definition Reader « . » load Bean Definitions « ( new » Class Path Resource « ( " » Nested Beans Element Attribute Recursion Tests « - autowire - candidates - context . xml " , this . » get Class « ( ) ) ) ; » assert Autowire Candidates « ( bf ) ; }
@Test { » Test Bean « jen = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " jenny " ) ; » Test Bean « dave = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " david " ) ; » assert That « ( jen . » get Spouse « ( ) == dave ) . » is True « ( ) ; }
@Test { » Test Bean « verbose = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " verbose " ) ; » assert That « ( verbose . » get Name « ( ) . equals ( " verbose " ) ) . » is True « ( ) ; }
@Test { » Test Bean « verbose = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » verbose 2 « " ) ; » assert That « ( verbose . » get Name « ( ) . equals ( " verbose " ) ) . » is True « ( ) ; }
@Test { » Test Bean « verbose = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » verbose 3 « " ) ; » assert That « ( verbose . » get Name « ( ) . equals ( " verbose " ) ) . » is True « ( ) ; }
@Test { » Test Bean « loner = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " loner " ) ; » Test Bean « dave = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " david " ) ; » assert That « ( loner . » get Friends « ( ) . size ( ) == 1 ) . » is True « ( ) ; » assert That « ( loner . » get Friends « ( ) . contains ( dave ) ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> this . » bean Factory « . » get Bean « ( " » jumble 2 « " ) ) . » with Cause Instance Of « ( » Bean Definition Store Exception « . class ) . » with Message Containing « ( " » rod 2 « " ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " » empty Map « " ) ; » assert That « ( » has Map « . » get Map « ( ) . size ( ) == 0 ) . » is True « ( ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " » empty Set « " ) ; » assert That « ( » has Map « . » get Set « ( ) . size ( ) == 0 ) . » is True « ( ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " » identity Map « " ) ; » assert That « ( » has Map « . » get Identity Map « ( ) . size ( ) == 2 ) . » is True « ( ) ; » Hash Set « set = new » Hash Set « ( » has Map « . » get Identity Map « ( ) . » key Set « ( ) ) ; » assert That « ( set . contains ( " foo " ) ) . » is True « ( ) ; » assert That « ( set . contains ( " jenny " ) ) . » is True « ( ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " » empty Props « " ) ; » assert That « ( » has Map « . » get Props « ( ) . size ( ) == 0 ) . » is True « ( ) ; » assert That « ( Properties . class ) . » is Equal To « ( » has Map « . » get Props « ( ) . » get Class « ( ) ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " props " ) ; » assert That « ( » has Map « . » get Props « ( ) . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( » has Map « . » get Props « ( ) . get ( " foo " ) . equals ( " bar " ) ) . » is True « ( ) ; » assert That « ( » has Map « . » get Props « ( ) . get ( " 2 " ) . equals ( " TWO " ) ) . » is True « ( ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " » class Array « " ) ; » assert That « ( » has Map « . » get Class Array « ( ) . length == 2 ) . » is True « ( ) ; » assert That « ( » has Map « . » get Class Array « ( ) [ 0 ] . equals ( String . class ) ) . » is True « ( ) ; » assert That « ( » has Map « . » get Class Array « ( ) [ 1 ] . equals ( Exception . class ) ) . » is True « ( ) ; }
@Test { » Has Map « » has Map « = ( » Has Map « ) this . » bean Factory « . » get Bean « ( " » class List « " ) ; » assert That « ( » has Map « . » get Class List « ( ) . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( » has Map « . » get Class List « ( ) . get ( 0 ) . equals ( String . class ) ) . » is True « ( ) ; » assert That « ( » has Map « . » get Class List « ( ) . get ( 1 ) . equals ( Exception . class ) ) . » is True « ( ) ; }
@Test { List list = ( List ) this . » bean Factory « . » get Bean « ( " » list Factory « " ) ; boolean condition = list instanceof » Linked List « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( list . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( " bar " ) ; » assert That « ( list . get ( 1 ) ) . » is Equal To « ( " jenny " ) ; }
@Test { List list = ( List ) this . » bean Factory « . » get Bean « ( " » p List Factory « " ) ; boolean condition = list instanceof » Linked List « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( list . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( " bar " ) ; » assert That « ( list . get ( 1 ) ) . » is Equal To « ( " jenny " ) ; }
@Test { Set set = ( Set ) this . » bean Factory « . » get Bean « ( " » set Factory « " ) ; boolean condition = set instanceof » Tree Set « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( set . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( set . contains ( " bar " ) ) . » is True « ( ) ; » assert That « ( set . contains ( " jenny " ) ) . » is True « ( ) ; }
@Test { Set set = ( Set ) this . » bean Factory « . » get Bean « ( " » p Set Factory « " ) ; boolean condition = set instanceof » Tree Set « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( set . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( set . contains ( " bar " ) ) . » is True « ( ) ; » assert That « ( set . contains ( " jenny " ) ) . » is True « ( ) ; }
@Test { Map map = ( Map ) this . » bean Factory « . » get Bean « ( " » map Factory « " ) ; boolean condition = map instanceof » Tree Map « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( map . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( map . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( map . get ( " jen " ) ) . » is Equal To « ( " jenny " ) ; }
@Test { Map map = ( Map ) this . » bean Factory « . » get Bean « ( " » p Map Factory « " ) ; boolean condition = map instanceof » Tree Map « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( map . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( map . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( map . get ( " jen " ) ) . » is Equal To « ( " jenny " ) ; }
@Test { Set set = ( Set ) this . » bean Factory « . » get Bean « ( " » enum Set Factory « " ) ; » assert That « ( set . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( set . contains ( " ONE " ) ) . » is True « ( ) ; » assert That « ( set . contains ( " TWO " ) ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » ignore Default Lifecycle Methods « . xml " , » get Class « ( ) ) ) ; bf . » pre Instantiate Singletons « ( ) ; bf . » destroy Singletons « ( ) ; }
@Test { » Default Namespace Handler Resolver « resolver = new » Default Namespace Handler Resolver « ( » get Class « ( ) . » get Class Loader « ( ) ) ; » Namespace Handler « handler = resolver . resolve ( " http : » // www . springframework . org / schema / util « " ) ; » assert That « ( handler ) . as ( " Handler should not be null . " ) . » is Not Null « ( ) ; » assert That « ( handler . » get Class « ( ) ) . as ( " Incorrect handler loaded " ) . » is Equal To « ( » Util Namespace Handler « . class ) ; }
@Test { » Default Namespace Handler Resolver « resolver = new » Default Namespace Handler Resolver « ( ) ; » Namespace Handler « handler = resolver . resolve ( " http : » // www . springframework . org / schema / util « " ) ; » assert That « ( handler ) . as ( " Handler should not be null . " ) . » is Not Null « ( ) ; » assert That « ( handler . » get Class « ( ) ) . as ( " Incorrect handler loaded " ) . » is Equal To « ( » Util Namespace Handler « . class ) ; }
@Test { String » mapping Path « = " org / springframework / beans / factory / xml / support / » non Existent « . properties " ; new » Default Namespace Handler Resolver « ( » get Class « ( ) . » get Class Loader « ( ) , » mapping Path « ) ; }
@Test { new » Default Namespace Handler Resolver « ( null ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Default Namespace Handler Resolver « ( null , null ) ) ; }
@Test { new » Default Namespace Handler Resolver « ( null , " 738 trbc » bobabloobop 871 « " ) ; }
@Test { » assert That « ( editor . » get As Text « ( ) ) . as ( " The returned value is not correct . " ) . » is Equal To « ( " " ) ; }
@Test { editor . » set Value « ( » Zone Id « . of ( " America / » New _ York « " ) ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " The text version is not correct . " ) . » is Equal To « ( " America / » New _ York « " ) ; }
@Test { » assert That « ( » byte Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; » byte Editor « . » set As Text « ( null ) ; » assert That « ( » byte Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That « ( » char Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; » char Editor « . » set As Text « ( null ) ; » assert That « ( » char Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Custom Number Editor « editor = new » Custom Number Editor « ( Short . class , true ) ; » assert That Exception Of Type « ( » Number Format Exception « . class ) . as ( " greater than Short . » MAX _ VALUE « + 1 " ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( String . » value Of « ( Short . » MAX _ VALUE « + 1 ) ) ) ; }
@Test { » Primitive Array Bean « bean = new » Primitive Array Bean « ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( bean ) ; bw . » set Property Value « ( " » byte Array « " , " myvalue " ) ; » assert That « ( new String ( bean . » get Byte Array « ( ) ) ) . » is Equal To « ( " myvalue " ) ; }
@Test { » Primitive Array Bean « bean = new » Primitive Array Bean « ( ) ; » Bean Wrapper « bw = new » Bean Wrapper Impl « ( bean ) ; bw . » set Property Value « ( " » char Array « " , " myvalue " ) ; » assert That « ( new String ( bean . » get Char Array « ( ) ) ) . » is Equal To « ( " myvalue " ) ; }
@Test { » Property Editor « » char Editor « = new » Character Editor « ( false ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » char Editor « . » set As Text « ( " » Cold Water Canyon « " ) ) ; }
@Test { » Property Editor « » char Editor « = new » Character Editor « ( false ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » char Editor « . » set As Text « ( null ) ) ; }
@Test { » Property Editor « » class Editor « = new » Class Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » class Editor « . » set As Text « ( " hairdresser . on . Fire " ) ) ; }
@Test { » Property Editor « » class Editor « = new » Class Editor « ( ) ; » class Editor « . » set As Text « ( " org . springframework . beans . testfixture . beans . » Test Bean « [ ] " ) ; » assert That « ( » class Editor « . » get Value « ( ) ) . » is Equal To « ( » Test Bean « [ ] . class ) ; » assert That « ( » class Editor « . » get As Text « ( ) ) . » is Equal To « ( " org . springframework . beans . testfixture . beans . » Test Bean « [ ] " ) ; }
@Test { String [ ] [ ] chessboard = new String [ 8 ] [ 8 ] ; » Class Editor « editor = new » Class Editor « ( ) ; editor . » set Value « ( chessboard . » get Class « ( ) ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " java . lang . String [ ] [ ] " ) ; }
@Test { String [ ] [ ] [ ] [ ] [ ] » ridiculous Chessboard « = new String [ 8 ] [ 4 ] [ 0 ] [ 1 ] [ 3 ] ; » Class Editor « editor = new » Class Editor « ( ) ; editor . » set Value « ( » ridiculous Chessboard « . » get Class « ( ) ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " java . lang . String [ ] [ ] [ ] [ ] [ ] " ) ; }
@Test { » Property Editor « » file Editor « = new » File Editor « ( ) ; » file Editor « . » set As Text « ( " file : myfile . txt " ) ; » assert That « ( » file Editor « . » get Value « ( ) ) . » is Equal To « ( new File ( " myfile . txt " ) ) ; » assert That « ( » file Editor « . » get As Text « ( ) ) . » is Equal To « ( ( new File ( " myfile . txt " ) ) . » get Path « ( ) ) ; }
@Test { » Property Editor « » file Editor « = new » File Editor « ( ) ; try { » file Editor « . » set As Text « ( " myfile . txt " ) ; } catch ( » Illegal Argument Exception « ex ) { } }
@Test { » Property Editor « » locale Editor « = new » Locale Editor « ( ) ; » locale Editor « . » set As Text « ( " » en _ CA « " ) ; » assert That « ( » locale Editor « . » get Value « ( ) ) . » is Equal To « ( Locale . CANADA ) ; » assert That « ( » locale Editor « . » get As Text « ( ) ) . » is Equal To « ( " » en _ CA « " ) ; » locale Editor « = new » Locale Editor « ( ) ; » assert That « ( » locale Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Custom Date Editor « editor = new » Custom Date Editor « ( null , false ) ; editor . » set Value « ( null ) ; » assert That « ( editor . » get Value « ( ) ) . » is Equal To « ( null ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Custom Date Editor « editor = new » Custom Date Editor « ( null , true ) ; editor . » set Value « ( null ) ; » assert That « ( editor . » get Value « ( ) ) . » is Equal To « ( null ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Custom Number Editor « editor = new » Custom Number Editor « ( Integer . class , false ) ; editor . » set As Text « ( " » 0 x « " + Integer . » to Hex String « ( 64 ) ) ; » assert That « ( editor . » get Value « ( ) ) . » is Equal To « ( new Integer ( 64 ) ) ; }
@Test { » Class Array Editor « editor = new » Class Array Editor « ( ) ; editor . » set As Text « ( null ) ; » assert That « ( editor . » get Value « ( ) ) . » is Null « ( ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Class Array Editor « editor = new » Class Array Editor « ( ) ; editor . » set As Text « ( " " ) ; » assert That « ( editor . » get Value « ( ) ) . » is Null « ( ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Class Array Editor « editor = new » Class Array Editor « ( ) ; editor . » set As Text « ( " \n " ) ; » assert That « ( editor . » get Value « ( ) ) . » is Null « ( ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Charset Editor « editor = new » Charset Editor « ( ) ; String name = " UTF - 8 " ; editor . » set As Text « ( name ) ; Charset charset = Charset . » for Name « ( name ) ; » assert That « ( editor . » get Value « ( ) ) . as ( " Invalid Charset conversion " ) . » is Equal To « ( charset ) ; editor . » set Value « ( charset ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " Invalid Charset conversion " ) . » is Equal To « ( name ) ; }
@Test { » Property Editor « » file Editor « = new » File Editor « ( ) ; » file Editor « . » set As Text « ( " classpath : " + » Class Utils « . » class Package As Resource Path « ( » get Class « ( ) ) + " / " + » Class Utils « . » get Short Name « ( » get Class « ( ) ) + " . class " ) ; Object value = » file Editor « . » get Value « ( ) ; boolean condition = value instanceof File ; » assert That « ( condition ) . » is True « ( ) ; File file = ( File ) value ; » assert That « ( file . exists ( ) ) . » is True « ( ) ; }
@Test { » Property Editor « » property Editor « = new » File Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » property Editor « . » set As Text « ( " classpath : » no _ way _ this _ file _ is _ found « . doc " ) ) ; }
@Test { » Property Editor « » file Editor « = new » File Editor « ( ) ; » file Editor « . » set As Text « ( " file : » no _ way _ this _ file _ is _ found « . doc " ) ; Object value = » file Editor « . » get Value « ( ) ; boolean » condition 1 « = value instanceof File ; » assert That « ( » condition 1 « ) . » is True « ( ) ; File file = ( File ) value ; boolean condition = ! file . exists ( ) ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Property Editor « » file Editor « = new » File Editor « ( ) ; » file Editor « . » set As Text « ( " / » no _ way _ this _ file _ is _ found « . doc " ) ; Object value = » file Editor « . » get Value « ( ) ; boolean » condition 1 « = value instanceof File ; » assert That « ( » condition 1 « ) . » is True « ( ) ; File file = ( File ) value ; boolean condition = ! file . exists ( ) ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Input Stream Editor « ( null ) ) ; }
@Test { » Input Stream Editor « editor = new » Input Stream Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( " classpath : bingo ! " ) ) ; }
@Test { » assert That « ( new » Input Stream Editor « ( ) . » get As Text « ( ) ) . » is Null « ( ) ; String resource = " classpath : " + » Class Utils « . » class Package As Resource Path « ( » get Class « ( ) ) + " / " + » Class Utils « . » get Short Name « ( » get Class « ( ) ) + " . class " ; » Input Stream Editor « editor = new » Input Stream Editor « ( ) ; editor . » set As Text « ( resource ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Null « ( ) ; }
@Test { » Property Editor « » property Editor « = new » Path Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » property Editor « . » set As Text « ( " classpath : / » no _ way _ this _ file _ is _ found « . doc " ) ) ; }
@Test { » Property Editor « » path Editor « = new » Path Editor « ( ) ; » path Editor « . » set As Text « ( " file : / » no _ way _ this _ file _ is _ found « . doc " ) ; Object value = » path Editor « . » get Value « ( ) ; boolean » condition 1 « = value instanceof Path ; » assert That « ( » condition 1 « ) . » is True « ( ) ; Path path = ( Path ) value ; boolean condition = ! path . » to File « ( ) . exists ( ) ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Property Editor « » path Editor « = new » Path Editor « ( ) ; » path Editor « . » set As Text « ( " / » no _ way _ this _ file _ is _ found « . doc " ) ; Object value = » path Editor « . » get Value « ( ) ; boolean » condition 1 « = value instanceof Path ; » assert That « ( » condition 1 « ) . » is True « ( ) ; Path path = ( Path ) value ; boolean condition = ! path . » to File « ( ) . exists ( ) ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { String s = " foo = bar " ; » Properties Editor « pe = new » Properties Editor « ( ) ; pe . » set As Text « ( s ) ; Properties p = ( Properties ) pe . » get Value « ( ) ; » assert That « ( p . » entry Set « ( ) . size ( ) == 1 ) . as ( " contains one entry " ) . » is True « ( ) ; » assert That « ( p . get ( " foo " ) . equals ( " bar " ) ) . as ( " foo = bar " ) . » is True « ( ) ; }
@Test { » Properties Editor « pe = new » Properties Editor « ( ) ; pe . » set As Text « ( null ) ; Properties p = ( Properties ) pe . » get Value « ( ) ; » assert That « ( p . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Properties Editor « pe = new » Properties Editor « ( ) ; pe . » set As Text « ( " " ) ; Properties p = ( Properties ) pe . » get Value « ( ) ; » assert That « ( p . » is Empty « ( ) ) . as ( " empty string means empty properties " ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Reader Editor « ( null ) ) ; }
@Test { String resource = " classpath : bingo ! " ; » Reader Editor « editor = new » Reader Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( resource ) ) ; }
@Test { » assert That « ( new » Reader Editor « ( ) . » get As Text « ( ) ) . » is Null « ( ) ; String resource = " classpath : " + » Class Utils « . » class Package As Resource Path « ( » get Class « ( ) ) + " / " + » Class Utils « . » get Short Name « ( » get Class « ( ) ) + " . class " ; » Reader Editor « editor = new » Reader Editor « ( ) ; editor . » set As Text « ( resource ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Null « ( ) ; }
@Test { » Resource Bundle Editor « editor = new » Resource Bundle Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( null ) ) ; }
@Test { » Resource Bundle Editor « editor = new » Resource Bundle Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( " " ) ) ; }
@Test { » Resource Bundle Editor « editor = new » Resource Bundle Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( " _ " ) ) ; }
@Test { » do Test URI « ( " mailto : juergen . hoeller @ » interface 21 « . com " ) ; }
@Test { » do Test URI « ( " gonna : / freak / in / the / morning / freak / in / the . evening " ) ; }
@Test { » do Test URI « ( " https : » // www . springframework . org « " ) ; }
@Test { » do Test URI « ( " https : » // www . springframework . org « # 1 " ) ; }
@Test { » Property Editor « » uri Editor « = new » URI Editor « ( ) ; » uri Editor « . » set As Text « ( " https : » // www . springframework . org « " ) ; Object value = » uri Editor « . » get Value « ( ) ; boolean condition = value instanceof URI ; » assert That « ( condition ) . » is True « ( ) ; URI uri = ( URI ) value ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " https : » // www . springframework . org « " ) ; }
@Test { » Property Editor « » uri Editor « = new » URI Editor « ( ) ; » uri Editor « . » set As Text « ( null ) ; » assert That « ( » uri Editor « . » get Value « ( ) ) . » is Null « ( ) ; » assert That « ( » uri Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Property Editor « » uri Editor « = new » URI Editor « ( ) ; » assert That « ( » uri Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » URL Editor « ( null ) ) ; }
@Test { » Property Editor « » url Editor « = new » URL Editor « ( ) ; » url Editor « . » set As Text « ( " mailto : juergen . hoeller @ » interface 21 « . com " ) ; Object value = » url Editor « . » get Value « ( ) ; boolean condition = value instanceof URL ; » assert That « ( condition ) . » is True « ( ) ; URL url = ( URL ) value ; » assert That « ( » url Editor « . » get As Text « ( ) ) . » is Equal To « ( url . » to External Form « ( ) ) ; }
@Test { » Property Editor « » url Editor « = new » URL Editor « ( ) ; » url Editor « . » set As Text « ( " https : » // www . springframework . org « " ) ; Object value = » url Editor « . » get Value « ( ) ; boolean condition = value instanceof URL ; » assert That « ( condition ) . » is True « ( ) ; URL url = ( URL ) value ; » assert That « ( » url Editor « . » get As Text « ( ) ) . » is Equal To « ( url . » to External Form « ( ) ) ; }
@Test { » Property Editor « » url Editor « = new » URL Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » url Editor « . » set As Text « ( " gonna : / freak / in / the / morning / freak / in / the . evening " ) ) ; }
@Test { » Property Editor « » url Editor « = new » URL Editor « ( ) ; » url Editor « . » set As Text « ( null ) ; » assert That « ( » url Editor « . » get Value « ( ) ) . » is Null « ( ) ; » assert That « ( » url Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Property Editor « » url Editor « = new » URL Editor « ( ) ; » assert That « ( » url Editor « . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » String Array Property Editor « editor = new » String Array Property Editor « ( ) ; editor . » set As Text « ( " 0 , 1 , 2 " ) ; Object value = editor . » get Value « ( ) ; » assert Trimmed Elements « ( value ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " 0 , 1 , 2 " ) ; }
@Test { » String Array Property Editor « editor = new » String Array Property Editor « ( " : " ) ; editor . » set As Text « ( " 0 : 1 : 2 " ) ; Object value = editor . » get Value « ( ) ; » assert Trimmed Elements « ( value ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " 0 : 1 : 2 " ) ; }
@Test { » String Array Property Editor « editor = new » String Array Property Editor « ( " , " , " \r \n " , false ) ; editor . » set As Text « ( " 0 \r , 1 , \n 2 " ) ; Object value = editor . » get Value « ( ) ; » assert Trimmed Elements « ( value ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " 0 , 1 , 2 " ) ; }
@Test { » String Array Property Editor « editor = new » String Array Property Editor « ( ) ; editor . » set As Text « ( " " ) ; Object value = editor . » get Value « ( ) ; » assert That « ( value ) . » is Instance Of « ( String [ ] . class ) ; » assert That « ( ( String [ ] ) value ) . » is Empty « ( ) ; }
@Test { » String Array Property Editor « editor = new » String Array Property Editor « ( " , " , true ) ; editor . » set As Text « ( " " ) ; » assert That « ( editor . » get Value « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Custom Collection Editor « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Custom Collection Editor « ( ( Class ) String . class ) ) ; }
@Test { » Custom Collection Editor « editor = new » Custom Collection Editor « ( » Collection Type With No No Arg Ctor « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set Value « ( " 1 " ) ) ; }
@Test { » Custom Collection Editor « editor = new » Custom Collection Editor « ( Collection . class ) ; editor . » set Value « ( " 0 , 1 , 2 " ) ; Collection < ? > value = ( Collection < ? > ) editor . » get Value « ( ) ; » assert That « ( value ) . » is Not Null « ( ) ; » assert That « ( value . size ( ) ) . as ( " There must be 1 element in the converted collection " ) . » is Equal To « ( 1 ) ; » assert That « ( value . iterator ( ) . next ( ) ) . » is Equal To « ( " 0 , 1 , 2 " ) ; }
@Test { Dog dog = new Dog ( ) ; Dog » dog 2 « = new Dog ( ) ; » Property Comparator « < Dog > c = new » Property Comparator « < > ( " » nick Name « " , false , true ) ; » assert That « ( c . compare ( dog , » dog 2 « ) == 0 ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Bean Factory « ( ) . » get Bean « ( ( String ) null ) ) ; }
@Test { » Must Be Initialized « mbi = ( » Must Be Initialized « ) » get Bean Factory « ( ) . » get Bean « ( " » must Be Initialized « " ) ; mbi . » business Method « ( ) ; }
@Test { » Lifecycle Bean « lb = ( » Lifecycle Bean « ) » get Bean Factory « ( ) . » get Bean « ( " lifecycle " ) ; » assert That « ( lb . » get Bean Name « ( ) ) . » is Equal To « ( " lifecycle " ) ; lb . » business Method « ( ) ; boolean condition = ! lb . » is Destroyed « ( ) ; » assert That « ( condition ) . as ( " Not destroyed " ) . » is True « ( ) ; }
@Test { Object o = » get Bean Factory « ( ) . » get Bean « ( " rod " , » Test Bean « . class ) ; boolean condition = o instanceof » Test Bean « ; » assert That « ( condition ) . as ( " Rod bean is a » Test Bean « " ) . » is True « ( ) ; }
@Test { » assert That « ( » get Bean Factory « ( ) . » contains Bean « ( " Mr Squiggle " ) ) . » is False « ( ) ; » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Factory « ( ) . » get Bean « ( " Mr Squiggle " ) ) ; }
@Test { Object o = » get Bean Factory « ( ) . » get Bean « ( " » valid Empty « " ) ; boolean condition = o instanceof » Test Bean « ; » assert That « ( condition ) . as ( " » valid Empty « bean is a » Test Bean « " ) . » is True « ( ) ; » Test Bean « ve = ( » Test Bean « ) o ; » assert That « ( ve . » get Name « ( ) == null && ve . » get Age « ( ) == 0 && ve . » get Spouse « ( ) == null ) . as ( " Valid empty has defaults " ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Factory « ( ) . » get Bean « ( " » type Mismatch « " ) ) . » with Cause Instance Of « ( » Type Mismatch Exception « . class ) ; }
@Test { » Test Bean « dad = ( » Test Bean « ) » get Bean Factory « ( ) . » get Bean « ( " father " ) ; » assert That « ( dad . » get Name « ( ) . equals ( " Albert " ) ) . as ( " Dad has correct name " ) . » is True « ( ) ; }
@Test { » assert That « ( » get Bean Factory « ( ) . » get Bean « ( " & » singleton Factory « " ) ) . » is Not Null « ( ) ; }
@Test { » Test Bean « tb = ( » Test Bean « ) » get Bean Factory « ( ) . » get Bean « ( " » singleton Factory « " ) ; » assert That « ( tb ) . » is Not Null « ( ) ; » Dummy Factory « factory = ( » Dummy Factory « ) » get Bean Factory « ( ) . » get Bean « ( " & » singleton Factory « " ) ; » assert That « ( factory . » was Initialized « ( ) ) . as ( " Factory was initialized because it implemented » Initializing Bean « " ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Is Not A Factory Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Factory « ( ) . » get Bean « ( " & rod " ) ) ; }
@Test { » assert Count « ( 13 ) ; }
@Test { String [ ] defnames = » get Listable Bean Factory « ( ) . » get Bean Names For Type « ( String . class ) ; » assert That « ( defnames . length == 0 ) . as ( " No string definitions " ) . » is True « ( ) ; }
@Test { » assert That « ( » get Listable Bean Factory « ( ) . » contains Bean Definition « ( " rod " ) ) . » is True « ( ) ; » assert That « ( » get Listable Bean Factory « ( ) . » contains Bean Definition « ( " roderick " ) ) . » is True « ( ) ; }
@Test { » Candidate Components Metadata « metadata = compile ( » Sample None « . class ) ; » assert That « ( metadata . » get Items « ( ) ) . » has Size « ( 0 ) ; }
@Test { » Candidate Components Metadata « metadata = compile ( » Candidate Components Indexer Tests « . class ) ; » assert That « ( metadata . » get Items « ( ) ) . » has Size « ( 0 ) ; }
@Test { » test Component « ( » Sample Component « . class ) ; }
@Test { » test Component « ( » Sample Service « . class ) ; }
@Test { » test Component « ( » Sample Controller « . class ) ; }
@Test { » test Component « ( » Sample Meta Controller « . class ) ; }
@Test { » test Single Component « ( » Sample Repository « . class , Component . class ) ; }
@Test { » test Single Component « ( » Sample Meta Indexed Controller « . class , Component . class , » Meta Controller Indexed « . class ) ; }
@Test { » test Component « ( » Abstract Controller « . class ) ; }
@Test { » test Single Component « ( » Sample Managed Bean « . class , » Managed Bean « . class ) ; }
@Test { » test Single Component « ( » Sample Named « . class , Named . class ) ; }
@Test { » test Single Component « ( » Sample Transactional « . class , Transactional . class ) ; }
@Test { » test Single Component « ( » Sample Entity « . class , Entity . class ) ; }
@Test { » test Single Component « ( » Sample Mapped Super Class « . class , » Mapped Superclass « . class ) ; }
@Test { » test Single Component « ( » Sample Embeddable « . class , Embeddable . class ) ; }
@Test { » test Single Component « ( » Sample Converter « . class , Converter . class ) ; }
@Test { » Candidate Components Metadata « metadata = compile ( " org / springframework / context / index / sample / jpa / package - info " ) ; » assert That « ( metadata ) . has ( Metadata . of ( " org . springframework . context . index . sample . jpa " , " package - info " ) ) ; }
@Test { » test Single Component « ( » Sample Specialized Repo « . class , Repo . class ) ; }
@Test { » test Single Component « ( » Sample Repo « . class , Repo . class ) ; }
@Test { » test Single Component « ( » Sample Smart Repo « . class , Repo . class , » Smart Repo « . class ) ; }
@Test { » test Single Component « ( » Specialized Repo « . class , Repo . class ) ; }
@Test { » test Single Component « ( » Smart Repo « . class , Repo . class , » Smart Repo « . class ) ; }
@Test { » test Single Component « ( Repo . class , Repo . class ) ; }
@Test { » Candidate Components Metadata « metadata = compile ( » Sample Non Static Embedded « . class ) ; » assert That « ( metadata . » get Items « ( ) ) . » has Size « ( 0 ) ; }
@Test { » Caffeine Cache Manager « cm = new » Caffeine Cache Manager « ( " » c 1 « " ) ; Cache » cache 1 « = cm . » get Cache « ( " » c 1 « " ) ; cm . » set Caffeine Spec « ( » Caffeine Spec « . parse ( " » maximum Size « = 10 " ) ) ; Cache » cache 1 x « = cm . » get Cache « ( " » c 1 « " ) ; » assert That « ( » cache 1 x « != » cache 1 « ) . » is True « ( ) ; }
@Test { » Caffeine Cache Manager « cm = new » Caffeine Cache Manager « ( " » c 1 « " ) ; Cache » cache 1 « = cm . » get Cache « ( " » c 1 « " ) ; cm . » set Cache Specification « ( " » maximum Size « = 10 " ) ; Cache » cache 1 x « = cm . » get Cache « ( " » c 1 « " ) ; » assert That « ( » cache 1 x « != » cache 1 « ) . » is True « ( ) ; }
@Test { » Caffeine Cache Manager « cm = new » Caffeine Cache Manager « ( " » c 1 « " ) ; » assert That « ( cm . » get Cache « ( " » some Cache « " ) ) . » is Null « ( ) ; cm . » set Cache Names « ( null ) ; » assert That « ( cm . » get Cache « ( " » some Cache « " ) ) . » is Not Null « ( ) ; }
@Test { String key = " brancusi " ; String value = " constantin " ; Element brancusi = new Element ( key , value ) ; brancusi . » set Time To Live « ( 3 ) ; » native Cache « . put ( brancusi ) ; » assert That « ( cache . get ( key ) . get ( ) ) . » is Equal To « ( value ) ; Thread . sleep ( 5 * 1000 ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { » do Test Eh Cache Factory Bean « ( false ) ; }
@Test { » do Test Eh Cache Factory Bean « ( true ) ; }
@Test { » tx Template « . » execute Without Result « ( s -> » test Evict « ( this . cs , false ) ) ; }
@Test { » tx Template « . » execute Without Result « ( s -> » test Evict Early « ( this . cs ) ) ; }
@Test { » tx Template « . » execute Without Result « ( s -> » test Evict All « ( this . cs , false ) ) ; }
@Test { » tx Template « . » execute Without Result « ( s -> » test Evict All Early « ( this . cs ) ) ; }
@Test { Map < String , » J Cache Interceptor « > interceptors = ctx . » get Beans Of Type « ( » J Cache Interceptor « . class ) ; » assert That « ( interceptors . size ( ) ) . as ( " Only one interceptor should be defined " ) . » is Equal To « ( 1 ) ; » J Cache Interceptor « interceptor = interceptors . values ( ) . iterator ( ) . next ( ) ; » assert That « ( interceptor . » get Class « ( ) ) . as ( " Custom interceptor not defined " ) . » is Equal To « ( » Test Cache Interceptor « . class ) ; }
@Test { Object o = cs . » cache With Exception « ( " id " , true ) ; » assert That « ( o ) . » is Equal To « ( 55L ) ; }
@Test { » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> cs . » cache With Checked Exception « ( " id " , true ) ) . » with Cause Exactly Instance Of « ( » IO Exception « . class ) ; }
@Test { » Configurable Application Context « context = new » Generic Xml Application Context « ( " / org / springframework / cache / jcache / config / » j Cache Namespace Driven « - resolver . xml " ) ; » Default J Cache Operation Source « ci = context . » get Bean « ( » Default J Cache Operation Source « . class ) ; » assert That « ( ci . » get Cache Resolver « ( ) ) . » is Same As « ( context . » get Bean « ( " » cache Resolver « " ) ) ; context . close ( ) ; }
@Test { » J Cache Interceptor « ci = ctx . » get Bean « ( » J Cache Interceptor « . class ) ; » assert That « ( ci . » get Error Handler « ( ) ) . » is Same As « ( ctx . » get Bean « ( " » error Handler « " , » Cache Error Handler « . class ) ) ; }
@Test { » Cache Remove All Operation « operation = » create Simple Operation « ( ) ; » Cache Invocation Parameter « [ ] » all Parameters « = operation . » get All Parameters « ( ) ; » assert That « ( » all Parameters « . length ) . » is Equal To « ( 0 ) ; }
@Test { » Cache Remove Operation « operation = » create Simple Operation « ( ) ; » Cache Invocation Parameter « [ ] » all Parameters « = operation . » get All Parameters « ( 2L ) ; » assert That « ( » all Parameters « . length ) . » is Equal To « ( 1 ) ; » assert Cache Invocation Parameter « ( » all Parameters « [ 0 ] , Long . class , 2L , 0 ) ; }
@Test { » Default Cache Invocation Context « < ? > » dummy Context « = » create Dummy Context « ( ) ; » Cache Resolver Adapter « adapter = new » Cache Resolver Adapter « ( » get Cache Resolver « ( » dummy Context « , null ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> adapter . » resolve Caches « ( » dummy Context « ) ) ; }
@Test { » Cache Method Details « < » Cache Result « > » method Details « = create ( » Cache Result « . class , » Sample Object « . class , " » another Simple Get « " , String . class , Long . class ) ; » Cache Result Operation « operation = » create Default Operation « ( » method Details « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> operation . » get All Parameters « ( " bar " ) ) ; }
@Test { » Cache Method Details « < » Cache Result « > » method Details « = create ( » Cache Result « . class , » Sample Object « . class , " » another Simple Get « " , String . class , Long . class ) ; » Cache Result Operation « operation = » create Default Operation « ( » method Details « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> operation . » get Key Parameters « ( " bar " ) ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on get " ) ; Object key = » Simple Key Generator « . » generate Key « ( 0L ) ; » will Throw « ( exception ) . given ( this . cache ) . get ( key ) ; this . » simple Service « . get ( 0L ) ; verify ( this . » error Handler « ) . » handle Cache Get Error « ( exception , this . cache , key ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on put " ) ; Object key = » Simple Key Generator « . » generate Key « ( 0L ) ; given ( this . cache . get ( key ) ) . » will Return « ( null ) ; » will Throw « ( exception ) . given ( this . cache ) . put ( key , 0L ) ; this . » simple Service « . get ( 0L ) ; verify ( this . » error Handler « ) . » handle Cache Put Error « ( exception , this . cache , key , 0L ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on put " ) ; Object key = » Simple Key Generator « . » generate Key « ( 0L ) ; » will Throw « ( exception ) . given ( this . cache ) . put ( key , 234L ) ; this . » simple Service « . put ( 0L , 234L ) ; verify ( this . » error Handler « ) . » handle Cache Put Error « ( exception , this . cache , key , 234L ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on evict " ) ; Object key = » Simple Key Generator « . » generate Key « ( 0L ) ; » will Throw « ( exception ) . given ( this . cache ) . evict ( key ) ; this . » simple Service « . evict ( 0L ) ; verify ( this . » error Handler « ) . » handle Cache Evict Error « ( exception , this . cache , key ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on evict " ) ; » will Throw « ( exception ) . given ( this . cache ) . clear ( ) ; this . » simple Service « . clear ( ) ; verify ( this . » error Handler « ) . » handle Cache Clear Error « ( exception , this . cache ) ; }
@Test { » Cache Result Operation « op = » get Default Cache Operation « ( » Cache Result Operation « . class , String . class ) ; » assert Defaults « ( op ) ; » assert That « ( op . » get Exception Cache Resolver « ( ) ) . as ( " Exception caching not enabled so resolver should not be set " ) . » is Null « ( ) ; }
@Test { » Cache Result Operation « op = » get Default Cache Operation « ( » Cache Result Operation « . class , String . class , boolean . class ) ; » assert Defaults « ( op ) ; » assert That « ( op . » get Exception Cache Resolver « ( ) ) . » is Equal To « ( » default Exception Cache Resolver « ) ; » assert That « ( op . » get Exception Cache Name « ( ) ) . » is Equal To « ( " exception " ) ; }
@Test { » Cache Put Operation « op = » get Default Cache Operation « ( » Cache Put Operation « . class , String . class , Object . class ) ; » assert Defaults « ( op ) ; }
@Test { » Cache Remove Operation « op = » get Default Cache Operation « ( » Cache Remove Operation « . class , String . class ) ; » assert Defaults « ( op ) ; }
@Test { » Cache Remove All Operation « op = » get Default Cache Operation « ( » Cache Remove All Operation « . class ) ; » assert That « ( op . » get Cache Resolver « ( ) ) . » is Equal To « ( » default Cache Resolver « ) ; }
@Test { » assert That « ( » get Cache Operation « ( » Annotated J Cacheable Service « . class , this . » cache Name « ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » get Cache Operation « ( » Invalid Cases « . class , this . » cache Name « ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( Object . class , " » to String « " ) ; » assert That « ( source . » determine Cache Name « ( method , null , " foo " ) ) . » is Equal To « ( " foo " ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( Object . class , " » to String « " ) ; » Cache Defaults « mock = mock ( » Cache Defaults « . class ) ; given ( mock . » cache Name « ( ) ) . » will Return « ( " " ) ; » assert That « ( source . » determine Cache Name « ( method , mock , " " ) ) . » is Equal To « ( " java . lang . Object . » to String « ( ) " ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( Object . class , " » to String « " ) ; » assert That « ( source . » determine Cache Name « ( method , null , " " ) ) . » is Equal To « ( " java . lang . Object . » to String « ( ) " ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( Comparator . class , " compare " , Object . class , Object . class ) ; » assert That « ( source . » determine Cache Name « ( method , null , " " ) ) . » is Equal To « ( " java . util . Comparator . compare ( java . lang . Object , java . lang . Object ) " ) ; }
@Test { » Cache Result Operation « operation = » get Cache Operation « ( » Cache Result Operation « . class , » Custom Service « . class , this . » cache Name « , Long . class ) ; » assert That « ( operation . » get Cache Resolver « ( ) ) . » is Equal To « ( » default Cache Resolver « ) ; » assert That « ( operation . » get Exception Cache Resolver « ( ) ) . » is Null « ( ) ; » assert Cache Key Generator « ( operation . » get Key Generator « ( ) , » Testable Cache Key Generator « . class ) ; }
@Test { » Cache Result Operation « operation = » get Cache Operation « ( » Cache Result Operation « . class , » Custom Service With Defaults « . class , this . » cache Name « , Long . class ) ; » assert J Cache Resolver « ( operation . » get Cache Resolver « ( ) , » Testable Cache Resolver « . class ) ; » assert J Cache Resolver « ( operation . » get Exception Cache Resolver « ( ) , null ) ; » assert Cache Key Generator « ( operation . » get Key Generator « ( ) , » Testable Cache Key Generator « . class ) ; }
@Test { » Cache Result Operation « operation = » get Cache Operation « ( » Cache Result Operation « . class , » Custom Service With Defaults « . class , this . » cache Name « , Long . class ) ; » assert J Cache Resolver « ( operation . » get Cache Resolver « ( ) , » Testable Cache Resolver « . class ) ; » assert J Cache Resolver « ( operation . » get Exception Cache Resolver « ( ) , » Testable Cache Resolver « . class ) ; » assert Cache Key Generator « ( operation . » get Key Generator « ( ) , » Testable Cache Key Generator « . class ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » create Operation Source « ( null , null , null , » default Key Generator « ) ) ; }
@Test { » create Operation Source « ( null , » default Cache Resolver « , » default Exception Cache Resolver « , » default Key Generator « ) ; }
@Test { » Cache Method Details « < » Cache Put « > » method Details « = create ( » Cache Put « . class , » Sample Object « . class , " » no Cache Value « " , Long . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Default Operation « ( » method Details « ) ) ; }
@Test { » Cache Method Details « < » Cache Put « > » method Details « = create ( » Cache Put « . class , » Sample Object « . class , " » multi Cache Values « " , Long . class , » Sample Object « . class , » Sample Object « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Default Operation « ( » method Details « ) ) ; }
@Test { » Cache Put Operation « operation = » create Simple Operation « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> operation . » get Value Parameter « ( 2L ) ) ; }
@Test { this . » key Generator « . expect ( 1L ) ; Object first = this . » simple Service « . get ( 1L ) ; Object second = this . » simple Service « . get ( 1L ) ; » assert That « ( second ) . » is Same As « ( first ) ; Object key = new » Simple Key « ( 1L ) ; » assert That « ( cache . get ( key ) . get ( ) ) . » is Equal To « ( first ) ; }
@Test { this . » key Generator « . expect ( 1L , " foo " , " bar " ) ; Object first = this . » simple Service « . get ( 1L , " foo " , " bar " ) ; Object second = this . » simple Service « . get ( 1L , " foo " , " bar " ) ; » assert That « ( second ) . » is Same As « ( first ) ; Object key = new » Simple Key « ( 1L , " foo " , " bar " ) ; » assert That « ( cache . get ( key ) . get ( ) ) . » is Equal To « ( first ) ; }
@Test { this . » key Generator « . expect ( 1L ) ; Object first = this . » simple Service « . » get Filtered « ( 1L , " foo " , " bar " ) ; Object second = this . » simple Service « . » get Filtered « ( 1L , " foo " , " bar " ) ; » assert That « ( second ) . » is Same As « ( first ) ; Object key = new » Simple Key « ( 1L ) ; » assert That « ( cache . get ( key ) . get ( ) ) . » is Equal To « ( first ) ; }
@Test { » assert That « ( » get Cache Manager « ( false ) . » get Cache « ( » CACHE _ NAME « ) ) . » is Instance Of « ( » get Cache Type « ( ) ) ; }
@Test { T » cache Manager « = » get Cache Manager « ( false ) ; » assert That « ( » cache Manager « . » get Cache Names « ( ) . contains ( this . » cache Name « ) ) . » is False « ( ) ; » assert That « ( » cache Manager « . » get Cache « ( this . » cache Name « ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » get Cache Manager « ( true ) . » get Cache « ( » CACHE _ NAME « ) ) . » is Instance Of « ( » Transaction Aware Cache Decorator « . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Transaction Aware Cache Decorator « ( null ) ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; » Transaction Aware Cache Decorator « cache = new » Transaction Aware Cache Decorator « ( target ) ; » assert That « ( cache . » get Target Cache « ( ) ) . » is Same As « ( target ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; » assert That « ( target . get ( key , String . class ) ) . » is Equal To « ( " 123 " ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; » tx Template « . » execute Without Result « ( s -> { cache . put ( key , " 123 " ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; } ) ; » assert That « ( target . get ( key , String . class ) ) . » is Equal To « ( " 123 " ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; cache . evict ( key ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; » tx Template « . » execute Without Result « ( s -> { cache . evict ( key ) ; » assert That « ( target . get ( key , String . class ) ) . » is Equal To « ( " 123 " ) ; } ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; cache . » evict If Present « ( key ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; » tx Template « . » execute Without Result « ( s -> { cache . » evict If Present « ( key ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; } ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; cache . clear ( ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; » tx Template « . » execute Without Result « ( s -> { cache . clear ( ) ; » assert That « ( target . get ( key , String . class ) ) . » is Equal To « ( " 123 " ) ; } ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; cache . invalidate ( ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache target = new » Concurrent Map Cache « ( " » test Cache « " ) ; Cache cache = new » Transaction Aware Cache Decorator « ( target ) ; Object key = new Object ( ) ; cache . put ( key , " 123 " ) ; » tx Template « . » execute Without Result « ( s -> { cache . invalidate ( ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; } ) ; » assert That « ( target . get ( key ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Simple Mail Message « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Simple Mail Message « ( ) . » copy To « ( null ) ) ; }
@Test { » Configurable Mime File Type Map « ftm = new » Configurable Mime File Type Map « ( ) ; » assert That « ( ftm . » get Content Type « ( new File ( " / tmp / foobar . HTM " ) ) ) . as ( " Invalid content type for HTM " ) . » is Equal To « ( " text / html " ) ; }
@Test { » assert That « ( editor . » get As Text « ( ) ) . as ( " Uninitialized editor did not return empty value string " ) . » is Equal To « ( EMPTY ) ; }
@Test { editor . » set As Text « ( null ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " Setting null did not result in empty value string " ) . » is Equal To « ( EMPTY ) ; }
@Test { editor . » set As Text « ( EMPTY ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " Setting empty string did not result in empty value string " ) . » is Equal To « ( EMPTY ) ; }
@Test { editor . » set As Text « ( " " ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " All whitespace was not recognized " ) . » is Equal To « ( EMPTY ) ; }
@Test { editor . » set As Text « ( SIMPLE ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " Simple email address failed " ) . » is Equal To « ( SIMPLE ) ; }
@Test { editor . » set As Text « ( " " + SIMPLE + " " ) ; » assert That « ( editor . » get As Text « ( ) ) . as ( " Whitespace was not stripped " ) . » is Equal To « ( SIMPLE ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( BAD ) ) ; }
@Test { » Mock Java Mail Sender « sender = new » Mock Java Mail Sender « ( ) ; » Simple Mail Message « » simple Message « = new » Simple Mail Message « ( ) ; » simple Message « . » set From « ( " " ) ; try { sender . send ( » simple Message « ) ; } catch ( » Mail Parse Exception « ex ) { boolean condition = ex . » get Cause « ( ) instanceof » Address Exception « ; » assert That « ( condition ) . » is True « ( ) ; } }
@Test { » Mock Java Mail Sender « sender = new » Mock Java Mail Sender « ( ) ; » Mime Message Preparator « preparator = new » Mime Message Preparator « ( ) { @ Override public void prepare ( » Mime Message « » mime Message « ) throws » Messaging Exception « { » mime Message « . » set From « ( new » Internet Address « ( " " ) ) ; } } ; try { sender . send ( preparator ) ; } catch ( » Mail Parse Exception « ex ) { boolean condition = ex . » get Cause « ( ) instanceof » Address Exception « ; » assert That « ( condition ) . » is True « ( ) ; } }
@Test { » Mock Java Mail Sender « sender = new » Mock Java Mail Sender « ( ) ; sender . » set Host « ( " " ) ; sender . » set Username « ( " username " ) ; sender . » set Password « ( " password " ) ; » Simple Mail Message « » simple Message 1 « = new » Simple Mail Message « ( ) ; » assert That Exception Of Type « ( » Mail Send Exception « . class ) . » is Thrown By « ( ( ) -> sender . send ( » simple Message 1 « ) ) . satisfies ( ex -> » assert That « ( ex . » get Failed Messages « ( ) ) . » is Empty « ( ) ) ; }
@Test { » Mock Java Mail Sender « sender = new » Mock Java Mail Sender « ( ) ; sender . » set Host « ( " host " ) ; sender . » test Connection « ( ) ; }
@Test { » Mock Java Mail Sender « sender = new » Mock Java Mail Sender « ( ) ; sender . » set Host « ( null ) ; » assert That Exception Of Type « ( » Messaging Exception « . class ) . » is Thrown By « ( sender :: » test Connection « ) ; }
@Test { » Cron Trigger Factory Bean « factory = new » Cron Trigger Factory Bean « ( ) ; factory . » set Name « ( " » my Trigger « " ) ; factory . » set Cron Expression « ( " 0 15 10 ? * * " ) ; factory . » after Properties Set « ( ) ; » Cron Trigger « trigger = factory . » get Object « ( ) ; » assert That « ( trigger . » get Cron Expression « ( ) ) . » is Equal To « ( " 0 15 10 ? * * " ) ; }
@Test { » Job Detail Impl « » job Detail « = new » Job Detail Impl « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » job Detail « . » set Job Class « ( ( Class ) » Dummy Runnable « . class ) ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; context . » register Bean Definition « ( " scheduler " , new » Root Bean Definition « ( » Scheduler Factory Bean « . class ) ) ; Scheduler bean = context . » get Bean « ( " scheduler " , Scheduler . class ) ; » assert That « ( bean . » is Started « ( ) ) . » is False « ( ) ; context . refresh ( ) ; » assert That « ( bean . » is Started « ( ) ) . » is True « ( ) ; }
@Test { » Class Path Xml Application Context « ctx = context ( " » scheduler Repository Exposure « . xml " ) ; » assert That « ( ctx . » get Bean « ( " scheduler " ) ) . » is Same As « ( » Scheduler Repository « . » get Instance « ( ) . lookup ( " » my Scheduler « " ) ) ; ctx . close ( ) ; }
@Test { » Dummy Job « . param = 0 ; » Dummy Job « . count = 0 ; » Class Path Xml Application Context « ctx = context ( " » database Persistence « . xml " ) ; » Jdbc Template « » jdbc Template « = new » Jdbc Template « ( ctx . » get Bean « ( » Data Source « . class ) ) ; » assert That « ( » jdbc Template « . » query For List « ( " SELECT * FROM » qrtz _ triggers « " ) . » is Empty « ( ) ) . as ( " No triggers were persisted " ) . » is False « ( ) ; }
@Test { » Simple Trigger Factory Bean « factory = new » Simple Trigger Factory Bean « ( ) ; factory . » set Name « ( " » my Trigger « " ) ; factory . » set Repeat Count « ( 5 ) ; factory . » set Repeat Interval « ( 1000L ) ; factory . » after Properties Set « ( ) ; » Simple Trigger « trigger = factory . » get Object « ( ) ; » assert That « ( trigger . » get Repeat Count « ( ) ) . » is Equal To « ( 5 ) ; » assert That « ( trigger . » get Repeat Interval « ( ) ) . » is Equal To « ( 1000L ) ; }
@Test { fcfb . » set Config Location « ( new » File System Resource « ( " myprops . properties " ) ) ; Properties props = new Properties ( ) ; props . » set Property « ( " myprop " , " / mydir " ) ; fcfb . » set Freemarker Settings « ( props ) ; » assert That IO Exception « ( ) . » is Thrown By « ( fcfb :: » after Properties Set « ) ; }
@Test { fcfb . » set Template Loader Path « ( " file : / mydir " ) ; fcfb . » after Properties Set « ( ) ; Configuration cfg = fcfb . » get Object « ( ) ; » assert That « ( cfg . » get Template Loader « ( ) ) . » is Instance Of « ( » Spring Template Loader « . class ) ; }
@Test { » My Valid Bean « bean = new » My Valid Bean « ( ) ; » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( bean ) ; » proxy Factory « . » add Advice « ( new » Method Validation Interceptor « ( ) ) ; » proxy Factory « . » add Advisor « ( new » Async Annotation Advisor « ( ) ) ; » do Test Proxy Validation « ( ( » My Valid Interface « < String > ) » proxy Factory « . » get Proxy « ( ) ) ; }
@Test { @ » Suppress Warnings « ( " resource " ) » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Lazy Method Validation Config « . class , » Custom Validator Bean « . class , » My Valid Bean « . class , » My Valid Factory Bean « . class ) ; ctx . » get Beans Of Type « ( » My Valid Interface « . class ) . values ( ) . » for Each « ( bean -> bean . » my Valid Method « ( " value " , 5 ) ) ; }
@Test { @ » Suppress Warnings « ( " resource " ) » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Lazy Method Validation Config With Proxy Target Class « . class , » Custom Validator Bean « . class , » My Valid Bean « . class , » My Valid Factory Bean « . class ) ; ctx . » get Beans Of Type « ( » My Valid Interface « . class ) . values ( ) . » for Each « ( bean -> bean . » my Valid Method « ( " value " , 5 ) ) ; }
@Test { Validator » native Validator « = » validator Adapter « . unwrap ( Validator . class ) ; » assert That « ( » native Validator « ) . » is Same As « ( this . » native Validator « ) ; }
@Test { Parent parent = new Parent ( ) ; parent . » set Name « ( " Parent whit list " ) ; parent . » get Child List « ( ) . » add All « ( » create Children « ( parent ) ) ; » Bean Property Binding Result « errors = new » Bean Property Binding Result « ( parent , " parent " ) ; » validator Adapter « . validate ( parent , errors ) ; » assert That « ( errors . » get Error Count « ( ) > 0 ) . » is True « ( ) ; }
@Test { Parent parent = new Parent ( ) ; parent . » set Name « ( " Parent with set " ) ; parent . » get Child Set « ( ) . » add All « ( » create Children « ( parent ) ) ; » Bean Property Binding Result « errors = new » Bean Property Binding Result « ( parent , " parent " ) ; » validator Adapter « . validate ( parent , errors ) ; » assert That « ( errors . » get Error Count « ( ) > 0 ) . » is True « ( ) ; }
@Test { » Local Validator Factory Bean « validator = new » Local Validator Factory Bean « ( ) ; validator . » after Properties Set « ( ) ; » Main Bean « » main Bean « = new » Main Bean « ( ) ; Errors errors = new » Bean Property Binding Result « ( » main Bean « , " » main Bean « " ) ; validator . validate ( » main Bean « , errors ) ; Object rejected = errors . » get Field Value « ( " inner . value " ) ; » assert That « ( rejected ) . » is Null « ( ) ; }
@Test { » Local Validator Factory Bean « validator = new » Local Validator Factory Bean « ( ) ; validator . » after Properties Set « ( ) ; » Main Bean With Optional « » main Bean « = new » Main Bean With Optional « ( ) ; Errors errors = new » Bean Property Binding Result « ( » main Bean « , " » main Bean « " ) ; validator . validate ( » main Bean « , errors ) ; Object rejected = errors . » get Field Value « ( " inner . value " ) ; » assert That « ( rejected ) . » is Null « ( ) ; }
@Test { Object first = service . cache ( this . » key Item « ) ; Object second = service . cache ( this . » key Item « ) ; » assert That « ( second ) . » is Same As « ( first ) ; }
@Test { Cache cache = » get Cache « ( » EXCEPTION _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; » assert That Null Pointer Exception « ( ) . » is Thrown By « ( ( ) -> service . » cache With Exception « ( this . » key Item « , false ) ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Object first = service . » cache Always Invoke « ( this . » key Item « ) ; Object second = service . » cache Always Invoke « ( this . » key Item « ) ; » assert That « ( second ) . » is Not Same As « ( first ) ; }
@Test { Object first = service . » cache With Partial Key « ( this . » key Item « , true ) ; Object second = service . » cache With Partial Key « ( this . » key Item « , false ) ; » assert That « ( second ) . » is Same As « ( first ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; service . » cache With Custom Cache Resolver « ( this . » key Item « ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; service . » cache With Custom Key Generator « ( this . » key Item « , " ignored " ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; service . put ( this . » key Item « , value ) ; Cache . » Value Wrapper « result = cache . get ( key ) ; » assert That « ( result ) . » is Not Null « ( ) ; » assert That « ( result . get ( ) ) . » is Equal To « ( value ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; » assert That Null Pointer Exception « ( ) . » is Thrown By « ( ( ) -> service . » put With Exception « ( this . » key Item « , value , false ) ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; service . » early Put « ( this . » key Item « , value ) ; Cache . » Value Wrapper « result = cache . get ( key ) ; » assert That « ( result ) . » is Not Null « ( ) ; » assert That « ( result . get ( ) ) . » is Equal To « ( value ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; cache . put ( key , value ) ; service . remove ( this . » key Item « ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; cache . put ( key , value ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> service . » remove With Exception « ( this . » key Item « , true ) ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; cache . put ( key , value ) ; » assert That Null Pointer Exception « ( ) . » is Thrown By « ( ( ) -> service . » remove With Exception « ( this . » key Item « , false ) ) ; Cache . » Value Wrapper « wrapper = cache . get ( key ) ; » assert That « ( wrapper ) . » is Not Null « ( ) ; » assert That « ( wrapper . get ( ) ) . » is Equal To « ( value ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; cache . put ( key , value ) ; service . » early Remove « ( this . » key Item « ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; cache . put ( key , value ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> service . » early Remove With Exception « ( this . » key Item « , true ) ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; Object value = new Object ( ) ; cache . put ( key , value ) ; » assert That Null Pointer Exception « ( ) . » is Thrown By « ( ( ) -> service . » early Remove With Exception « ( this . » key Item « , false ) ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; cache . put ( key , new Object ( ) ) ; service . » remove All « ( ) ; » assert That « ( » is Empty « ( cache ) ) . » is True « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; cache . put ( key , new Object ( ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> service . » remove All With Exception « ( true ) ) ; » assert That « ( » is Empty « ( cache ) ) . » is True « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; cache . put ( key , new Object ( ) ) ; » assert That Null Pointer Exception « ( ) . » is Thrown By « ( ( ) -> service . » remove All With Exception « ( false ) ) ; » assert That « ( cache . get ( key ) ) . » is Not Null « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; cache . put ( key , new Object ( ) ) ; service . » early Remove All « ( ) ; » assert That « ( » is Empty « ( cache ) ) . » is True « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; cache . put ( key , new Object ( ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> service . » early Remove All With Exception « ( true ) ) ; » assert That « ( » is Empty « ( cache ) ) . » is True « ( ) ; }
@Test { Cache cache = » get Cache « ( » DEFAULT _ CACHE « ) ; Object key = » create Key « ( this . » key Item « ) ; cache . put ( key , new Object ( ) ) ; » assert That Null Pointer Exception « ( ) . » is Thrown By « ( ( ) -> service . » early Remove All With Exception « ( false ) ) ; » assert That « ( » is Empty « ( cache ) ) . » is True « ( ) ; }
@Test { new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " . xml " , » get Class « ( ) ) ; }
@Test { this . » test Bean « . » set Name « ( " abc " ) ; » assert That « ( this . » test Bean « . » get Name « ( ) ) . as ( " Name changed in around advice " ) . » is Equal To « ( " ABC " ) ; }
@Test { this . » test Bean « . » set Age « ( 5 ) ; » assert That « ( this . » test Bean « . » get Age « ( ) ) . as ( " » get Args « is defensive " ) . » is Equal To « ( 5 ) ; }
@Test { this . » test Bean « . » set My Float « ( 1.0F ) ; » assert That « ( this . » test Bean « . » get My Float « ( ) > 1.9F ) . as ( " value changed in around advice " ) . » is True « ( ) ; » assert That « ( this . » first Test Aspect « . » get Last Before Float Value « ( ) > 1.9F ) . as ( " changed value visible to next advice in chain " ) . » is True « ( ) ; }
@Test { this . » to Be Advised « . foo ( " Hello " ) ; }
@Test { boolean condition = this . » serializable Bean « instanceof Advised ; » assert That « ( condition ) . as ( " bean with serializable type should be proxied " ) . » is True « ( ) ; }
@Test { boolean condition = this . » non Serializable Bean « instanceof Advised ; » assert That « ( condition ) . as ( " bean with non - serializable type should not be proxied " ) . » is False « ( ) ; }
@Test { boolean condition = this . bar instanceof Advised ; » assert That « ( condition ) . as ( " bean with args check should be proxied " ) . » is True « ( ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( counter . » this As Class Counter « ) . » is Equal To « ( 0 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( counter . » this As Interface Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( counter . » target As Class Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( counter . » target As Interface Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( counter . » this As Class And Target As Class Counter « ) . » is Equal To « ( 0 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( counter . » this As Interface And Target As Interface Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » test Annotated Class Bean « . » do It « ( ) ; » assert That « ( counter . » at Target Class Annotation Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » test Annotated Method Bean « . » do It « ( ) ; » assert That « ( counter . » at Annotation Method Annotation Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( » this As Class Counter « . » get Count « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( » this As Interface Counter « . » get Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( » target As Class Counter « . » get Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( » target As Interface Counter « . » get Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( » this As Class And Target As Class Counter « . » get Count « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » test Bean « . » do It « ( ) ; » assert That « ( » this As Interface And Target As Interface Counter « . » get Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean Proxy « . » set Age « ( 5 ) ; verify ( » mock Collaborator « ) . » one Int Arg « ( 5 ) ; }
@Test { » test Bean Proxy « . » get Age « ( ) ; verify ( » mock Collaborator « ) . » one Object Arg « ( this . » test Bean Proxy « ) ; }
@Test { » test Bean Proxy « . » get Doctor « ( ) ; verify ( » mock Collaborator « ) . » one Object Arg « ( this . » test Bean Target « ) ; }
@Test { » test Bean Proxy « . » set Age « ( 5 ) ; verify ( » mock Collaborator « ) . » one Int And One Object « ( 5 , this . » test Bean Proxy « ) ; }
@Test { » test Bean Proxy « . » get Age « ( ) ; verify ( » mock Collaborator « ) . » needs Join Point « ( " » get Age « " ) ; }
@Test { » test Bean Proxy « . » get Age « ( ) ; verify ( » mock Collaborator « ) . » needs Join Point Static Part « ( " » get Age « " ) ; }
@Test { » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> this . » test Bean « . exceptional ( new Throwable ( ) ) ) ; verify ( » mock Collaborator « ) . » no Args « ( ) ; }
@Test { Throwable t = new Throwable ( ) ; » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> this . » test Bean « . exceptional ( t ) ) ; verify ( » mock Collaborator « ) . » one Throwable « ( t ) ; }
@Test { Throwable t = new Throwable ( ) ; » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> this . » test Bean « . exceptional ( t ) ) ; verify ( » mock Collaborator « ) . » no Args « ( ) ; verify ( » mock Collaborator « ) . » one Throwable « ( t ) ; verify ( » mock Collaborator « ) . » no Args On Throwable Match « ( ) ; }
@Test { » Runtime Exception « ex = new » Runtime Exception « ( ) ; » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> this . » test Bean « . exceptional ( ex ) ) ; verify ( » mock Collaborator « ) . » one Runtime Exception « ( ex ) ; }
@Test { » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> this . » test Bean « . exceptional ( new Throwable ( ) ) ) ; verify ( » mock Collaborator « ) . » no Args On Throwable Match « ( ) ; }
@Test { » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> this . » test Bean « . exceptional ( new » Runtime Exception « ( ) ) ) ; verify ( » mock Collaborator « ) . » no Args On Runtime Exception Match « ( ) ; }
@Test { Object tb = ctx . » get Bean « ( " » test Bean « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( tb ) ) . » is True « ( ) ; Object » tb 2 « = ctx . » get Bean « ( " » test Bean 2 « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( » tb 2 « ) ) . » is True « ( ) ; }
@Test { » assert That « ( interceptor . » get Count « ( ) ) . as ( " Count should be 0 " ) . » is Equal To « ( 0 ) ; » test Bean « . » get Spouses « ( ) ; » assert That « ( interceptor . » get Count « ( ) ) . as ( " Count should be 1 " ) . » is Equal To « ( 1 ) ; » test Bean « . » get Spouse « ( ) ; » assert That « ( interceptor . » get Count « ( ) ) . as ( " Count should be 1 " ) . » is Equal To « ( 1 ) ; }
@Test { boolean condition = this . » test Bean 1 « instanceof Advised ; » assert That « ( condition ) . as ( " Matching bean must be advised ( proxied ) " ) . » is True « ( ) ; this . » test Bean 1 « . » set Age « ( 20 ) ; this . » test Bean 1 « . » set Name « ( " " ) ; » assert That « ( this . » counter Aspect « . » get Count « ( ) ) . as ( " Advice not executed : must have been " ) . » is Equal To « ( 2 ) ; }
@Test { boolean condition = this . » test Bean 2 « instanceof Advised ; » assert That « ( condition ) . as ( " Non - matching bean must * not * be advised ( proxied ) " ) . » is False « ( ) ; this . » test Bean 2 « . » set Age « ( 20 ) ; » assert That « ( this . » counter Aspect « . » get Count « ( ) ) . as ( " Advice must * not * have been executed " ) . » is Equal To « ( 0 ) ; }
@Test { boolean condition = this . » test Bean Containing Nested Bean « . » get Doctor « ( ) instanceof Advised ; » assert That « ( condition ) . as ( " Non - matching bean must * not * be advised ( proxied ) " ) . » is False « ( ) ; }
@Test { » test Bean Proxy « . » set Age « ( 5 ) ; verify ( » mock Collaborator « ) . » one Int And One Object « ( 5 , this . » test Bean Target « ) ; }
@Test { boolean condition = this . target instanceof Serializable ; » assert That « ( condition ) . as ( " target bean is serializable " ) . » is True « ( ) ; }
@Test { boolean condition = this . target instanceof » Bean Name Aware « ; » assert That « ( condition ) . as ( " target bean is bean name aware " ) . » is True « ( ) ; }
@Test { » Aspect Collaborator « collab = new » Aspect Collaborator « ( ) ; this . aspect . » set Collaborator « ( collab ) ; this . target . » do Something « ( ) ; » assert That « ( collab . » before Fired « ) . as ( " before advice fired " ) . » is True « ( ) ; }
@Test { » Aspect Collaborator « collab = new » Aspect Collaborator « ( ) ; this . aspect . » set Collaborator « ( collab ) ; this . target . » get X « ( ) ; » assert That « ( collab . » around Fired « ) . as ( " around advice fired " ) . » is True « ( ) ; }
@Test { » Aspect Collaborator « collab = new » Aspect Collaborator « ( ) ; this . aspect . » set Collaborator « ( collab ) ; this . target . » get X « ( ) ; » assert That « ( collab . » after Returning Fired « ) . as ( " after returning advice fired " ) . » is True « ( ) ; }
@Test { » test Bean Proxy « . » set Name « ( " adrian " ) ; » test Bean Proxy « . » get Name « ( ) ; verify ( » mock Collaborator « ) . » one String « ( " adrian " ) ; }
@Test { » test Bean Proxy « . » returns This « ( ) ; verify ( » mock Collaborator « ) . » one Object Arg « ( this . » test Bean Target « ) ; }
@Test { » test Bean Proxy « . » returns This « ( ) ; verify ( » mock Collaborator « ) . » one Test Bean Arg « ( this . » test Bean Target « ) ; }
@Test { this . » test Bean Target « . » set Spouse « ( new » Test Bean « ( ) ) ; » I Test Bean « [ ] spouses = this . » test Bean Target « . » get Spouses « ( ) ; » test Bean Proxy « . » get Spouses « ( ) ; verify ( » mock Collaborator « ) . » test Bean Array Arg « ( spouses ) ; }
@Test { » test Bean Proxy « . » set Spouse « ( this . » test Bean Proxy « ) ; » test Bean Proxy « . » get Spouse « ( ) ; » verify No Interactions « ( » mock Collaborator « ) ; }
@Test { » test Bean Proxy « . » returns This « ( ) ; verify ( » mock Collaborator « ) . » object Match No Args « ( ) ; }
@Test { » test Bean Proxy « . » set Age « ( 20 ) ; » test Bean Proxy « . » have Birthday « ( ) ; verify ( » mock Collaborator « ) . » one Int « ( 20 ) ; }
@Test { » Precedence Test Aspect « . Collaborator collaborator = new » Precedence Verifying Collaborator « ( ) ; this . » high Precedence Aspect « . » set Collaborator « ( collaborator ) ; this . » low Precedence Aspect « . » set Collaborator « ( collaborator ) ; this . » high Precedence Spring Advice « . » set Collaborator « ( collaborator ) ; this . » low Precedence Spring Advice « . » set Collaborator « ( collaborator ) ; this . » test Bean « . » get Age « ( ) ; }
@Test { » assert That « ( » Aop Utils « . » is Aop Proxy « ( » test Bean Proxy « ) ) . » is True « ( ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( » introduction Object « ) ) . as ( " Introduction should not be proxied " ) . » is False « ( ) ; boolean condition = » test Bean Proxy « instanceof Lockable ; » assert That « ( condition ) . as ( " Introduction must have been made " ) . » is True « ( ) ; }
@Test { Lockable lockable = ( Lockable ) » test Bean Proxy « ; » assert That « ( lockable . locked ( ) ) . » is False « ( ) ; » test Bean Proxy « . » get Age « ( ) ; » test Bean Proxy « . » set Name « ( " " ) ; lockable . lock ( ) ; » assert That Illegal State Exception « ( ) . as ( " should be locked " ) . » is Thrown By « ( ( ) -> » test Bean Proxy « . » set Name « ( " " ) ) ; }
@Test { boolean condition = » no Methods Bean « instanceof » I Counter « ; » assert That « ( condition ) . as ( " Introduction must have been made " ) . » is True « ( ) ; }
@Test { ( ( » I Counter « ) » no Methods Bean « ) . increment ( ) ; » assert That « ( counter . » get Count « ( ) ) . as ( " Delegate » ' s « counter should be updated " ) . » is Equal To « ( 1 ) ; }
@Test { boolean condition = » test Bean 1 « instanceof Advised ; » assert That « ( condition ) . as ( " Expected a proxy " ) . » is True « ( ) ; » test Bean 1 « . » set Age « ( 20 ) ; » test Bean 1 « . » set Name « ( " " ) ; » assert That « ( » counter Aspect « . count ) . » is Equal To « ( 2 ) ; }
@Test { boolean condition = » test Bean 3 « instanceof Advised ; » assert That « ( condition ) . as ( " Did » n ' t « expect a proxy " ) . » is False « ( ) ; » test Bean 3 « . » set Age « ( 20 ) ; » assert That « ( » counter Aspect « . count ) . » is Equal To « ( 0 ) ; }
@Test { » check Xml Aspect « ( » get Class « ( ) . » get Simple Name « ( ) + " - before . xml " ) ; }
@Test { » check Xml Aspect « ( » get Class « ( ) . » get Simple Name « ( ) + " - after . xml " ) ; }
@Test { » check At Aspect J Aspect « ( » get Class « ( ) . » get Simple Name « ( ) + " - » at Aspect J « - before . xml " ) ; }
@Test { » check At Aspect J Aspect « ( » get Class « ( ) . » get Simple Name « ( ) + " - » at Aspect J « - after . xml " ) ; }
@Test { » test Impl 1 « . » interface Method « ( ) ; » assert That « ( » test Aspect For Test Impl 1 « . count ) . as ( " Should have been advised by POJO advice for impl " ) . » is Equal To « ( 1 ) ; » assert That « ( » test Aspect For Abstract Test Impl « . count ) . as ( " Should have been advised by POJO advice for base type " ) . » is Equal To « ( 1 ) ; » assert That « ( » test Interceptor « . count ) . as ( " Should have been advised by advisor " ) . » is Equal To « ( 1 ) ; }
@Test { » test Impl 2 « . » interface Method « ( ) ; » assert That « ( » test Aspect For Test Impl 1 « . count ) . as ( " Should » n ' t « have been advised by POJO advice for impl " ) . » is Equal To « ( 0 ) ; » assert That « ( » test Aspect For Abstract Test Impl « . count ) . as ( " Should have been advised by POJO advice for base type " ) . » is Equal To « ( 1 ) ; » assert That « ( » test Interceptor « . count ) . as ( " Should » n ' t « have been advised by advisor " ) . » is Equal To « ( 0 ) ; }
@Test { » test Bean Proxy « . » get Age « ( ) ; verify ( » mock Collaborator « ) . » one Object Arg « ( this . » test Bean Target « ) ; }
@Test { » test Bean Proxy « . » get Age « ( ) ; verify ( » mock Collaborator « ) . » just Join Point « ( " » get Age « " ) ; }
@Test { » assert That « ( » test Bean « . » do This « ( ) ) . » is Equal To « ( " this value " ) ; » assert That « ( » test Bean « . » do That « ( ) ) . » is Equal To « ( " that value " ) ; }
@Test { » assert That « ( » test Bean « . » do The Other « ( ) ) . » is Equal To « ( " » do The Other « " ) ; }
@Test { » assert That « ( » test Bean « . » do This « ( ) ) . » is Equal To « ( " this value " ) ; }
@Test { » assert That « ( » test Bean « . » do This « ( ) ) . » is Equal To « ( " this value » do This « " ) ; » assert That « ( » test Bean « . » do That « ( ) ) . » is Equal To « ( " that value » do That « " ) ; » assert That « ( » test Bean « . » do Array « ( ) . length ) . » is Equal To « ( 2 ) ; }
@Test { ctx . » get Bean « ( " » array Factory Bean « " ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " aspects . xml " ) ; » I Test Bean « tb = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; tb . » set Age « ( 10 ) ; » assert That « ( tb . » get Age « ( ) ) . » is Equal To « ( 20 ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » aspects With Ordering « . xml " ) ; » I Test Bean « tb = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » assert That « ( tb . » get Age « ( ) ) . » is Equal To « ( 71 ) ; }
@Test { » Class Path Xml Application Context « ac = » new Context « ( " » aspects Plus Advisor « . xml " ) ; » I Test Bean « » should Be Weaved « = ( » I Test Bean « ) ac . » get Bean « ( " adrian " ) ; » do Test Aspects And Advisor Are Applied « ( ac , » should Be Weaved « ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » two Advice Aspect « . xml " ) ; » I Test Bean « » adrian 1 « = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » test Age Aspect « ( » adrian 1 « , 0 , 2 ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » two Advice Aspect Singleton « . xml " ) ; » I Test Bean « » adrian 1 « = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » test Age Aspect « ( » adrian 1 « , 0 , 1 ) ; » I Test Bean « » adrian 2 « = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » assert That « ( » adrian 2 « ) . » is Not Same As « ( » adrian 1 « ) ; » test Age Aspect « ( » adrian 2 « , 2 , 1 ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » two Advice Aspect Prototype « . xml " ) ; » I Test Bean « » adrian 1 « = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » test Age Aspect « ( » adrian 1 « , 0 , 1 ) ; » I Test Bean « » adrian 2 « = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » assert That « ( » adrian 2 « ) . » is Not Same As « ( » adrian 1 « ) ; » test Age Aspect « ( » adrian 2 « , 0 , 1 ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » uses Include « . xml " ) ; » I Test Bean « adrian = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( adrian ) ) . » is True « ( ) ; » assert That « ( adrian . » get Age « ( ) ) . » is Equal To « ( 68 ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » aspects With CGLIB « . xml " ) ; » Proxy Config « pc = ( » Proxy Config « ) bf . » get Bean « ( » Aop Config Utils « . » AUTO _ PROXY _ CREATOR _ BEAN _ NAME « ) ; » assert That « ( pc . » is Proxy Target Class « ( ) ) . as ( " should be proxying classes " ) . » is True « ( ) ; » assert That « ( pc . » is Expose Proxy « ( ) ) . as ( " should expose proxy " ) . » is True « ( ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » aspects With Abstract Bean « . xml " ) ; » I Test Bean « adrian = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( adrian ) ) . » is True « ( ) ; » assert That « ( adrian . » get Age « ( ) ) . » is Equal To « ( 68 ) ; }
@Test { » Class Path Xml Application Context « bf = » new Context « ( " » with Bean Name Auto Proxy Creator « . xml " ) ; » I Test Bean « tb = ( » I Test Bean « ) bf . » get Bean « ( " adrian " ) ; » assert That « ( tb . » get Age « ( ) ) . » is Equal To « ( 68 ) ; }
@Test { » test Repeated Around Advice Invocations « ( » ASPECTJ _ CONTEXT « , » get Count « ( ) , " » Aspect J « " ) ; }
@Test { » test Repeated Around Advice Invocations « ( » SPRING _ AOP _ CONTEXT « , » get Count « ( ) , " Spring AOP " ) ; }
@Test { » test Before Advice Without Join Point « ( » ASPECTJ _ CONTEXT « , » get Count « ( ) , " » Aspect J « " ) ; }
@Test { » test Before Advice Without Join Point « ( » SPRING _ AOP _ CONTEXT « , » get Count « ( ) , " Spring AOP " ) ; }
@Test { » test After Returning Advice Without Join Point « ( » ASPECTJ _ CONTEXT « , » get Count « ( ) , " » Aspect J « " ) ; }
@Test { » test After Returning Advice Without Join Point « ( » SPRING _ AOP _ CONTEXT « , » get Count « ( ) , " Spring AOP " ) ; }
@Test { » test Mix « ( » ASPECTJ _ CONTEXT « , » get Count « ( ) , " » Aspect J « " ) ; }
@Test { » test Mix « ( » SPRING _ AOP _ CONTEXT « , » get Count « ( ) , " Spring AOP " ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " . xml " , » get Class « ( ) ) ; service = ( Service ) ctx . » get Bean « ( " service " ) ; » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( this . service :: » serve Me « ) . » with Message Containing « ( " advice invoked " ) ; }
@Test { » test Bean « . » get Strings « ( ) ; » assert That « ( » counter Aspect « . » get Strings Invocations Count « ) . » is Equal To « ( 1 ) ; » assert That « ( » counter Aspect « . » get Integers Invocations Count « ) . » is Equal To « ( 0 ) ; » counter Aspect « . reset ( ) ; » test Bean « . » get Integers « ( ) ; » assert That « ( » counter Aspect « . » get Strings Invocations Count « ) . » is Equal To « ( 0 ) ; » assert That « ( » counter Aspect « . » get Integers Invocations Count « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » get Strings « ( ) ; » assert That « ( » counter Aspect « . » get Raws Invocations Count « ) . » is Equal To « ( 1 ) ; » counter Aspect « . reset ( ) ; » test Bean « . » get Integers « ( ) ; » assert That « ( » counter Aspect « . » get Raws Invocations Count « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » get Integers « ( ) ; » assert That « ( » counter Aspect « . » get Numbers Invocations Count « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » get Test Beans « ( ) ; » assert That « ( » counter Aspect « . » get Test Bean Invocations Count « ) . » is Equal To « ( 1 ) ; » counter Aspect « . reset ( ) ; » test Bean « . » get Employees « ( ) ; » assert That « ( » counter Aspect « . » get Test Bean Invocations Count « ) . » is Equal To « ( 0 ) ; }
@Test { ( ( » Derived String Parameterized Class « ) » test Bean « ) . » generic Derived Interface Method « ( " " ) ; » assert That « ( » counter Aspect « . count ) . » is Equal To « ( 1 ) ; }
@Test { ( ( » Derived String Parameterized Class « ) » test Bean « ) . » generic Base Interface Method « ( " " ) ; » assert That « ( » counter Aspect « . count ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . save ( " " ) ; » assert That « ( » counter Aspect « . » generic Interface Generic Arg Execution Count « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » save All « ( null ) ; » assert That « ( » counter Aspect « . » generic Interface Generic Collection Arg Execution Count « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » save All « ( null ) ; » assert That « ( » counter Aspect « . » generic Interface Subtype Generic Collection Arg Execution Count « ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » generic Derived Interface Method « ( " " ) ; » assert That « ( » counter Aspect « . count ) . » is Equal To « ( 1 ) ; }
@Test { » test Bean « . » generic Base Interface Method « ( " " ) ; » assert That « ( » counter Aspect « . count ) . » is Equal To « ( 1 ) ; }
@Test { new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - ok . xml " , » get Class « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - error . xml " , » get Class « ( ) ) ) . matches ( ex -> ex . contains ( » SAX Parse Exception « . class ) ) ; }
@Test { » I Test Bean « bean = » get Test Bean « ( ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( bean ) ) . as ( " Should be a CGLIB proxy " ) . » is True « ( ) ; » assert That « ( ( ( Advised ) bean ) . » is Expose Proxy « ( ) ) . as ( " Should expose proxy " ) . » is True « ( ) ; }
@Test { » I Test Bean « bean = » get Test Bean « ( ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . as ( " Bean is not a proxy " ) . » is True « ( ) ; Advised advised = ( Advised ) bean ; Advisor [ ] advisors = advised . » get Advisors « ( ) ; » assert That « ( advisors . length > 0 ) . as ( " Advisors should not be empty " ) . » is True « ( ) ; }
@Test { new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - context . xml " , » get Class « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - error . xml " , » get Class « ( ) ) ) . matches ( ex -> ex . contains ( » Illegal Argument Exception « . class ) ) ; }
@Test { » assert That « ( factory . » is Singleton « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( factory . » get Object Type « ( ) ) . » is Equal To « ( Method . class ) ; }
@Test { factory . » set Method Name « ( " » to String « ( ) " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Bean Factory « ( » bean Factory « ) ) ; }
@Test { factory . » set Target Bean Name « ( " " ) ; factory . » set Method Name « ( " » to String « ( ) " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Bean Factory « ( » bean Factory « ) ) ; }
@Test { factory . » set Target Bean Name « ( » BEAN _ NAME « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Bean Factory « ( » bean Factory « ) ) ; }
@Test { factory . » set Target Bean Name « ( » BEAN _ NAME « ) ; factory . » set Method Name « ( " " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Bean Factory « ( » bean Factory « ) ) ; }
@Test { factory . » set Target Bean Name « ( » BEAN _ NAME « ) ; factory . » set Method Name « ( " » to String « ( ) " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Bean Factory « ( » bean Factory « ) ) ; verify ( » bean Factory « ) . » get Type « ( » BEAN _ NAME « ) ; }
@Test { given ( » bean Factory « . » get Type « ( » BEAN _ NAME « ) ) . » will Return « ( ( Class ) String . class ) ; factory . » set Target Bean Name « ( » BEAN _ NAME « ) ; factory . » set Method Name « ( " » load Of Old « ( ) " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Bean Factory « ( » bean Factory « ) ) ; }
@Test { » assert That Exception Of Type « ( » Aop Config Exception « . class ) . » is Thrown By « ( ( ) -> { » Advised Support « pc = new » Advised Support « ( » I Test Bean « . class ) ; » Aop Proxy « aop = » create Aop Proxy « ( pc ) ; aop . » get Proxy « ( ) ; } ) ; }
@Test { int » how Many « = 10000 ; » Stop Watch « sw = new » Stop Watch « ( ) ; sw . start ( " Create " + » how Many « + " proxies " ) ; » test Many Proxies « ( » how Many « ) ; sw . stop ( ) ; » assert That « ( sw . » get Total Time Millis « ( ) < 5000 ) . as ( " Proxy creation was too slow " ) . » is True « ( ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; » assert That « ( » Serialization Test Utils « . » is Serializable « ( tb ) ) . » is False « ( ) ; » Proxy Factory « pf = new » Proxy Factory « ( tb ) ; pf . » add Advice « ( new » Nop Interceptor « ( ) ) ; » I Test Bean « proxy = ( » I Test Bean « ) » create Aop Proxy « ( pf ) . » get Proxy « ( ) ; » assert That « ( » Serialization Test Utils « . » is Serializable « ( proxy ) ) . » is False « ( ) ; }
@Test { » Needs To See Proxy « et = new » Needs To See Proxy « ( ) ; » Proxy Factory « » pf 1 « = new » Proxy Factory « ( et ) ; » assert That « ( » pf 1 « . » is Expose Proxy « ( ) ) . » is False « ( ) ; » I Needs To See Proxy « proxied = ( » I Needs To See Proxy « ) » create Proxy « ( » pf 1 « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> proxied . » increment Via Proxy « ( ) ) ; }
@Test { » test Context « ( true ) ; }
@Test { » test Context « ( false ) ; }
@Test { » Test Bean « raw = new » Own Spouse « ( ) ; » Proxy Creator Support « pc = new » Proxy Creator Support « ( ) ; pc . » set Interfaces « ( » I Test Bean « . class ) ; pc . » set Target « ( raw ) ; » I Test Bean « tb = ( » I Test Bean « ) » create Proxy « ( pc ) ; » assert That « ( tb . » get Spouse « ( ) ) . as ( " this return is wrapped in proxy " ) . » is Same As « ( tb ) ; }
@Test { » Needs To See Proxy « target = new » Needs To See Proxy « ( ) ; » Advised Support « pc = new » Advised Support « ( » I Needs To See Proxy « . class ) ; pc . » set Target « ( target ) ; pc . » set Expose Proxy « ( true ) ; » Aop Proxy « aop = » create Aop Proxy « ( pc ) ; » I Needs To See Proxy « proxied = ( » I Needs To See Proxy « ) aop . » get Proxy « ( ) ; proxied . » increment Via Proxy « ( ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; » Proxy Factory « pc = new » Proxy Factory « ( ) ; pc . » add Interface « ( » I Test Bean « . class ) ; pc . » add Advisor « ( new » Lock Mixin Advisor « ( ) ) ; pc . » set Target « ( tb ) ; » test Test Bean Introduction « ( pc ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; » Proxy Factory « pc = new » Proxy Factory « ( ) ; pc . » add Interface « ( » I Test Bean « . class ) ; pc . » add Advice « ( new » Lock Mixin « ( ) ) ; pc . » set Target « ( tb ) ; » test Test Bean Introduction « ( pc ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; target . » set Age « ( 21 ) ; » Proxy Factory « pc = new » Proxy Factory « ( target ) ; pc . » add Advisor « ( new » Default Introduction Advisor « ( new » Dummy Introduction Advice Impl « ( ) , Comparable . class ) ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> { » I Test Bean « proxied = ( » I Test Bean « ) » create Proxy « ( pc ) ; proxied . » get Name « ( ) ; } ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; target . » set Age « ( 21 ) ; » Proxy Factory « pc = new » Proxy Factory « ( target ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> pc . » add Advisor « ( 0 , new » Default Introduction Advisor « ( new » Timestamp Introduction Interceptor « ( ) , » I Test Bean « . class ) ) ) ; » I Test Bean « proxied = ( » I Test Bean « ) » create Proxy « ( pc ) ; » assert That « ( proxied . » get Age « ( ) ) . » is Equal To « ( target . » get Age « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Jdk Dynamic Aop Proxy « ( null ) ) ; }
@Test { » Test Bean « raw = new » Test Bean « ( ) ; raw . » set Age « ( 32 ) ; » Advised Support « pc = new » Advised Support « ( » I Test Bean « . class ) ; pc . » set Target « ( raw ) ; » Jdk Dynamic Aop Proxy « aop = new » Jdk Dynamic Aop Proxy « ( pc ) ; Object proxy = aop . » get Proxy « ( ) ; boolean condition = proxy instanceof » I Test Bean « ; » assert That « ( condition ) . » is True « ( ) ; boolean » condition 1 « = proxy instanceof » Test Bean « ; » assert That « ( » condition 1 « ) . » is False « ( ) ; }
@Test { final int age = 25 ; » Method Interceptor « mi = ( invocation -> age ) ; » Advised Support « pc = new » Advised Support « ( » I Test Bean « . class ) ; pc . » add Advice « ( mi ) ; » Aop Proxy « aop = » create Aop Proxy « ( pc ) ; » I Test Bean « tb = ( » I Test Bean « ) aop . » get Proxy « ( ) ; » assert That « ( tb . » get Age « ( ) ) . as ( " correct return value " ) . » is Equal To « ( age ) ; }
@Test { » Foo Bar « bean = new » Foo Bar « ( ) ; » Proxy Creator Support « as = new » Proxy Creator Support « ( ) ; as . » set Interfaces « ( Foo . class ) ; as . » set Target « ( bean ) ; Foo proxy = ( Foo ) » create Proxy « ( as ) ; » assert That « ( proxy . » get Bar This « ( ) ) . as ( " Target should be returned when return types are incompatible " ) . » is Same As « ( bean ) ; » assert That « ( proxy . » get Foo This « ( ) ) . as ( " Proxy should be returned when return types are compatible " ) . » is Same As « ( proxy ) ; }
@Test { » Advised Support « as = new » Advised Support « ( Named . class ) ; as . » set Target « ( new Person ( ) ) ; » Jdk Dynamic Aop Proxy « » aop Proxy « = new » Jdk Dynamic Aop Proxy « ( as ) ; Named proxy = ( Named ) » aop Proxy « . » get Proxy « ( ) ; Named named = new Person ( ) ; » assert That « ( proxy ) . » is Equal To « ( named ) ; » assert That « ( named . » hash Code « ( ) ) . » is Equal To « ( proxy . » hash Code « ( ) ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( new » Vararg Test Bean « ( ) ) ; » Vararg Test Interface « proxy = ( » Vararg Test Interface « ) » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . » do With Varargs « ( » My Enum « . A , » My Other Enum « . C ) ) . » is True « ( ) ; }
@Test { » I Test Bean « » test 1 « = ( » I Test Bean « ) factory . » get Bean « ( " » test 1 « " ) ; » assert That « ( Proxy . » is Proxy Class « ( » test 1 « . » get Class « ( ) ) ) . as ( " » test 1 « is a dynamic proxy " ) . » is True « ( ) ; }
@Test { » I Test Bean « » test 1 « = ( » I Test Bean « ) factory . » get Bean « ( " » test 2 « " ) ; » assert That « ( Proxy . » is Proxy Class « ( » test 1 « . » get Class « ( ) ) ) . as ( " » test 2 « is a dynamic proxy " ) . » is True « ( ) ; }
@Test { » I Test Bean « » test 1 « = ( » I Test Bean « ) factory . » get Bean « ( " » test 3 « " ) ; » assert That « ( Proxy . » is Proxy Class « ( » test 1 « . » get Class « ( ) ) ) . as ( " » test 3 « is a dynamic proxy " ) . » is True « ( ) ; }
@Test { » I Test Bean « » test 1 « = ( » I Test Bean « ) factory . » get Bean « ( " » test 4 « " ) ; » assert That « ( Proxy . » is Proxy Class « ( » test 1 « . » get Class « ( ) ) ) . as ( " » test 4 « is a dynamic proxy " ) . » is True « ( ) ; }
@Test { » test Double Target Source Is Rejected « ( " » double Target « " ) ; » test Double Target Source Is Rejected « ( " » arbitrary Target « " ) ; }
@Test { Object prototype = » test Prototype Instances Are Independent « ( " » cglib Prototype « " ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( prototype ) ) . as ( " It » ' s « a cglib proxy " ) . » is True « ( ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( prototype ) ) . as ( " It » ' s « not a dynamic proxy " ) . » is False « ( ) ; }
@Test { String name = " Hieronymous " ; » Test Bean « target = ( » Test Bean « ) factory . » get Bean « ( " test " ) ; target . » set Name « ( name ) ; » I Test Bean « » auto Invoker « = ( » I Test Bean « ) factory . » get Bean « ( " » auto Invoker « " ) ; » assert That « ( » auto Invoker « . » get Name « ( ) . equals ( name ) ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( » INVALID _ CONTEXT « , CLASS ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . as ( " Interceptor names cannot be empty " ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » empty Interceptor Names « " ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( » INVALID _ CONTEXT « , CLASS ) ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . as ( " Should require target name " ) . » is Thrown By « ( ( ) -> bf . » get Bean « ( " » globals Without Target « " ) ) . » with Cause Instance Of « ( » Aop Config Exception « . class ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( » SERIALIZATION _ CONTEXT « , CLASS ) ) ; Person p = ( Person ) bf . » get Bean « ( " » interceptor Not Serializable Singleton « " ) ; » assert That « ( » Serialization Test Utils « . » is Serializable « ( p ) ) . as ( " Not serializable because an interceptor is » n ' t « serializable " ) . » is False « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( » AUTOWIRING _ CONTEXT « , CLASS ) ) ; bf . » get Bean « ( " » test Bean « " ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( » FROZEN _ CONTEXT « , CLASS ) ) ; Advised advised = ( Advised ) bf . » get Bean « ( " frozen " ) ; » assert That « ( advised . » is Frozen « ( ) ) . as ( " The proxy should be frozen " ) . » is True « ( ) ; }
@Test { » Proxy Factory Bean « fb = new » Proxy Factory Bean « ( ) ; fb . » set Target « ( new » Test Bean « ( ) ) ; fb . » add Advice « ( new » Debug Interceptor « ( ) ) ; fb . » set Bean Factory « ( new » Default Listable Bean Factory « ( ) ) ; » I Test Bean « proxy = ( » I Test Bean « ) fb . » get Object « ( ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( proxy ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Cglib Aop Proxy « ( null ) ) ; }
@Test { » Advised Support « pc = new » Advised Support « ( » I Test Bean « . class ) ; pc . » add Advice « ( new » Nop Interceptor « ( ) ) ; » Aop Proxy « aop = » create Aop Proxy « ( pc ) ; » assert That Exception Of Type « ( » Aop Config Exception « . class ) . » is Thrown By « ( aop :: » get Proxy « ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( » DEPENDENCY _ CHECK _ CONTEXT « , » get Class « ( ) ) ; ctx . » get Bean « ( " » test Bean « " ) ; }
@Test { » Counting Before Advice « advice = new » Counting Before Advice « ( ) ; » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( new » My Bean « ( ) ) ; » proxy Factory « . » add Advice « ( advice ) ; » proxy Factory « . » set Proxy Target Class « ( true ) ; » My Bean « proxy = ( » My Bean « ) » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . add ( 1 , 3 ) ) . » is Equal To « ( 4 ) ; » assert That « ( advice . » get Calls « ( " add " ) ) . » is Equal To « ( 1 ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( new » My Bean « ( ) ) ; » My Bean « proxy = ( » My Bean « ) » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . add ( 1 , 3 ) ) . » is Equal To « ( 4 ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( new » My Bean « ( ) ) ; » My Bean « proxy = ( » My Bean « ) » proxy Factory « . » get Proxy « ( ) ; » assert That « ( proxy . » do With Varargs « ( » My Enum « . A , » My Other Enum « . C ) ) . » is True « ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - without - bpp . xml " , » get Class « ( ) ) ; » I Test Bean « tb = ( » I Test Bean « ) ctx . » get Bean « ( " » test Bean « " ) ; » assert That Exception Of Type « ( » Unknown Advice Type Exception « . class ) . » is Thrown By « ( tb :: » get Name « ) ; » assert That « ( » get Advice Impl « ( tb ) . » get Invocation Counter « ( ) ) . » is Zero « ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - with - bpp . xml " , » get Class « ( ) ) ; » I Test Bean « tb = ( » I Test Bean « ) ctx . » get Bean « ( " » test Bean « " ) ; tb . » get Name « ( ) ; » get Advice Impl « ( tb ) . » get Invocation Counter « ( ) ; }
@Test { » Bean Factory « bf = new » Class Path Xml Application Context « ( » CUSTOM _ TARGETSOURCE _ CONTEXT « , CLASS ) ; » I Test Bean « test = ( » I Test Bean « ) bf . » get Bean « ( " test " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( test ) ) . » is False « ( ) ; » assert That « ( test . » get Name « ( ) ) . » is Equal To « ( " Rod " ) ; » assert That « ( test . » get Spouse « ( ) . » get Name « ( ) ) . » is Equal To « ( " Kerry " ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » get Class « ( ) . » get Simple Name « ( ) + " - context . xml " , » get Class « ( ) ) ; » Test Bean « bean = ( » Test Bean « ) ctx . » get Bean « ( " bean " ) ; bean . » set Name « ( " foo " ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( " foo " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> bean . » set Name « ( null ) ) ; }
@Test { » Test Bean « tb = ( » Test Bean « ) » bean Factory « . » get Bean « ( " noproxy " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( tb ) ) . » is False « ( ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( " noproxy " ) ; }
@Test { » I Test Bean « tb = ( » I Test Bean « ) » bean Factory « . » get Bean « ( " » only Jdk « " ) ; » jdk Assertions « ( tb , 1 ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( " » only Jdk « " ) ; }
@Test { » I Test Bean « tb = ( » I Test Bean « ) » bean Factory « . » get Bean « ( " » double Jdk « " ) ; » jdk Assertions « ( tb , 2 ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( " » double Jdk « " ) ; }
@Test { » I Test Bean « tb = ( » I Test Bean « ) » bean Factory « . » get Bean « ( " » jdk 1 « " ) ; » jdk Assertions « ( tb , 1 ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( " » jdk 1 « " ) ; }
@Test { » Test Bean « tb = ( » Test Bean « ) » bean Factory « . » get Bean « ( " » cglib 1 « " ) ; » cglib Assertions « ( tb ) ; » assert That « ( tb . » get Name « ( ) ) . » is Equal To « ( " » cglib 1 « " ) ; }
@Test { » I Test Bean « » test Bean « = ( » I Test Bean « ) » bean Factory « . » get Bean « ( " » frozen Bean « " ) ; » assert That « ( ( ( Advised ) » test Bean « ) . » is Frozen « ( ) ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( » MAP _ CONTEXT « ) ; Object » base Map « = bf . » get Bean « ( " » singleton Map « " ) ; boolean condition = » base Map « instanceof Map ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( » MAP _ CONTEXT « ) ; Object » simple Map « = bf . » get Bean « ( " » simple Map « " ) ; boolean » condition 1 « = » simple Map « instanceof Map ; » assert That « ( » condition 1 « ) . » is True « ( ) ; boolean condition = » simple Map « instanceof » Hash Map « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » test Functionality « ( " pooled " ) ; }
@Test { » test Functionality « ( " » pooled No Interceptors « " ) ; }
@Test { » Commons Pool 2 Target Source « cpts = ( » Commons Pool 2 Target Source « ) » bean Factory « . » get Bean « ( " » person Pool Target Source « " ) ; » Singleton Target Source « serialized = ( » Singleton Target Source « ) » Serialization Test Utils « . » serialize And Deserialize « ( cpts ) ; boolean condition = serialized . » get Target « ( ) instanceof Person ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Commons Pool 2 Target Source « » target Source « = new » Commons Pool 2 Target Source « ( ) ; » target Source « . » set Block When Exhausted « ( true ) ; » assert That « ( » target Source « . » is Block When Exhausted « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » User Service Impl « . class , Foo . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » User Service Impl « . class ) . object ) . » is Not Null « ( ) ; }
@Test { » Overload Lookup « olup = ( » Overload Lookup « ) » application Context « . » get Bean « ( " » auto Proxied Overload « " ) ; » I Test Bean « jenny = olup . » new Test Bean « ( ) ; » assert That « ( jenny . » get Name « ( ) ) . » is Equal To « ( " Jenny " ) ; » assert That « ( olup . » test Method « ( ) ) . » is Equal To « ( " foo " ) ; » assert Interceptor Count « ( 2 ) ; }
@Test { » Overload Lookup « olup = ( » Overload Lookup « ) » application Context « . » get Bean « ( " » regularly Proxied Overload « " ) ; » I Test Bean « jenny = olup . » new Test Bean « ( ) ; » assert That « ( jenny . » get Name « ( ) ) . » is Equal To « ( " Jenny " ) ; » assert That « ( olup . » test Method « ( ) ) . » is Equal To « ( " foo " ) ; » assert Interceptor Count « ( 2 ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; » Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( context ) ; reader . » load Bean Definitions « ( » CONFIG _ LOCATION « ) ; context . » register Singleton « ( " » test Bean « " , » Non Qualified Test Bean « . class ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( context :: refresh ) . » with Message Containing « ( " found 6 " ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; » Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( context ) ; reader . » load Bean Definitions « ( » CONFIG _ LOCATION « ) ; context . » register Singleton « ( " » test Bean « " , » Qualified By Attributes Test Bean « . class ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( context :: refresh ) . » with Message Containing « ( " found 6 " ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; » Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( context ) ; reader . » load Bean Definitions « ( » CONFIG _ LOCATION « ) ; }
@Test { » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( factory ) . » load Bean Definitions « ( » COLLECTIONS _ XSD _ CONTEXT « ) ; factory . » pre Instantiate Singletons « ( ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; xbf . » set Allow Circular References « ( false ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » set Validation Mode « ( » Xml Bean Definition Reader « . » VALIDATION _ NONE « ) ; reader . » load Bean Definitions « ( » REFTYPES _ CONTEXT « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " jenny " ) ) . matches ( ex -> ex . contains ( » Bean Currently In Creation Exception « . class ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » FACTORY _ CIRCLE _ CONTEXT « ) ; » Test Bean « tb = ( » Test Bean « ) xbf . » get Bean « ( " » singleton Factory « " ) ; » Dummy Factory « db = ( » Dummy Factory « ) xbf . » get Bean « ( " & » singleton Factory « " ) ; » assert That « ( tb == db . » get Other Test Bean « ( ) ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » FACTORY _ CIRCLE _ CONTEXT « ) ; » assert That « ( xbf . » get Bean « ( " && » singleton Factory « " ) ) . » is Instance Of « ( » Dummy Factory « . class ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » COMPLEX _ FACTORY _ CIRCLE _ CONTEXT « ) ; xbf . » get Bean « ( " » proxy 1 « " ) ; » assert That « ( xbf . » get Singleton Count « ( ) ) . » is Equal To « ( 4 ) ; xbf . » get Bean « ( " » proxy 2 « " ) ; » assert That « ( xbf . » get Singleton Count « ( ) ) . » is Equal To « ( 5 ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » NO _ SUCH _ FACTORY _ METHOD _ CONTEXT « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » default Test Bean « " ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » INITIALIZERS _ CONTEXT « ) ; » Double Initializer « in = ( » Double Initializer « ) xbf . » get Bean « ( " init - » method 1 « " ) ; » assert That « ( in . » get Num « ( ) ) . » is Equal To « ( 14 ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » INITIALIZERS _ CONTEXT « ) ; » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " init - » method 3 « " ) ) . » with Message Containing « ( " initializers . xml " ) . » with Message Containing « ( " init - » method 3 « " ) . » with Message Containing « ( " init " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » MISSING _ CONTEXT « ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » INVALID _ CONTEXT « ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » AUTOWIRE _ CONTEXT « ) ; » Test Bean « spouse = new » Test Bean « ( " kerry " , 0 ) ; xbf . » register Singleton « ( " spouse " , spouse ) ; » do Test Autowire « ( xbf ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; try { xbf . » get Bean « ( " » rod 2 Accessor « " ) ; } catch ( » Bean Creation Exception « ex ) { » assert That « ( ex . » to String « ( ) . contains ( " touchy " ) ) . » is True « ( ) ; ex . » print Stack Trace « ( ) ; » assert That « ( ( Object ) ex . » get Related Causes « ( ) ) . » is Null « ( ) ; } }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; File file = ( File ) xbf . » get Bean « ( " file " ) ; » assert That « ( file . » get Path « ( ) ) . » is Equal To « ( ( File . separator + " test " ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » rod 7 « " , » Constructor Dependencies Bean « . class ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » rod 8 « " , » Constructor Dependencies Bean « . class ) ) ; }
@Test { » do Test Dependencies « ( » DEP _ DEPENDSON _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ DEPENDSON _ INNER _ CONTEXT « , 4 ) ; }
@Test { » do Test Dependencies « ( » DEP _ CARG _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ CARG _ AUTOWIRE _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ CARG _ INNER _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ PROP « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ PROP _ MIDDLE _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ PROP _ ABN _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ PROP _ ABT _ CONTEXT « , 1 ) ; }
@Test { » do Test Dependencies « ( » DEP _ PROP _ INNER _ CONTEXT « , 1 ) ; }
@Test { » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( factory ) . » load Bean Definitions « ( » CLASS _ NOT _ FOUND _ CONTEXT « ) ; » assert That Exception Of Type « ( » Cannot Load Bean Class Exception « . class ) . » is Thrown By « ( ( ) -> factory . » get Bean « ( " » class Not Found « " ) ) . » with Cause Instance Of « ( » Class Not Found Exception « . class ) . satisfies ( ex -> » assert That « ( ex . » get Resource Description « ( ) ) . contains ( " » class Not Found « . xml " ) ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( bf ) ; reader . » set Bean Class Loader « ( null ) ; reader . » load Bean Definitions « ( » CLASS _ NOT _ FOUND _ CONTEXT « ) ; » assert That « ( bf . » get Bean Definition « ( " » class Not Found « " ) . » get Bean Class Name « ( ) ) . » is Equal To « ( " » What A Lot Of Rubbish « " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » RESOURCE _ CONTEXT « ) ; xbf . » get Bean « ( " » resource 1 « " , » Resource Test Bean « . class ) ; xbf . » get Bean « ( " » resource 2 « " , » Resource Test Bean « . class ) ; }
@Test { URL url = » get Class « ( ) . » get Resource « ( » RESOURCE _ CONTEXT « . » get Path « ( ) ) ; » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( new » Url Resource « ( url ) ) ; xbf . » get Bean « ( " » resource 1 « " , » Resource Test Bean « . class ) ; xbf . » get Bean « ( " » resource 2 « " , » Resource Test Bean « . class ) ; }
@Test { String file = » get Class « ( ) . » get Resource « ( » RESOURCE _ CONTEXT « . » get Path « ( ) ) . » to URI « ( ) . » get Path « ( ) ; » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( new » File System Resource « ( file ) ) ; xbf . » get Bean « ( " » resource 1 « " , » Resource Test Bean « . class ) ; xbf . » get Bean « ( " » resource 2 « " , » Resource Test Bean « . class ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » RECURSIVE _ IMPORT _ CONTEXT « ) ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( xbf ) ; reader . » load Bean Definitions « ( » INVALID _ NO _ SUCH _ METHOD _ CONTEXT « ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> xbf . » get Bean « ( " » constructor Overrides « " ) ) . » with Message Containing « ( " » bogus Method « " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Double Boolean Constructor Bean « bean = ( » Double Boolean Constructor Bean « ) xbf . » get Bean « ( " » bean With Double Boolean « " ) ; » assert That « ( bean . » boolean 1 « ) . » is Equal To « ( Boolean . TRUE ) ; » assert That « ( bean . » boolean 2 « ) . » is Equal To « ( Boolean . FALSE ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Double Boolean Constructor Bean « bean = ( » Double Boolean Constructor Bean « ) xbf . » get Bean « ( " » bean With Double Boolean And Index « " ) ; » assert That « ( bean . » boolean 1 « ) . » is Equal To « ( Boolean . FALSE ) ; » assert That « ( bean . » boolean 2 « ) . » is Equal To « ( Boolean . TRUE ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Lenient Dependency Test Bean « bean = ( » Lenient Dependency Test Bean « ) xbf . » get Bean « ( " » lenient Dependency Test Bean « " ) ; » assert That « ( bean . tb instanceof » Derived Test Bean « ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Lenient Dependency Test Bean « bean = ( » Lenient Dependency Test Bean « ) xbf . » get Bean « ( " » lenient Dependency Test Bean Factory Method « " ) ; » assert That « ( bean . tb instanceof » Derived Test Bean « ) . » is True « ( ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Abstract Bean Definition « bd = ( » Abstract Bean Definition « ) xbf . » get Bean Definition « ( " string " ) ; bd . » set Lenient Constructor Resolution « ( false ) ; String str = ( String ) xbf . » get Bean « ( " string " ) ; » assert That « ( str ) . » is Equal To « ( " test " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Abstract Bean Definition « bd = ( » Abstract Bean Definition « ) xbf . » get Bean Definition « ( " » string Constructor « " ) ; bd . » set Lenient Constructor Resolution « ( false ) ; » String Constructor Test Bean « tb = ( » String Constructor Test Bean « ) xbf . » get Bean « ( " » string Constructor « " ) ; » assert That « ( tb . name ) . » is Equal To « ( " test " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Constructor Array Test Bean « bean = ( » Constructor Array Test Bean « ) xbf . » get Bean « ( " » constructor Array No Type « " ) ; » assert That « ( bean . array instanceof String [ ] ) . » is True « ( ) ; » assert That « ( ( ( String [ ] ) bean . array ) . length ) . » is Equal To « ( 0 ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » CONSTRUCTOR _ ARG _ CONTEXT « ) ; » Atomic Integer « bean = ( » Atomic Integer « ) xbf . » get Bean « ( " » constructor Unresolvable Name « " ) ; » assert That « ( bean . get ( ) ) . » is Equal To « ( 1 ) ; bean = ( » Atomic Integer « ) xbf . » get Bean « ( " » constructor Unresolvable Name With Index « " ) ; » assert That « ( bean . get ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » TEST _ WITH _ DUP _ NAMES _ CONTEXT « ) ) . » with Message Containing « ( " Bean name 'foo' " ) ; }
@Test { » Default Listable Bean Factory « xbf = new » Default Listable Bean Factory « ( ) ; » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> new » Xml Bean Definition Reader « ( xbf ) . » load Bean Definitions « ( » TEST _ WITH _ DUP _ NAME _ IN _ ALIAS _ CONTEXT « ) ) . » with Message Containing « ( " Bean name 'foo' " ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » test Bean « " ) ; » assert Test Bean « ( bean ) ; }
@Test { » Test Bean « bean = ( » Test Bean « ) this . » bean Factory « . » get Bean « ( " » customised Test Bean « " ) ; » assert Test Bean « ( bean ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Bean Definition « ( " » decorate With Attribute « " ) ; » assert That « ( » bean Definition « . » get Attribute « ( " » object Name « " ) ) . » is Equal To « ( " foo " ) ; }
@Test { List < ? > things = ( List < ? > ) this . » bean Factory « . » get Bean « ( " list . of . things " ) ; » assert That « ( things ) . » is Not Null « ( ) ; » assert That « ( things . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { Set < ? > things = ( Set < ? > ) this . » bean Factory « . » get Bean « ( " set . of . things " ) ; » assert That « ( things ) . » is Not Null « ( ) ; » assert That « ( things . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { Map < ? , ? > things = ( Map < ? , ? > ) this . » bean Factory « . » get Bean « ( " map . of . things " ) ; » assert That « ( things ) . » is Not Null « ( ) ; » assert That « ( things . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Spr 11124 Config « . class ) ; » Spr 11124 Service « bean = context . » get Bean « ( » Spr 11124 Service « . class ) ; bean . single ( 2 ) ; bean . single ( 2 ) ; bean . multiple ( 2 ) ; bean . multiple ( 2 ) ; context . close ( ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Spr 11249 Config « . class ) ; » Spr 11249 Service « bean = context . » get Bean « ( » Spr 11249 Service « . class ) ; Object result = bean . » do Something « ( " op " , 2 , 3 ) ; » assert That « ( bean . » do Something « ( " op " , 2 , 3 ) ) . » is Same As « ( result ) ; context . close ( ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Spr 13081 Config « . class ) ; » Spr 13081 Service « bean = context . » get Bean « ( » Spr 13081 Service « . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> bean . » get Simple « ( null ) ) . » with Message Containing « ( » My Cache Resolver « . class . » get Name « ( ) ) ; }
@Test { Cache cache = this . manager . » get Cache « ( " bucket " ) ; » assert That « ( cache ) . » is Not Null « ( ) ; » assert That « ( this . manager . » get Cache « ( " bucket " ) ) . » is Same As « ( cache ) ; }
@Test { String name = » create Random Key « ( ) ; Cache cache = this . manager . » get Cache « ( name ) ; » assert That « ( cache . » get Name « ( ) ) . » is Equal To « ( name ) ; Object key = new Object ( ) ; cache . put ( key , new Object ( ) ) ; » assert That « ( cache . get ( key ) ) . » is Null « ( ) ; » assert That « ( cache . get ( key , Object . class ) ) . » is Null « ( ) ; » assert That « ( cache . » get Native Cache « ( ) ) . » is Same As « ( cache ) ; }
@Test { String name = " bucket " ; » assert That « ( this . manager . » get Cache Names « ( ) . contains ( name ) ) . » is False « ( ) ; this . manager . » get Cache « ( name ) ; » assert That « ( this . manager . » get Cache Names « ( ) . contains ( name ) ) . » is True « ( ) ; }
@Test { String name = » create Random Key « ( ) ; Cache cache = this . manager . » get Cache « ( name ) ; Object » return Value « = new Object ( ) ; Object value = cache . get ( new Object ( ) , ( ) -> » return Value « ) ; » assert That « ( value ) . » is Equal To « ( » return Value « ) ; }
@Test { Cache cache = this . manager . » get Cache « ( » create Random Key « ( ) ) ; String key = » create Random Key « ( ) ; try { cache . get ( key , ( ) -> { throw new » Unsupported Operation Exception « ( " Expected exception " ) ; } ) ; } catch ( Cache . » Value Retrieval Exception « ex ) { » assert That « ( ex . » get Cause « ( ) ) . » is Not Null « ( ) ; » assert That « ( ex . » get Cause « ( ) . » get Class « ( ) ) . » is Equal To « ( » Unsupported Operation Exception « . class ) ; } }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " singular " , 1 ) ; » assert That « ( ops . iterator ( ) . next ( ) instanceof » Cacheable Operation « ) . » is True « ( ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " multiple " , 2 ) ; Iterator < » Cache Operation « > it = ops . iterator ( ) ; » assert That « ( it . next ( ) instanceof » Cacheable Operation « ) . » is True « ( ) ; » assert That « ( it . next ( ) instanceof » Cache Evict Operation « ) . » is True « ( ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " caching " , 2 ) ; Iterator < » Cache Operation « > it = ops . iterator ( ) ; » assert That « ( it . next ( ) instanceof » Cacheable Operation « ) . » is True « ( ) ; » assert That « ( it . next ( ) instanceof » Cache Evict Operation « ) . » is True « ( ) ; }
@Test { » get Ops « ( » Annotated Class « . class , " » empty Caching « " , 0 ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » single Stereotype « " , 1 ) ; » assert That « ( ops . iterator ( ) . next ( ) instanceof » Cache Evict Operation « ) . » is True « ( ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » custom Key Generator « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Key Generator « ( ) ) . as ( " Custom key generator not set " ) . » is Equal To « ( " custom " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » custom Key Generator Inherited « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Key Generator « ( ) ) . as ( " Custom key generator not set " ) . » is Equal To « ( " custom " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » get Ops « ( » Annotated Class « . class , " » invalid Key And Key Generator Set « " ) ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » custom Cache Manager « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Cache Manager « ( ) ) . as ( " Custom cache manager not set " ) . » is Equal To « ( " custom " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » custom Cache Manager Inherited « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Cache Manager « ( ) ) . as ( " Custom cache manager not set " ) . » is Equal To « ( " custom " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » custom Cache Resolver « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Cache Resolver « ( ) ) . as ( " Custom cache resolver not set " ) . » is Equal To « ( " custom " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » custom Cache Resolver Inherited « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Cache Resolver « ( ) ) . as ( " Custom cache resolver not set " ) . » is Equal To « ( " custom " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » get Ops « ( » Annotated Class « . class , " » invalid Cache Resolver And Cache Manager Set « " ) ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Full Default « . class , " » method Level Cache Name « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " " , " » class Cache Resolver « " , " custom " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Full Default « . class , " » method Level Key Generator « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " custom " , " " , " » class Cache Resolver « " , " » class Cache Name « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Full Default « . class , " » method Level Cache Manager « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " custom " , " " , " » class Cache Name « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Full Default « . class , " » method Level Cache Resolver « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " " , " custom " , " » class Cache Name « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class « . class , " » no Cache Name Specified « " ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « . » get Cache Names « ( ) ) . as ( " cache names set must not be null " ) . » is Not Null « ( ) ; » assert That « ( » cache Operation « . » get Cache Names « ( ) . size ( ) ) . as ( " no cache names specified " ) . » is Equal To « ( 0 ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Custom Default « . class , " » method Level Cache Name « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " " , " » class Cache Resolver « " , " custom " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Multiple Cache Config « . class , " » multiple Cache Config « " ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " " , " " , " " , " » my Cache « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Interface Cache Config « . class , " » interface Cache Config « " ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " " , " " , " " , " » my Cache « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Interface Cache Config « . class , " » interface Cacheable Override « " ) ; » assert That « ( ops . size ( ) ) . » is Same As « ( 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert That « ( » cache Operation « instanceof » Cacheable Operation « ) . » is True « ( ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Some Default « . class , " » method Level Cache Manager « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " custom " , " " , " » class Cache Name « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Some Default « . class , " » method Level Cache Resolver « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " " , " custom " , " » class Cache Name « " ) ; }
@Test { Collection < » Cache Operation « > ops = » get Ops « ( » Annotated Class With Some Default « . class , " » no Customization « " , 1 ) ; » Cache Operation « » cache Operation « = ops . iterator ( ) . next ( ) ; » assert Shared Config « ( » cache Operation « , " » class Key Generator « " , " » class Cache Manager « " , " " , " » class Cache Name « " ) ; }
@Test { » assert That « ( this . cache . » is Store By Value « ( ) ) . » is False « ( ) ; }
@Test { » Concurrent Map Cache « » serialize Cache « = » create Cache With Store By Value « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » serialize Cache « . put ( » create Random Key « ( ) , this . cache ) ) . » with Message Containing « ( " Failed to serialize " ) . » with Message Containing « ( this . cache . » get Class « ( ) . » get Name « ( ) ) ; }
@Test { » Concurrent Map Cache « » serialize Cache « = » create Cache With Store By Value « ( ) ; String key = » create Random Key « ( ) ; this . » native Cache « . put ( key , " Some garbage " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » serialize Cache « . get ( key ) ) . » with Message Containing « ( " Failed to deserialize " ) . » with Message Containing « ( " Some garbage " ) ; }
@Test { » Cache Interceptor « ci = this . ctx . » get Bean « ( " » org . springframework . cache . interceptor . Cache Interceptor « # 0 " , » Cache Interceptor « . class ) ; » assert That « ( ci . » get Key Generator « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » key Generator « " ) ) ; }
@Test { » Configurable Application Context « context = new » Generic Xml Application Context « ( " / org / springframework / cache / config / » annotation Driven Cache Namespace « - resolver . xml " ) ; » Cache Interceptor « ci = context . » get Bean « ( » Cache Interceptor « . class ) ; » assert That « ( ci . » get Cache Resolver « ( ) ) . » is Same As « ( context . » get Bean « ( " » cache Resolver « " ) ) ; context . close ( ) ; }
@Test { » Configurable Application Context « context = new » Generic Xml Application Context « ( " / org / springframework / cache / config / » annotation Driven Cache Namespace « - manager - resolver . xml " ) ; » Cache Interceptor « ci = context . » get Bean « ( » Cache Interceptor « . class ) ; » assert That « ( ci . » get Cache Resolver « ( ) ) . » is Same As « ( context . » get Bean « ( " » cache Resolver « " ) ) ; context . close ( ) ; }
@Test { » Cache Interceptor « ci = this . ctx . » get Bean « ( " » org . springframework . cache . interceptor . Cache Interceptor « # 0 " , » Cache Interceptor « . class ) ; » assert That « ( ci . » get Error Handler « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » error Handler « " , » Cache Error Handler « . class ) ) ; }
@Test { » Cache Interceptor « bean = this . ctx . » get Bean « ( " » cache Advice Class « " , » Cache Interceptor « . class ) ; » assert That « ( bean . » get Key Generator « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » key Generator « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Generic Xml Application Context « ( " / org / springframework / cache / config / cache - advice - invalid . xml " ) ) ; }
@Test { Map < String , » Cache Interceptor « > interceptors = this . ctx . » get Beans Of Type « ( » Cache Interceptor « . class ) ; » assert That « ( interceptors . size ( ) ) . as ( " Only one interceptor should be defined " ) . » is Equal To « ( 1 ) ; » Cache Interceptor « interceptor = interceptors . values ( ) . iterator ( ) . next ( ) ; » assert That « ( interceptor . » get Class « ( ) ) . as ( " Custom interceptor not defined " ) . » is Equal To « ( » Test Cache Interceptor « . class ) ; }
@Test { Object o = this . cs . » throw Unchecked « ( 0L ) ; » assert That « ( o ) . » is Equal To « ( 55L ) ; }
@Test { » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> this . cs . » throw Checked « ( 0L ) ) . » with Cause Exactly Instance Of « ( » IO Exception « . class ) ; }
@Test { this . context = new » Annotation Config Application Context « ( » Foo Config « . class ) ; » Foo Service « service = this . context . » get Bean « ( » Foo Service « . class ) ; » foo Get Simple « ( service ) ; }
@Test { this . context = new » Annotation Config Application Context « ( » Foo Config Cglib « . class ) ; » Foo Service « service = this . context . » get Bean « ( » Foo Service « . class ) ; » foo Get Simple « ( service ) ; }
@Test { this . context = new » Annotation Config Application Context « ( » Bean Condition Config « . class ) ; » Foo Service « service = this . context . » get Bean « ( » Foo Service « . class ) ; Cache cache = » get Cache « ( ) ; Object key = new Object ( ) ; service . » get With Condition « ( key ) ; » assert Cache Miss « ( key , cache ) ; service . » get With Condition « ( key ) ; » assert Cache Miss « ( key , cache ) ; » assert That « ( this . context . » get Bean « ( » Bean Condition Config « . Bar . class ) . count ) . » is Equal To « ( 2 ) ; }
@Test { » Cache Interceptor « ci = this . ctx . » get Bean « ( » Cache Interceptor « . class ) ; » assert That « ( ci . » get Key Generator « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » key Generator « " , » Key Generator « . class ) ) ; }
@Test { » Cache Interceptor « ci = this . ctx . » get Bean « ( » Cache Interceptor « . class ) ; » assert That « ( ci . » get Error Handler « ( ) ) . » is Same As « ( this . ctx . » get Bean « ( " » error Handler « " , » Cache Error Handler « . class ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Single Cache Manager Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Multi Cache Manager Config « . class ) ; try { ctx . refresh ( ) ; } catch ( » Illegal State Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " no unique bean of type » Cache Manager « " ) ) . » is True « ( ) ; } }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Multi Cache Manager Configurer « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Multi Cache Manager Configurer « . class , » Enable Caching Config « . class ) ; try { ctx . refresh ( ) ; } catch ( » Bean Creation Exception « ex ) { Throwable root = ex . » get Root Cause « ( ) ; boolean condition = root instanceof » Illegal State Exception « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( root . » get Message « ( ) . contains ( " implementations of » Caching Configurer « " ) ) . » is True « ( ) ; } }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Empty Config « . class ) ; try { ctx . refresh ( ) ; } catch ( » Illegal State Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " no bean of type » Cache Manager « " ) ) . » is True « ( ) ; } }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Full Caching Config « . class ) ; » Cache Interceptor « ci = context . » get Bean « ( » Cache Interceptor « . class ) ; » assert That « ( ci . » get Cache Resolver « ( ) ) . » is Same As « ( context . » get Bean « ( " » cache Resolver « " ) ) ; » assert That « ( ci . » get Key Generator « ( ) ) . » is Same As « ( context . » get Bean « ( " » key Generator « " ) ) ; context . close ( ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Shared Config « . class , » Spr 11692 Config « . class ) ; » Base Dao « < User > » user Dao « = ( » Base Dao « < User > ) context . » get Bean « ( " » user Dao « " ) ; » Base Dao « < Order > » order Dao « = ( » Base Dao « < Order > ) context . » get Bean « ( " » order Dao « " ) ; » user Dao « . persist ( new User ( " 1 " ) ) ; » order Dao « . persist ( new Order ( " 2 " ) ) ; context . close ( ) ; }
@Test { String key = " 1 " ; Long first = this . service . » get Or Put « ( key , true ) ; Long second = this . service . » get Or Put « ( key , true ) ; » assert That « ( second ) . » is Same As « ( first ) ; Long expected = first + 1 ; Long third = this . service . » get Or Put « ( key , false ) ; » assert That « ( third ) . » is Equal To « ( expected ) ; Long fourth = this . service . » get Or Put « ( key , true ) ; » assert That « ( fourth ) . » is Same As « ( third ) ; }
@Test { » Evaluation Context « context = » create Evaluation Context « ( " » the Result « " ) ; Object value = new » Spel Expression Parser « ( ) . » parse Expression « ( " # result " ) . » get Value « ( context ) ; » assert That « ( value ) . » is Equal To « ( " » the Result « " ) ; }
@Test { » Evaluation Context « context = » create Evaluation Context « ( null ) ; Object value = new » Spel Expression Parser « ( ) . » parse Expression « ( " # result " ) . » get Value « ( context ) ; » assert That « ( value ) . » is Null « ( ) ; }
@Test { » Evaluation Context « context = » create Evaluation Context « ( » Cache Operation Expression Evaluator « . » NO _ RESULT « ) ; Object value = new » Spel Expression Parser « ( ) . » parse Expression « ( " # result " ) . » get Value « ( context ) ; » assert That « ( value ) . » is Null « ( ) ; }
@Test { » Evaluation Context « context = » create Evaluation Context « ( » Cache Operation Expression Evaluator « . » RESULT _ UNAVAILABLE « ) ; » assert That Exception Of Type « ( » Variable Not Available Exception « . class ) . » is Thrown By « ( ( ) -> new » Spel Expression Parser « ( ) . » parse Expression « ( " # result " ) . » get Value « ( context ) ) . satisfies ( ex -> » assert That « ( ex . » get Name « ( ) ) . » is Equal To « ( " result " ) ) ; }
@Test { Cache cache = this . » cache Manager « . » get Cache « ( " default " ) ; Object key = new Object ( ) ; » assert Cache Miss « ( key , cache ) ; Object value = this . » simple Service « . » get Simple « ( key ) ; » assert Cache Hit « ( key , value , cache ) ; }
@Test { Cache cache = this . » cache Manager « . » get Cache « ( " primary " ) ; Object key = new Object ( ) ; » assert Cache Miss « ( key , cache ) ; Object value = this . » simple Service « . » get With Custom Cache Resolver « ( key ) ; » assert Cache Hit « ( key , value , cache ) ; }
@Test { Cache cache = this . » another Cache Manager « . » get Cache « ( " default " ) ; Object key = new Object ( ) ; » assert Cache Miss « ( key , cache ) ; Object value = this . » simple Service « . » get With Custom Cache Manager « ( key ) ; » assert Cache Hit « ( key , value , cache ) ; }
@Test { Cache cache = this . » cache Manager « . » get Cache « ( " secondary " ) ; Object key = new Object ( ) ; » assert Cache Miss « ( key , cache ) ; Object value = this . » simple Service « . » get With Named Cache Resolution « ( key ) ; » assert Cache Hit « ( key , value , cache ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Simple Service « . class , " » no Cache Resolved « " , Object . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simple Service « . » no Cache Resolved « ( new Object ( ) ) ) . » with Message Containing « ( method . » to String « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> this . » simple Service « . » unknown Cache Resolver « ( new Object ( ) ) ) . satisfies ( ex -> » assert That « ( ex . » get Bean Name « ( ) ) . » is Equal To « ( " » unknown Cache Resolver « " ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simple Service « . » unless Sync « ( " key " ) ) . » with Message Containing « ( " @ Cacheable ( sync = true ) does not support unless attribute " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simple Service « . » several Caches Sync « ( " key " ) ) . » with Message Containing « ( " @ Cacheable ( sync = true ) only allows a single cache " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simple Service « . » several Caches With Resolved Sync « ( " key " ) ) . » with Message Containing « ( " @ Cacheable ( sync = true ) only allows a single cache " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simple Service « . » sync With Another Operation « ( " key " ) ) . » with Message Containing « ( " @ Cacheable ( sync = true ) cannot be combined with other cache operations " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simple Service « . » sync With Two Get Operations « ( " key " ) ) . » with Message Containing « ( " Only one @ Cacheable ( sync = true ) entry is allowed " ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on get " ) ; » will Throw « ( exception ) . given ( this . cache ) . get ( 0L ) ; Object result = this . » simple Service « . get ( 0L ) ; verify ( this . » error Handler « ) . » handle Cache Get Error « ( exception , cache , 0L ) ; verify ( this . cache ) . get ( 0L ) ; verify ( this . cache ) . put ( 0L , result ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on get " ) ; » will Throw « ( exception ) . given ( this . cache ) . get ( 0L ) ; this . » cache Interceptor « . » set Error Handler « ( new » Simple Cache Error Handler « ( ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> this . » simple Service « . get ( 0L ) ) . » with Message « ( " Test exception on get " ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on put " ) ; » will Throw « ( exception ) . given ( this . cache ) . put ( 0L , 0L ) ; this . » simple Service « . put ( 0L ) ; verify ( this . » error Handler « ) . » handle Cache Put Error « ( exception , cache , 0L , 0L ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on put " ) ; » will Throw « ( exception ) . given ( this . cache ) . put ( 0L , 0L ) ; this . » cache Interceptor « . » set Error Handler « ( new » Simple Cache Error Handler « ( ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> this . » simple Service « . put ( 0L ) ) . » with Message « ( " Test exception on put " ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on evict " ) ; » will Throw « ( exception ) . given ( this . cache ) . evict ( 0L ) ; this . » simple Service « . evict ( 0L ) ; verify ( this . » error Handler « ) . » handle Cache Evict Error « ( exception , cache , 0L ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on evict " ) ; » will Throw « ( exception ) . given ( this . cache ) . evict ( 0L ) ; this . » cache Interceptor « . » set Error Handler « ( new » Simple Cache Error Handler « ( ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> this . » simple Service « . evict ( 0L ) ) . » with Message « ( " Test exception on evict " ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on evict " ) ; » will Throw « ( exception ) . given ( this . cache ) . clear ( ) ; this . » simple Service « . clear ( ) ; verify ( this . » error Handler « ) . » handle Cache Clear Error « ( exception , cache ) ; }
@Test { » Unsupported Operation Exception « exception = new » Unsupported Operation Exception « ( " Test exception on clear " ) ; » will Throw « ( exception ) . given ( this . cache ) . clear ( ) ; this . » cache Interceptor « . » set Error Handler « ( new » Simple Cache Error Handler « ( ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> this . » simple Service « . clear ( ) ) . » with Message « ( " Test exception on clear " ) ; }
@Test { boolean threw = false ; try { » new Parser « ( ) . parse ( » load As Configuration Source « ( A . class ) , " A " ) ; } catch ( » Bean Definition Parsing Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " Illegal attempt by @ Configuration class 'AbstractCircularImportDetectionTests.B' " + " to import class 'AbstractCircularImportDetectionTests.A' " ) ) . as ( " Wrong message . Got : " + ex . » get Message « ( ) ) . » is True « ( ) ; threw = true ; } » assert That « ( threw ) . » is True « ( ) ; }
@Test { boolean threw = false ; try { » new Parser « ( ) . parse ( » load As Configuration Source « ( X . class ) , " X " ) ; } catch ( » Bean Definition Parsing Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " Illegal attempt by @ Configuration class 'AbstractCircularImportDetectionTests.Z2' " + " to import class 'AbstractCircularImportDetectionTests.Z' " ) ) . as ( " Wrong message . Got : " + ex . » get Message « ( ) ) . » is True « ( ) ; threw = true ; } » assert That « ( threw ) . » is True « ( ) ; }
@Test { try ( » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ) { context . register ( » Simple Factory Bean « . class ) ; context . » add Bean Factory Post Processor « ( factory -> » Bean Factory Utils « . » bean Names For Type Including Ancestors « ( factory , String . class ) ) ; context . refresh ( ) ; } }
@Test { try ( » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ) { context . register ( » Bean Method Configuration « . class ) ; context . » add Bean Factory Post Processor « ( factory -> » Bean Factory Utils « . » bean Names For Type Including Ancestors « ( factory , String . class ) ) ; context . refresh ( ) ; } }
@Test { » Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Annotated Bean Definition « bd = new » Annotated Generic Bean Definition « ( » Component From String Meta « . class ) ; String » bean Name « = this . » bean Name Generator « . » generate Bean Name « ( bd , registry ) ; » assert That « ( » bean Name « ) . » is Equal To « ( " henry " ) ; }
@Test { » Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Annotated Bean Definition « bd = new » Annotated Generic Bean Definition « ( » Component From Non String Meta « . class ) ; String » bean Name « = this . » bean Name Generator « . » generate Bean Name « ( bd , registry ) ; » assert That « ( » bean Name « ) . » is Equal To « ( " » annotation Bean Name Generator Tests « . » Component From Non String Meta « " ) ; }
@Test { » Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Annotated Bean Definition « bd = new » Annotated Generic Bean Definition « ( » Composed Controller Annotation Without Name « . class ) ; String » bean Name « = this . » bean Name Generator « . » generate Bean Name « ( bd , registry ) ; String » expected Generated Bean Name « = this . » bean Name Generator « . » build Default Bean Name « ( bd ) ; » assert That « ( » bean Name « ) . » is Equal To « ( » expected Generated Bean Name « ) ; }
@Test { » Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Annotated Bean Definition « bd = new » Annotated Generic Bean Definition « ( » Composed Controller Annotation With Blank Name « . class ) ; String » bean Name « = this . » bean Name Generator « . » generate Bean Name « ( bd , registry ) ; String » expected Generated Bean Name « = this . » bean Name Generator « . » build Default Bean Name « ( bd ) ; » assert That « ( » bean Name « ) . » is Equal To « ( » expected Generated Bean Name « ) ; }
@Test { » Bean Definition Registry « registry = new » Simple Bean Definition Registry « ( ) ; » Annotated Bean Definition « bd = new » Annotated Generic Bean Definition « ( » Composed Controller Annotation With String Value « . class ) ; String » bean Name « = this . » bean Name Generator « . » generate Bean Name « ( bd , registry ) ; » assert That « ( » bean Name « ) . » is Equal To « ( " » rest Controller « " ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » custom Name Generator Tests « . xml " ) ; » assert That « ( context . » contains Bean « ( " testing . » foo Service Impl « " ) ) . » is True « ( ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » custom Scope Resolver Tests « . xml " ) ; » Bean Definition « bd = context . » get Bean Factory « ( ) . » get Bean Definition « ( " » foo Service Impl « " ) ; » assert That « ( bd . » get Scope « ( ) ) . » is Equal To « ( " » my Custom Scope « " ) ; » assert That « ( bd . » is Singleton « ( ) ) . » is False « ( ) ; }
@Test { » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » invalid Constructor Name Generator Tests « . xml " ) ) ; }
@Test { » assert That Exception Of Type « ( » Beans Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » invalid Class Name Scope Resolver Tests « . xml " ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( Config . class ) ; ctx . » get Bean « ( " » test Bean « " , » Test Bean « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Overloading « . class ) ; ctx . » set Allow Bean Definition Overriding « ( false ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( String . class ) ) . » is Equal To « ( " regular " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Overloading « . class ) ; ctx . » get Default Listable Bean Factory « ( ) . » register Singleton « ( " » an Int « " , 5 ) ; ctx . » set Allow Bean Definition Overriding « ( false ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( String . class ) ) . » is Equal To « ( " » overloaded 5 « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Shadow Config « . class ) ; » assert That « ( ctx . » get Bean « ( String . class ) ) . » is Equal To « ( " shadow " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class ) ; ctx . register ( » Annotation Aware Aspect J Auto Proxy Creator « . class ) ; ctx . register ( » Test Advisor « . class ) ; ctx . refresh ( ) ; ctx . » get Bean « ( " » test Bean « " , » Test Bean « . class ) ; }
@Test { » Generic Application Context « ctx = » create Context « ( ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Resource Annotated Test Bean « . class ) ; rbd . » set Scope « ( » Bean Definition « . » SCOPE _ PROTOTYPE « ) ; ctx . » register Bean Definition « ( " test " , rbd ) ; ctx . » register Bean Definition « ( " spouse " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » assert Fast Enough « ( ctx ) ; }
@Test { » Generic Application Context « ctx = » create Context « ( ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Resource Annotated Test Bean « . class ) ; rbd . » set Scope « ( » Bean Definition « . » SCOPE _ PROTOTYPE « ) ; rbd . » get Property Values « ( ) . add ( " spouse " , new » Runtime Bean Reference « ( " spouse " ) ) ; ctx . » register Bean Definition « ( " test " , rbd ) ; ctx . » register Bean Definition « ( " spouse " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » assert Fast Enough « ( ctx ) ; }
@Test { » Generic Application Context « ctx = » create Context « ( ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Autowired Annotated Test Bean « . class ) ; rbd . » set Scope « ( » Bean Definition « . » SCOPE _ PROTOTYPE « ) ; ctx . » register Bean Definition « ( " test " , rbd ) ; ctx . » register Bean Definition « ( " spouse " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » assert Fast Enough « ( ctx ) ; }
@Test { » Generic Application Context « ctx = » create Context « ( ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Autowired Annotated Test Bean « . class ) ; rbd . » set Scope « ( » Bean Definition « . » SCOPE _ PROTOTYPE « ) ; rbd . » get Property Values « ( ) . add ( " spouse " , new » Runtime Bean Reference « ( " spouse " ) ) ; ctx . » register Bean Definition « ( " test " , rbd ) ; ctx . » register Bean Definition « ( " spouse " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » assert Fast Enough « ( ctx ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; bf . » add Bean Post Processor « ( new » Common Annotation Bean Post Processor « ( ) ) ; » Root Bean Definition « rbd = new » Root Bean Definition « ( » Null Factory « . class ) ; rbd . » set Factory Method Name « ( " create " ) ; bf . » register Bean Definition « ( " bean " , rbd ) ; » assert That « ( bf . » get Bean « ( " bean " ) . » to String « ( ) ) . » is Equal To « ( " null " ) ; bf . » destroy Singletons « ( ) ; }
@Test { » Common Annotation Bean Post Processor « bpp = new » Common Annotation Bean Post Processor « ( ) ; » Common Annotation Bean Post Processor « » bpp 2 « = ( » Common Annotation Bean Post Processor « ) » Serialization Test Utils « . » serialize And Deserialize « ( bpp ) ; » Annotated Init Destroy Bean « bean = new » Annotated Init Destroy Bean « ( ) ; » bpp 2 « . » post Process Before Destruction « ( bean , " » annotated Bean « " ) ; » assert That « ( bean . » destroy Called « ) . » is True « ( ) ; }
@Test { this . context = new » Annotation Config Application Context « ( » Base Configuration « . class , » Single Constructor Component « . class ) ; » assert That « ( this . context . » get Bean « ( » Single Constructor Component « . class ) . » autowired Name « ) . » is Equal To « ( " foo " ) ; }
@Test { this . context = new » Annotation Config Application Context « ( » Base Configuration « . class , » Two Constructors Component « . class ) ; » assert That « ( this . context . » get Bean « ( » Two Constructors Component « . class ) . name ) . » is Equal To « ( " fallback " ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Base Configuration « . class , » Two Specific Constructors Component « . class ) ) . » with Message Containing « ( » No Such Method Exception « . class . » get Name « ( ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Jdk Proxy « . class ) ; » aspect Is Applied « ( ctx ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( ctx . » get Bean « ( » Foo Service « . class ) ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Cglib Proxy « . class ) ; » aspect Is Applied « ( ctx ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( ctx . » get Bean « ( » Foo Service « . class ) ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Exposed Proxy « . class ) ; » aspect Is Applied « ( ctx ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( ctx . » get Bean « ( » Foo Service « . class ) ) ) . » is True « ( ) ; }
@Test { » Configurable Application Context « ctx = new » Annotation Config Application Context « ( » Config With Jdk Proxy « . class , » Sample Service « . class , » Logging Aspect « . class ) ; » Sample Service « » sample Service « = ctx . » get Bean « ( » Sample Service « . class ) ; » sample Service « . execute ( new » Sample Dto « ( ) ) ; » sample Service « . execute ( new » Sample Input Bean « ( ) ) ; » sample Service « . execute ( ( » Sample Dto « ) null ) ; » sample Service « . execute ( ( » Sample Input Bean « ) null ) ; }
@Test { » Configurable Application Context « ctx = new » Annotation Config Application Context « ( » Config With Cglib Proxy « . class , » Sample Service « . class , » Logging Aspect « . class ) ; » Sample Service « » sample Service « = ctx . » get Bean « ( » Sample Service « . class ) ; » sample Service « . execute ( new » Sample Dto « ( ) ) ; » sample Service « . execute ( new » Sample Input Bean « ( ) ) ; » sample Service « . execute ( ( » Sample Dto « ) null ) ; » sample Service « . execute ( ( » Sample Input Bean « ) null ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; » test Default « ( provider , » Scanned Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; » test Default « ( provider , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; » test Ant Style « ( provider , » Scanned Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; » test Ant Style « ( provider , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( " bogus " ) ; » assert That « ( candidates . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( " bogus " ) ; » assert That « ( candidates . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; provider . » add Include Filter « ( new » Annotation Type Filter « ( Component . class ) ) ; provider . » reset Filters « ( true ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ BASE _ PACKAGE « ) ; » assert Bean Definition Type « ( candidates , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; » test Custom Annotation Type Include Filter « ( provider , » Scanned Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; » test Custom Annotation Type Include Filter « ( provider , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; » test Custom Assignable Type Include Filter « ( provider , » Scanned Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; » test Custom Assignable Type Include Filter « ( provider , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; » test Custom Supported Include And Exclude Filter « ( provider , » Scanned Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; » test Custom Supported Include And Exclude Filter « ( provider , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; provider . » add Exclude Filter « ( new » Regex Pattern Type Filter « ( Pattern . compile ( » TEST _ BASE _ PACKAGE « + " . * Named . * " ) ) ) ; » test Exclude « ( provider , » Scanned Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; provider . » set Resource Loader « ( new » Default Resource Loader « ( » TEST _ BASE _ CLASSLOADER « ) ) ; provider . » add Exclude Filter « ( new » Regex Pattern Type Filter « ( Pattern . compile ( » TEST _ BASE _ PACKAGE « + " . * Named . * " ) ) ) ; » test Exclude « ( provider , » Annotated Generic Bean Definition « . class ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ BASE _ PACKAGE « ) ; » assert That « ( candidates . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » add Include Filter « ( new » Annotation Type Filter « ( Aspect . class ) ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ BASE _ PACKAGE « ) ; » assert That « ( candidates . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » contains Bean Class « ( candidates , » Service Invocation Counter « . class ) ) . » is True « ( ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » add Include Filter « ( new » Assignable Type Filter « ( » Foo Dao « . class ) ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ BASE _ PACKAGE « ) ; » assert That « ( candidates . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » contains Bean Class « ( candidates , » Stub Foo Dao « . class ) ) . » is True « ( ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( false ) ; provider . » add Include Filter « ( new » Assignable Type Filter « ( » Message Bean « . class ) ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ BASE _ PACKAGE « ) ; » assert That « ( candidates . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » contains Bean Class « ( candidates , » Message Bean « . class ) ) . » is True « ( ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ PROFILE _ PACKAGE « ) ; » assert That « ( » contains Bean Class « ( candidates , » Profile Annotated Component « . class ) ) . » is False « ( ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; » Configurable Environment « env = new » Standard Environment « ( ) ; env . » set Active Profiles « ( " other " ) ; provider . » set Environment « ( env ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ PROFILE _ PACKAGE « ) ; » assert That « ( » contains Bean Class « ( candidates , » Profile Annotated Component « . class ) ) . » is False « ( ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; » Configurable Environment « env = new » Standard Environment « ( ) ; env . » set Active Profiles « ( » Profile Annotated Component « . » PROFILE _ NAME « ) ; provider . » set Environment « ( env ) ; Set < » Bean Definition « > candidates = provider . » find Candidate Components « ( » TEST _ PROFILE _ PACKAGE « ) ; » assert That « ( » contains Bean Class « ( candidates , » Profile Annotated Component « . class ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Profile Annotated Component « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » Profile Annotated Component « . » BEAN _ NAME « ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » get Environment « ( ) . » set Active Profiles « ( » Profile Annotated Component « . » PROFILE _ NAME « ) ; ctx . register ( » Profile Annotated Component « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » Profile Annotated Component « . » BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » get Environment « ( ) . » set Active Profiles « ( » Dev Component « . » PROFILE _ NAME « ) ; ctx . register ( » Profile Meta Annotated Component « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » Profile Meta Annotated Component « . » BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » get Environment « ( ) . » set Active Profiles « ( " other " ) ; ctx . register ( » Profile Annotated Component « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » Profile Annotated Component « . » BEAN _ NAME « ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » get Environment « ( ) . » set Active Profiles « ( " other " ) ; ctx . register ( » Profile Meta Annotated Component « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » Profile Meta Annotated Component « . » BEAN _ NAME « ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » get Environment « ( ) . » set Default Profiles « ( » TEST _ DEFAULT _ PROFILE _ NAME « ) ; ctx . register ( » Default Profile Annotated Component « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » Default Profile Annotated Component « . » BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Class Path Scanning Candidate Component Provider « provider = new » Class Path Scanning Candidate Component Provider « ( true ) ; Set < » Bean Definition « > components = provider . » find Candidate Components « ( » Annotated Component « . class . » get Package « ( ) . » get Name « ( ) ) ; » assert That « ( components ) . » has Size « ( 1 ) ; » assert That « ( components . iterator ( ) . next ( ) . » get Bean Class Name « ( ) ) . » is Equal To « ( » Annotated Component « . class . » get Name « ( ) ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » get Class « ( ) . » get Name « ( ) + " . » Singleton Bean Config « " ) ) ; » Configuration Class Post Processor « pp = new » Configuration Class Post Processor « ( ) ; pp . » post Process Bean Factory « ( » bean Factory « ) ; Foo foo = » bean Factory « . » get Bean « ( " foo " , Foo . class ) ; Bar bar = » bean Factory « . » get Bean « ( " bar " , Bar . class ) ; » assert That « ( bar . foo ) . » is Same As « ( foo ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " » unloaded Config « " , new » Root Bean Definition « ( » Unloaded Config « . class . » get Name « ( ) ) ) ; » bean Factory « . » register Bean Definition « ( " » loaded Config « " , new » Root Bean Definition « ( » Loaded Config « . class ) ) ; » Configuration Class Post Processor « pp = new » Configuration Class Post Processor « ( ) ; pp . » post Process Bean Factory « ( » bean Factory « ) ; » bean Factory « . » get Bean « ( " foo " ) ; » bean Factory « . » get Bean « ( " bar " ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Configuration Class « . class ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Configuration Class « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Configuration With Attribute Override For Base Package « . class ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Configuration With Attribute Override For Base Package « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Configuration With Attribute Override For Exclude Filter « . class ) ; » assert Support For Composed Annotation With Exclude « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Configuration With Attribute Override For Exclude Filter « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation With Exclude « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Extended Configuration With Attribute Override For Exclude Filter « . class ) ; » assert Support For Composed Annotation With Exclude « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Extended Configuration With Attribute Override For Exclude Filter « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation With Exclude « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Composed Configuration With Attribute Overrides Class « . class ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Composed Composed Configuration With Attribute Overrides Class « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Meta Component Scan Configuration With Attribute Overrides Class « . class ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Meta Component Scan Configuration With Attribute Overrides Class « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Sub Meta Component Scan Configuration With Attribute Overrides Class « . class ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » Root Bean Definition « » bean Definition « = new » Root Bean Definition « ( » Sub Meta Component Scan Configuration With Attribute Overrides Class « . class . » get Name « ( ) ) ; » assert Support For Composed Annotation « ( » bean Definition « ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Config With Ordered Nested Classes « . class ) ) ; » Configuration Class Post Processor « pp = new » Configuration Class Post Processor « ( ) ; pp . » post Process Bean Factory « ( » bean Factory « ) ; Foo foo = » bean Factory « . » get Bean « ( Foo . class ) ; boolean condition = foo instanceof » Extended Foo « ; » assert That « ( condition ) . » is True « ( ) ; Bar bar = » bean Factory « . » get Bean « ( Bar . class ) ; » assert That « ( bar . foo ) . » is Same As « ( foo ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " » config Class « " , new » Root Bean Definition « ( » Raw Matching Configuration « . class ) ) ; » Configuration Class Post Processor « pp = new » Configuration Class Post Processor « ( ) ; pp . » post Process Bean Factory « ( » bean Factory « ) ; » assert That « ( » bean Factory « . » get Bean « ( " » repo Consumer « " ) ) . » is Same As « ( » bean Factory « . » get Bean « ( " » raw Repo « " ) ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " » config Class « " , new » Root Bean Definition « ( » Wildcard Matching Configuration « . class ) ) ; » Configuration Class Post Processor « pp = new » Configuration Class Post Processor « ( ) ; pp . » post Process Bean Factory « ( » bean Factory « ) ; » assert That « ( » bean Factory « . » get Bean « ( " » repo Consumer « " ) ) . » is Same As « ( » bean Factory « . » get Bean « ( " » generic Repo « " ) ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " » config Class « " , new » Root Bean Definition « ( » Wildcard With Extends Configuration « . class ) ) ; new » Configuration Class Post Processor « ( ) . » post Process Bean Factory « ( » bean Factory « ) ; » assert That « ( » bean Factory « . » get Bean « ( " » repo Consumer « " ) ) . » is Same As « ( » bean Factory « . » get Bean « ( " » string Repo « " ) ) ; }
@Test { » bean Factory « . » register Bean Definition « ( " » config Class « " , new » Root Bean Definition « ( » Wildcard With Generic Extends Configuration « . class ) ) ; new » Configuration Class Post Processor « ( ) . » post Process Bean Factory « ( » bean Factory « ) ; » assert That « ( » bean Factory « . » get Bean « ( " » repo Consumer « " ) ) . » is Same As « ( » bean Factory « . » get Bean « ( " » generic Repo « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( A . class , » A Strich « . class ) ) . » with Message Containing « ( " Circular reference " ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Bean Argument Config With Prototype « . class ) ; ctx . » get Bean « ( » Foo Factory « . class ) . » create Foo « ( new » Bar Argument « ( ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Bean Argument Config With Singleton « . class ) ; ctx . » get Bean « ( » Foo Factory « . class ) . » create Foo « ( new » Bar Argument « ( ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Bean Argument Config With Null « . class ) ; ctx . » get Bean « ( " » a Foo « " ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Foo Bar Configuration « . class ) ; » assert That « ( ctx . » get Bean « ( » Foo Impl « . class ) . bar ) . » is Same As « ( ctx . » get Bean « ( » Bar Impl « . class ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Vararg Configuration « . class , » Test Bean « . class ) ; » Vararg Configuration « bean = ctx . » get Bean « ( » Vararg Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . length ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » test Beans « [ 0 ] ) . » is Same As « ( ctx . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Vararg Configuration « . class ) ; » Vararg Configuration « bean = ctx . » get Bean « ( » Vararg Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . length ) . » is Equal To « ( 0 ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Collection Argument Configuration « . class , » Test Bean « . class ) ; » Collection Argument Configuration « bean = ctx . » get Bean « ( » Collection Argument Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » test Beans « . get ( 0 ) ) . » is Same As « ( ctx . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Collection Argument Configuration « . class ) ; » Collection Argument Configuration « bean = ctx . » get Bean « ( » Collection Argument Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Map Argument Configuration « . class , » Dummy Runnable « . class ) ; » Map Argument Configuration « bean = ctx . » get Bean « ( » Map Argument Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » test Beans « . values ( ) . iterator ( ) . next ( ) ) . » is Same As « ( ctx . » get Bean « ( Runnable . class ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Map Argument Configuration « . class ) ; » Map Argument Configuration « bean = ctx . » get Bean « ( » Map Argument Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Collection Injection Configuration « . class ) ; » Collection Injection Configuration « bean = ctx . » get Bean « ( » Collection Injection Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » test Beans « . get ( 0 ) ) . » is Same As « ( ctx . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Map Injection Configuration « . class ) ; » Map Injection Configuration « bean = ctx . » get Bean « ( » Map Injection Configuration « . class ) ; » assert That « ( bean . » test Beans « ) . » is Not Null « ( ) ; » assert That « ( bean . » test Beans « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( bean . » test Beans « . get ( " » test Bean « " ) ) . » is Same As « ( ctx . » get Bean « ( Runnable . class ) ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Bean Lookup Configuration « . class ) ; » Bean Lookup Configuration « bean = ctx . » get Bean « ( » Bean Lookup Configuration « . class ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Not Null « ( ) ; » assert That « ( bean . » get Test Bean « ( ) ) . » is Same As « ( ctx . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> { » Application Context « ctx = new » Annotation Config Application Context « ( » My Test Bean « . class ) ; ctx . » get Bean « ( " » my Test Bean « " , » Test Bean « . class ) ; } ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Bean Definition Registry Post Processor Config « . class ) ; boolean condition = ctx . » get Bean « ( " » my Test Bean « " ) instanceof » Test Bean « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config 1 « . class , » Config 2 « . class ) ; ctx . refresh ( ) ; assertions ( ctx ) ; » Config 2 « » config 2 « = ctx . » get Bean « ( » Config 2 « . class ) ; » assert That « ( » config 2 « . » test Bean « ) . » is Equal To « ( ctx . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config 2 « . class , » Config 1 « . class ) ; ctx . refresh ( ) ; assertions ( ctx ) ; }
@Test { » do Test Lazy Resource Injection « ( » Field Resource Injection Bean With Composite Annotation « . class ) ; }
@Test { » do Test Lazy Resource Injection « ( » Method Resource Injection Bean « . class ) ; }
@Test { » do Test Lazy Resource Injection « ( » Method Resource Injection Bean With Method Level Lazy « . class ) ; }
@Test { » do Test Lazy Resource Injection « ( » Method Resource Injection Bean With Composite Annotation « . class ) ; }
@Test { » do Test Lazy Resource Injection « ( » Constructor Resource Injection Bean « . class ) ; }
@Test { » do Test Lazy Resource Injection « ( » Constructor Resource Injection Bean With Constructor Level Lazy « . class ) ; }
@Test { » do Test Lazy Resource Injection « ( » Constructor Resource Injection Bean With Composite Annotation « . class ) ; }
@Test { » Generic Application Context « context = new » Generic Application Context « ( ) ; context . » register Bean Definition « ( " » stub Foo Dao « " , new » Root Bean Definition « ( » Test Bean « . class ) ) ; » Class Path Bean Definition Scanner « scanner = new » Class Path Bean Definition Scanner « ( context ) ; scanner . » set Include Annotation Config « ( false ) ; scanner . scan ( » BASE _ PACKAGE « ) ; }
@Test { » Generic Application Context « context = new » Generic Application Context « ( ) ; » Class Path Bean Definition Scanner « scanner = new » Class Path Bean Definition Scanner « ( context ) ; scanner . » set Include Annotation Config « ( false ) ; scanner . scan ( " org . springframework . context . » annotation 3 « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> scanner . scan ( » BASE _ PACKAGE « ) ) . » with Message Containing « ( " » stub Foo Dao « " ) . » with Message Containing « ( » Stub Foo Dao « . class . » get Name « ( ) ) ; }
@Test { » Generic Application Context « context = new » Generic Application Context « ( ) ; » Class Path Bean Definition Scanner « scanner = new » Class Path Bean Definition Scanner « ( context ) ; scanner . » set Include Annotation Config « ( false ) ; scanner . scan ( » BASE _ PACKAGE « ) ; scanner . scan ( » BASE _ PACKAGE « ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( Config . class , Bar . class ) ; » assert That « ( ctx . » get Bean « ( Bar . class ) . foo ) . » is Not Null « ( ) ; }
@Test { » assert Pre Freeze « ( » Direct Configuration « . class ) ; }
@Test { » assert Post Freeze « ( » Direct Configuration « . class ) ; }
@Test { » assert Pre Freeze « ( » Generic Method Configuration « . class ) ; }
@Test { » assert Post Freeze « ( » Generic Method Configuration « . class ) ; }
@Test { » assert Pre Freeze « ( » Generic Class Configuration « . class ) ; }
@Test { » assert Post Freeze « ( » Generic Class Configuration « . class ) ; }
@Test { » assert Pre Freeze « ( » Attribute Class Configuration « . class ) ; }
@Test { » assert Post Freeze « ( » Attribute Class Configuration « . class ) ; }
@Test { » Annotation Metadata « metadata = mock ( » Annotation Metadata « . class ) ; Group . Entry entry = new Group . Entry ( metadata , " com . example . Test " ) ; » assert That « ( entry ) . » is Equal To « ( entry ) ; }
@Test { » Annotation Metadata « metadata = mock ( » Annotation Metadata « . class ) ; » assert That « ( new Group . Entry ( metadata , " com . example . Test " ) ) . » is Equal To « ( new Group . Entry ( metadata , " com . example . Test " ) ) ; }
@Test { » assert That « ( new Group . Entry ( mock ( » Annotation Metadata « . class ) , " com . example . Test " ) ) . » is Not Equal To « ( new Group . Entry ( mock ( » Annotation Metadata « . class ) , " com . example . Test " ) ) ; }
@Test { » Annotation Metadata « metadata = mock ( » Annotation Metadata « . class ) ; » assert That « ( new Group . Entry ( metadata , " com . example . » Another Test « " ) ) . » is Not Equal To « ( new Group . Entry ( metadata , " com . example . Test " ) ) ; }
@Test { » Generic Xml Application Context « ctx = new » Generic Xml Application Context « ( » get Class « ( ) , " » Enable Load Time Weaving Tests « - context . xml " ) ; ctx . » get Bean « ( " » load Time Weaver « " , » Load Time Weaver « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Enable LTW Config _ with Aj Weaving Disabled « . class ) ; ctx . refresh ( ) ; » Load Time Weaver « » load Time Weaver « = ctx . » get Bean « ( " » load Time Weaver « " , » Load Time Weaver « . class ) ; » verify No Interactions « ( » load Time Weaver « ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Enable LTW Config _ with Aj Weaving Autodetect « . class ) ; ctx . refresh ( ) ; » Load Time Weaver « » load Time Weaver « = ctx . » get Bean « ( " » load Time Weaver « " , » Load Time Weaver « . class ) ; » verify No Interactions « ( » load Time Weaver « ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Enable LTW Config _ with Aj Weaving Enabled « . class ) ; ctx . refresh ( ) ; » Load Time Weaver « » load Time Weaver « = ctx . » get Bean « ( " » load Time Weaver « " , » Load Time Weaver « . class ) ; verify ( » load Time Weaver « ) . » add Transformer « ( » is A « ( » Class File Transformer « . class ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . scan ( example . scannable . » Package Marker « . class . » get Package « ( ) . » get Name « ( ) ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » foo Service Impl « " ) ) . as ( " control scan for example . scannable package failed to register » Foo Service Impl « bean " ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Component Scan With Bean Name Generator « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » custom _ foo Service Impl « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » foo Service Impl « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Component Scan With Scope Resolver « . class ) ; » assert That « ( ctx . » get Bean « ( » Custom Scope Annotation Bean « . class ) ) . » is Not Same As « ( ctx . » get Bean « ( » Custom Scope Annotation Bean « . class ) ) ; » assert That « ( ctx . » contains Bean « ( " » scanned Component « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Multi Component Scan « . class ) ; » assert That « ( ctx . » get Bean « ( » Custom Scope Annotation Bean « . class ) ) . » is Not Same As « ( ctx . » get Bean « ( » Custom Scope Annotation Bean « . class ) ) ; » assert That « ( ctx . » contains Bean « ( " » scanned Component « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Component Scan With Custom Type Filter « . class ) ; » assert That « ( ctx . » get Default Listable Bean Factory « ( ) . » contains Singleton « ( " » component Scan Parser Tests « . » Kustom Annotation Autowired Bean « " ) ) . » is False « ( ) ; » Kustom Annotation Autowired Bean « » test Bean « = ctx . » get Bean « ( " » component Scan Parser Tests « . » Kustom Annotation Autowired Bean « " , » Kustom Annotation Autowired Bean « . class ) ; » assert That « ( » test Bean « . » get Dependency « ( ) ) . » is Not Null « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Component Scan With Aware Type Filter « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » accepts Profiles « ( Profiles . of ( " the - filter - ran " ) ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Component Scan With Scoped Proxy Through Regex « . class ) ; ctx . » get Bean Factory « ( ) . » register Scope « ( " » my Scope « " , new » Simple Map Scope « ( ) ) ; ctx . refresh ( ) ; » Foo Service « bean = ( » Foo Service « ) ctx . » get Bean « ( " » scoped Proxy Test Bean « " ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( bean ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Component Scan With Scoped Proxy Through Aspect J Pattern « . class ) ; ctx . » get Bean Factory « ( ) . » register Scope « ( " » my Scope « " , new » Simple Map Scope « ( ) ) ; ctx . refresh ( ) ; » Foo Service « bean = ( » Foo Service « ) ctx . » get Bean « ( " » scoped Proxy Test Bean « " ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( bean ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Component Scan With Multiple Annotation Include Filters 1 « . class ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Default Named Component « . class ) ; ctx . » get Bean « ( » Message Bean « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Component Scan With Multiple Annotation Include Filters 2 « . class ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Default Named Component « . class ) ; ctx . » get Bean « ( » Message Bean « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Component Scan With Base Packages And Value Alias « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » foo Service Impl « " ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( Config . class ) ; boolean b = ctx . » get Bean « ( " b " , boolean . class ) ; » assert That « ( b ) . » is Equal To « ( true ) ; int i = ctx . » get Bean « ( " i " , int . class ) ; » assert That « ( i ) . » is Equal To « ( 42 ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( Config . class ) ; boolean b = ctx . » get Bean « ( boolean . class ) ; » assert That « ( b ) . » is Equal To « ( true ) ; int i = ctx . » get Bean « ( int . class ) ; » assert That « ( i ) . » is Equal To « ( 42 ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( Config . class , » Autowired Component « . class ) ; » assert That « ( ctx . » get Bean « ( » Autowired Component « . class ) . b ) . » is Equal To « ( true ) ; » assert That « ( ctx . » get Bean « ( » Autowired Component « . class ) . i ) . » is Equal To « ( 42 ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( Config . class , » Resource Component « . class ) ; » assert That « ( ctx . » get Bean « ( » Resource Component « . class ) . b ) . » is Equal To « ( true ) ; » assert That « ( ctx . » get Bean « ( » Resource Component « . class ) . i ) . » is Equal To « ( 42 ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Wrapper . class ) ; » assert That « ( context . » get Bean « ( " value " ) ) . » is Equal To « ( " foo " ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; » assert That « ( context . » get Bean « ( " value " ) ) . » is Equal To « ( " foo " ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; » String Holder « holder = context . » get Bean « ( » String Holder « . class ) ; » assert That « ( holder . » items List « . get ( 0 ) ) . » is Equal To « ( " second " ) ; » assert That « ( holder . » items List « . get ( 1 ) ) . » is Equal To « ( " first " ) ; » assert That « ( holder . » items List « . get ( 2 ) ) . » is Equal To « ( " » unknown Order « " ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; » String Holder « holder = context . » get Bean « ( » String Holder « . class ) ; » assert That « ( holder . » items Array « [ 0 ] ) . » is Equal To « ( " second " ) ; » assert That « ( holder . » items Array « [ 1 ] ) . » is Equal To « ( " first " ) ; » assert That « ( holder . » items Array « [ 2 ] ) . » is Equal To « ( " » unknown Order « " ) ; }
@Test { new » Annotation Config Application Context « ( » Pooling Target Source Config « . class ) ; }
@Test { try ( » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Register Bean Phase Importing Configuration « . class ) ) { context . » get Bean « ( " » some Bean « " ) ; } }
@Test { try ( » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Parse Configuration Phase Importing Configuration « . class ) ) { context . » get Bean « ( " » some Bean « " ) ; } }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . » set Allow Bean Definition Overriding « ( false ) ; context . register ( » Unconditional Importing Configuration « . class ) ; context . refresh ( ) ; try { context . » get Bean « ( " » some Bean « " ) ; } finally { context . close ( ) ; } }
@Test { » do Assertions « ( new » Class Path Xml Application Context « ( " » Spr 6602 Tests « - context . xml " , » Spr 6602 Tests « . class ) ) ; }
@Test { » do Assertions « ( new » Annotation Config Application Context « ( » Foo Config « . class ) ) ; }
@Test { » My Bean Impl « . initialized = false ; » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Static « . class ) ; » My Bean « bean = ctx . » get Bean « ( " » my Bean « " , » My Bean « . class ) ; » assert That « ( » My Bean Impl « . initialized ) . » is False « ( ) ; bean . » do It « ( ) ; » assert That « ( » My Bean Impl « . initialized ) . » is True « ( ) ; }
@Test { » My Bean Impl « . initialized = false ; » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Static And Interface « . class ) ; » My Bean « bean = ctx . » get Bean « ( " » my Bean « " , » My Bean « . class ) ; » assert That « ( » My Bean Impl « . initialized ) . » is False « ( ) ; bean . » do It « ( ) ; » assert That « ( » My Bean Impl « . initialized ) . » is True « ( ) ; }
@Test { » My Bean Impl « . initialized = false ; » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Non Static « . class ) ; » My Bean « bean = ctx . » get Bean « ( " » my Bean « " , » My Bean « . class ) ; » assert That « ( » My Bean Impl « . initialized ) . » is False « ( ) ; bean . » do It « ( ) ; » assert That « ( » My Bean Impl « . initialized ) . » is True « ( ) ; }
@Test { » My Bean Impl « . initialized = false ; » Application Context « ctx = new » Annotation Config Application Context « ( » Config With Non Static And Interface « . class ) ; » My Bean « bean = ctx . » get Bean « ( " » my Bean « " , » My Bean « . class ) ; » assert That « ( » My Bean Impl « . initialized ) . » is False « ( ) ; bean . » do It « ( ) ; » assert That « ( » My Bean Impl « . initialized ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Bean One Configuration « . class , » Bean Two Configuration « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 2 « " ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( " » configuration Class With Condition Tests « . » Bean Two Configuration « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Bean Two Configuration « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » configuration Class With Condition Tests « . » Bean Two Configuration « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Bean One Configuration « . class , » Bean Three Configuration « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 3 « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Bean Three Configuration « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 3 « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Configuration With Meta Condition « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " bean " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Configuration With Meta Condition « . class . » get Name « ( ) ) ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " bean " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Non Configuration Class « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Non Configuration Class « . class . » get Name « ( ) ) ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Condition On Method Configuration « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Condition On Method Configuration « . class . » get Name « ( ) ) ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » bean 1 « " ) ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Imports Not Created « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Config With Bean Skipped « . class ) ; » assert That « ( context . » get Beans Of Type « ( » Example Bean « . class ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Config With Bean Reactivated « . class ) ; Map < String , » Example Bean « > beans = context . » get Beans Of Type « ( » Example Bean « . class ) ; » assert That « ( beans . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( beans . » key Set « ( ) . iterator ( ) . next ( ) ) . » is Equal To « ( " baz " ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Config With Alternative Beans « . class ) ; Map < String , » Example Bean « > beans = context . » get Beans Of Type « ( » Example Bean « . class ) ; » assert That « ( beans . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( beans . » key Set « ( ) . iterator ( ) . next ( ) ) . » is Equal To « ( " baz " ) ; }
@Test { try ( » Annotation Config Application Context « » direct Registration « = new » Annotation Config Application Context « ( ) ) { » direct Registration « . register ( » Accidental Lite Configuration « . class ) ; » direct Registration « . refresh ( ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> » direct Registration « . » get Bean « ( Thing . class ) ) ; } }
@Test { try ( » Annotation Config Application Context « » direct Registration « = new » Annotation Config Application Context « ( ) ) { » direct Registration « . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Accidental Lite Configuration « . class . » get Name « ( ) ) ) ; » direct Registration « . refresh ( ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> » direct Registration « . » get Bean « ( Thing . class ) ) ; } }
@Test { try ( » Annotation Config Application Context « » via Import « = new » Annotation Config Application Context « ( ) ) { » via Import « . register ( Importer . class ) ; » via Import « . refresh ( ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> » via Import « . » get Bean « ( Thing . class ) ) ; } }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Test Profile Beans « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Bean « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Profile Bean « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Implicit Name « . class , » With Custom Factory « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " » P 2 TESTBEAN « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Implicit Name « . class , » With Custom Factory As Meta « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " » P 2 TESTBEAN « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Unresolvable Placeholder « . class ) ; try { ctx . refresh ( ) ; } catch ( » Bean Definition Store Exception « ex ) { » assert That « ( ex . » get Cause « ( ) instanceof » Illegal Argument Exception « ) . » is True « ( ) ; } }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Unresolvable Placeholder And Default « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " » p 1 Test Bean « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Resolvable Placeholder « . class ) ; System . » set Property « ( " path . to . properties " , " org / springframework / context / annotation " ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " » p 1 Test Bean « " ) ; System . » clear Property « ( " path . to . properties " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Resolvable Placeholder And Factory Bean « . class ) ; System . » set Property « ( " path . to . properties " , " org / springframework / context / annotation " ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " » p 1 Test Bean « " ) ; System . » clear Property « ( " path . to . properties " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Empty Resource Locations « . class ) ; try { ctx . refresh ( ) ; } catch ( » Bean Definition Store Exception « ex ) { » assert That « ( ex . » get Cause « ( ) instanceof » Illegal Argument Exception « ) . » is True « ( ) ; } }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Config With Name And Multiple Resource Locations « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » get Property « ( " testbean . name " ) ) . » is Equal To « ( " » p 2 Test Bean « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Config With Multiple Resource Locations « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » get Property « ( " testbean . name " ) ) . » is Equal To « ( " » p 2 Test Bean « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Config With Property Sources « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » get Property « ( " testbean . name " ) ) . » is Equal To « ( " » p 2 Test Bean « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Config With Named Property Sources « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » get Property « ( " testbean . name " ) ) . » is Equal To « ( " » p 2 Test Bean « " ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Config With Missing Property Source « . class ) ) . » with Cause Instance Of « ( » File Not Found Exception « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Config With Ignored Property Source « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 2 « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Config With Same Source Imported In Different Order « . class ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » contains Property « ( " from . » p 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » get Environment « ( ) . » get Property « ( " testbean . name " ) ) . » is Equal To « ( " » p 2 Test Bean « " ) ; }
@Test { » Annotation Config Application Context « » ctx Without Name « = new » Annotation Config Application Context « ( » Config With Four Resource Locations « . class ) ; » assert That « ( » ctx Without Name « . » get Environment « ( ) . » get Property « ( " testbean . name " ) ) . » is Equal To « ( " » p 4 Test Bean « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Annotation Scope Metadata Resolver « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » scope Metadata Resolver « . » set Scope Annotation Type « ( null ) ) ; }
@Test { » Generic Application Context « context = new » Generic Application Context « ( ) ; » Xml Bean Definition Reader « reader = new » Xml Bean Definition Reader « ( context ) ; reader . » load Bean Definitions « ( » LOCATION _ PREFIX « + " » default Autowire By Type Tests « . xml " ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( context :: refresh ) ; }
@Test { » Class Path Xml Application Context « context = » load Context « ( " » aspectj Type Filter Tests « . xml " ) ; » assert That « ( context . » contains Bean « ( " » foo Service Impl « " ) ) . » is True « ( ) ; » assert That « ( context . » contains Bean « ( " » stub Foo Dao « " ) ) . » is True « ( ) ; » assert That « ( context . » contains Bean « ( " » scoped Proxy Test Bean « " ) ) . » is False « ( ) ; context . close ( ) ; }
@Test { » Class Path Xml Application Context « context = » load Context « ( " » non Matching Resource Pattern Tests « . xml " ) ; » assert That « ( context . » contains Bean « ( " » foo Service Impl « " ) ) . » is False « ( ) ; context . close ( ) ; }
@Test { » Class Path Xml Application Context « context = » load Context « ( " » matching Resource Pattern Tests « . xml " ) ; » assert That « ( context . » contains Bean « ( " » foo Service Impl « " ) ) . » is True « ( ) ; context . close ( ) ; }
@Test { » Class Path Xml Application Context « context = » load Context « ( " » component Scan With Autowired Qualifier Tests « . xml " ) ; » Autowired Qualifier Foo Service « » foo Service « = ( » Autowired Qualifier Foo Service « ) context . » get Bean « ( " » foo Service « " ) ; » assert That « ( » foo Service « . » is Init Called « ( ) ) . » is True « ( ) ; » assert That « ( » foo Service « . foo ( 123 ) ) . » is Equal To « ( " bar " ) ; context . close ( ) ; }
@Test { » Class Path Xml Application Context « context = » load Context « ( " » custom Annotation Used For Both Component Scan And Qualifier Tests « . xml " ) ; » Kustom Annotation Autowired Bean « » test Bean « = ( » Kustom Annotation Autowired Bean « ) context . » get Bean « ( " » test Bean « " ) ; » assert That « ( » test Bean « . » get Dependency « ( ) ) . » is Not Null « ( ) ; context . close ( ) ; }
@Test { » Class Path Xml Application Context « context = » load Context « ( " » custom Type Filter Tests « . xml " ) ; » Kustom Annotation Autowired Bean « » test Bean « = ( » Kustom Annotation Autowired Bean « ) context . » get Bean « ( " » test Bean « " ) ; » assert That « ( » test Bean « . » get Dependency « ( ) ) . » is Not Null « ( ) ; context . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Concrete Factory Bean Implementation Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Parameterized Factory Bean Implementation Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Parameterized Factory Bean Interface Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Non Public Parameterized Factory Bean Interface Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Raw Factory Bean Interface Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Wildcard Parameterized Factory Bean Interface Config « . class ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » App Config « . class ) ; ctx . register ( » Factory Bean Calling Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( " » my String « " ) ) . » is Equal To « ( " true " ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . register ( Config . class , » Name Config « . class ) ; context . refresh ( ) ; context . » get Bean « ( " » test Bean « " ) ; context . » get Bean « ( " name " ) ; Map < String , Object > beans = context . » get Beans With Annotation « ( Configuration . class ) ; » assert That « ( beans ) . » has Size « ( 2 ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . register ( Config . class , » Name Config « . class , » Untyped Factory Bean « . class ) ; context . refresh ( ) ; context . » get Bean « ( " » test Bean « " ) ; context . » get Bean « ( " name " ) ; Map < String , Object > beans = context . » get Beans With Annotation « ( Configuration . class ) ; » assert That « ( beans ) . » has Size « ( 2 ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; » Test Bean « » test Bean « = context . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « ) . » is Not Null « ( ) ; » assert That « ( » test Bean « . name ) . » is Equal To « ( " foo " ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; Class < ? > » target Type « = Pattern . class ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> context . » get Bean « ( » target Type « ) ) . » with Message Containing « ( format ( " No qualifying bean of type '%s' " , » target Type « . » get Name « ( ) ) ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Two Test Bean Config « . class ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> context . » get Bean « ( » Test Bean « . class ) ) . » with Message Containing « ( " No qualifying bean of type ' " + » Test Bean « . class . » get Name « ( ) + " ' " ) . » with Message Containing « ( " » tb 1 « " ) . » with Message Containing « ( " » tb 2 « " ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; Config » config Object « = ( Config ) context . » get Bean « ( " » annotation Config Application Context Tests « . Config " ) ; » assert That « ( » config Object « ) . » is Not Null « ( ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Custom Name « . class ) ; » Config With Custom Name « » config Object « = ( » Config With Custom Name « ) context . » get Bean « ( " » custom Config Bean Name « " ) ; » assert That « ( » config Object « ) . » is Not Null « ( ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Autowired Config « . class ) ; » assert That « ( context . » get Bean « ( » Test Bean « . class ) . name ) . » is Equal To « ( " foo " ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . » register Bean « ( " fb " , » Non Instantiated Factory Bean « . class , » Non Instantiated Factory Bean « :: new , bd -> bd . » set Lazy Init « ( true ) ) ; context . refresh ( ) ; » assert That « ( context . » get Type « ( " fb " ) ) . » is Equal To « ( String . class ) ; » assert That « ( context . » get Type « ( " & fb " ) ) . » is Equal To « ( » Non Instantiated Factory Bean « . class ) ; }
@Test { » Imported Registrar « . called = false ; » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Importing Registrar Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( " » registrar Imported Bean « " ) ) . » is Not Null « ( ) ; » assert That « ( ctx . » get Bean « ( " » other Imported Config Bean « " ) ) . » is Not Null « ( ) ; }
@Test { » Annotation Metadata « » import Metadata « = new » Annotation Config Application Context « ( » Configuration One « . class , » Configuration Two « . class ) . » get Bean « ( » Metadata Holder « . class ) . » import Metadata « ; » assert That « ( ( ( » Standard Annotation Metadata « ) » import Metadata « ) . » get Introspected Class « ( ) ) . » is Equal To « ( » Configuration One « . class ) ; }
@Test { » Annotation Metadata « » import Metadata « = new » Annotation Config Application Context « ( » Configuration Two « . class , » Configuration One « . class ) . » get Bean « ( » Metadata Holder « . class ) . » import Metadata « ; » assert That « ( ( ( » Standard Annotation Metadata « ) » import Metadata « ) . » get Introspected Class « ( ) ) . » is Equal To « ( » Configuration One « . class ) ; }
@Test { » Annotation Metadata « » import Metadata « = new » Annotation Config Application Context « ( » Configuration One « . class , » Configuration Three « . class ) . » get Bean « ( » Metadata Holder « . class ) . » import Metadata « ; » assert That « ( ( ( » Standard Annotation Metadata « ) » import Metadata « ) . » get Introspected Class « ( ) ) . » is Equal To « ( » Configuration One « . class ) ; }
@Test { new » Annotation Config Application Context « ( » Application Configuration « . class ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Factory Bean « . class ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo . » to String « ( ) ) . » is Equal To « ( " x " ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo ) . » is Same As « ( context . » get Bean « ( » Foo Interface « . class ) ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Abstract Factory Bean « . class ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo . » to String « ( ) ) . » is Equal To « ( " x " ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo ) . » is Same As « ( context . » get Bean « ( » Foo Interface « . class ) ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Abstract Factory Bean For Interface « . class ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo . » to String « ( ) ) . » is Equal To « ( " x " ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo ) . » is Same As « ( context . » get Bean « ( » Foo Interface « . class ) ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Abstract Factory Bean As Return Type « . class ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo . » to String « ( ) ) . » is Equal To « ( " x " ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo ) . » is Same As « ( context . » get Bean « ( » Foo Interface « . class ) ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Final Factory Bean « . class ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo . » to String « ( ) ) . » is Equal To « ( " x " ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo ) . » is Same As « ( context . » get Bean « ( » Foo Interface « . class ) ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Config With Final Factory Bean As Return Type « . class ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo . » to String « ( ) ) . » is Equal To « ( " x " ) ; » assert That « ( context . » get Bean « ( Bar . class ) . foo ) . » is Not Same As « ( context . » get Bean « ( » Foo Interface « . class ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Test Bean Config « . class , » Autowired Config With BFPP As Instance Method « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Autowired Config With BFPP As Instance Method « . class ) . » autowired Test Bean « ) . » is Null « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Test Bean Config « . class , » Autowired Config With BFPP As Static Method « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Autowired Config With BFPP As Static Method « . class ) . » autowired Test Bean « ) . » is Not Null « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Static Bean Method « . class ) ; ctx . refresh ( ) ; » assert That « ( » Config With Static Bean Method « . » test Bean « ( ) ) . » is Not Same As « ( » Config With Static Bean Method « . » test Bean « ( ) ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » scoped Proxy Default Tests « . xml " ) ; context . » get Bean Factory « ( ) . » register Scope « ( " » my Scope « " , new » Simple Map Scope « ( ) ) ; » Scoped Proxy Test Bean « bean = ( » Scoped Proxy Test Bean « ) context . » get Bean « ( " » scoped Proxy Test Bean « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . » is False « ( ) ; context . close ( ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » scoped Proxy No Tests « . xml " ) ; context . » get Bean Factory « ( ) . » register Scope « ( " » my Scope « " , new » Simple Map Scope « ( ) ) ; » Scoped Proxy Test Bean « bean = ( » Scoped Proxy Test Bean « ) context . » get Bean « ( " » scoped Proxy Test Bean « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . » is False « ( ) ; context . close ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Parsing Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " org / springframework / context / annotation / » scoped Proxy Invalid Config Tests « . xml " ) ) . » with Message Containing « ( " Cannot define both 'scope-resolver' and 'scoped-proxy' on < component - scan > tag " ) . » with Message Containing « ( " Offending resource : class path resource [ org / springframework / context / annotation / » scoped Proxy Invalid Config Tests « . xml ] " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config 1 « . class ) ; ctx . register ( » Config 2 « . class ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Simple Component « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » register Bean Definition « ( " » config 1 « " , new » Root Bean Definition « ( » Config 1 « . class . » get Name « ( ) ) ) ; ctx . » register Bean Definition « ( " » config 2 « " , new » Root Bean Definition « ( » Config 2 « . class . » get Name « ( ) ) ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Simple Component « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config 3 « . class ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Simple Component « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Config 3 « . class . » get Name « ( ) ) ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Simple Component « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . scan ( " org . springframework . context . annotation . componentscan . importing " ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Simple Component « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Importing Config « . class . » get Name « ( ) ) ) ; ctx . refresh ( ) ; ctx . » get Bean « ( » Simple Component « . class ) ; }
@Test { » No Args Constructor « instance = » instantiate Class « ( » No Args Constructor « . class ) ; » assert That « ( instance . » set Environment « ) . » is Same As « ( this . environment ) ; » assert That « ( instance . » set Bean Factory « ) . » is Same As « ( this . registry ) ; » assert That « ( instance . » set Bean Class Loader « ) . » is Same As « ( this . » bean Class Loader « ) ; » assert That « ( instance . » set Resource Loader « ) . » is Same As « ( this . » resource Loader « ) ; }
@Test { » Args Constructor « instance = » instantiate Class « ( » Args Constructor « . class ) ; » assert That « ( instance . environment ) . » is Same As « ( this . environment ) ; » assert That « ( instance . » bean Factory « ) . » is Same As « ( this . registry ) ; » assert That « ( instance . » bean Class Loader « ) . » is Same As « ( this . » bean Class Loader « ) ; » assert That « ( instance . » resource Loader « ) . » is Same As « ( this . » resource Loader « ) ; }
@Test { » Multiple Constructors « instance = » instantiate Class « ( » Multiple Constructors « . class ) ; » assert That « ( instance . » used Default Constructor « ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » Bean Instantiation Exception « . class ) . » is Thrown By « ( ( ) -> » instantiate Class « ( » Multiple Constructors With No Default « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Instantiation Exception « . class ) . » is Thrown By « ( ( ) -> » instantiate Class « ( » Invalid Constructor Parameter Type « . class ) ) . » with Cause Instance Of « ( » Illegal State Exception « . class ) . » with Message Containing « ( " No suitable constructor found " ) ; }
@Test { » assert That Exception Of Type « ( » Bean Instantiation Exception « . class ) . » is Thrown By « ( ( ) -> » instantiate Class « ( » Invalid Constructor Parameter Sub Type « . class ) ) . » with Cause Instance Of « ( » Illegal State Exception « . class ) . » with Message Containing « ( " No suitable constructor found " ) ; }
@Test { reset ( this . » resource Loader « ) ; » Args Constructor « instance = » instantiate Class « ( » Args Constructor « . class ) ; » assert That « ( instance . » bean Class Loader « ) . » is Null « ( ) ; }
@Test { reset ( this . » resource Loader « ) ; » No Args Constructor « instance = » instantiate Class « ( » No Args Constructor « . class ) ; » assert That « ( instance . » set Bean Class Loader « ) . » is Null « ( ) ; » assert That « ( instance . » set Bean Class Loader Called « ) . » is False « ( ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Child Config « . class ) ; » assert That « ( context . » get Bean « ( » My Component « . class ) ) . » is Not Null « ( ) ; context . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Repro Config « . class ) ; ctx . refresh ( ) ; Foo » foo 1 « = ctx . » get Bean « ( " » foo 1 « " , Foo . class ) ; Foo » foo 2 « = ctx . » get Bean « ( " » foo 2 « " , Foo . class ) ; ctx . » get Bean « ( " » package Private Bar « " , Bar . class ) ; » assert That « ( » foo 1 « . bar ) . » is Not Equal To « ( » foo 2 « . bar ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Workaround Config « . class ) ; ctx . refresh ( ) ; Foo » foo 1 « = ctx . » get Bean « ( " » foo 1 « " , Foo . class ) ; Foo » foo 2 « = ctx . » get Bean « ( " » foo 2 « " , Foo . class ) ; ctx . » get Bean « ( " » protected Bar « " , Bar . class ) ; » assert That « ( » foo 1 « . bar ) . » is Equal To « ( » foo 2 « . bar ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Custom Config With Attribute Override « . class , » Custom Pojo « . class ) ; » assert That « ( ctx . » get Bean Factory « ( ) . » contains Singleton « ( " » test Bean X « " ) ) . » is False « ( ) ; » Custom Pojo « pojo = ctx . » get Bean « ( » Custom Pojo « . class ) ; » assert That « ( pojo . » test Bean « . » get Name « ( ) ) . » is Equal To « ( " interesting " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( A . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " outer " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " imported " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " nested " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » nested Bean « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( A . B . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " outer " ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( " imported " ) ) . » is False « ( ) ; » assert That « ( ctx . » contains Bean « ( " nested " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » nested Bean « " ) ) . » is True « ( ) ; }
@Test { » assert Advice Was Applied « ( » Aspect Config « . class ) ; }
@Test { » assert Advice Was Applied « ( » Configuration With Aspect « . class ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( Application . class , » Counting Aspect « . class ) ; ctx . » get Beans Of Type « ( Runnable . class ) . » for Each « ( ( k , v ) -> v . run ( ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Value Field And Placeholder Configurer « . class ) ; System . » set Property « ( " test . name " , " foo " ) ; ctx . refresh ( ) ; System . » clear Property « ( " test . name " ) ; » Test Bean « » test Bean « = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Null « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Value Field And Static Placeholder Configurer « . class ) ; System . » set Property « ( " test . name " , " foo " ) ; ctx . refresh ( ) ; System . » clear Property « ( " test . name " ) ; » Test Bean « » test Bean « = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Value Field « . class ) ; ctx . register ( » Config With Placeholder Configurer « . class ) ; System . » set Property « ( " test . name " , " foo " ) ; ctx . refresh ( ) ; System . » clear Property « ( " test . name " ) ; » Test Bean « » test Bean « = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Value Field « . class ) ; ctx . register ( » Config With Placeholder Configurer « . class ) ; ctx . refresh ( ) ; » Test Bean « » test Bean « = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Value Field « . class ) ; ctx . refresh ( ) ; » Test Bean « » test Bean « = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » custom Name « " ) ) . » is True « ( ) ; » Test Bean « a = ctx . » get Bean « ( " a " , » Test Bean « . class ) ; » Test Bean « b = ctx . » get Bean « ( " b " , » Test Bean « . class ) ; » assert That « ( b ) . » is Same As « ( a . » get Spouse « ( ) ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( ) ; ctx . » register Bean Definition « ( " a " , new » Root Bean Definition « ( » Configuration Class Post Processor « . class ) ) ; ctx . » register Bean Definition « ( " b " , new » Root Bean Definition « ( » Configuration Class Post Processor « . class ) ) ; ctx . » register Bean Definition « ( " » my Config « " , new » Root Bean Definition « ( Config . class ) ) ; ctx . refresh ( ) ; }
@Test { new » Annotation Config Application Context « ( Config . class ) . » get Bean « ( » Example Bean « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Multi Meta Import Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Bean 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Bean 2 « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Multi Meta Import Config With Local Import « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Bean 1 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Bean 2 « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » test Bean 3 « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » First Level Sub Config « . class ) ; » assert That « ( ctx . » contains Bean « ( " » xml Declared Bean « " ) ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Second Level Sub Config « . class ) ; » assert That « ( ctx . » contains Bean « ( " » second Level Xml Declared Bean « " ) ) . as ( " failed to pick up second - level - declared XML bean " ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » xml Declared Bean « " ) ) . as ( " failed to pick up parent - declared XML bean " ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Import Xml With Aop Namespace Config « . class ) ; Object bean = ctx . » get Bean « ( " » proxied Xml Bean « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Import Xml Autowired Config « . class ) ; String name = ctx . » get Bean « ( " » xml Bean Name « " , String . class ) ; » assert That « ( name ) . » is Equal To « ( " xml . declared " ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Import Non Xml Resource Config « . class ) ; » assert That « ( ctx . » contains Bean « ( " » properties Declared Bean « " ) ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { this . context . register ( » Conditional Then Unconditional « . class ) ; this . context . refresh ( ) ; » assert That « ( this . context . » contains Bean « ( " » bean Two « " ) ) . » is False « ( ) ; » assert That « ( this . context . » contains Bean « ( " » bean One « " ) ) . » is True « ( ) ; }
@Test { this . context . register ( » Unconditional Then Conditional « . class ) ; this . context . refresh ( ) ; » assert That « ( this . context . » contains Bean « ( " » bean Two « " ) ) . » is False « ( ) ; » assert That « ( this . context . » contains Bean « ( " » bean One « " ) ) . » is True « ( ) ; }
@Test { » autowired Config Class Is Enhanced « ( » Config That Does Import « . class ) ; }
@Test { » autowired Config Class Is Enhanced « ( » Config That Does Not Import « . class , » Config To Be Autowired « . class ) ; }
@Test { » autowired Config Class Bean Methods Respect Scoping « ( » Config That Does Import « . class ) ; }
@Test { » autowired Config Class Bean Methods Respect Scoping « ( » Config That Does Not Import « . class , » Config To Be Autowired « . class ) ; }
@Test { » Application Context « ctx = new » Annotation Config Application Context « ( » Config That Imports Non Config Class « . class ) ; » Config That Imports Non Config Class « config = ctx . » get Bean « ( » Config That Imports Non Config Class « . class ) ; » assert That « ( config . » test Bean « ) . » is Same As « ( ctx . » get Bean « ( » Test Bean « . class ) ) ; }
@Test { » generic Test Scope « ( " » scoped Class « " ) ; }
@Test { » generic Test Scope « ( " » scoped Interface « " ) ; }
@Test { String » bean Name « = " » scoped Proxy Interface « " ; Object bean = ctx . » get Bean « ( " » scoped Target « . " + » bean Name « ) ; boolean condition = bean instanceof » Scoped Object « ; » assert That « ( condition ) . » is False « ( ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( » Autowired Configuration Tests « . class . » get Simple Name « ( ) + " . xml " , » Autowired Configuration Tests « . class ) ; » assert That « ( context . » get Bean « ( " colour " , Colour . class ) ) . » is Equal To « ( Colour . RED ) ; » assert That « ( context . » get Bean « ( " » test Bean « " , » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( Colour . RED . » to String « ( ) ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Autowired Method Config « . class , » Color Config « . class ) ; » assert That « ( context . » get Bean « ( Colour . class ) ) . » is Equal To « ( Colour . RED ) ; » assert That « ( context . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " RED - RED " ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Optional Autowired Method Config « . class , » Color Config « . class ) ; » assert That « ( context . » get Bean « ( Colour . class ) ) . » is Equal To « ( Colour . RED ) ; » assert That « ( context . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " RED - RED " ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Optional Autowired Method Config « . class ) ; » assert That « ( context . » get Beans Of Type « ( Colour . class ) . » is Empty « ( ) ) . » is True « ( ) ; » assert That « ( context . » get Bean « ( » Test Bean « . class ) . » get Name « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " » Value Injection Tests « . xml " , » Autowired Configuration Tests « . class ) ; » do Test Value Injection « ( context ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Value Config With Meta Annotation « . class ) ; » do Test Value Injection « ( context ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Value Config With Aliased Meta Annotation « . class ) ; » do Test Value Injection « ( context ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Value Config With Provider Fields « . class ) ; » do Test Value Injection « ( context ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Value Config With Provider Constructor Arguments « . class ) ; » do Test Value Injection « ( context ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( » Value Config With Provider Method Arguments « . class ) ; » do Test Value Injection « ( context ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " » Autowired Configuration Tests « - custom . xml " , » Autowired Configuration Tests « . class ) ; » Test Bean « » test Bean « = context . » get Bean « ( " » test Bean « " , » Test Bean « . class ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " localhost " ) ; » assert That « ( » test Bean « . » get Age « ( ) ) . » is Equal To « ( » content Length « ( ) ) ; }
@Test { int » config Classes « = 3 ; int » beans In Classes « = 3 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » Configuration With Import Annotation « . class , » Other Configuration With Import Annotation « . class ) ; }
@Test { int » config Classes « = 2 ; int » beans In Classes « = 2 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » Other Configuration « . class , » Configuration With Import Annotation « . class ) ; }
@Test { int » config Classes « = 2 ; int » beans In Classes « = 2 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » Configuration With Import Annotation « . class , » Other Configuration « . class ) ; }
@Test { int » config Classes « = 2 ; int » beans In Classes « = 3 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » App Config « . class ) ; }
@Test { int » config Classes « = 4 ; int » beans In Classes « = 5 ; » assert Bean Definition Count « ( » config Classes « + » beans In Classes « , » First Level « . class ) ; }
@Test { int » config Classes « = 3 ; int » beans In Classes « = 3 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » With Multiple Arguments To Import Annotation « . class ) ; }
@Test { int » config Classes « = 2 ; int » beans In Classes « = 2 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » Outer Config « . » Inner Config « . class ) ; }
@Test { int » config Classes « = 2 ; int » beans In Classes « = 0 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » Config Annotated « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( B . class ) ; ctx . refresh ( ) ; System . out . println ( ctx . » get Bean Factory « ( ) ) ; » assert That « ( ctx . » get Bean Names For Type « ( B . class ) [ 0 ] ) . » is Equal To « ( " config - b " ) ; » assert That « ( ctx . » get Bean Names For Type « ( A . class ) [ 0 ] ) . » is Equal To « ( " config - a " ) ; }
@Test { int » config Classes « = 2 ; int » beans In Classes « = 2 ; » assert Bean Definition Count « ( ( » config Classes « + » beans In Classes « ) , » Configuration With Import Annotation « . class ) ; }
@Test { @ Configuration class Config { @ Bean ( autowire = Autowire . » BY _ TYPE « ) Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » get Autowire Mode « ( ) ) . as ( " autowire mode was not propagated " ) . » is Equal To « ( » Abstract Bean Definition « . » AUTOWIRE _ BY _ TYPE « ) ; }
@Test { @ Configuration class Config { @ Bean ( » autowire Candidate « = false ) Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Autowire Candidate « ( ) ) . as ( " autowire candidate flag was not propagated " ) . » is False « ( ) ; }
@Test { @ Configuration class Config { @ Bean ( » init Method « = " start " ) Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » get Init Method Name « ( ) ) . as ( " init method name was not propagated " ) . » is Equal To « ( " start " ) ; }
@Test { @ Configuration class Config { @ Bean ( » destroy Method « = " destroy " ) Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » get Destroy Method Name « ( ) ) . as ( " destroy method name was not propagated " ) . » is Equal To « ( " destroy " ) ; }
@Test { @ Configuration class Config { @ Bean ( ) @ » Depends On « ( { " bar " , " baz " } ) Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » get Depends On « ( ) ) . as ( " » depends On « metadata was not propagated " ) . » is Equal To « ( new String [ ] { " bar " , " baz " } ) ; }
@Test { @ Configuration class Config { @ Primary @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Primary « ( ) ) . as ( " primary metadata was not propagated " ) . » is True « ( ) ; }
@Test { @ Configuration class Config { @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Primary « ( ) ) . as ( " @ Bean methods should be non - primary by default " ) . » is False « ( ) ; }
@Test { @ Configuration class Config { @ Lazy @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Lazy Init « ( ) ) . as ( " lazy metadata was not propagated " ) . » is True « ( ) ; }
@Test { @ Configuration class Config { @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Lazy Init « ( ) ) . as ( " @ Bean methods should be non - lazy by default " ) . » is False « ( ) ; }
@Test { @ Lazy @ Configuration class Config { @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Lazy Init « ( ) ) . as ( " @ Bean methods declared in a @ Lazy @ Configuration should be lazily instantiated " ) . » is True « ( ) ; }
@Test { @ Lazy @ Configuration class Config { @ Lazy ( false ) @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Lazy Init « ( ) ) . as ( " @ Lazy ( false ) @ Bean methods declared in a @ Lazy @ Configuration should be eagerly instantiated " ) . » is False « ( ) ; }
@Test { @ Lazy ( false ) @ Configuration class Config { @ Bean Object foo ( ) { return null ; } } » assert That « ( » bean Def « ( Config . class ) . » is Lazy Init « ( ) ) . as ( " @ Lazy ( false ) @ Configuration should produce eager bean definitions " ) . » is False « ( ) ; }
@Test { » custom Bean Name Is Respected « ( » Config With Bean With Custom Name « . class , ( ) -> » Config With Bean With Custom Name « . » test Bean « , " » custom Name « " ) ; }
@Test { » custom Bean Name Is Respected « ( » Config With Bean With Custom Name Configured Via Value Attribute « . class , ( ) -> » Config With Bean With Custom Name Configured Via Value Attribute « . » test Bean « , " enigma " ) ; }
@Test { » aliases Are Respected « ( » Config With Bean With Aliases « . class , ( ) -> » Config With Bean With Aliases « . » test Bean « , " » name 1 « " ) ; }
@Test { » aliases Are Respected « ( » Config With Bean With Aliases Configured Via Value Attribute « . class , ( ) -> » Config With Bean With Aliases Configured Via Value Attribute « . » test Bean « , " enigma " ) ; }
@Test { » Generic Application Context « ac = new » Generic Application Context « ( ) ; » Annotation Config Utils « . » register Annotation Config Processors « ( ac ) ; ac . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Config With Bean With Provider Implementation « . class ) ) ; ac . refresh ( ) ; » assert That « ( » Config With Bean With Provider Implementation « . » test Bean « ) . » is Same As « ( ac . » get Bean « ( " » custom Name « " ) ) ; }
@Test { » Generic Application Context « ac = new » Generic Application Context « ( ) ; » Annotation Config Utils « . » register Annotation Config Processors « ( ac ) ; ac . » register Bean Definition « ( " config " , new » Root Bean Definition « ( » Config With Set With Provider Implementation « . class ) ) ; ac . refresh ( ) ; » assert That « ( » Config With Set With Provider Implementation « . set ) . » is Same As « ( ac . » get Bean « ( " » custom Name « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Parsing Exception « . class ) . » is Thrown By « ( ( ) -> » init Bean Factory « ( » Config With Final Bean « . class ) ) ; }
@Test { » Bean Factory « factory = » init Bean Factory « ( » Simplest Possible Config « . class ) ; String » string Bean « = factory . » get Bean « ( " » string Bean « " , String . class ) ; » assert That « ( » string Bean « ) . » is Equal To « ( " foo " ) ; }
@Test { » Bean Factory « factory = » init Bean Factory « ( » Config With Non Specific Return Types « . class ) ; » assert That « ( factory . » get Type « ( " » string Bean « " ) ) . » is Equal To « ( Object . class ) ; » assert That « ( factory . » is Type Match « ( " » string Bean « " , String . class ) ) . » is False « ( ) ; String » string Bean « = factory . » get Bean « ( " » string Bean « " , String . class ) ; » assert That « ( » string Bean « ) . » is Equal To « ( " foo " ) ; }
@Test { » Bean Factory « factory = » init Bean Factory « ( » Config With Null Reference « . class ) ; » Test Bean « foo = factory . » get Bean « ( " foo " , » Test Bean « . class ) ; » assert That « ( factory . » get Bean « ( " bar " ) . equals ( null ) ) . » is True « ( ) ; » assert That « ( foo . » get Spouse « ( ) ) . » is Null « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Functional Registration « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Test Bean « . class ) . » get Spouse « ( ) ) . » is Same As « ( ctx . » get Bean « ( " spouse " ) ) ; » assert That « ( ctx . » get Bean « ( » Nested Test Bean « . class ) . » get Company « ( ) ) . » is Equal To « ( " functional " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Config With Application Listener « . class ) ; ctx . refresh ( ) ; » Config With Application Listener « config = ctx . » get Bean « ( » Config With Application Listener « . class ) ; » assert That « ( config . closed ) . » is False « ( ) ; ctx . close ( ) ; » assert That « ( config . closed ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . scan ( " org . springframework . context . annotation . configuration . » spr 8955 « " ) ; ctx . refresh ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » High Level Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Low Level Config « . class ) . scanned ) . » is Not Null « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Low Level Config « . class ) ; ctx . refresh ( ) ; » assert That « ( ctx . » get Bean « ( » Low Level Config « . class ) . scanned ) . » is Not Null « ( ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing Config « . class , » A Enclosing Config « . » Child Config « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; context = ctx ; ctx . scan ( » A Enclosing Config « . class . » get Package « ( ) . » get Name « ( ) ) ; ctx . refresh ( ) ; » assert That « ( context . » get Bean « ( " » my Bean « " , String . class ) ) . » is Equal To « ( " » my Bean « " ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing With Import Resource Config « . class , » A Enclosing With Import Resource Config « . » Child Config « . class ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing With Component Scan Config « . class , » A Enclosing With Component Scan Config « . » Child Config « . class ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing With Grandparent Config « . class , » A Enclosing With Grandparent Config « . » Child Config « . class ) ; }
@Test { » assert Loads My Bean « ( » Import Child Config « . class , » Child Config « . class ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing With Import Config « . class , » A Enclosing With Import Config « . » Child Config « . class ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing Config « . » Child Config « . class , » A Enclosing Config « . class ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing Config « . class ) ; }
@Test { » assert Loads My Bean « ( » A Enclosing Config « . » Child Config « . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Property Sources Placeholder Configurer « . class ) ; ctx . register ( » Import Configuration « . class ) ; ctx . refresh ( ) ; ctx . close ( ) ; }
@Test { » Test Import « . scanned = false ; » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . scan ( » Test Import « . class . » get Package « ( ) . » get Name « ( ) ) ; context . refresh ( ) ; context . » get Bean « ( » Test Configuration « . class ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . register ( » Scanning Configuration « . class ) ; context . refresh ( ) ; context . » get Bean « ( » Scanned Component « . class ) ; context . » get Bean « ( » Scanned Component « . State . class ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . scan ( » get Class « ( ) . » get Package « ( ) . » get Name « ( ) ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " » with Nested Annotation « " ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( Config . class ) ; ctx . refresh ( ) ; }
@Test { » Application Context « » application Context « = new » Class Path Xml Application Context « ( " » context Namespace Handler Tests « - replace . xml " , » get Class « ( ) ) ; » assert That « ( » application Context « . » get Bean « ( " string " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( » application Context « . » get Bean « ( " » null String « " ) ) . » is Equal To « ( " null " ) ; }
@Test { » Application Context « » application Context « = new » Class Path Xml Application Context « ( " » context Namespace Handler Tests « - location . xml " , » get Class « ( ) ) ; » assert That « ( » application Context « . » get Bean « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( » application Context « . » get Bean « ( " bar " ) ) . » is Equal To « ( " foo " ) ; » assert That « ( » application Context « . » get Bean « ( " spam " ) ) . » is Equal To « ( " maps " ) ; }
@Test { » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " » context Namespace Handler Tests « - location - placeholder . xml " , » get Class « ( ) ) ) . satisfies ( ex -> » assert That « ( ex . » get Root Cause « ( ) ) . » is Instance Of « ( » Illegal Argument Exception « . class ) . » has Message « ( " Could not resolve placeholder 'foo' in value \" $ { foo } \" " ) ) ; }
@Test { » Application Context « » application Context « = new » Class Path Xml Application Context « ( " » context Namespace Handler Tests « - replace - ignore . xml " , » get Class « ( ) ) ; » assert That « ( » application Context « . » get Bean « ( " string " ) ) . » is Equal To « ( " $ { bar } " ) ; » assert That « ( » application Context « . » get Bean « ( " » null String « " ) ) . » is Equal To « ( " null " ) ; }
@Test { » Application Context « » application Context « = new » Class Path Xml Application Context « ( " » context Namespace Handler Tests « - override . xml " , » get Class « ( ) ) ; Date date = ( Date ) » application Context « . » get Bean « ( " date " ) ; Calendar calendar = Calendar . » get Instance « ( ) ; calendar . » set Time « ( date ) ; » assert That « ( calendar . get ( Calendar . MINUTE ) ) . » is Equal To « ( 42 ) ; }
@Test { » Application Context « ac = new » Annotation Config Application Context « ( » Auditable Listener « . class ) ; » Auditable Payload Event « event = new » Auditable Payload Event « < > ( this , " xyz " ) ; ac . » publish Event « ( event ) ; » assert That « ( ac . » get Bean « ( » Auditable Listener « . class ) . events . contains ( event ) ) . » is True « ( ) ; }
@Test { » Smart Application Listener « » smart Listener « = mock ( » Smart Application Listener « . class ) ; » Generic Application Listener Adapter « listener = new » Generic Application Listener Adapter « ( » smart Listener « ) ; » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Application Event « . class ) ; listener . » supports Event Type « ( type ) ; verify ( » smart Listener « , times ( 1 ) ) . » supports Event Type « ( » Application Event « . class ) ; }
@Test { » Smart Application Listener « » smart Listener « = mock ( » Smart Application Listener « . class ) ; » Generic Application Listener Adapter « listener = new » Generic Application Listener Adapter « ( » smart Listener « ) ; listener . » supports Source Type « ( Object . class ) ; verify ( » smart Listener « , times ( 1 ) ) . » supports Source Type « ( Object . class ) ; }
@Test { » supports Event Type « ( true , » String Event Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ) ; }
@Test { » Generic Test Event « < String > » string Event « = » create Generic Test Event « ( " test " ) ; » Resolvable Type « » event Type « = » Resolvable Type « . » for Type « ( » string Event « . » get Class « ( ) ) ; » supports Event Type « ( false , » String Event Listener « . class , » event Type « ) ; }
@Test { » Resolvable Type « » event Type « = » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ; » supports Event Type « ( true , » String Event Listener « . class , » event Type « ) ; }
@Test { » Resolvable Type « » event Type « = new » Smart Generic Test Event « < > ( this , " foo " ) . » get Resolvable Type « ( ) ; » supports Event Type « ( true , » String Event Listener « . class , » event Type « ) ; }
@Test { » String Event « » string Event « = new » String Event « ( this , " test " ) ; » Resolvable Type « » event Type « = » Resolvable Type « . » for Type « ( » string Event « . » get Class « ( ) ) ; » supports Event Type « ( true , » String Event Listener « . class , » event Type « ) ; }
@Test { » supports Event Type « ( false , » String Event Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , Long . class ) ) ; }
@Test { » Long Event « » string Event « = new » Long Event « ( this , 123L ) ; » Resolvable Type « » event Type « = » Resolvable Type « . » for Type « ( » string Event « . » get Class « ( ) ) ; » supports Event Type « ( false , » String Event Listener « . class , » event Type « ) ; }
@Test { » Generic Test Event « < Long > » long Event « = » create Generic Test Event « ( 123L ) ; » Resolvable Type « » event Type « = » Resolvable Type « . » for Type « ( » long Event « . » get Class « ( ) ) ; » supports Event Type « ( false , » String Event Listener « . class , » event Type « ) ; }
@Test { » supports Event Type « ( false , » Object Event Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , Long . class ) ) ; }
@Test { » supports Event Type « ( true , » Upper Bound Event Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , » Illegal State Exception « . class ) ) ; }
@Test { » supports Event Type « ( false , » Upper Bound Event Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , » IO Exception « . class ) ) ; }
@Test { » supports Event Type « ( true , » Generic Event Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ) ; }
@Test { » Generic Test Event « < String > » string Event « = » create Generic Test Event « ( " test " ) ; » Resolvable Type « » event Type « = » Resolvable Type « . » for Type « ( » string Event « . » get Class « ( ) ) ; » supports Event Type « ( true , » Generic Event Listener « . class , » event Type « ) ; }
@Test { » supports Event Type « ( true , » Raw Application Listener « . class , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ) ; }
@Test { » Generic Test Event « < String > » string Event « = » create Generic Test Event « ( " test " ) ; » Resolvable Type « » event Type « = » Resolvable Type « . » for Type « ( » string Event « . » get Class « ( ) ) ; » supports Event Type « ( true , » Raw Application Listener « . class , » event Type « ) ; }
@Test { load ( » Meta Annotation Listener Test Bean « . class ) ; » Meta Annotation Listener Test Bean « bean = this . context . » get Bean « ( » Meta Annotation Listener Test Bean « . class ) ; this . » event Collector « . » assert No Event Received « ( bean ) ; » Test Event « event = new » Test Event « ( ) ; this . context . » publish Event « ( event ) ; this . » event Collector « . » assert Event « ( bean , event ) ; this . » event Collector « . » assert Total Events Count « ( 1 ) ; }
@Test { @ » Suppress Warnings « ( " resource " ) » Annotation Config Application Context « » failing Context « = new » Annotation Config Application Context « ( ) ; » failing Context « . register ( » Basic Configuration « . class , » Invalid Method Signature Event Listener « . class ) ; » assert That Exception Of Type « ( » Bean Initialization Exception « . class ) . » is Thrown By « ( ( ) -> » failing Context « . refresh ( ) ) . » with Message Containing « ( » Invalid Method Signature Event Listener « . class . » get Name « ( ) ) . » with Message Containing « ( " » cannot Be Called « " ) ; }
@Test { » assert That Exception Of Type « ( » Bean Initialization Exception « . class ) . » is Thrown By « ( ( ) -> load ( » Cglib Proxy With Private Method « . class ) ) . » with Cause Instance Of « ( » Illegal State Exception « . class ) ; }
@Test { » load Async « ( » Exception Event Listener « . class ) ; » Another Test Event « event = new » Another Test Event « ( this , " fail " ) ; » Exception Event Listener « listener = this . context . » get Bean « ( » Exception Event Listener « . class ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; this . context . » publish Event « ( event ) ; this . » count Down Latch « . await ( 2 , » Time Unit « . SECONDS ) ; this . » event Collector « . » assert Event « ( listener , event ) ; this . » event Collector « . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » Test Event Listener « . class ) ; » Test Event Listener « listener = this . context . » get Bean « ( » Test Event Listener « . class ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; this . context . » publish Event « ( " test " ) ; this . » event Collector « . » assert Event « ( listener , " test " ) ; this . » event Collector « . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » Test Event Listener « . class ) ; » Test Event Listener « listener = this . context . » get Bean « ( » Test Event Listener « . class ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; this . context . » publish Event « ( 123L ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; this . » event Collector « . » assert Total Events Count « ( 0 ) ; }
@Test { load ( » Generic Event Listener « . class ) ; » Generic Event Listener « listener = this . context . » get Bean « ( » Generic Event Listener « . class ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; this . context . » publish Event « ( " TEST " ) ; this . » event Collector « . » assert Event « ( listener , " TEST " ) ; this . » event Collector « . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » Resolvable Type Event Listener « . class ) ; » Resolvable Type Event Listener « listener = this . context . » get Bean « ( » Resolvable Type Event Listener « . class ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; » Generic Event Pojo « < String > event = new » Generic Event Pojo « < > ( " TEST " ) ; this . context . » publish Event « ( event ) ; this . » event Collector « . » assert Event « ( listener , event ) ; this . » event Collector « . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » Resolvable Type Event Listener « . class ) ; » Resolvable Type Event Listener « listener = this . context . » get Bean « ( » Resolvable Type Event Listener « . class ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; » Generic Event Pojo « < Long > event = new » Generic Event Pojo « < > ( 123L ) ; this . context . » publish Event « ( event ) ; this . » event Collector « . » assert No Event Received « ( listener ) ; this . » event Collector « . » assert Total Events Count « ( 0 ) ; }
@Test { » validate Condition Match « ( » Conditional Event Listener « . class ) ; }
@Test { » validate Condition Match « ( » Conditional Event Listener « . class , » Method Validation Post Processor « . class ) ; }
@Test { load ( » Ordered Test Listener « . class ) ; » Ordered Test Listener « listener = this . context . » get Bean « ( » Ordered Test Listener « . class ) ; » assert That « ( listener . order . » is Empty « ( ) ) . » is True « ( ) ; this . context . » publish Event « ( " whatever " ) ; » assert That « ( listener . order ) . contains ( " first " , " second " , " third " ) ; }
@Test { load ( » Event On Post Construct « . class , » Ordered Test Listener « . class ) ; » Ordered Test Listener « listener = this . context . » get Bean « ( » Ordered Test Listener « . class ) ; » assert That « ( listener . order ) . contains ( " first " , " second " , " third " ) ; }
@Test { load ( » Missing Event Listener « . class ) ; context . » get Bean « ( » Use Missing Event Listener « . class ) ; context . » get Bean « ( » Application Event Multicaster « . class ) . » multicast Event « ( new » Test Event « ( this ) ) ; }
@Test { » multicast Event « ( true , » Application Listener « . class , new » Context Refreshed Event « ( new » Static Application Context « ( ) ) , null ) ; » multicast Event « ( true , » Application Listener « . class , new » Context Closed Event « ( new » Static Application Context « ( ) ) , null ) ; }
@Test { » multicast Event « ( true , » String Event Listener « . class , » create Generic Test Event « ( " test " ) , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ) ; }
@Test { » multicast Event « ( false , » String Event Listener « . class , » create Generic Test Event « ( 123L ) , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , Long . class ) ) ; }
@Test { » multicast Event « ( false , » String Event Listener « . class , » create Generic Test Event « ( " test " ) , » get Generic Application Event Type « ( " » wildcard Event « " ) ) ; }
@Test { » multicast Event « ( true , » String Event Listener « . class , new » String Event « ( this , " test " ) , null ) ; }
@Test { » multicast Event « ( false , » String Event Listener « . class , new » Long Event « ( this , 123L ) , null ) ; }
@Test { » multicast Event « ( true , » String Event Listener « . class , new » Smart Generic Test Event « < > ( this , " test " ) , null ) ; }
@Test { » multicast Event « ( false , » String Event Listener « . class , new » Smart Generic Test Event « < > ( this , 123L ) , null ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; » Application Listener « < » Application Event « > listener = event -> { throw new » Class Cast Exception « ( event . » get Class « ( ) . » get Name « ( ) ) ; } ; context . » add Application Listener « ( listener ) ; context . refresh ( ) ; context . » publish Event « ( new » My Event « ( context ) ) ; context . close ( ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; » Application Listener « < » Application Event « > listener = event -> { throw new » Class Cast Exception « ( " spring . context / " + event . » get Class « ( ) . » get Name « ( ) ) ; } ; context . » add Application Listener « ( listener ) ; context . refresh ( ) ; context . » publish Event « ( new » My Event « ( context ) ) ; context . close ( ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Raw « " , » Application Event « . class ) ; » supports Event Type « ( true , method , » Resolvable Type « . » for Class « ( » Application Event « . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Raw « " , » Application Event « . class ) ; » supports Event Type « ( true , method , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String « " , » Generic Test Event « . class ) ; » supports Event Type « ( true , method , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , String . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String « " , » Generic Test Event « . class ) ; » supports Event Type « ( false , method , » Resolvable Type « . » for Class With Generics « ( » Generic Test Event « . class , Long . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » supports Event Type « ( true , method , » create Generic Event Type « ( String . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » supports Event Type « ( false , method , » create Generic Event Type « ( Integer . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » supports Event Type « ( true , method , » Resolvable Type « . » for Class « ( » Payload Application Event « . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » supports Event Type « ( true , method , » Resolvable Type « . » for Class « ( » Payload Test Event « . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » supports Event Type « ( true , method , » Resolvable Type « . » for Class « ( » Payload String Test Event « . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String Annotation Value « " ) ; » supports Event Type « ( true , method , » create Generic Event Type « ( String . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String Annotation Classes « " ) ; » supports Event Type « ( true , method , » create Generic Event Type « ( String . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String Annotation Value And Parameter « " , String . class ) ; » supports Event Type « ( true , method , » create Generic Event Type « ( String . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String Or Integer « " ) ; » supports Event Type « ( true , method , » create Generic Event Type « ( String . class ) ) ; » supports Event Type « ( true , method , » create Generic Event Type « ( Integer . class ) ) ; » supports Event Type « ( false , method , » create Generic Event Type « ( Double . class ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » too Many Parameters « " , String . class , String . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » create Test Instance « ( method ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » no Parameter « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » create Test Instance « ( method ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » more Than One Parameter « " , String . class , Integer . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » create Test Instance « ( method ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String « " , » Generic Test Event « . class ) ; » Application Listener Method Adapter « adapter = » create Test Instance « ( method ) ; » assert That « ( adapter . » get Order « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Raw « " , » Application Event « . class ) ; » Application Listener Method Adapter « adapter = » create Test Instance « ( method ) ; » assert That « ( adapter . » get Order « ( ) ) . » is Equal To « ( 42 ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String « " , » Generic Test Event « . class ) ; » Generic Test Event « < String > event = » create Generic Test Event « ( " test " ) ; » invoke Listener « ( method , event ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle Generic String « ( event ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String « " , » Generic Test Event « . class ) ; » Generic Test Event « < String > event = new » Smart Generic Test Event « < > ( this , " test " ) ; » invoke Listener « ( method , event ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle Generic String « ( event ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String Payload « " , » Entity Wrapper « . class ) ; » Entity Wrapper « < String > payload = new » Entity Wrapper « < > ( " test " ) ; » invoke Listener « ( method , new » Payload Application Event « < > ( this , payload ) ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle Generic String Payload « ( payload ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic String Payload « " , » Entity Wrapper « . class ) ; » Entity Wrapper « < Integer > payload = new » Entity Wrapper « < > ( 123 ) ; » invoke Listener « ( method , new » Payload Application Event « < > ( this , payload ) ) ; verify ( this . » sample Events « , times ( 0 ) ) . » handle Generic String Payload « ( any ( ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle Generic Any Payload « " , » Entity Wrapper « . class ) ; » Entity Wrapper « < String > payload = new » Entity Wrapper « < > ( " test " ) ; » invoke Listener « ( method , new » Payload Application Event « < > ( this , payload ) ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle Generic Any Payload « ( payload ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » generate Runtime Exception « " , » Generic Test Event « . class ) ; » Generic Test Event « < String > event = » create Generic Test Event « ( " fail " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Listener « ( method , event ) ) . » with Message Containing « ( " Test exception " ) . » with No Cause « ( ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » generate Checked Exception « " , » Generic Test Event « . class ) ; » Generic Test Event « < String > event = » create Generic Test Event « ( " fail " ) ; » assert That Exception Of Type « ( » Undeclared Throwable Exception « . class ) . » is Thrown By « ( ( ) -> » invoke Listener « ( method , event ) ) . » with Cause Instance Of « ( » IO Exception « . class ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » Payload Application Event « < String > event = new » Payload Application Event « < > ( this , " test " ) ; » invoke Listener « ( method , event ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle String « ( " test " ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String « " , String . class ) ; » Payload Application Event « < Long > event = new » Payload Application Event « < > ( this , 123L ) ; » invoke Listener « ( method , event ) ; verify ( this . » sample Events « , never ( ) ) . » handle String « ( » any String « ( ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String Annotation Classes « " ) ; » Payload Application Event « < String > event = new » Payload Application Event « < > ( this , " test " ) ; » invoke Listener « ( method , event ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle String Annotation Classes « ( ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » handle String Annotation Value And Parameter « " , String . class ) ; » Payload Application Event « < String > event = new » Payload Application Event « < > ( this , " test " ) ; » invoke Listener « ( method , event ) ; verify ( this . » sample Events « , times ( 1 ) ) . » handle String Annotation Value And Parameter « ( " test " ) ; }
@Test { » Event Publication Interceptor « interceptor = new » Event Publication Interceptor « ( ) ; interceptor . » set Application Event Publisher « ( this . publisher ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( interceptor :: » after Properties Set « ) ; }
@Test { » Event Publication Interceptor « interceptor = new » Event Publication Interceptor « ( ) ; interceptor . » set Application Event Publisher « ( this . publisher ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { interceptor . » set Application Event Class « ( » get Class « ( ) ) ; interceptor . » after Properties Set « ( ) ; } ) ; }
@Test { » Event Publication Interceptor « interceptor = new » Event Publication Interceptor « ( ) ; interceptor . » set Application Event Publisher « ( this . publisher ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { interceptor . » set Application Event Class « ( » Application Event « . class ) ; interceptor . » after Properties Set « ( ) ; } ) ; }
@Test { » Event Publication Interceptor « interceptor = new » Event Publication Interceptor « ( ) ; interceptor . » set Application Event Publisher « ( this . publisher ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { interceptor . » set Application Event Class « ( » Test Event With No Valid One Arg Object Ctor « . class ) ; interceptor . » after Properties Set « ( ) ; } ) ; }
@Test { » Annotated Element Key « instance = new » Annotated Element Key « ( this . method , » get Class « ( ) ) ; » assert Key Equals « ( instance , instance ) ; }
@Test { » Annotated Element Key « first = new » Annotated Element Key « ( this . method , » get Class « ( ) ) ; » Annotated Element Key « second = new » Annotated Element Key « ( this . method , » get Class « ( ) ) ; » assert Key Equals « ( first , second ) ; }
@Test { » Annotated Element Key « first = new » Annotated Element Key « ( this . method , null ) ; » Annotated Element Key « second = new » Annotated Element Key « ( this . method , null ) ; » assert Key Equals « ( first , second ) ; }
@Test { » Annotated Element Key « first = new » Annotated Element Key « ( this . method , » get Class « ( ) ) ; » Annotated Element Key « second = new » Annotated Element Key « ( this . method , null ) ; » assert That « ( first . equals ( second ) ) . » is False « ( ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » get Class « ( ) , " » to String « " ) ; Expression expression = » expression Evaluator « . » get Test Expression « ( " true " , method , » get Class « ( ) ) ; » has Parsed Expression « ( " true " ) ; » assert That « ( expression . » get Value « ( ) ) . » is Equal To « ( true ) ; » assert That « ( » expression Evaluator « . » test Cache « . size ( ) ) . as ( " Expression should be in cache " ) . » is Equal To « ( 1 ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » get Class « ( ) , " » to String « " ) ; » expression Evaluator « . » get Test Expression « ( " true " , method , » get Class « ( ) ) ; » expression Evaluator « . » get Test Expression « ( " true " , method , Object . class ) ; » assert That « ( » expression Evaluator « . » test Cache « . size ( ) ) . as ( " Cached expression should be based on type " ) . » is Equal To « ( 2 ) ; }
@Test { » Generic Groovy Application Context « ctx = new » Generic Groovy Application Context « ( " org / springframework / context / groovy / » application Context « . groovy " ) ; Object framework = ctx . » get Bean « ( " framework " ) ; » assert That « ( framework ) . as ( " could not find framework bean " ) . » is Not Null « ( ) ; » assert That « ( framework ) . » is Equal To « ( " Grails " ) ; }
@Test { » assert That Exception Of Type « ( » Bean Definition Parsing Exception « . class ) . » is Thrown By « ( ( ) -> new » Generic Groovy Application Context « ( " org / springframework / context / groovy / » application Context « - error . groovy " ) ) ; }
@Test { » Candidate Components Index « index = new » Candidate Components Index « ( Collections . » singleton List « ( » create Sample Properties « ( ) ) ) ; Set < String > actual = index . » get Candidate Types « ( " com . example . service " , " service " ) ; » assert That « ( actual ) . contains ( " com . example . service . One " , " com . example . service . sub . Two " , " com . example . service . Three " ) ; }
@Test { » Candidate Components Index « index = new » Candidate Components Index « ( Collections . » singleton List « ( » create Sample Properties « ( ) ) ) ; Set < String > actual = index . » get Candidate Types « ( " com . example . service . sub " , " service " ) ; » assert That « ( actual ) . contains ( " com . example . service . sub . Two " ) ; }
@Test { » Candidate Components Index « index = new » Candidate Components Index « ( Collections . » singleton List « ( » create Sample Properties « ( ) ) ) ; Set < String > actual = index . » get Candidate Types « ( " com . example . service . none " , " service " ) ; » assert That « ( actual ) . » is Empty « ( ) ; }
@Test { » Candidate Components Index « index = new » Candidate Components Index « ( Collections . » singleton List « ( » create Sample Properties « ( ) ) ) ; Set < String > actual = index . » get Candidate Types « ( " com . example . service " , " entity " ) ; » assert That « ( actual ) . » is Empty « ( ) ; }
@Test { » Candidate Components Index « index = new » Candidate Components Index « ( Arrays . » as List « ( » create Properties « ( " com . example . Foo " , " service " ) , » create Properties « ( " com . example . Foo " , " entity " ) ) ) ; » assert That « ( index . » get Candidate Types « ( " com . example " , " service " ) ) . contains ( " com . example . Foo " ) ; » assert That « ( index . » get Candidate Types « ( " com . example " , " entity " ) ) . contains ( " com . example . Foo " ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( null ) ; » assert That « ( index ) . as ( " No spring . components should be available at the default location " ) . » is Null « ( ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( » Candidate Components Test Class Loader « . index ( » get Class « ( ) . » get Class Loader « ( ) , new » Class Path Resource « ( " spring . components " , » get Class « ( ) ) ) ) ; Set < String > components = index . » get Candidate Types « ( " org . springframework " , " foo " ) ; » assert That « ( components ) . contains ( " org . springframework . context . index . » Sample 1 « " , " org . springframework . context . index . » Sample 2 « " ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( » Candidate Components Test Class Loader « . index ( » get Class « ( ) . » get Class Loader « ( ) , new » Class Path Resource « ( " spring . components " , » get Class « ( ) ) ) ) ; Set < String > components = index . » get Candidate Types « ( " org . springframework " , " biz " ) ; » assert That « ( components ) . contains ( " org . springframework . context . index . » Sample 3 « " ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( » Candidate Components Test Class Loader « . index ( » get Class « ( ) . » get Class Loader « ( ) , new » Class Path Resource « ( " spring . components " , » get Class « ( ) ) ) ) ; Set < String > components = index . » get Candidate Types « ( " org . springframework " , " none " ) ; » assert That « ( components ) . » is Empty « ( ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( » Candidate Components Test Class Loader « . index ( » get Class « ( ) . » get Class Loader « ( ) , new » Class Path Resource « ( " spring . components " , » get Class « ( ) ) ) ) ; Set < String > components = index . » get Candidate Types « ( " com . example " , " foo " ) ; » assert That « ( components ) . » is Empty « ( ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ; » assert That « ( index ) . » is Null « ( ) ; }
@Test { » Candidate Components Index « index = » Candidate Components Index Loader « . » load Index « ( » Candidate Components Test Class Loader « . index ( » get Class « ( ) . » get Class Loader « ( ) , new » Class Path Resource « ( " empty - spring . components " , » get Class « ( ) ) ) ) ; » assert That « ( index ) . » is Null « ( ) ; }
@Test { final » IO Exception « cause = new » IO Exception « ( " test exception " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> { » Candidate Components Test Class Loader « » class Loader « = new » Candidate Components Test Class Loader « ( » get Class « ( ) . » get Class Loader « ( ) , cause ) ; » Candidate Components Index Loader « . » load Index « ( » class Loader « ) ; } ) . » with Message Containing « ( " Unable to load indexes " ) . » with Cause « ( cause ) ; }
@Test { » Application Context « ctx = new » Generic Xml Application Context « ( » RELATIVE _ CLASS « , » RESOURCE _ NAME « ) ; » assert That « ( ctx . » contains Bean « ( » TEST _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Generic Xml Application Context « ctx = new » Generic Xml Application Context « ( ) ; ctx . load ( » RELATIVE _ CLASS « , » RESOURCE _ NAME « ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » TEST _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Generic Xml Application Context « ( » FQ _ RESOURCE _ PATH « ) ; » assert That « ( ctx . » contains Bean « ( » TEST _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » Generic Xml Application Context « ctx = new » Generic Xml Application Context « ( ) ; ctx . load ( » FQ _ RESOURCE _ PATH « ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( » TEST _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » assert Factory Count Throughout Lifecycle « ( new » Generic Application Context « ( ) ) ; }
@Test { » assert Factory Count Throughout Lifecycle « ( new » Class Path Xml Application Context « ( ) ) ; }
@Test { » Generic Application Context « ctx = new » Generic Application Context « ( ) ; » register Misconfigured Bean Definition « ( ctx ) ; » assert Factory Count Throughout Lifecycle « ( ctx ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( ) { @ Override protected void » customize Bean Factory « ( » Default Listable Bean Factory « » bean Factory « ) { super . » customize Bean Factory « ( » bean Factory « ) ; » register Misconfigured Bean Definition « ( » bean Factory « ) ; } } ; » assert Factory Count Throughout Lifecycle « ( ctx ) ; }
@Test { String name = " » thread Scoped Object « " ; » Test Bean « bean = this . » application Context « . » get Bean « ( name , » Test Bean « . class ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » assert That « ( this . » application Context « . » get Bean « ( name ) ) . » is Same As « ( bean ) ; » Test Bean « » bean 2 « = this . » application Context « . » get Bean « ( name , » Test Bean « . class ) ; » assert That « ( » bean 2 « ) . » is Same As « ( bean ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( " » spr 7283 « . xml " , » get Class « ( ) ) ; List < ? > list = ctx . » get Bean « ( " list " , List . class ) ; » assert That « ( list . size ( ) ) . » is Equal To « ( 2 ) ; boolean » condition 1 « = list . get ( 0 ) instanceof A ; » assert That « ( » condition 1 « ) . » is True « ( ) ; boolean condition = list . get ( 1 ) instanceof B ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » assert Count « ( 15 ) ; }
@Test { » Test Application Event Multicaster « . counter = 0 ; super . events ( ) ; » assert That « ( » Test Application Event Multicaster « . counter ) . » is Equal To « ( 1 ) ; }
@Test { » Static Application Context « ac = new » Static Application Context « ( ) ; ac . » register Singleton « ( " » tb 1 « " , » Test Bean « . class ) ; ac . » register Singleton « ( " » tb 2 « " , » Test Bean « . class ) ; » Test Bean Factory Post Processor « bfpp = new » Test Bean Factory Post Processor « ( ) ; ac . » add Bean Factory Post Processor « ( bfpp ) ; » assert That « ( bfpp . » was Called « ) . » is False « ( ) ; ac . refresh ( ) ; » assert That « ( bfpp . » was Called « ) . » is True « ( ) ; }
@Test { » Static Application Context « ac = new » Static Application Context « ( ) ; ac . » register Singleton « ( " » tb 1 « " , » Test Bean « . class ) ; ac . » register Singleton « ( " » tb 2 « " , » Test Bean « . class ) ; ac . » register Singleton « ( " bfpp " , » Test Bean Factory Post Processor « . class ) ; ac . refresh ( ) ; » Test Bean Factory Post Processor « bfpp = ( » Test Bean Factory Post Processor « ) ac . » get Bean « ( " bfpp " ) ; » assert That « ( bfpp . » was Called « ) . » is True « ( ) ; }
@Test { » Static Application Context « ac = new » Static Application Context « ( ) ; ac . » register Bean Definition « ( " bfpp " , new » Root Bean Definition « ( » Listening Bean Factory Post Processor « . class ) ) ; ac . refresh ( ) ; boolean condition = ac . » get Bean « ( » Listening Bean Factory Post Processor « . class ) . received instanceof » Context Refreshed Event « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » FQ _ SIMPLE _ CONTEXT « ) ; » assert That « ( ctx . » contains Bean « ( " » some Message Source « " ) ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » SIMPLE _ CONTEXT « , » get Class « ( ) ) ; » assert That « ( ctx . » contains Bean « ( " » some Message Source « " ) ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » FQ _ CONTEXT _ B « , » FQ _ ALIASED _ CONTEXT _ C « , » FQ _ CONTEXT _ A « ) ; » assert That « ( ctx . » contains Bean « ( " service " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » logic One « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » logic Two « " ) ) . » is True « ( ) ; ctx . refresh ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » INVALID _ CLASS _ CONTEXT « , » get Class « ( ) ) ; » assert That « ( ctx . » contains Bean « ( " » some Message Source « " ) ) . » is True « ( ) ; » assert That Exception Of Type « ( » Cannot Load Bean Class Exception « . class ) . » is Thrown By « ( ( ) -> ctx . » get Bean « ( " » some Message Source « " ) ) . satisfies ( ex -> » assert That « ( ex . contains ( » Class Not Found Exception « . class ) ) . » is True « ( ) ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » CLASS _ WITH _ PLACEHOLDER _ CONTEXT « , » get Class « ( ) ) ; » assert That « ( ctx . » contains Bean « ( " » some Message Source « " ) ) . » is True « ( ) ; boolean condition = ctx . » get Bean « ( " » some Message Source « " ) instanceof » Static Message Source « ; » assert That « ( condition ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( new String [ ] { » CONTEXT _ B « , » CONTEXT _ C « , » CONTEXT _ A « } , » get Class « ( ) ) ; » assert That « ( ctx . » contains Bean « ( " service " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » logic One « " ) ) . » is True « ( ) ; » assert That « ( ctx . » contains Bean « ( " » logic Two « " ) ) . » is True « ( ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » CONTEXT _ WILDCARD « ) ; ctx . » get Bean Factory « ( ) . » register Singleton « ( " » manual FBAAL « " , new » Factory Bean And Application Listener « ( ) ) ; » assert That « ( ctx . » get Beans Of Type « ( » Application Listener « . class ) . size ( ) ) . » is Equal To « ( 2 ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « ctx = new » Class Path Xml Application Context « ( » FQ _ SIMPLE _ CONTEXT « , » ALIAS _ THAT _ OVERRIDES _ PARENT _ CONTEXT « ) ; Object » my Ms « = ctx . » get Bean « ( " » my Message Source « " ) ; Object » some Ms 2 « = ctx . » get Bean « ( " » some Message Source « " ) ; » assert That « ( » some Ms 2 « ) . » is Same As « ( » my Ms « ) ; » assert One Message Source Only « ( ctx , » my Ms « ) ; }
@Test { » Conversion Service Factory Bean « factory = new » Conversion Service Factory Bean « ( ) ; factory . » after Properties Set « ( ) ; » Conversion Service « service = factory . » get Object « ( ) ; » assert That « ( service . » can Convert « ( String . class , Integer . class ) ) . » is True « ( ) ; }
@Test { » Conversion Service Factory Bean « factory = new » Conversion Service Factory Bean « ( ) ; Set < Object > converters = new » Hash Set « < > ( ) ; converters . add ( " bogus " ) ; factory . » set Converters « ( converters ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( factory :: » after Properties Set « ) ; }
@Test { » do Test Conversion Service In Application Context « ( " » conversion Service « . xml " , » Class Path Resource « . class ) ; }
@Test { » do Test Conversion Service In Application Context « ( " » conversion Service With Resource Overriding « . xml " , » File System Resource « . class ) ; }
@Test { » Configurable Application Context « parent = new » Generic Application Context « ( ) ; parent . refresh ( ) ; » Annotation Config Application Context « child = new » Annotation Config Application Context « ( ) ; child . » set Parent « ( parent ) ; child . refresh ( ) ; » Configurable Environment « env = child . » get Bean « ( » Configurable Environment « . class ) ; » assert That « ( env ) . » is Same As « ( child . » get Environment « ( ) ) ; child . close ( ) ; parent . close ( ) ; }
@Test { » assert That « ( sac . » get Message « ( " message . format . » example 2 « " , null , " This is a default msg if not found in » Message Source « . " , Locale . US ) . equals ( " This is a test message in the message catalog with no args . " ) ) . as ( " valid msg from » static Msg Source « with default msg passed in returned msg from msg catalog for Locale . US " ) . » is True « ( ) ; }
@Test { » assert That « ( sac . » get Message « ( " bogus . message " , null , " This is a default msg if not found in » Message Source « . " , Locale . US ) . equals ( " This is a default msg if not found in » Message Source « . " ) ) . as ( " bogus msg from » static Msg Source « with default msg passed in returned default msg for Locale . US " ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » No Such Message Exception « . class ) . » is Thrown By « ( ( ) -> sac . » get Message « ( " bogus . message " , null , Locale . US ) ) ; }
@Test { » Static Application Context « context = new » Static Application Context « ( ) ; context . refresh ( ) ; Object » lifecycle Processor « = new » Direct Field Accessor « ( context ) . » get Property Value « ( " » lifecycle Processor « " ) ; » assert That « ( » lifecycle Processor « ) . » is Not Null « ( ) ; » assert That « ( » lifecycle Processor « . » get Class « ( ) ) . » is Equal To « ( » Default Lifecycle Processor « . class ) ; }
@Test { » do Test Message Access « ( false , true , false , false , false ) ; }
@Test { » do Test Message Access « ( false , true , false , false , true ) ; }
@Test { » do Test Message Access « ( false , true , true , true , false ) ; }
@Test { » do Test Message Access « ( false , false , false , false , false ) ; }
@Test { » do Test Message Access « ( false , false , true , true , false ) ; }
@Test { » do Test Message Access « ( true , true , false , false , false ) ; }
@Test { » do Test Message Access « ( true , true , false , false , true ) ; }
@Test { » do Test Message Access « ( true , true , true , true , false ) ; }
@Test { » do Test Message Access « ( true , false , false , false , false ) ; }
@Test { » do Test Message Access « ( true , false , true , true , false ) ; }
@Test { » Generic Application Context « ac = new » Generic Application Context « ( ) ; ac . refresh ( ) ; » assert That « ( ac . » get Message « ( " » code 1 « " , null , " default " , Locale . ENGLISH ) ) . » is Equal To « ( " default " ) ; » assert That « ( ac . » get Message « ( " » code 1 « " , new Object [ ] { " value " } , " default { 0 } " , Locale . ENGLISH ) ) . » is Equal To « ( " default value " ) ; }
@Test { » Resource Bundle Message Source « ms = new » Resource Bundle Message Source « ( ) ; ms . » set Basename « ( " org / springframework / context / support / messages " ) ; » assert That « ( ms . » get Message « ( " » code 1 « " , null , Locale . ENGLISH ) ) . » is Equal To « ( " » message 1 « " ) ; » assert That « ( ms . » get Message « ( " » code 2 « " , null , Locale . GERMAN ) ) . » is Equal To « ( " » nachricht 2 « " ) ; }
@Test { » Resource Bundle Message Source « ms = new » Resource Bundle Message Source « ( ) ; ms . » set Basename « ( " org / springframework / context / support / messages " ) ; ms . » set Default Encoding « ( " ISO - 8859 - 1 " ) ; » assert That « ( ms . » get Message « ( " » code 1 « " , null , Locale . ENGLISH ) ) . » is Equal To « ( " » message 1 « " ) ; » assert That « ( ms . » get Message « ( " » code 2 « " , null , Locale . GERMAN ) ) . » is Equal To « ( " » nachricht 2 « " ) ; }
@Test { » Resource Bundle Message Source « ms = new » Resource Bundle Message Source « ( ) ; ms . » set Basename « ( " org / springframework / context / support / messages " ) ; ms . » set Default Encoding « ( " argh " ) ; ms . » set Fallback To System Locale « ( false ) ; » assert That Exception Of Type « ( » No Such Message Exception « . class ) . » is Thrown By « ( ( ) -> ms . » get Message « ( " » code 1 « " , null , Locale . ENGLISH ) ) ; }
@Test { » Reloadable Resource Bundle Message Source « ms = new » Reloadable Resource Bundle Message Source « ( ) ; ms . » set Basename « ( " org / springframework / context / support / messages " ) ; » assert That « ( ms . » get Message « ( " » code 1 « " , null , Locale . ENGLISH ) ) . » is Equal To « ( " » message 1 « " ) ; » assert That « ( ms . » get Message « ( " » code 2 « " , null , Locale . GERMAN ) ) . » is Equal To « ( " » nachricht 2 « " ) ; }
@Test { » Reloadable Resource Bundle Message Source « ms = new » Reloadable Resource Bundle Message Source « ( ) ; ms . » set Basename « ( " org / springframework / context / support / messages " ) ; ms . » set Default Encoding « ( " ISO - 8859 - 1 " ) ; » assert That « ( ms . » get Message « ( " » code 1 « " , null , Locale . ENGLISH ) ) . » is Equal To « ( " » message 1 « " ) ; » assert That « ( ms . » get Message « ( " » code 2 « " , null , Locale . GERMAN ) ) . » is Equal To « ( " » nachricht 2 « " ) ; }
@Test { » local Properties Override « ( false ) ; }
@Test { » local Properties Override « ( true ) ; }
@Test { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; bf . » register Bean Definition « ( " » test Bean « " , » generic Bean Definition « ( » Test Bean « . class ) . » add Property Value « ( " name " , " $ { my . name } " ) . » get Bean Definition « ( ) ) ; » Property Sources Placeholder Configurer « ppc = new » Property Sources Placeholder Configurer « ( ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> ppc . » post Process Bean Factory « ( bf ) ) ; }
@Test { » Property Sources Placeholder Configurer « ppc = new » Property Sources Placeholder Configurer « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ppc :: » get Applied Property Sources « ) ; }
@Test { » Local Interface With Business Methods « ejb = mock ( » Local Interface With Business Methods « . class ) ; String » jndi Name « = " foobar " ; Context » mock Context « = » mock Context « ( » jndi Name « , ejb ) ; » configured Interceptor « ( » mock Context « , » jndi Name « ) ; verify ( » mock Context « ) . close ( ) ; }
@Test { » test Exception « ( new » Application Exception « ( ) ) ; }
@Test { » Remote Interface « ejb = mock ( » Remote Interface « . class ) ; String » jndi Name « = " foobar " ; Context » mock Context « = » mock Context « ( » jndi Name « , ejb ) ; » Simple Remote Slsb Invoker Interceptor « si = » configured Interceptor « ( » mock Context « , » jndi Name « ) ; » configured Proxy « ( si , » Remote Interface « . class ) ; verify ( » mock Context « ) . close ( ) ; }
@Test { » do Test Invokes Method On Ejb Instance « ( true , true ) ; }
@Test { » do Test Invokes Method On Ejb Instance « ( false , true ) ; }
@Test { » do Test Invokes Method On Ejb Instance « ( false , false ) ; }
@Test { » do Test Invokes Method On Ejb Instance « ( true , false ) ; }
@Test { » do Test Invokes Method On Ejb Instance With Connect Exception With Refresh « ( true , true ) ; }
@Test { » do Test Invokes Method On Ejb Instance With Connect Exception With Refresh « ( false , true ) ; }
@Test { » do Test Invokes Method On Ejb Instance With Connect Exception With Refresh « ( false , false ) ; }
@Test { » do Test Invokes Method On Ejb Instance With Connect Exception With Refresh « ( true , false ) ; }
@Test { » do Test Exception « ( new » Application Exception « ( ) ) ; }
@Test { » do Test Exception « ( new » Remote Exception « ( ) ) ; }
@Test { » Component Definition « component = this . » event Listener « . » get Component Definition « ( " simple " ) ; boolean condition = component instanceof » Bean Component Definition « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Component Definition « component = this . » event Listener « . » get Component Definition « ( " » simple Local Ejb « " ) ; boolean condition = component instanceof » Bean Component Definition « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Component Definition « component = this . » event Listener « . » get Component Definition « ( " » simple Remote Ejb « " ) ; boolean condition = component instanceof » Bean Component Definition « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " simple " ) ; » assert That « ( » bean Definition « . » get Bean Class Name « ( ) ) . » is Equal To « ( » Jndi Object Factory Bean « . class . » get Name « ( ) ) ; » assert Property Value « ( » bean Definition « , " » jndi Name « " , " jdbc / » My Data Source « " ) ; » assert Property Value « ( » bean Definition « , " » resource Ref « " , " true " ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " » with Environment « " ) ; » assert Property Value « ( » bean Definition « , " » jndi Environment « " , " foo = bar " ) ; » assert Property Value « ( » bean Definition « , " » default Object « " , new » Runtime Bean Reference « ( " » my Bean « " ) ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " » with Referenced Environment « " ) ; » assert Property Value « ( » bean Definition « , " » jndi Environment « " , new » Runtime Bean Reference « ( " » my Environment « " ) ) ; » assert That « ( » bean Definition « . » get Property Values « ( ) . contains ( " » environment Ref « " ) ) . » is False « ( ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " » simple Local Ejb « " ) ; » assert That « ( » bean Definition « . » get Bean Class Name « ( ) ) . » is Equal To « ( » Local Stateless Session Proxy Factory Bean « . class . » get Name « ( ) ) ; » assert Property Value « ( » bean Definition « , " » business Interface « " , » I Test Bean « . class . » get Name « ( ) ) ; » assert Property Value « ( » bean Definition « , " » jndi Name « " , " ejb / » My Local Bean « " ) ; }
@Test { » Bean Definition « » bean Definition « = this . » bean Factory « . » get Merged Bean Definition « ( " » simple Remote Ejb « " ) ; » assert That « ( » bean Definition « . » get Bean Class Name « ( ) ) . » is Equal To « ( » Simple Remote Stateless Session Proxy Factory Bean « . class . » get Name « ( ) ) ; » assert Property Value « ( » bean Definition « , " » business Interface « " , » I Test Bean « . class . » get Name « ( ) ) ; » assert Property Value « ( » bean Definition « , " » jndi Name « " , " ejb / » My Remote Bean « " ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Time Zone « ( UTC ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " Jun 1 , 2009 " ) ; » assert That « ( formatter . parse ( " Jun 1 , 2009 " , Locale . US ) ) . » is Equal To « ( date ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( " yyyy - MM - dd " ) ; formatter . » set Time Zone « ( UTC ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " 2009 - 06 - 01 " ) ; » assert That « ( formatter . parse ( " 2009 - 06 - 01 " , Locale . US ) ) . » is Equal To « ( date ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Time Zone « ( UTC ) ; formatter . » set Style « ( » Date Format « . SHORT ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " 6 / 1 / 09 " ) ; » assert That « ( formatter . parse ( " 6 / 1 / 09 " , Locale . US ) ) . » is Equal To « ( date ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Time Zone « ( UTC ) ; formatter . » set Style « ( » Date Format « . MEDIUM ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " Jun 1 , 2009 " ) ; » assert That « ( formatter . parse ( " Jun 1 , 2009 " , Locale . US ) ) . » is Equal To « ( date ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Time Zone « ( UTC ) ; formatter . » set Style « ( » Date Format « . LONG ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " June 1 , 2009 " ) ; » assert That « ( formatter . parse ( " June 1 , 2009 " , Locale . US ) ) . » is Equal To « ( date ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Time Zone « ( UTC ) ; formatter . » set Style « ( » Date Format « . FULL ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " Monday , June 1 , 2009 " ) ; » assert That « ( formatter . parse ( " Monday , June 1 , 2009 " , Locale . US ) ) . » is Equal To « ( date ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Time Zone « ( UTC ) ; formatter . » set Iso « ( ISO . DATE ) ; Date date = » get Date « ( 2009 , Calendar . JUNE , 1 , 14 , 23 , 5 , 3 ) ; » assert That « ( formatter . print ( date , Locale . US ) ) . » is Equal To « ( " 2009 - 06 - 01 " ) ; » assert That « ( formatter . parse ( " 2009 - 6 - 01 " , Locale . US ) ) . » is Equal To « ( » get Date « ( 2009 , Calendar . JUNE , 1 ) ) ; }
@Test { » Date Formatter « formatter = new » Date Formatter « ( ) ; formatter . » set Style Pattern « ( " OO " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> formatter . parse ( " 2009 " , Locale . US ) ) . » with Message Containing « ( " Unsupported style pattern 'OO' " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " millis " , " 1256961600 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " millis " ) ) . » is Equal To « ( " 1256961600 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » millis Annotated « " , " 10 / 31 / 09 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » millis Annotated « " ) ) . » is Equal To « ( " 10 / 31 / 09 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » calendar Annotated « " , " 10 / 31 / 09 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » calendar Annotated « " ) ) . » is Equal To « ( " 10 / 31 / 09 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Annotated « " , " 10 / 31 / 09 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » date Annotated « " ) ) . » is Equal To « ( " 10 / 31 / 09 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Annotated « " , new String [ ] { " 10 / 31 / 09 12 : 00 PM " } ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Annotated « " , " Oct » X 31 « , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Error Count « ( " » date Annotated « " ) ) . » is Equal To « ( 1 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » date Annotated « " ) ) . » is Equal To « ( " Oct » X 31 « , 2009 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Annotated « " , " Oct 031 , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Error Count « ( " » date Annotated « " ) ) . » is Equal To « ( 1 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » date Annotated « " ) ) . » is Equal To « ( " Oct 031 , 2009 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Annotated Pattern « " , " 10 / 31 / 09 1 : 05 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » date Annotated Pattern « " ) ) . » is Equal To « ( " 10 / 31 / 09 1 : 05 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Annotated Pattern « " , " 02 / 29 / 09 12 : 00 PM " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » iso Date « " , " 2009 - 10 - 31 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » iso Date « " ) ) . » is Equal To « ( " 2009 - 10 - 31 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » iso Time « " , " 12 : 00 : 00 .000 - 05 : 00 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » iso Time « " ) ) . » is Equal To « ( " 17 : 00 : 00 .000 Z " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " children [ 0 ] . » date Annotated « " , " 10 / 31 / 09 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " children [ 0 ] . » date Annotated « " ) ) . » is Equal To « ( " 10 / 31 / 09 " ) ; }
@Test { Date date = new Date ( ) ; Object actual = this . » conversion Service « . convert ( date , » Type Descriptor « . » value Of « ( Date . class ) , » Type Descriptor « . » value Of « ( String . class ) ) ; String expected = date . » to String « ( ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » Date Formatter Registrar « registrar = new » Date Formatter Registrar « ( ) ; registrar . » set Formatter « ( new » Date Formatter « ( ) ) ; setup ( registrar ) ; Date date = new Date ( ) ; Object actual = this . » conversion Service « . convert ( date , » Type Descriptor « . » value Of « ( Date . class ) , » Type Descriptor « . » value Of « ( String . class ) ) ; String expected = new » Date Formatter « ( ) . print ( date , Locale . US ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { String string = " Sat , 12 Aug 1995 13 : 30 : 00 GM " ; Date date = this . » conversion Service « . convert ( string , Date . class ) ; » assert That « ( date ) . » is Equal To « ( new Date ( string ) ) ; }
@Test { » Date Formatter Registrar « registrar = new » Date Formatter Registrar « ( ) ; » Date Formatter « » date Formatter « = new » Date Formatter « ( ) ; » date Formatter « . » set Iso « ( ISO . » DATE _ TIME « ) ; registrar . » set Formatter « ( » date Formatter « ) ; setup ( registrar ) ; String string = " 2009 - 06 - 01 » T 14 « : 23 : 05 .003 + 00 : 00 " ; Date date = this . » conversion Service « . convert ( string , Date . class ) ; » assert That « ( date ) . » is Not Null « ( ) ; }
@Test { » assert That « ( factory . » get Object Type « ( ) ) . » is Equal To « ( » Date Time Formatter « . class ) ; }
@Test { factory . » after Properties Set « ( ) ; » assert That « ( factory . » get Object « ( ) ) . » is Equal To « ( » Date Time Format « . » medium Date Time « ( ) ) ; }
@Test { factory . » after Properties Set « ( ) ; » Date Time Formatter « formatter = factory . » get Object « ( ) ; » assert That « ( formatter ) . » is Equal To « ( » Date Time Format « . » medium Date Time « ( ) ) ; factory . » set Style « ( " LL " ) ; » assert That « ( factory . » get Object « ( ) ) . » is Same As « ( formatter ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date « " , " 10 / 31 / 09 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Date « " ) ) . » is Equal To « ( " 10 / 31 / 09 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date « " , new String [ ] { " 10 / 31 / 09 " } ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date Annotated « " , " Oct 31 , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Date Annotated « " ) ) . » is Equal To « ( " Oct 31 , 2009 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date Annotated « " , " Oct 031 , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Error Count « ( " » local Date Annotated « " ) ) . » is Equal To « ( 1 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Date Annotated « " ) ) . » is Equal To « ( " Oct 031 , 2009 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " children [ 0 ] . » local Date Annotated « " , " Oct 31 , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " children [ 0 ] . » local Date Annotated « " ) ) . » is Equal To « ( " Oct 31 , 2009 " ) ; }
@Test { binder . » init Direct Field Access « ( ) ; » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date Annotated « " , " Oct 31 , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Date Annotated « " ) ) . » is Equal To « ( " Oct 31 , 2009 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Time « " , " 12 : 00 PM " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Time « " ) ) . » is Equal To « ( " 12 : 00 PM " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Time Annotated « " , " 12 : 00 : 00 PM " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Time Annotated « " ) ) . » is Equal To « ( " 12 : 00 : 00 PM " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Time Annotated Pattern « " , " 10 / 31 / 09 12 : 00 PM " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » date Time Annotated Pattern « " ) ) . » is Equal To « ( " 10 / 31 / 09 12 : 00 PM " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » date Time Annotated Pattern « " , " 02 / 29 / 09 12 : 00 PM " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " date " , " Sat , 12 Aug 1995 13 : 30 : 00 GMT " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " date " ) ) . » is Equal To « ( " Sat , 12 Aug 1995 13 : 30 : 00 GMT " ) ; }
@Test { » Data Binder « binder = new » Data Binder « ( new » Joda Time Bean « ( ) ) ; » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " date " , " Sat , 12 Aug 1995 13 : 30 : 00 GMT " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » iso Time « " , " 12 : 00 : 00 .000 - 05 : 00 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » iso Time « " ) ) . » is Equal To « ( " 12 : 00 : 00 .000 " ) ; }
@Test { » Joda Time Formatter Registrar « registrar = new » Joda Time Formatter Registrar « ( ) ; » Date Time Formatter Factory « factory = new » Date Time Formatter Factory « ( ) ; factory . » set Iso « ( ISO . » DATE _ TIME « ) ; registrar . » set Date Time Formatter « ( factory . » create Date Time Formatter « ( ) ) ; setup ( registrar ) ; String string = " 2009 - 10 - 31 » T 07 « : 00 : 00 .000 - 05 : 00 " ; Date date = this . » conversion Service « . convert ( string , Date . class ) ; » assert That « ( date ) . » is Not Null « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " period " , " » P 6 Y 3 M 1 D « " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " period " ) . » to String « ( ) . equals ( " » P 6 Y 3 M 1 D « " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " duration " , " » PT 72 « .345 S " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " duration " ) . » to String « ( ) . equals ( " » PT 72 « .345 S " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » year Month « " , " 2007 - 12 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » year Month « " ) . » to String « ( ) . equals ( " 2007 - 12 " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » month Day « " , " -- 12 - 03 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » month Day « " ) . » to String « ( ) . equals ( " -- 12 - 03 " ) ) . » is True « ( ) ; }
@Test { » assert That « ( factory . » create Date Time Formatter « ( ) ) . » is Equal To « ( » Date Time Format « . » medium Date Time « ( ) ) ; }
@Test { factory = new » Date Time Formatter Factory « ( " » yyyy M Mdd H Hmmss « " ) ; » Date Time Formatter « formatter = factory . » create Date Time Formatter « ( ) ; » assert That « ( formatter . print ( » date Time « ) ) . » is Equal To « ( " 20091021121000 " ) ; }
@Test { » Date Time Formatter « formatter = factory . » create Date Time Formatter « ( null ) ; » assert That « ( formatter ) . » is Null « ( ) ; }
@Test { » Date Time Formatter « fallback = » Date Time Format « . » for Style « ( " LL " ) ; » Date Time Formatter « formatter = factory . » create Date Time Formatter « ( fallback ) ; » assert That « ( formatter ) . » is Same As « ( fallback ) ; }
@Test { » assert That « ( factory . » create Date Time Formatter « ( ) . » to String « ( ) ) . » is Equal To « ( » Date Time Formatter « . » of Localized Date Time « ( » Format Style « . MEDIUM ) . » to String « ( ) ) ; }
@Test { factory = new » Date Time Formatter Factory « ( " » yyyy M Mdd H Hmmss « " ) ; » Date Time Formatter « formatter = factory . » create Date Time Formatter « ( ) ; » assert That « ( formatter . format ( » date Time « ) ) . » is Equal To « ( " 20091021121000 " ) ; }
@Test { » Date Time Formatter « fallback = » Date Time Formatter « . » of Localized Date Time « ( » Format Style « . LONG ) ; » Date Time Formatter « formatter = factory . » create Date Time Formatter « ( fallback ) ; » assert That « ( formatter ) . » is Same As « ( fallback ) ; }
@Test { factory . » after Properties Set « ( ) ; » assert That « ( factory . » get Object « ( ) . » to String « ( ) ) . » is Equal To « ( » Date Time Formatter « . » of Localized Date Time « ( » Format Style « . MEDIUM ) . » to String « ( ) ) ; }
@Test { factory . » after Properties Set « ( ) ; » Date Time Formatter « formatter = factory . » get Object « ( ) ; » assert That « ( formatter . » to String « ( ) ) . » is Equal To « ( » Date Time Formatter « . » of Localized Date Time « ( » Format Style « . MEDIUM ) . » to String « ( ) ) ; factory . » set Style Pattern « ( " LL " ) ; » assert That « ( factory . » get Object « ( ) ) . » is Same As « ( formatter ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date Annotated « " , " Oct - 31 , 2009 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Error Count « ( " » local Date Annotated « " ) ) . » is Equal To « ( 1 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Date Annotated « " ) ) . » is Equal To « ( " Oct - 31 , 2009 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Date « " , new » Gregorian Calendar « ( 2009 , 9 , 31 , 0 , 0 ) ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Date « " ) ) . » is Equal To « ( " 10 / 31 / 09 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » local Time « " , new » Gregorian Calendar « ( 1970 , 0 , 0 , 12 , 0 ) ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » local Time « " ) ) . » is Equal To « ( " 12 : 00 PM " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » iso Time « " , " 12 : 00 : 00 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » iso Time « " ) ) . » is Equal To « ( " 12 : 00 : 00 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » iso Time « " , " 12 : 00 : 00 .000 - 05 : 00 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » iso Time « " ) ) . » is Equal To « ( " 12 : 00 : 00 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " duration " , " » PT 8 H 6 M 12 « .345 S " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " duration " ) . » to String « ( ) . equals ( " » PT 8 H 6 M 12 « .345 S " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " year " , " 2007 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " year " ) . » to String « ( ) . equals ( " 2007 " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " month " , " JULY " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " month " ) . » to String « ( ) . equals ( " JULY " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " month " , " July " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " month " ) . » to String « ( ) . equals ( " JULY " ) ) . » is True « ( ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » number Default « " , " 3 , 339.12 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » number Default « " ) ) . » is Equal To « ( " 3 , 339 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " » number Default Annotated « " , " 3 , 339.12 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " » number Default Annotated « " ) ) . » is Equal To « ( " 3 , 339.12 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " currency " , " » $ 3 « , 339.12 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " currency " ) ) . » is Equal To « ( " » $ 3 « , 339.12 " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " percent " , " 53 % " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " percent " ) ) . » is Equal To « ( " 53 % " ) ; }
@Test { » Mutable Property Values « » property Values « = new » Mutable Property Values « ( ) ; » property Values « . add ( " pattern " , " 1 , 25.00 " ) ; binder . bind ( » property Values « ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Error Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( binder . » get Binding Result « ( ) . » get Field Value « ( " pattern " ) ) . » is Equal To « ( " 1 , 25.00 " ) ; }
@Test { » assert That « ( formatter . print ( new » Big Decimal « ( " 23.56 " ) , Locale . US ) ) . » is Equal To « ( " 23.56 " ) ; }
@Test { » assert That « ( formatter . parse ( " 23.56 " , Locale . US ) ) . » is Equal To « ( new » Big Decimal « ( " 23.56 " ) ) ; }
@Test { » assert That Exception Of Type « ( » Parse Exception « . class ) . » is Thrown By « ( ( ) -> formatter . parse ( " bogus " , Locale . US ) ) ; }
@Test { » assert That Exception Of Type « ( » Parse Exception « . class ) . » is Thrown By « ( ( ) -> formatter . parse ( " 23.56 bogus " , Locale . US ) ) ; }
@Test { » assert That « ( formatter . print ( new » Big Decimal « ( " .23 " ) , Locale . US ) ) . » is Equal To « ( " 23 % " ) ; }
@Test { » assert That « ( formatter . parse ( " 23.56 % " , Locale . US ) ) . » is Equal To « ( new » Big Decimal « ( " .2356 " ) ) ; }
@Test { » assert That Exception Of Type « ( » Parse Exception « . class ) . » is Thrown By « ( ( ) -> formatter . parse ( " 23.56 % bogus " , Locale . US ) ) ; }
@Test { » assert That « ( formatter . print ( new » Big Decimal « ( " 23 " ) , Locale . US ) ) . » is Equal To « ( " » $ 23 « .00 " ) ; }
@Test { » assert That « ( formatter . parse ( " » $ 23 « .56 " , Locale . US ) ) . » is Equal To « ( new » Big Decimal « ( " 23.56 " ) ) ; }
@Test { this . formatter . » set Rounding Mode « ( » Rounding Mode « . DOWN ) ; » assert That « ( formatter . parse ( " » $ 23 « .567 " , Locale . US ) ) . » is Equal To « ( new » Big Decimal « ( " 23.56 " ) ) ; }
@Test { » assert That « ( formatter . parse ( " » $ 23 « " , Locale . US ) ) . » is Equal To « ( new » Big Decimal « ( " 23.00 " ) ) ; }
@Test { » assert That Exception Of Type « ( » Parse Exception « . class ) . » is Thrown By « ( ( ) -> formatter . parse ( " » $ 23 « .56 bogus " , Locale . US ) ) ; }
@Test { » formatting Service « . » add Formatter For Field Type « ( Number . class , new » Number Style Formatter « ( ) ) ; String formatted = » formatting Service « . convert ( 3 , String . class ) ; » assert That « ( formatted ) . » is Equal To « ( " 3 " ) ; Integer i = » formatting Service « . convert ( " 3 " , Integer . class ) ; » assert That « ( i ) . » is Equal To « ( new Integer ( 3 ) ) ; }
@Test { » formatting Service « . » add Formatter For Field Annotation « ( new » Joda Date Time Format Annotation Formatter Factory « ( ) ) ; » do Test Format Field For Annotation « ( Model . class , false ) ; }
@Test { » formatting Service « . » add Formatter For Field Annotation « ( new » Joda Date Time Format Annotation Formatter Factory « ( ) ) ; » do Test Format Field For Annotation « ( Model . class , true ) ; }
@Test { » formatting Service « . » add Formatter For Field Type « ( Number . class , new » Number Style Formatter « ( ) ) ; » assert That « ( » formatting Service « . convert ( null , » Type Descriptor « . » value Of « ( Integer . class ) , » Type Descriptor « . » value Of « ( String . class ) ) ) . » is Equal To « ( " " ) ; }
@Test { » formatting Service « . » add Formatter For Field Type « ( Number . class , new » Number Style Formatter « ( ) ) ; » assert That « ( » formatting Service « . convert ( null , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ) . » is Null « ( ) ; }
@Test { » formatting Service « . » add Formatter For Field Type « ( Number . class , new » Number Style Formatter « ( ) ) ; » assert That « ( » formatting Service « . convert ( " " , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ) . » is Null « ( ) ; }
@Test { » formatting Service « . » add Formatter For Field Type « ( Integer . class , new » Null Returning Formatter « ( ) ) ; » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » formatting Service « . convert ( " 1 " , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ) ; }
@Test { » formatting Service « . » add Formatter For Field Type « ( Integer . class , new » Number Style Formatter « ( ) ) ; » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » formatting Service « . convert ( null , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( int . class ) ) ) ; }
@Test { » assert That « ( » formatting Service « . convert ( null , » Type Descriptor « . » value Of « ( Integer . class ) , » Type Descriptor « . » value Of « ( String . class ) ) ) . » is Equal To « ( null ) ; }
@Test { » assert That « ( » formatting Service « . convert ( null , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » formatting Service « . convert ( " " , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ) . » is Null « ( ) ; }
@Test { » register Default Value « ( Date . class , new Date ( ) ) ; }
@Test { » formatting Service « . » add Formatter « ( new » Number Style Formatter « ( " # , # » 00 . 0 « # " ) ) ; » assert That « ( » formatting Service « . convert ( 123 , String . class ) ) . » is Equal To « ( " 123.0 " ) ; » assert That « ( » formatting Service « . convert ( " 123.0 " , Integer . class ) ) . » is Equal To « ( 123 ) ; }
@Test { » formatting Service « . » add Printer « ( new » Number Style Formatter « ( " # , # » 00 . 0 « # " ) ) ; » assert That « ( » formatting Service « . convert ( 123 , String . class ) ) . » is Equal To « ( " 123.0 " ) ; » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » formatting Service « . convert ( " 123.0 " , Integer . class ) ) . » with Cause Instance Of « ( » Number Format Exception « . class ) ; }
@Test { » formatting Service « . » add Parser « ( new » Number Style Formatter « ( " # , # » 00 . 0 « # " ) ) ; » assert That « ( » formatting Service « . convert ( " 123.0 " , Integer . class ) ) . » is Equal To « ( 123 ) ; » assert That « ( » formatting Service « . convert ( 123 , String . class ) ) . » is Equal To « ( " 123 " ) ; }
@Test { Formatter < ? > formatter = new » Number Style Formatter « ( ) ; » formatting Service « . » add Formatter « ( ( Formatter < ? > ) new » Proxy Factory « ( formatter ) . » get Proxy « ( ) ) ; » assert That « ( » formatting Service « . convert ( null , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ) . » is Null « ( ) ; }
@Test { » formatting Service « . » add Converter « ( new » Integer Converter « ( ) ) ; » assert That « ( » formatting Service « . convert ( " 1 " , Integer . class ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Converter < ? , ? > converter = new » Integer Converter « ( ) ; » formatting Service « . » add Converter « ( ( Converter < ? , ? > ) new » Proxy Factory « ( converter ) . » get Proxy « ( ) ) ; » assert That « ( » formatting Service « . convert ( " 1 " , Integer . class ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { » formatting Service « . » add Converter Factory « ( new » Integer Converter Factory « ( ) ) ; » assert That « ( » formatting Service « . convert ( " 1 " , Integer . class ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { » Converter Factory « < ? , ? > » converter Factory « = new » Integer Converter Factory « ( ) ; » formatting Service « . » add Converter Factory « ( ( » Converter Factory « < ? , ? > ) new » Proxy Factory « ( » converter Factory « ) . » get Proxy « ( ) ) ; » assert That « ( » formatting Service « . convert ( " 1 " , Integer . class ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { » Formatting Conversion Service Factory Bean « factory = new » Formatting Conversion Service Factory Bean « ( ) ; Set < Object > formatters = new » Hash Set « < > ( ) ; formatters . add ( new Object ( ) ) ; factory . » set Formatters « ( formatters ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( factory :: » after Properties Set « ) ; }
@Test { » Class Loader « loader = new » Simple Instrumentable Class Loader « ( » Class Utils « . » get Default Class Loader « ( ) ) ; » Reflective Load Time Weaver « handler = new » Reflective Load Time Weaver « ( loader ) ; » assert That « ( handler . » get Instrumentable Class Loader « ( ) ) . » is Same As « ( loader ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Reflective Load Time Weaver « ( null ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Reflective Load Time Weaver « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Reflective Load Time Weaver « ( new » Just Add Transformer Class Loader « ( ) ) . » add Transformer « ( null ) ) ; }
@Test { » Reflective Load Time Weaver « weaver = new » Reflective Load Time Weaver « ( new » Just Add Transformer Class Loader « ( ) ) ; » Class Loader « » throwaway Class Loader « = weaver . » get Throwaway Class Loader « ( ) ; » assert That « ( » throwaway Class Loader « ) . » is Not Null « ( ) ; }
@Test { » Totally Compliant Class Loader « » class Loader « = new » Totally Compliant Class Loader « ( ) ; » Reflective Load Time Weaver « weaver = new » Reflective Load Time Weaver « ( » class Loader « ) ; » Class Loader « » throwaway Class Loader « = weaver . » get Throwaway Class Loader « ( ) ; » assert That « ( » throwaway Class Loader « ) . » is Not Null « ( ) ; » assert That « ( » class Loader « . » get Num Times Get Throwaway Class Loader Called « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » this Class Loader « . » get Resource « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » assert That « ( » overriding Loader « . » get Resource « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; }
@Test { » assert That « ( » this Class Loader « . » get Resource « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » overriding Loader « . override ( » EXISTING _ RESOURCE « , null ) ; » assert That « ( » overriding Loader « . » get Resource « ( » EXISTING _ RESOURCE « ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » this Class Loader « . » get Resource As Stream « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » assert That « ( » overriding Loader « . » get Resource As Stream « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; }
@Test { » assert That « ( » this Class Loader « . » get Resource As Stream « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » overriding Loader « . override ( » EXISTING _ RESOURCE « , null ) ; » assert That « ( » overriding Loader « . » get Resource As Stream « ( » EXISTING _ RESOURCE « ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » this Class Loader « . » get Resources « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » assert That « ( » overriding Loader « . » get Resources « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » assert That « ( » count Elements « ( » overriding Loader « . » get Resources « ( » EXISTING _ RESOURCE « ) ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » this Class Loader « . » get Resources « ( » EXISTING _ RESOURCE « ) ) . » is Not Null « ( ) ; » overriding Loader « . override ( » EXISTING _ RESOURCE « , null ) ; » assert That « ( » count Elements « ( » overriding Loader « . » get Resources « ( » EXISTING _ RESOURCE « ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; » assert That « ( proxy . » get Class « ( ) ) . as ( " The proxy class should be different than the base class " ) . » is Not Same As « ( » I Jmx Test Bean « . class ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « » proxy 1 « = » get Proxy « ( ) ; » I Jmx Test Bean « » proxy 2 « = » get Proxy « ( ) ; » assert That « ( » proxy 2 « ) . as ( " The proxies should NOT be the same " ) . » is Not Same As « ( » proxy 1 « ) ; » assert That « ( » proxy 2 « . » get Class « ( ) ) . as ( " The proxy classes should be the same " ) . » is Same As « ( » proxy 1 « . » get Class « ( ) ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « » proxy 1 « = » get Proxy « ( ) ; int age = » proxy 1 « . » get Age « ( ) ; » assert That « ( age ) . as ( " The age should be 100 " ) . » is Equal To « ( 100 ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; proxy . » set Name « ( " Rob Harrop " ) ; » assert That « ( target . » get Name « ( ) ) . as ( " The name of the bean should have been updated " ) . » is Equal To « ( " Rob Harrop " ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> proxy . » set Name « ( " Juergen " ) ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; » assert That Exception Of Type « ( » Class Not Found Exception « . class ) . » is Thrown By « ( ( ) -> proxy . » set Name « ( " Juergen Class " ) ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; » assert That IO Exception « ( ) . » is Thrown By « ( ( ) -> proxy . » set Name « ( " Juergen IO " ) ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; » assert That Exception Of Type « ( » Invalid Invocation Exception « . class ) . » is Thrown By « ( ( ) -> proxy . » set Age « ( 900 ) ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; long result = proxy . » my Operation « ( ) ; » assert That « ( result ) . as ( " The operation should return 1 " ) . » is Equal To « ( 1 ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « proxy = » get Proxy « ( ) ; int result = proxy . add ( 1 , 2 ) ; » assert That « ( result ) . as ( " The operation should return 3 " ) . » is Equal To « ( 3 ) ; }
@Test { » assume True « ( » run Tests « ) ; » I Jmx Test Bean « bean = » get Proxy « ( ) ; » assert That Exception Of Type « ( » Invalid Invocation Exception « . class ) . » is Thrown By « ( ( ) -> bean . » dont Expose Me « ( ) ) ; }
@Test { » Date Range « dr = » get Context « ( ) . » get Bean « ( " » date Range « " , » Date Range « . class ) ; » assert That « ( dr . » get Start Date « ( ) ) . as ( " » start Date « " ) . » is Equal To « ( » get Start Date « ( ) ) ; » assert That « ( dr . » get End Date « ( ) ) . as ( " » end Date « " ) . » is Equal To « ( » get End Date « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . as ( " no » Notification Listener « supplied " ) . » is Thrown By « ( new » Notification Listener Bean « ( ) :: » after Properties Set « ) ; }
@Test { » Configurable Application Context « ctx = » load Context « ( " org / springframework / jmx / export / » notification Publisher Tests « . xml " ) ; this . server . » add Notification Listener « ( » Object Name Manager « . » get Instance « ( " spring : type = » Publisher M Bean « " ) , listener , null , null ) ; » My Notification Publisher M Bean « publisher = ( » My Notification Publisher M Bean « ) ctx . » get Bean « ( " » publisher M Bean « " ) ; publisher . » send Notification « ( ) ; » assert That « ( listener . count ) . as ( " Notification not sent " ) . » is Equal To « ( 1 ) ; }
@Test { » I Jmx Test Bean « bean = » get Context « ( ) . » get Bean « ( " » test Bean « " , » I Jmx Test Bean « . class ) ; » assert That « ( bean . » get Name « ( ) ) . as ( " Name " ) . » is Equal To « ( " Rob Harrop " ) ; » assert That « ( bean . » get Age « ( ) ) . as ( " Age " ) . » is Equal To « ( 100 ) ; }
@Test { » Object Name « oname = new » Object Name « ( " bean : name = » proxy Test Bean 1 « " ) ; Object name = » get Server « ( ) . » get Attribute « ( oname , " Name " ) ; Integer age = ( Integer ) » get Server « ( ) . » get Attribute « ( oname , " Age " ) ; » assert That « ( name ) . as ( " Name is incorrect in JMX " ) . » is Equal To « ( " Rob Harrop " ) ; » assert That « ( age . » int Value « ( ) ) . as ( " Age is incorrect in JMX " ) . » is Equal To « ( 100 ) ; }
@Test { Map < String , » Notification Listener « > listeners = new » Hash Map « < > ( ) ; listeners . put ( " * " , null ) ; » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> exporter . » set Notification Listener Mappings « ( listeners ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; exporter . » set Beans « ( » get Bean Map « ( ) ) ; exporter . » set Server « ( server ) ; try { start ( exporter ) ; » assert Is Registered « ( " The bean was not registered with the » M Bean Server « " , » Object Name Manager « . » get Instance « ( » OBJECT _ NAME « ) ) ; } finally { exporter . destroy ( ) ; } }
@Test { » Configurable Application Context « ctx = load ( " » autodetect No M Beans « . xml " ) ; try { ctx . » get Bean « ( " exporter " ) ; } finally { ctx . close ( ) ; } }
@Test { » Mock M Bean Exporter Listener « » listener 1 « = new » Mock M Bean Exporter Listener « ( ) ; » Mock M Bean Exporter Listener « » listener 2 « = new » Mock M Bean Exporter Listener « ( ) ; » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; exporter . » set Beans « ( » get Bean Map « ( ) ) ; exporter . » set Server « ( server ) ; exporter . » set Listeners « ( » listener 1 « , » listener 2 « ) ; start ( exporter ) ; exporter . destroy ( ) ; » assert Listener « ( » listener 1 « ) ; » assert Listener « ( » listener 2 « ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> exporter . » set Autodetect Mode « ( - 1 ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> exporter . » set Autodetect Mode « ( 5 ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> exporter . » set Autodetect Mode Name « ( " " ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> exporter . » set Autodetect Mode Name « ( " \t " ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> exporter . » set Autodetect Mode Name « ( " That Hansel is ... * sssooo * hot right now ! " ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; Map < String , Object > beans = new » Hash Map « < > ( ) ; beans . put ( » OBJECT _ NAME « , " » bean Name « " ) ; exporter . » set Beans « ( beans ) ; » assert That Exception Of Type « ( » M Bean Export Exception « . class ) . » is Thrown By « ( ( ) -> start ( exporter ) ) ; }
@Test { » M Bean Exporter « exporter = new » M Bean Exporter « ( ) ; exporter . » set Autodetect Mode « ( » M Bean Exporter « . » AUTODETECT _ ALL « ) ; » assert That Exception Of Type « ( » M Bean Export Exception « . class ) . » is Thrown By « ( ( ) -> start ( exporter ) ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = inf . » get Attribute « ( " Colour " ) ; » assert That « ( attr . » is Writable « ( ) ) . as ( " The name attribute should be writable " ) . » is True « ( ) ; » assert That « ( attr . » is Readable « ( ) ) . as ( " The name attribute should be readable " ) . » is True « ( ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Operation Info « op = inf . » get Operation « ( " » from Interface « " ) ; » assert That « ( op ) . » is Not Null « ( ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Operation Info « op = inf . » get Operation « ( " » get Expensive To Calculate « " ) ; » assert That « ( op ) . » is Not Null « ( ) ; }
@Test { load ( » Lazy Naming Configuration « . class ) ; » validate Annotation Test Bean « ( ) ; }
@Test { load ( » Proxy Configuration « . class ) ; » validate Annotation Test Bean « ( ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Metadata Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Package Private Configuration « . class ) ) . » with Message Containing « ( » Package Private Test Bean « . class . » get Name « ( ) ) . » with Message Containing « ( " must be public " ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Metadata Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Package Private Interface Implementation Configuration « . class ) ) . » with Message Containing « ( » Package Private Annotation Test Bean « . class . » get Name « ( ) ) . » with Message Containing « ( " must be public " ) ; }
@Test { load ( » Package Private Extension Configuration « . class ) ; » validate Annotation Test Bean « ( ) ; }
@Test { » Mock Environment « env = new » Mock Environment « ( ) ; env . » set Property « ( " » server Name « " , " server " ) ; » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . » set Environment « ( env ) ; context . register ( » Placeholder Based Configuration « . class ) ; context . refresh ( ) ; this . ctx = context ; » validate Annotation Test Bean « ( ) ; }
@Test { load ( » Component Scan Configuration « . class ) ; » M Bean Server « server = ( » M Bean Server « ) this . ctx . » get Bean « ( " server " ) ; » validate M Bean Attribute « ( server , " bean : name = » test Bean 4 « " , null ) ; }
@Test { » assert That « ( » Jmx Utils « . » is M Bean « ( » Foo Not X « . class ) ) . as ( " » MX Bean « annotation not detected correctly " ) . » is False « ( ) ; }
@Test { » assert That « ( » Jmx Utils « . » is M Bean « ( » Foo X « . class ) ) . as ( " » MX Bean « annotation not detected correctly " ) . » is True « ( ) ; }
@Test { » Object Instance « instance = » get Object Instance « ( ) ; » assert That « ( instance ) . as ( " Bean should not be null " ) . » is Not Null « ( ) ; }
@Test { » I Jmx Test Bean « bean = » get Bean « ( ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » M Bean Info « inf = » get M Bean Info « ( ) ; » assert That « ( inf . » get Operations « ( ) . length ) . as ( " Incorrect number of operations registered " ) . » is Equal To « ( » get Expected Operation Count « ( ) ) ; }
@Test { » I Jmx Test Bean « bean = » get Bean « ( ) ; » assert That « ( bean ) . » is Not Null « ( ) ; » M Bean Info « inf = » get M Bean Info « ( ) ; » assert That « ( inf . » get Attributes « ( ) . length ) . as ( " Incorrect number of attributes registered " ) . » is Equal To « ( » get Expected Attribute Count « ( ) ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » assert That « ( info ) . as ( " » M Bean Info « should not be null " ) . » is Not Null « ( ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » assert That « ( info . » get Description « ( ) ) . as ( " The » M Bean « description should not be null " ) . » is Not Null « ( ) ; }
@Test { » Object Name « » object Name « = » Object Name Manager « . » get Instance « ( » get Object Name « ( ) ) ; » get Server « ( ) . » set Attribute « ( » object Name « , new Attribute ( » NAME _ ATTRIBUTE « , " Rob Harrop " ) ) ; » I Jmx Test Bean « bean = ( » I Jmx Test Bean « ) » get Context « ( ) . » get Bean « ( " » test Bean « " ) ; » assert That « ( bean . » get Name « ( ) ) . » is Equal To « ( " Rob Harrop " ) ; }
@Test { » Object Name « » object Name « = » Object Name Manager « . » get Instance « ( » get Object Name « ( ) ) ; » get Bean « ( ) . » set Name « ( " John Smith " ) ; Object val = » get Server « ( ) . » get Attribute « ( » object Name « , » NAME _ ATTRIBUTE « ) ; » assert That « ( val ) . as ( " Incorrect result " ) . » is Equal To « ( " John Smith " ) ; }
@Test { » Object Name « » object Name « = » Object Name Manager « . » get Instance « ( » get Object Name « ( ) ) ; Object result = » get Server « ( ) . invoke ( » object Name « , " add " , new Object [ ] { new Integer ( 20 ) , new Integer ( 30 ) } , new String [ ] { " int " , " int " } ) ; » assert That « ( result ) . as ( " Incorrect result " ) . » is Equal To « ( new Integer ( 50 ) ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » assert That « ( info . » get Description « ( ) ) . as ( " The descriptions are not the same " ) . » is Equal To « ( " My Managed Bean " ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = inf . » get Attribute « ( » AGE _ ATTRIBUTE « ) ; » assert That « ( attr . » get Description « ( ) ) . as ( " The description for the age attribute is incorrect " ) . » is Equal To « ( " The Age Attribute " ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = inf . » get Attribute « ( » NAME _ ATTRIBUTE « ) ; » assert That « ( attr . » get Description « ( ) ) . as ( " The description for the name attribute is incorrect " ) . » is Equal To « ( " The Name Attribute " ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = inf . » get Attribute « ( » AGE _ ATTRIBUTE « ) ; » assert That « ( attr . » is Writable « ( ) ) . as ( " The age attribute should not be writable " ) . » is False « ( ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = inf . » get Attribute « ( » NAME _ ATTRIBUTE « ) ; » assert That « ( attr . » is Writable « ( ) ) . as ( " The name attribute should be writable " ) . » is True « ( ) ; » assert That « ( attr . » is Readable « ( ) ) . as ( " The name attribute should be readable " ) . » is True « ( ) ; }
@Test { » Model M Bean Info « inf = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = inf . » get Attribute « ( " » Nick Name « " ) ; » assert That « ( attr ) . as ( " Attribute should not be null " ) . » is Not Null « ( ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = info . » get Attribute « ( " Superman " ) ; » assert That « ( attr ) . as ( " Attribute should not be null " ) . » is Not Null « ( ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; Descriptor desc = info . » get Operation « ( " » my Operation « " ) . » get Descriptor « ( ) ; » assert That « ( desc . » get Field Value « ( " » currency Time Limit « " ) ) . as ( " Currency Time Limit should be 30 " ) . » is Equal To « ( " 30 " ) ; » assert That « ( desc . » get Field Value « ( " role " ) ) . as ( " Role should be \" operation \" " ) . » is Equal To « ( " operation " ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = info . » get Attribute « ( » AGE _ ATTRIBUTE « ) ; » assert That « ( attr . » is Readable « ( ) ) . » is True « ( ) ; » assert That « ( attr . » is Writable « ( ) ) . » is False « ( ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = info . » get Attribute « ( » AGE _ ATTRIBUTE « ) ; » assert That « ( attr . » is Readable « ( ) ) . as ( " Age is not readable " ) . » is True « ( ) ; » assert That « ( attr . » is Writable « ( ) ) . as ( " Age is not writable " ) . » is False « ( ) ; }
@Test { » Model M Bean Info « inf = ( » Model M Bean Info « ) » get M Bean Info « ( ) ; » M Bean Attribute Info « attr = inf . » get Attribute « ( " » Nick Name « " ) ; » assert That « ( attr ) . as ( " Nick Name should not be null " ) . » is Not Null « ( ) ; » assert That « ( attr . » is Writable « ( ) ) . as ( " Nick Name should be writable " ) . » is True « ( ) ; » assert That « ( attr . » is Readable « ( ) ) . as ( " Nick Name should be readable " ) . » is True « ( ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = info . » get Attribute « ( » AGE _ ATTRIBUTE « ) ; » assert That « ( attr . » is Readable « ( ) ) . as ( " Age is not readable " ) . » is True « ( ) ; » assert That « ( attr . » is Writable « ( ) ) . as ( " Age is not writable " ) . » is True « ( ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » Model M Bean Attribute Info « attr = info . » get Attribute « ( " Superman " ) ; » assert That « ( attr . » is Readable « ( ) ) . » is True « ( ) ; » assert That « ( attr . » is Writable « ( ) ) . » is False « ( ) ; }
@Test { » Method Name Based M Bean Info Assembler « assembler = » get With Mapping « ( " foobar " , " add , » my Operation « , » get Name « , » set Name « , » get Age « " ) ; assembler . » set Managed Methods « ( " » get Nick Name « " , " » set Nick Name « " ) ; » Model M Bean Info « inf = assembler . » get M Bean Info « ( » get Bean « ( ) , » get Object Name « ( ) ) ; » M Bean Attribute Info « attr = inf . » get Attribute « ( " » Nick Name « " ) ; » assert Nick Name « ( attr ) ; }
@Test { » Model M Bean Info « inf = ( » Model M Bean Info « ) » get M Bean Info « ( ) ; » M Bean Attribute Info « attr = inf . » get Attribute « ( " » Nick Name « " ) ; » assert Nick Name « ( attr ) ; }
@Test { » Model M Bean Info « info = » get M Bean Info From Assembler « ( ) ; » M Bean Operation Info « » operation Set Age « = info . » get Operation « ( " » set Name « " ) ; » assert That « ( » operation Set Age « . » get Signature « ( ) [ 0 ] . » get Name « ( ) ) . » is Equal To « ( " name " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get With Mapping « ( " com . foo . bar . Unknown " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get With Mapping « ( " » Jmx Test Bean « " ) ) ; }
@Test { » Interface Based M Bean Info Assembler « assembler = » get With Mapping « ( " foobar " , " org . springframework . jmx . export . assembler . » I Custom Jmx Bean « " ) ; assembler . » set Managed Interfaces « ( new Class < ? > [ ] { » I Additional Test Methods « . class } ) ; » Model M Bean Info « inf = assembler . » get M Bean Info « ( » get Bean « ( ) , » get Object Name « ( ) ) ; » M Bean Attribute Info « attr = inf . » get Attribute « ( " » Nick Name « " ) ; » assert Nick Name « ( attr ) ; }
@Test { » Object Naming Strategy « strat = » get Strategy « ( ) ; » Object Name « » object Name « = strat . » get Object Name « ( » get Managed Resource « ( ) , » get Key « ( ) ) ; » assert That « ( » get Correct Object Name « ( ) ) . » is Equal To « ( » object Name « . » get Canonical Name « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Model M Bean Notification Publisher « ( null , » create Object Name « ( ) , this ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Model M Bean Notification Publisher « ( new » Spring Model M Bean « ( ) , null , this ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Model M Bean Notification Publisher « ( new » Spring Model M Bean « ( ) , » create Object Name « ( ) , null ) ) ; }
@Test { » Notification Publisher « publisher = new » Model M Bean Notification Publisher « ( new » Spring Model M Bean « ( ) , » create Object Name « ( ) , this ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> publisher . » send Notification « ( null ) ) ; }
@Test { » Connector Server Factory Bean « bean = new » Connector Server Factory Bean « ( ) ; bean . » set Service Url « ( this . » service Url « ) ; bean . » after Properties Set « ( ) ; try { » check Server Connection « ( » get Server « ( ) ) ; } finally { bean . destroy ( ) ; } }
@Test { » Connector Server Factory Bean « bean = new » Connector Server Factory Bean « ( ) ; bean . » set Service Url « ( this . » service Url « ) ; bean . » set Server « ( » get Server « ( ) ) ; bean . » after Properties Set « ( ) ; try { » check Server Connection « ( » get Server « ( ) ) ; } finally { bean . destroy ( ) ; } }
@Test { » Connector Server Factory Bean « bean = new » Connector Server Factory Bean « ( ) ; bean . » set Service Url « ( this . » service Url « ) ; bean . » set Object Name « ( » OBJECT _ NAME « ) ; bean . » after Properties Set « ( ) ; try { » Object Instance « instance = » get Server « ( ) . » get Object Instance « ( » Object Name « . » get Instance « ( » OBJECT _ NAME « ) ) ; » assert That « ( instance ) . as ( " » Object Instance « should not be null " ) . » is Not Null « ( ) ; } finally { bean . destroy ( ) ; } }
@Test { » Connector Server Factory Bean « bean = new » Connector Server Factory Bean « ( ) ; bean . » set Service Url « ( this . » service Url « ) ; bean . » after Properties Set « ( ) ; try { » assert That Exception Of Type « ( » Instance Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » get Server « ( ) . » get Object Instance « ( » Object Name « . » get Instance « ( » OBJECT _ NAME « ) ) ) ; } finally { bean . destroy ( ) ; } }
@Test { » M Bean Server Connection Factory Bean « bean = new » M Bean Server Connection Factory Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( bean :: » after Properties Set « ) . » with Message « ( " Property 'serviceUrl' is required " ) ; }
@Test { » M Bean Server Connection Factory Bean « bean = new » M Bean Server Connection Factory Bean « ( ) ; bean . » set Service Url « ( this . » service Url « ) ; bean . » set Connect On Startup « ( false ) ; bean . » after Properties Set « ( ) ; » M Bean Server Connection « connection = bean . » get Object « ( ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( connection ) ) . » is True « ( ) ; bean . destroy ( ) ; }
@Test { » M Bean Server Factory Bean « bean = new » M Bean Server Factory Bean « ( ) ; bean . » after Properties Set « ( ) ; try { » M Bean Server « server = bean . » get Object « ( ) ; » assert That « ( server ) . as ( " The » M Bean Server « should not be null " ) . » is Not Null « ( ) ; } finally { bean . destroy ( ) ; } }
@Test { » M Bean Server Factory Bean « bean = new » M Bean Server Factory Bean « ( ) ; bean . » set Default Domain « ( " foo " ) ; bean . » after Properties Set « ( ) ; try { » M Bean Server « server = bean . » get Object « ( ) ; » assert That « ( server . » get Default Domain « ( ) ) . as ( " The default domain should be foo " ) . » is Equal To « ( " foo " ) ; } finally { bean . destroy ( ) ; } }
@Test { » M Bean Server Factory Bean « bean = new » M Bean Server Factory Bean « ( ) ; bean . » set Locate Existing Server If Possible « ( true ) ; bean . » after Properties Set « ( ) ; try { » assert That « ( bean . » get Object « ( ) ) . » is Same As « ( » Management Factory « . » get Platform M Bean Server « ( ) ) ; } finally { bean . destroy ( ) ; } }
@Test { » M Bean Server Factory Bean « bean = new » M Bean Server Factory Bean « ( ) ; bean . » set Agent Id « ( " " ) ; bean . » after Properties Set « ( ) ; try { » assert That « ( bean . » get Object « ( ) ) . » is Same As « ( » Management Factory « . » get Platform M Bean Server « ( ) ) ; } finally { bean . destroy ( ) ; } }
@Test { » assert Creation « ( true , " The server should be available in the list " ) ; }
@Test { » assert Creation « ( false , " The server should not be available in the list " ) ; }
@Test { » assert That « ( » Jmx Utils « . » is M Bean « ( » Jmx Class « . class ) ) . » is True « ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( » Specialized Jmx Interface « . class ) ) . » is False « ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( » Jmx Interface « . class ) ) . » is False « ( ) ; }
@Test { » Dynamic M Bean « mbean = new » Test Dynamic M Bean « ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( mbean . » get Class « ( ) ) ) . as ( " Dynamic » M Bean « not detected correctly " ) . » is True « ( ) ; }
@Test { » Standard M Bean « mbean = new » Standard M Bean « ( new » Jmx Test Bean « ( ) , » I Jmx Test Bean « . class ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( mbean . » get Class « ( ) ) ) . as ( " Standard » M Bean « not detected correctly " ) . » is True « ( ) ; }
@Test { » Standard M Bean « mbean = new » Standard M Bean Impl « ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( mbean . » get Class « ( ) ) ) . as ( " Standard » M Bean « not detected correctly " ) . » is True « ( ) ; }
@Test { » assert That « ( » Jmx Utils « . » is M Bean « ( Object . class ) ) . as ( " Object incorrectly identified as an » M Bean « " ) . » is False « ( ) ; }
@Test { Foo foo = new Foo ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( foo . » get Class « ( ) ) ) . as ( " Simple » M Bean « not detected correctly " ) . » is True « ( ) ; }
@Test { » Foo X « foo = new » Foo X « ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( foo . » get Class « ( ) ) ) . as ( " Simple » MX Bean « not detected correctly " ) . » is True « ( ) ; }
@Test { Bar bar = new Bar ( ) ; Abc abc = new Abc ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( bar . » get Class « ( ) ) ) . as ( " Simple » M Bean « ( through inheritance ) not detected correctly " ) . » is True « ( ) ; » assert That « ( » Jmx Utils « . » is M Bean « ( abc . » get Class « ( ) ) ) . as ( " Simple » M Bean « ( through 2 levels of inheritance ) not detected correctly " ) . » is True « ( ) ; }
@Test { » Property Descriptor « pd = new » Bean Wrapper Impl « ( » Attribute Test Bean « . class ) . » get Property Descriptor « ( " name " ) ; String » attribute Name « = » Jmx Utils « . » get Attribute Name « ( pd , true ) ; » assert That « ( » attribute Name « ) . as ( " Incorrect casing on attribute name " ) . » is Equal To « ( " Name " ) ; }
@Test { » Property Descriptor « pd = new » Bean Wrapper Impl « ( » Attribute Test Bean « . class ) . » get Property Descriptor « ( " name " ) ; String » attribute Name « = » Jmx Utils « . » get Attribute Name « ( pd , false ) ; » assert That « ( » attribute Name « ) . as ( " Incorrect casing on attribute name " ) . » is Equal To « ( " name " ) ; }
@Test { » M Bean Server « server = null ; try { server = » Jmx Utils « . » locate M Bean Server « ( ) ; } finally { if ( server != null ) { » M Bean Server Factory « . » release M Bean Server « ( server ) ; } } }
@Test { Field » builder Field « = » Naming Manager « . class . » get Declared Field « ( " » initctx _ factory _ builder « " ) ; » builder Field « . » set Accessible « ( true ) ; Object » old Builder « = » builder Field « . get ( null ) ; » builder Field « . set ( null , null ) ; try { » assert That « ( » Jndi Locator Delegate « . » is Default Jndi Environment Available « ( ) ) . » is Equal To « ( false ) ; } finally { » builder Field « . set ( null , » old Builder « ) ; } }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( jof :: » after Properties Set « ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " java : comp / env / foo " , o ) ) ; jof . » set Jndi Name « ( " java : comp / env / foo " ) ; jof . » set Resource Ref « ( true ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == o ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " java : comp / env / foo " , o ) ) ; jof . » set Jndi Name « ( " java : comp / env / foo " ) ; jof . » set Resource Ref « ( false ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == o ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " java : foo " , o ) ) ; jof . » set Jndi Name « ( " java : foo " ) ; jof . » set Resource Ref « ( true ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == o ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " java : foo " , o ) ) ; jof . » set Jndi Name « ( " java : foo " ) ; jof . » set Resource Ref « ( false ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == o ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " java : comp / env / foo " , o ) ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Resource Ref « ( true ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == o ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " java : comp / env / foo " , o ) ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Resource Ref « ( false ) ; » assert That Exception Of Type « ( » Naming Exception « . class ) . » is Thrown By « ( jof :: » after Properties Set « ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; Object o = new Object ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , o ) ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Resource Ref « ( false ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == o ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; String s = " " ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , s ) ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Expected Type « ( String . class ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) == s ) . » is True « ( ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , new Object ( ) ) ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Expected Type « ( String . class ) ; » assert That Exception Of Type « ( » Naming Exception « . class ) . » is Thrown By « ( jof :: » after Properties Set « ) . » with Message Containing « ( " java . lang . String " ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , " " ) ) ; jof . » set Jndi Name « ( " » my Foo « " ) ; jof . » set Expected Type « ( String . class ) ; jof . » set Default Object « ( " » my String « " ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) ) . » is Equal To « ( " » my String « " ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , " " ) ) ; jof . » set Jndi Name « ( " » my Foo « " ) ; jof . » set Expected Type « ( Integer . class ) ; jof . » set Default Object « ( " 5 " ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) ) . » is Equal To « ( new Integer ( 5 ) ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , " " ) ) ; jof . » set Jndi Name « ( " » my Foo « " ) ; jof . » set Expected Type « ( Integer . class ) ; jof . » set Default Object « ( " 5 " ) ; jof . » set Bean Factory « ( new » Default Listable Bean Factory « ( ) ) ; jof . » after Properties Set « ( ) ; » assert That « ( jof . » get Object « ( ) ) . » is Equal To « ( new Integer ( 5 ) ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , " " ) ) ; jof . » set Jndi Name « ( " » my Foo « " ) ; jof . » set Expected Type « ( Boolean . class ) ; jof . » set Default Object « ( " 5 " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( jof :: » after Properties Set « ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; » Test Bean « tb = new » Test Bean « ( ) ; jof . » set Jndi Template « ( new » Expected Lookup Template « ( " foo " , tb ) ) ; jof . » set Jndi Name « ( " » my Foo « " ) ; jof . » set Proxy Interface « ( » I Test Bean « . class ) ; jof . » set Default Object « ( Boolean . TRUE ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( jof :: » after Properties Set « ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Lookup On Startup « ( false ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( jof :: » after Properties Set « ) ; }
@Test { » Jndi Object Factory Bean « jof = new » Jndi Object Factory Bean « ( ) ; jof . » set Jndi Name « ( " foo " ) ; jof . » set Cache « ( false ) ; jof . » set Lookup On Startup « ( false ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( jof :: » after Properties Set « ) ; }
@Test { » Jndi Property Source « ps = new » Jndi Property Source « ( " » jndi Properties « " ) ; » assert That « ( ps . » get Property « ( " bogus " ) ) . » is Null « ( ) ; }
@Test { » Jndi Locator Delegate « » jndi Locator « = new » Jndi Locator Delegate « ( ) { @ Override public Object lookup ( String » jndi Name « ) throws » Naming Exception « { throw new » Illegal State Exception « ( " Should not get called " ) ; } } ; » jndi Locator « . » set Resource Ref « ( true ) ; » Jndi Property Source « ps = new » Jndi Property Source « ( " » jndi Properties « " , » jndi Locator « ) ; » assert That « ( ps . » get Property « ( " » property Key « : » default Value « " ) ) . » is Null « ( ) ; }
@Test { » Jndi Locator Delegate « » jndi Locator « = new » Jndi Locator Delegate « ( ) { @ Override public Object lookup ( String » jndi Name « ) throws » Naming Exception « { » assert That « ( » jndi Name « ) . » is Equal To « ( " my : key " ) ; return " my : value " ; } } ; » jndi Locator « . » set Resource Ref « ( false ) ; » Jndi Property Source « ps = new » Jndi Property Source « ( " » jndi Properties « " , » jndi Locator « ) ; » assert That « ( ps . » get Property « ( " my : key " ) ) . » is Equal To « ( " my : value " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Jndi Template Editor « ( ) . » set As Text « ( null ) ) ; }
@Test { » Jndi Template Editor « je = new » Jndi Template Editor « ( ) ; je . » set As Text « ( " " ) ; » Jndi Template « jt = ( » Jndi Template « ) je . » get Value « ( ) ; » assert That « ( jt . » get Environment « ( ) == null ) . » is True « ( ) ; }
@Test { Object o = new Object ( ) ; String name = " foo " ; final Context context = mock ( Context . class ) ; given ( context . lookup ( name ) ) . » will Return « ( o ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; Object » o 2 « = jt . lookup ( name ) ; » assert That « ( » o 2 « ) . » is Equal To « ( o ) ; verify ( context ) . close ( ) ; }
@Test { » Name Not Found Exception « ne = new » Name Not Found Exception « ( ) ; String name = " foo " ; final Context context = mock ( Context . class ) ; given ( context . lookup ( name ) ) . » will Throw « ( ne ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; » assert That Exception Of Type « ( » Name Not Found Exception « . class ) . » is Thrown By « ( ( ) -> jt . lookup ( name ) ) ; verify ( context ) . close ( ) ; }
@Test { String name = " foo " ; final Context context = mock ( Context . class ) ; given ( context . lookup ( name ) ) . » will Return « ( null ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; » assert That Exception Of Type « ( » Name Not Found Exception « . class ) . » is Thrown By « ( ( ) -> jt . lookup ( name ) ) ; verify ( context ) . close ( ) ; }
@Test { Object o = new Object ( ) ; String name = " foo " ; final Context context = mock ( Context . class ) ; given ( context . lookup ( name ) ) . » will Return « ( o ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; » assert That Exception Of Type « ( » Type Mismatch Naming Exception « . class ) . » is Thrown By « ( ( ) -> jt . lookup ( name , String . class ) ) ; verify ( context ) . close ( ) ; }
@Test { Object o = new Object ( ) ; String name = " foo " ; final Context context = mock ( Context . class ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; jt . bind ( name , o ) ; verify ( context ) . bind ( name , o ) ; verify ( context ) . close ( ) ; }
@Test { Object o = new Object ( ) ; String name = " foo " ; final Context context = mock ( Context . class ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; jt . rebind ( name , o ) ; verify ( context ) . rebind ( name , o ) ; verify ( context ) . close ( ) ; }
@Test { String name = " something " ; final Context context = mock ( Context . class ) ; » Jndi Template « jt = new » Jndi Template « ( ) { @ Override protected Context » create Initial Context « ( ) { return context ; } } ; jt . unbind ( name ) ; verify ( context ) . unbind ( name ) ; verify ( context ) . close ( ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Remote Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Connect Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Connect IO Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Unknown Host Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » No Such Object Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Stub Not Found Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Marshal Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception « ( » Unmarshal Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception And Refresh « ( » Connect Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception And Refresh « ( » Connect IO Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception And Refresh « ( » Unknown Host Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception And Refresh « ( » No Such Object Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Exception And Refresh « ( » Stub Not Found Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception « ( » Remote Exception « . class , » Remote Access Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception « ( » Connect Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception « ( » Connect IO Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception « ( » Unknown Host Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception « ( » No Such Object Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception « ( » Stub Not Found Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception And Refresh « ( » Remote Exception « . class , » Remote Access Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception And Refresh « ( » Connect Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception And Refresh « ( » Connect IO Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception And Refresh « ( » Unknown Host Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception And Refresh « ( » No Such Object Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » do Test Rmi Proxy Factory Bean With Business Interface And Exception And Refresh « ( » Stub Not Found Exception « . class , » Remote Connect Failure Exception « . class ) ; }
@Test { » Rmi Client Interceptor « client = new » Rmi Client Interceptor « ( ) ; client . » set Service Interface « ( » I Remote Bean « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( client :: » after Properties Set « ) ; }
@Test { try { throw new » Illegal State Exception « ( " Mmm " ) ; } catch ( Exception ex ) { int » original Stack Trace Lngth « = ex . » get Stack Trace « ( ) . length ; » Remote Invocation Utils « . » fill In Client Stack Trace If Possible « ( ex ) ; » assert That « ( ex . » get Stack Trace « ( ) . length > » original Stack Trace Lngth « ) . as ( " Stack trace not being filled in " ) . » is True « ( ) ; } }
@Test { » Remote Invocation Utils « . » fill In Client Stack Trace If Possible « ( null ) ; }
@Test { » Configurable Application Context « context = » init Context « ( new » Root Bean Definition « ( » Async Annotation Bean Post Processor « . class ) ) ; Object target = context . » get Bean « ( " target " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( target ) ) . » is True « ( ) ; context . close ( ) ; }
@Test { » Configurable Application Context « context = » init Context « ( new » Root Bean Definition « ( » Async Annotation Bean Post Processor « . class ) ) ; » I Test Bean « » test Bean « = context . » get Bean « ( " target " , » I Test Bean « . class ) ; » test Bean « . test ( ) ; Thread » main Thread « = Thread . » current Thread « ( ) ; » test Bean « . await ( 3000 ) ; Thread » async Thread « = » test Bean « . » get Thread « ( ) ; » assert That « ( » async Thread « ) . » is Not Same As « ( » main Thread « ) ; context . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Async Config « . class ) ; ctx . refresh ( ) ; » Async Bean « » async Bean « = ctx . » get Bean « ( » Async Bean « . class ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( » async Bean « ) ) . » is True « ( ) ; » async Bean « . work ( ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Async Config With Mockito « . class , » Async Bean User « . class ) ; ctx . refresh ( ) ; » Async Bean User « » async Bean User « = ctx . » get Bean « ( » Async Bean User « . class ) ; » Async Bean « » async Bean « = » async Bean User « . » get Async Bean « ( ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( » async Bean « ) ) . » is True « ( ) ; » async Bean « . work ( ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Async Config « . class , » Async Bean With Interface « . class , » Async Bean User « . class ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ctx :: refresh ) . » with Cause Instance Of « ( » Bean Not Of Required Type Exception « . class ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Async Config « . class , » Async Bean User « . class , » Async Bean With Interface « . class ) ; » assert That Exception Of Type « ( » Unsatisfied Dependency Exception « . class ) . » is Thrown By « ( ctx :: refresh ) . » with Cause Instance Of « ( » Bean Not Of Required Type Exception « . class ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Async Config « . class ) ; ctx . refresh ( ) ; » Async Annotation Bean Post Processor « bpp = ctx . » get Bean « ( » Async Annotation Bean Post Processor « . class ) ; » assert That « ( bpp . » get Order « ( ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Ordered Async Config « . class ) ; ctx . refresh ( ) ; » Async Annotation Bean Post Processor « bpp = ctx . » get Bean « ( » Async Annotation Bean Post Processor « . class ) ; » assert That « ( bpp . » get Order « ( ) ) . » is Equal To « ( Ordered . » HIGHEST _ PRECEDENCE « ) ; ctx . close ( ) ; }
@Test { @ » Suppress Warnings « ( " resource " ) » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( ) ; ctx . register ( » Aspect J Async Annotation Config « . class ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ctx :: refresh ) ; }
@Test { » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Jdk Proxy Configuration « . class ) ) . » with Cause Instance Of « ( » Bean Not Of Required Type Exception « . class ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Fixed Rate Task Config « . class ) ; » assert That « ( ctx . » get Bean « ( » Scheduled Task Holder « . class ) . » get Scheduled Tasks « ( ) . size ( ) ) . » is Equal To « ( 2 ) ; Thread . sleep ( 100 ) ; » assert That « ( ctx . » get Bean « ( » Atomic Integer « . class ) . get ( ) ) . » is Greater Than Or Equal To « ( 10 ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Fixed Rate Task Config Subclass « . class ) ; » assert That « ( ctx . » get Bean « ( » Scheduled Task Holder « . class ) . » get Scheduled Tasks « ( ) . size ( ) ) . » is Equal To « ( 2 ) ; Thread . sleep ( 100 ) ; » assert That « ( ctx . » get Bean « ( » Atomic Integer « . class ) . get ( ) ) . » is Greater Than Or Equal To « ( 10 ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Ambiguous Explicit Scheduler Config « . class ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Scheduling Enabled _ with Ambiguous Task Schedulers _ but No Actual Tasks « . class ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Scheduling Enabled _ with Ambiguous Task Schedulers _ and Single Task « . class ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Scheduling Enabled _ with Ambiguous Task Schedulers _ and Single Task _ disambiguated By Scheduled Task Registrar « . class ) ; Thread . sleep ( 100 ) ; » assert That « ( ctx . » get Bean « ( » Thread Aware Worker « . class ) . » executed By Thread « ) . » starts With « ( " » explicit Scheduler 2 « - " ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Scheduling Enabled _ with Ambiguous Task Schedulers _ and Single Task _ disambiguated By Scheduler Name Attribute « . class ) ; Thread . sleep ( 100 ) ; » assert That « ( ctx . » get Bean « ( » Thread Aware Worker « . class ) . » executed By Thread « ) . » starts With « ( " » explicit Scheduler 2 « - " ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Scheduling Enabled _ with Task Added Via _ configure Tasks « . class ) ; Thread . sleep ( 100 ) ; » assert That « ( ctx . » get Bean « ( » Thread Aware Worker « . class ) . » executed By Thread « ) . » starts With « ( " » task Scheduler « - " ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Trigger Task Config « . class ) ; Thread . sleep ( 100 ) ; » assert That « ( ctx . » get Bean « ( » Atomic Integer « . class ) . get ( ) ) . » is Greater Than « ( 1 ) ; }
@Test { ctx = new » Annotation Config Application Context « ( » Fixed Rate Task Config _ with Initial Delay « . class ) ; Thread . sleep ( 1950 ) ; » Atomic Integer « counter = ctx . » get Bean « ( » Atomic Integer « . class ) ; » assert That « ( counter . get ( ) ) . » is Between « ( 1 , 10 ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Several Fixed Rates With Repeated Scheduled Annotation Test Bean « . class ) ; » several Fixed Rates « ( context , » processor Definition « , » target Definition « ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Several Fixed Rates With Schedules Container Annotation Test Bean « . class ) ; » several Fixed Rates « ( context , » processor Definition « , » target Definition « ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Fixed Rates Sub Bean « . class ) ; » several Fixed Rates « ( context , » processor Definition « , » target Definition « ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Fixed Rates Default Bean « . class ) ; » several Fixed Rates « ( context , » processor Definition « , » target Definition « ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Several Fixed Rates With Repeated Scheduled Annotation Test Bean « . class ) ; » target Definition « . » set Factory Method Name « ( " » nested Proxy « " ) ; » several Fixed Rates « ( context , » processor Definition « , » target Definition « ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Cron With Invalid Timezone Test Bean « . class ) ; context . » register Bean Definition « ( " » post Processor « " , » processor Definition « ) ; context . » register Bean Definition « ( " target " , » target Definition « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( context :: refresh ) ; }
@Test { » property Placeholder With Fixed Delay « ( false ) ; }
@Test { » property Placeholder With Fixed Delay « ( true ) ; }
@Test { » property Placeholder With Fixed Rate « ( false ) ; }
@Test { » property Placeholder With Fixed Rate « ( true ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Empty Annotation Test Bean « . class ) ; context . » register Bean Definition « ( " » post Processor « " , » processor Definition « ) ; context . » register Bean Definition « ( " target " , » target Definition « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( context :: refresh ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Invalid Cron Test Bean « . class ) ; context . » register Bean Definition « ( " » post Processor « " , » processor Definition « ) ; context . » register Bean Definition « ( " target " , » target Definition « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( context :: refresh ) ; }
@Test { » Bean Definition « » processor Definition « = new » Root Bean Definition « ( » Scheduled Annotation Bean Post Processor « . class ) ; » Bean Definition « » target Definition « = new » Root Bean Definition « ( » Non Empty Param List Test Bean « . class ) ; context . » register Bean Definition « ( " » post Processor « " , » processor Definition « ) ; context . » register Bean Definition « ( " target " , » target Definition « ) ; » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( context :: refresh ) ; }
@Test { » Test Task « task = new » Test Task « ( 1 ) ; executor . execute ( task ) ; await ( task ) ; » assert Thread Name Prefix « ( task ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; executor . execute ( task ) ; }
@Test { » Test Task « task = new » Test Task « ( 1 ) ; Future < ? > future = executor . submit ( task ) ; Object result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( result ) . » is Null « ( ) ; » assert Thread Name Prefix « ( task ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; Future < ? > future = executor . submit ( task ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( ( ) -> future . get ( 1000 , » Time Unit « . MILLISECONDS ) ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; }
@Test { Future < ? > » future 1 « = executor . submit ( new » Test Task « ( - 1 ) ) ; Future < ? > » future 2 « = executor . submit ( new » Test Task « ( - 1 ) ) ; » shutdown Executor « ( ) ; » assert That Exception Of Type « ( » Cancellation Exception « . class ) . » is Thrown By « ( ( ) -> { » future 1 « . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » future 2 « . get ( 1000 , » Time Unit « . MILLISECONDS ) ; } ) ; }
@Test { » Test Task « task = new » Test Task « ( 1 ) ; » Listenable Future « < ? > future = executor . » submit Listenable « ( task ) ; future . » add Callback « ( result -> outcome = result , ex -> outcome = ex ) ; Awaitility . await ( ) . » at Most « ( 1 , » Time Unit « . SECONDS ) . » poll Interval « ( 10 , » Time Unit « . MILLISECONDS ) . until ( future :: » is Done « ) ; » assert That « ( outcome ) . » is Null « ( ) ; » assert Thread Name Prefix « ( task ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; » Listenable Future « < ? > future = executor . » submit Listenable « ( task ) ; future . » add Callback « ( result -> outcome = result , ex -> outcome = ex ) ; Awaitility . await ( ) . » dont Catch Uncaught Exceptions « ( ) . » at Most « ( 1 , » Time Unit « . SECONDS ) . » poll Interval « ( 10 , » Time Unit « . MILLISECONDS ) . until ( ( ) -> future . » is Done « ( ) && outcome != null ) ; » assert That « ( outcome . » get Class « ( ) ) . » is Same As « ( » Runtime Exception « . class ) ; }
@Test { » Test Callable « task = new » Test Callable « ( 1 ) ; Future < String > future = executor . submit ( task ) ; String result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( result . substring ( 0 , » THREAD _ NAME _ PREFIX « . length ( ) ) ) . » is Equal To « ( » THREAD _ NAME _ PREFIX « ) ; }
@Test { » Test Callable « task = new » Test Callable « ( 0 ) ; Future < String > future = executor . submit ( task ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( ( ) -> future . get ( 1000 , » Time Unit « . MILLISECONDS ) ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » Test Callable « task = new » Test Callable « ( 0 ) ; » Listenable Future « < String > future = executor . » submit Listenable « ( task ) ; future . » add Callback « ( result -> outcome = result , ex -> outcome = ex ) ; Awaitility . await ( ) . » dont Catch Uncaught Exceptions « ( ) . » at Most « ( 1 , » Time Unit « . SECONDS ) . » poll Interval « ( 10 , » Time Unit « . MILLISECONDS ) . until ( ( ) -> future . » is Done « ( ) && outcome != null ) ; » assert That « ( outcome . » get Class « ( ) ) . » is Same As « ( » Runtime Exception « . class ) ; }
@Test { » Listenable Future « < ? > » future 1 « = executor . » submit Listenable « ( new » Test Callable « ( - 1 ) ) ; » Listenable Future « < ? > » future 2 « = executor . » submit Listenable « ( new » Test Callable « ( - 1 ) ) ; » shutdown Executor « ( ) ; » assert That Exception Of Type « ( » Cancellation Exception « . class ) . » is Thrown By « ( ( ) -> { » future 1 « . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » future 2 « . get ( 1000 , » Time Unit « . MILLISECONDS ) ; } ) ; }
@Test { » Concurrent Task Executor « executor = new » Concurrent Task Executor « ( ) ; executor . execute ( new » No Op Runnable « ( ) ) ; }
@Test { » Concurrent Task Executor « executor = new » Concurrent Task Executor « ( null ) ; executor . execute ( new » No Op Runnable « ( ) ) ; }
@Test { » Concurrent Task Executor « executor = new » Concurrent Task Executor « ( ) ; executor . » set Concurrent Executor « ( null ) ; executor . execute ( new » No Op Runnable « ( ) ) ; }
@Test { » Scheduled Executor Factory Bean « factory = new » Scheduled Executor Factory Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Pool Size « ( - 1 ) ) ; }
@Test { final » Scheduled Executor Service « executor = mock ( » Scheduled Executor Service « . class ) ; » Scheduled Executor Factory Bean « factory = new » Scheduled Executor Factory Bean « ( ) { @ Override protected » Scheduled Executor Service « » create Executor « ( int » pool Size « , » Thread Factory « » thread Factory « , » Rejected Execution Handler « » rejected Execution Handler « ) { return executor ; } } ; factory . » set Scheduled Executor Tasks « ( new » Scheduled Executor Task « [ ] { new » No Op Scheduled Executor Task « ( ) } ) ; factory . » after Properties Set « ( ) ; factory . destroy ( ) ; verify ( executor ) . » shutdown Now « ( ) ; }
@Test { Runnable runnable = mock ( Runnable . class ) ; » Scheduled Executor Factory Bean « factory = new » Scheduled Executor Factory Bean « ( ) ; factory . » set Scheduled Executor Tasks « ( new » Scheduled Executor Task « [ ] { new » Scheduled Executor Task « ( runnable ) } ) ; factory . » after Properties Set « ( ) ; » pause To Let Task Start « ( 1 ) ; factory . destroy ( ) ; verify ( runnable ) . run ( ) ; }
@Test { Runnable runnable = mock ( Runnable . class ) ; » Scheduled Executor Task « task = new » Scheduled Executor Task « ( runnable ) ; task . » set Period « ( 500 ) ; task . » set Fixed Rate « ( true ) ; » Scheduled Executor Factory Bean « factory = new » Scheduled Executor Factory Bean « ( ) ; factory . » set Scheduled Executor Tasks « ( new » Scheduled Executor Task « [ ] { task } ) ; factory . » after Properties Set « ( ) ; » pause To Let Task Start « ( 2 ) ; factory . destroy ( ) ; verify ( runnable , » at Least « ( 2 ) ) . run ( ) ; }
@Test { Runnable runnable = mock ( Runnable . class ) ; » Scheduled Executor Task « task = new » Scheduled Executor Task « ( runnable ) ; task . » set Period « ( 500 ) ; task . » set Delay « ( 3000 ) ; » Scheduled Executor Factory Bean « factory = new » Scheduled Executor Factory Bean « ( ) ; factory . » set Scheduled Executor Tasks « ( new » Scheduled Executor Task « [ ] { task } ) ; factory . » after Properties Set « ( ) ; » pause To Let Task Start « ( 1 ) ; factory . destroy ( ) ; verify ( runnable , never ( ) ) . run ( ) ; }
@Test { » Scheduled Executor Factory Bean « factory = new » Scheduled Executor Factory Bean « ( ) ; » assert That « ( factory . » get Object Type « ( ) ) . » is Equal To « ( » Scheduled Executor Service « . class ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Executor Config « . class ) ; » Executor Service « executor = context . » get Bean « ( » Executor Service « . class ) ; » Future Task « < String > task = new » Future Task « < > ( ( ) -> " foo " ) ; executor . execute ( task ) ; » assert That « ( task . get ( ) ) . » is Equal To « ( " foo " ) ; context . close ( ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; » Test Error Handler « » error Handler « = new » Test Error Handler « ( 1 ) ; scheduler . » set Error Handler « ( » error Handler « ) ; scheduler . execute ( task ) ; await ( » error Handler « ) ; » assert That « ( » error Handler « . » last Error « ) . » is Not Null « ( ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; » Test Error Handler « » error Handler « = new » Test Error Handler « ( 1 ) ; scheduler . » set Error Handler « ( » error Handler « ) ; Future < ? > future = scheduler . submit ( task ) ; Object result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; » assert That « ( result ) . » is Null « ( ) ; » assert That « ( » error Handler « . » last Error « ) . » is Not Null « ( ) ; }
@Test { » Test Callable « task = new » Test Callable « ( 0 ) ; » Test Error Handler « » error Handler « = new » Test Error Handler « ( 1 ) ; scheduler . » set Error Handler « ( » error Handler « ) ; Future < String > future = scheduler . submit ( task ) ; Object result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; » assert That « ( result ) . » is Null « ( ) ; » assert That « ( » error Handler « . » last Error « ) . » is Not Null « ( ) ; }
@Test { » Test Task « task = new » Test Task « ( 1 ) ; Future < ? > future = scheduler . schedule ( task , new Date ( ) ) ; Object result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( result ) . » is Null « ( ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; » assert Thread Name Prefix « ( task ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; Future < ? > future = scheduler . schedule ( task , new Date ( ) ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( ( ) -> future . get ( 1000 , » Time Unit « . MILLISECONDS ) ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » Test Task « task = new » Test Task « ( 0 ) ; » Test Error Handler « » error Handler « = new » Test Error Handler « ( 1 ) ; scheduler . » set Error Handler « ( » error Handler « ) ; Future < ? > future = scheduler . schedule ( task , new Date ( ) ) ; Object result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( future . » is Done « ( ) ) . » is True « ( ) ; » assert That « ( result ) . » is Null « ( ) ; » assert That « ( » error Handler « . » last Error « ) . » is Not Null « ( ) ; }
@Test { » Test Task « task = new » Test Task « ( 3 ) ; Future < ? > future = scheduler . schedule ( task , new » Test Trigger « ( 3 ) ) ; Object result = future . get ( 1000 , » Time Unit « . MILLISECONDS ) ; » assert That « ( result ) . » is Null « ( ) ; await ( task ) ; » assert Thread Name Prefix « ( task ) ; }
@Test { for ( int i = 0 ; i < 1000 ; i ++ ) { » schedule Trigger Task « ( ) ; } }
@Test { » assert That « ( context . » contains Bean « ( » Task Management Config Utils « . » ASYNC _ ANNOTATION _ PROCESSOR _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { » assert That « ( context . » contains Bean « ( » Task Management Config Utils « . » SCHEDULED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME « ) ) . » is True « ( ) ; }
@Test { Object executor = context . » get Bean « ( " » test Executor « " ) ; Object » post Processor « = context . » get Bean « ( » Task Management Config Utils « . » ASYNC _ ANNOTATION _ PROCESSOR _ BEAN _ NAME « ) ; » assert That « ( ( ( Supplier < ? > ) new » Direct Field Accessor « ( » post Processor « ) . » get Property Value « ( " executor " ) ) . get ( ) ) . » is Same As « ( executor ) ; }
@Test { Object scheduler = context . » get Bean « ( " » test Scheduler « " ) ; Object » post Processor « = context . » get Bean « ( » Task Management Config Utils « . » SCHEDULED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME « ) ; » assert That « ( new » Direct Field Accessor « ( » post Processor « ) . » get Property Value « ( " scheduler " ) ) . » is Same As « ( scheduler ) ; }
@Test { Object » exception Handler « = context . » get Bean « ( " » test Exception Handler « " ) ; Object » post Processor « = context . » get Bean « ( » Task Management Config Utils « . » ASYNC _ ANNOTATION _ PROCESSOR _ BEAN _ NAME « ) ; » assert That « ( ( ( Supplier < ? > ) new » Direct Field Accessor « ( » post Processor « ) . » get Property Value « ( " » exception Handler « " ) ) . get ( ) ) . » is Same As « ( » exception Handler « ) ; }
@Test { Object executor = this . context . » get Bean « ( " » single Size « " ) ; » assert That « ( » get Core Pool Size « ( executor ) ) . » is Equal To « ( 42 ) ; » assert That « ( » get Max Pool Size « ( executor ) ) . » is Equal To « ( 42 ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> this . context . » get Bean « ( " » invalid Pool Size « " ) ) ; }
@Test { Object executor = this . context . » get Bean « ( " » range With Bounded Queue « " ) ; » assert That « ( » get Core Pool Size « ( executor ) ) . » is Equal To « ( 7 ) ; » assert That « ( » get Max Pool Size « ( executor ) ) . » is Equal To « ( 42 ) ; » assert That « ( » get Queue Capacity « ( executor ) ) . » is Equal To « ( 11 ) ; }
@Test { Object executor = this . context . » get Bean « ( " » property Placeholder With Range « " ) ; » assert That « ( » get Core Pool Size « ( executor ) ) . » is Equal To « ( 5 ) ; » assert That « ( » get Max Pool Size « ( executor ) ) . » is Equal To « ( 25 ) ; » assert That « ( » get Allow Core Thread Time Out « ( executor ) ) . » is Equal To « ( false ) ; » assert That « ( » get Queue Capacity « ( executor ) ) . » is Equal To « ( 10 ) ; }
@Test { Object executor = this . context . » get Bean « ( " » property Placeholder With Range And Core Thread Timeout « " ) ; » assert That « ( » get Core Pool Size « ( executor ) ) . » is Equal To « ( 99 ) ; » assert That « ( » get Max Pool Size « ( executor ) ) . » is Equal To « ( 99 ) ; » assert That « ( » get Allow Core Thread Time Out « ( executor ) ) . » is Equal To « ( true ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> this . context . » get Bean « ( " » property Placeholder With Invalid Pool Size « " ) ) ; }
@Test { » Customizable Thread Creator « executor = this . context . » get Bean « ( " default " , » Customizable Thread Creator « . class ) ; » assert That « ( executor . » get Thread Name Prefix « ( ) ) . » is Equal To « ( " default - " ) ; }
@Test { » assert That « ( this . context . » is Type Match « ( " default " , Executor . class ) ) . » is True « ( ) ; » assert That « ( this . context . » is Type Match « ( " default " , » Task Executor « . class ) ) . » is True « ( ) ; » assert That « ( this . context . » is Type Match « ( " default " , » Thread Pool Task Executor « . class ) ) . » is True « ( ) ; }
@Test { try ( » Configurable Application Context « » application Context « = new » Generic Xml Application Context « ( » get Class « ( ) , " » lazy Scheduled Tasks Context « . xml " ) ) { Task task = » application Context « . » get Bean « ( Task . class ) ; while ( ! task . executed ) { try { Thread . sleep ( 10 ) ; } catch ( Exception ex ) { } } } }
@Test { » Trigger Task « » mock Trigger Task « = mock ( » Trigger Task « . class ) ; this . » task Registrar « . » set Trigger Tasks List « ( Collections . » singleton List « ( » mock Trigger Task « ) ) ; » assert That « ( this . » task Registrar « . » get Trigger Task List « ( ) ) . » contains Exactly « ( » mock Trigger Task « ) ; }
@Test { » Cron Task « » mock Cron Task « = mock ( » Cron Task « . class ) ; this . » task Registrar « . » set Cron Tasks List « ( Collections . » singleton List « ( » mock Cron Task « ) ) ; » assert That « ( this . » task Registrar « . » get Cron Task List « ( ) ) . » contains Exactly « ( » mock Cron Task « ) ; }
@Test { » Interval Task « » mock Fixed Rate Task « = mock ( » Interval Task « . class ) ; this . » task Registrar « . » set Fixed Rate Tasks List « ( Collections . » singleton List « ( » mock Fixed Rate Task « ) ) ; » assert That « ( this . » task Registrar « . » get Fixed Rate Task List « ( ) ) . » contains Exactly « ( » mock Fixed Rate Task « ) ; }
@Test { » Interval Task « » mock Fixed Delay Task « = mock ( » Interval Task « . class ) ; this . » task Registrar « . » set Fixed Delay Tasks List « ( Collections . » singleton List « ( » mock Fixed Delay Task « ) ) ; » assert That « ( this . » task Registrar « . » get Fixed Delay Task List « ( ) ) . » contains Exactly « ( » mock Fixed Delay Task « ) ; }
@Test { this . » task Registrar « . » add Cron Task « ( » no _ op « , " * * * * * ? " ) ; » assert That « ( this . » task Registrar « . » get Cron Task List « ( ) ) . » has Size « ( 1 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » task Registrar « . » add Cron Task « ( » no _ op « , " * * * " ) ) . » with Message « ( " Cron expression must consist of 6 fields ( found 3 in \" * * * \" ) " ) ; }
@Test { this . » task Registrar « . » add Cron Task « ( » no _ op « , » Scheduled Task Registrar « . » CRON _ DISABLED « ) ; » assert That « ( this . » task Registrar « . » get Cron Task List « ( ) ) . » is Empty « ( ) ; }
@Test { Object » scheduler Bean « = this . context . » get Bean « ( " » test Scheduler « " ) ; Object » scheduler Ref « = new » Direct Field Accessor « ( this . registrar ) . » get Property Value « ( " » task Scheduler « " ) ; » assert That « ( » scheduler Ref « ) . » is Equal To « ( » scheduler Bean « ) ; }
@Test { List < » Cron Task « > tasks = ( List < » Cron Task « > ) new » Direct Field Accessor « ( this . registrar ) . » get Property Value « ( " » cron Tasks « " ) ; » assert That « ( tasks . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( tasks . get ( 0 ) . » get Expression « ( ) ) . » is Equal To « ( " * / 4 * 9 - 17 * * MON - FRI " ) ; }
@Test { List < » Trigger Task « > tasks = ( List < » Trigger Task « > ) new » Direct Field Accessor « ( this . registrar ) . » get Property Value « ( " » trigger Tasks « " ) ; » assert That « ( tasks . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( tasks . get ( 0 ) . » get Trigger « ( ) ) . » is Instance Of « ( » Test Trigger « . class ) ; }
@Test { » Thread Pool Task Scheduler « scheduler = ( » Thread Pool Task Scheduler « ) this . context . » get Bean « ( " » default Scheduler « " ) ; Integer size = ( Integer ) new » Direct Field Accessor « ( scheduler ) . » get Property Value « ( " » pool Size « " ) ; » assert That « ( size ) . » is Equal To « ( new Integer ( 1 ) ) ; }
@Test { » Thread Pool Task Scheduler « scheduler = ( » Thread Pool Task Scheduler « ) this . context . » get Bean « ( " » custom Scheduler « " ) ; Integer size = ( Integer ) new » Direct Field Accessor « ( scheduler ) . » get Property Value « ( " » pool Size « " ) ; » assert That « ( size ) . » is Equal To « ( new Integer ( 42 ) ) ; }
@Test { » Thread Pool Task Scheduler « scheduler = ( » Thread Pool Task Scheduler « ) this . context . » get Bean « ( " » custom Scheduler « " ) ; » assert That « ( scheduler . » get Thread Name Prefix « ( ) ) . » is Equal To « ( " » custom Scheduler « - " ) ; }
@Test { » assert That « ( new » Cron Sequence Generator « ( " * / 15 * 1 - 4 * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 53 , 50 ) ) ) . » is Equal To « ( new Date ( 2012 , 6 , 2 , 1 , 0 ) ) ; }
@Test { » assert That « ( new » Cron Sequence Generator « ( " * / 15 * 1 - 4 * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 53 ) ) ) . » is Equal To « ( new Date ( 2012 , 6 , 2 , 1 , 0 ) ) ; }
@Test { » assert That « ( new » Cron Sequence Generator « ( " 0 * / 2 1 - 4 * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ) . » is Equal To « ( new Date ( 2012 , 6 , 2 , 1 , 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Cron Sequence Generator « ( " * / 0 * * * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Cron Sequence Generator « ( " * / - 1 * * * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Cron Sequence Generator « ( " * 6 - 5 * * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Cron Sequence Generator « ( " * * 6 - 5 * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ) ; }
@Test { new » Cron Sequence Generator « ( " * 6 - 6 * * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ; }
@Test { new » Cron Sequence Generator « ( " * * 6 - 6 * * * " ) . next ( new Date ( 2012 , 6 , 1 , 9 , 0 ) ) ; }
@Test { » assert That « ( » Cron Sequence Generator « . » is Valid Expression « ( " 0 * / 2 1 - 4 * * * " ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Cron Sequence Generator « . » is Valid Expression « ( " 0 * / 2 1 - 4 * * * * " ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Cron Sequence Generator « . » is Valid Expression « ( " 100 * / 2 1 - 4 * * * " ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Cron Sequence Generator « . » is Valid Expression « ( " 0 * / 2 1 - 4 * INVALID * " ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Cron Sequence Generator « . » is Valid Expression « ( null ) ) . » is False « ( ) ; }
@Test { Date now = new Date ( ) ; » Periodic Trigger « trigger = new » Periodic Trigger « ( 5000 ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Negligible Difference « ( now , next ) ; }
@Test { Date now = new Date ( ) ; long period = 5000 ; long » initial Delay « = 30000 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period ) ; trigger . » set Initial Delay « ( » initial Delay « ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Approximate Difference « ( now , next , » initial Delay « ) ; }
@Test { Date now = new Date ( ) ; » Periodic Trigger « trigger = new » Periodic Trigger « ( 5 , » Time Unit « . SECONDS ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Negligible Difference « ( now , next ) ; }
@Test { Date now = new Date ( ) ; long period = 5 ; long » initial Delay « = 30 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period , » Time Unit « . SECONDS ) ; trigger . » set Initial Delay « ( » initial Delay « ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Approximate Difference « ( now , next , » initial Delay « * 1000 ) ; }
@Test { Date now = new Date ( ) ; long period = 5000 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period ) ; Date next = trigger . » next Execution Time « ( context ( now , 500 , 3000 ) ) ; » assert Approximate Difference « ( now , next , period + 3000 ) ; }
@Test { Date now = new Date ( ) ; long period = 5000 ; long » initial Delay « = 30000 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period ) ; trigger . » set Initial Delay « ( » initial Delay « ) ; Date next = trigger . » next Execution Time « ( context ( now , 500 , 3000 ) ) ; » assert Approximate Difference « ( now , next , period + 3000 ) ; }
@Test { Date now = new Date ( ) ; long period = 5 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period , » Time Unit « . SECONDS ) ; Date next = trigger . » next Execution Time « ( context ( now , 500 , 3000 ) ) ; » assert Approximate Difference « ( now , next , ( period * 1000 ) + 3000 ) ; }
@Test { Date now = new Date ( ) ; » Periodic Trigger « trigger = new » Periodic Trigger « ( 5000 ) ; trigger . » set Fixed Rate « ( true ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Negligible Difference « ( now , next ) ; }
@Test { Date now = new Date ( ) ; » Periodic Trigger « trigger = new » Periodic Trigger « ( 5 , » Time Unit « . SECONDS ) ; trigger . » set Fixed Rate « ( true ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Negligible Difference « ( now , next ) ; }
@Test { Date now = new Date ( ) ; long period = 5000 ; long » initial Delay « = 30000 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period ) ; trigger . » set Fixed Rate « ( true ) ; trigger . » set Initial Delay « ( » initial Delay « ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Approximate Difference « ( now , next , » initial Delay « ) ; }
@Test { Date now = new Date ( ) ; long period = 5 ; long » initial Delay « = 30 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period , » Time Unit « . MINUTES ) ; trigger . » set Fixed Rate « ( true ) ; trigger . » set Initial Delay « ( » initial Delay « ) ; Date next = trigger . » next Execution Time « ( context ( null , null , null ) ) ; » assert Approximate Difference « ( now , next , ( » initial Delay « * 60 * 1000 ) ) ; }
@Test { Date now = new Date ( ) ; long period = 5000 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period ) ; trigger . » set Fixed Rate « ( true ) ; Date next = trigger . » next Execution Time « ( context ( now , 500 , 3000 ) ) ; » assert Approximate Difference « ( now , next , period ) ; }
@Test { Date now = new Date ( ) ; long period = 5000 ; long » initial Delay « = 30000 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period ) ; trigger . » set Fixed Rate « ( true ) ; trigger . » set Initial Delay « ( » initial Delay « ) ; Date next = trigger . » next Execution Time « ( context ( now , 500 , 3000 ) ) ; » assert Approximate Difference « ( now , next , period ) ; }
@Test { Date now = new Date ( ) ; long period = 5 ; » Periodic Trigger « trigger = new » Periodic Trigger « ( period , » Time Unit « . HOURS ) ; trigger . » set Fixed Rate « ( true ) ; Date next = trigger . » next Execution Time « ( context ( now , 500 , 3000 ) ) ; » assert Approximate Difference « ( now , next , ( period * 60 * 60 * 1000 ) ) ; }
@Test { » Script Evaluator « evaluator = new » Bsh Script Evaluator « ( ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return 3 * 2 ; " ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Script Evaluator « evaluator = new » Bsh Script Evaluator « ( ) ; Object result = evaluator . evaluate ( new » Resource Script Source « ( new » Class Path Resource « ( " simple . bsh " , » get Class « ( ) ) ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Script Evaluator « evaluator = new » Bsh Script Evaluator « ( ) ; Map < String , Object > arguments = new » Hash Map « < > ( ) ; arguments . put ( " a " , 3 ) ; arguments . put ( " b " , 2 ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return a * b ; " ) , arguments ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » assert That Exception Of Type « ( » Nested Runtime Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " org / springframework / scripting / bsh / » bsh Broken Context « . xml " ) ) . matches ( ex -> ex . contains ( » Script Compilation Exception « . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bsh Script Factory « ( null , Messenger . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bsh Script Factory « ( " " , Messenger . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bsh Script Factory « ( " \n " , Messenger . class ) ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " bsh - with - xsd . xml " , » get Class « ( ) ) ; Calculator calculator = ( Calculator ) ctx . » get Bean « ( " calculator " ) ; » assert That « ( calculator ) . » is Not Null « ( ) ; boolean condition = calculator instanceof Refreshable ; » assert That « ( condition ) . » is False « ( ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " bsh - with - xsd . xml " , » get Class « ( ) ) ; Messenger messenger = ( Messenger ) ctx . » get Bean « ( " » refreshable Messenger « " ) ; » assert That « ( messenger . » get Message « ( ) ) . » is Equal To « ( " Hello World ! " ) ; boolean condition = messenger instanceof Refreshable ; » assert That « ( condition ) . as ( " Messenger should be Refreshable " ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " bsh - with - xsd . xml " , » get Class « ( ) ) ; Messenger » event Listener « = ( Messenger ) ctx . » get Bean « ( " » event Listener « " ) ; ctx . » publish Event « ( new » My Event « ( ctx ) ) ; » assert That « ( » event Listener « . » get Message « ( ) ) . » is Equal To « ( " count = 2 " ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( CONFIG ) ; » I Test Bean « » test Bean « = ( » I Test Bean « ) context . » get Bean « ( " » test Bean « " ) ; » assert That « ( » test Bean « . » is Initialized « ( ) ) . » is True « ( ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( CONFIG ) ; » I Test Bean « » test Bean « = ( » I Test Bean « ) context . » get Bean « ( " / url " ) ; » assert That « ( » test Bean « . » is Initialized « ( ) ) . » is True « ( ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( CONFIG ) ; » I Test Bean « » test Bean « = ( » I Test Bean « ) context . » get Bean « ( " » non Refreshable Test Bean « " ) ; » assert That « ( » test Bean « . » is Destroyed « ( ) ) . » is False « ( ) ; context . close ( ) ; » assert That « ( » test Bean « . » is Destroyed « ( ) ) . » is True « ( ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( CONFIG ) ; » I Test Bean « » test Bean « = ( » I Test Bean « ) context . » get Bean « ( " » test Bean « " ) ; » I Test Bean « » other Bean « = ( » I Test Bean « ) context . » get Bean « ( " » other Bean « " ) ; » assert That « ( » test Bean « . » get Other Bean « ( ) ) . » is Equal To « ( » other Bean « ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( » PROXY _ CONFIG « ) ; Object » test Bean « = context . » get Bean « ( " » test Bean « " ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( » test Bean « ) ) . » is True « ( ) ; }
@Test { » Test Service « target = ( » Test Service « ) » script Factory « . » get Scripted Object « ( new » Resource Script Source « ( new » Class Path Resource « ( " » Groovy Service Impl « . grv " , » get Class « ( ) ) ) ) ; » test Advice « ( new » Default Pointcut Advisor « ( » log Advice « ) , » log Advice « , target , " » Groovy Service Impl « " ) ; }
@Test { » assert That Exception Of Type « ( » Nested Runtime Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " org / springframework / scripting / groovy / » groovy Broken Context « . xml " ) ) . matches ( ex -> ex . contains ( » Script Compilation Exception « . class ) ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " » two Classes Correct One First « . xml " , » get Class « ( ) ) ; Messenger messenger = ( Messenger ) ctx . » get Bean « ( " messenger " ) ; » assert That « ( messenger ) . » is Not Null « ( ) ; » assert That « ( messenger . » get Message « ( ) ) . » is Equal To « ( " Hello World ! " ) ; » Groovy Object « goo = ( » Groovy Object « ) messenger ; » assert That « ( goo ) . » is Not Null « ( ) ; }
@Test { » assert That Exception Of Type « ( Exception . class ) . as ( " two classes defined in » Groovy Script Factory « source , non - Messenger class defined first " ) . » is Thrown By « ( ( ) -> { » Application Context « ctx = new » Class Path Xml Application Context « ( " » two Classes Wrong One First « . xml " , » get Class « ( ) ) ; ctx . » get Bean « ( " messenger " , Messenger . class ) ; } ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Groovy Script Factory « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Groovy Script Factory « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Groovy Script Factory « ( " \n " ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . as ( " 'inline:' prefix was preceded by whitespace " ) . » is Thrown By « ( ( ) -> new » Class Path Xml Application Context « ( " » lwsp Bad Groovy Context « . xml " , » get Class « ( ) ) ) . matches ( ex -> ex . contains ( » File Not Found Exception « . class ) ) ; }
@Test { » Script Source « script = mock ( » Script Source « . class ) ; given ( script . » get Script As String « ( ) ) . » will Return « ( " class Bar { } " ) ; given ( script . » suggested Class Name « ( ) ) . » will Return « ( " » some Name « " ) ; » Groovy Script Factory « factory = new » Groovy Script Factory « ( " a script source locator ( does » n ' t « matter here ) " ) ; Object » scripted Object « = factory . » get Scripted Object « ( script ) ; » assert That « ( » scripted Object « ) . » is Not Null « ( ) ; }
@Test { » Groovy Script Factory « factory = new » Groovy Script Factory « ( " a script source locator ( does » n ' t « matter here ) " ) ; » assert That Null Pointer Exception « ( ) . as ( " » Null Pointer Exception « as per contract ( 'null' » Script Source « supplied ) " ) . » is Thrown By « ( ( ) -> factory . » get Scripted Object « ( null ) ) ; }
@Test { try { new » Class Path Xml Application Context « ( " groovy - with - xsd - proxy - target - class . xml " , » get Class « ( ) ) ; } catch ( » Bean Creation Exception « ex ) { » assert That « ( ex . » get Message « ( ) . contains ( " Cannot use » proxy Target Class « = true " ) ) . » is True « ( ) ; } }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " groovy - with - xsd . xml " , » get Class « ( ) ) ; Map < ? , Messenger > beans = ctx . » get Beans Of Type « ( Messenger . class ) ; » assert That « ( beans . size ( ) ) . » is Equal To « ( 4 ) ; » assert That « ( ctx . » get Bean « ( » My Bytecode Processor « . class ) . processed . contains ( " org . springframework . scripting . groovy . » Groovy Messenger 2 « " ) ) . » is True « ( ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " groovy - with - xsd - » jsr 223 « . xml " , » get Class « ( ) ) ; » assert That « ( Arrays . » as List « ( ctx . » get Bean Names For Type « ( Messenger . class ) ) . contains ( " » messenger With Interface « " ) ) . » is True « ( ) ; Messenger messenger = ( Messenger ) ctx . » get Bean « ( " » messenger With Interface « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( messenger ) ) . » is False « ( ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " groovy - with - xsd - » jsr 223 « . xml " , » get Class « ( ) ) ; » assert That « ( Arrays . » as List « ( ctx . » get Bean Names For Type « ( Messenger . class ) ) . contains ( " » inline Messenger « " ) ) . » is True « ( ) ; Messenger messenger = ( Messenger ) ctx . » get Bean « ( " » inline Messenger « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( messenger ) ) . » is False « ( ) ; }
@Test { » Application Context « ctx = new » Class Path Xml Application Context « ( " groovy - with - xsd - » jsr 223 « . xml " , » get Class « ( ) ) ; » assert That « ( Arrays . » as List « ( ctx . » get Bean Names For Type « ( Messenger . class ) ) . contains ( " » inline Messenger With Interface « " ) ) . » is True « ( ) ; Messenger messenger = ( Messenger ) ctx . » get Bean « ( " » inline Messenger With Interface « " ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( messenger ) ) . » is False « ( ) ; }
@Test { » test Meta Class « ( " org / springframework / scripting / groovy / calculators . xml " ) ; }
@Test { » test Meta Class « ( " org / springframework / scripting / groovy / calculators - with - xsd . xml " ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " » groovy Context « . xml " , » get Class « ( ) ) ; Object factory = context . » get Bean « ( " & factory " ) ; boolean » condition 1 « = factory instanceof » Factory Bean « ; » assert That « ( » condition 1 « ) . » is True « ( ) ; Object result = context . » get Bean « ( " factory " ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( " test " ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " » groovy Context « . xml " , » get Class « ( ) ) ; Object factory = context . » get Bean « ( " & » refreshable Factory « " ) ; boolean » condition 1 « = factory instanceof » Factory Bean « ; » assert That « ( » condition 1 « ) . » is True « ( ) ; Object result = context . » get Bean « ( " » refreshable Factory « " ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( " test " ) ; }
@Test { » Script Evaluator « evaluator = new » Groovy Script Evaluator « ( ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return 3 * 2 " ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Script Evaluator « evaluator = new » Groovy Script Evaluator « ( ) ; Object result = evaluator . evaluate ( new » Resource Script Source « ( new » Class Path Resource « ( " simple . groovy " , » get Class « ( ) ) ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Script Evaluator « evaluator = new » Groovy Script Evaluator « ( ) ; Map < String , Object > arguments = new » Hash Map « < > ( ) ; arguments . put ( " a " , 3 ) ; arguments . put ( " b " , 2 ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return a * b " ) , arguments ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Groovy Script Evaluator « evaluator = new » Groovy Script Evaluator « ( ) ; » My Bytecode Processor « processor = new » My Bytecode Processor « ( ) ; evaluator . » get Compiler Configuration « ( ) . » set Bytecode Postprocessor « ( processor ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return 3 * 2 " ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; » assert That « ( processor . processed . contains ( " » Script 1 « " ) ) . » is True « ( ) ; }
@Test { » Groovy Script Evaluator « evaluator = new » Groovy Script Evaluator « ( ) ; » Import Customizer « » import Customizer « = new » Import Customizer « ( ) ; » import Customizer « . » add Star Imports « ( " org . springframework . util " ) ; evaluator . » set Compilation Customizers « ( » import Customizer « ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return » Resource Utils « . » CLASSPATH _ URL _ PREFIX « " ) ) ; » assert That « ( result ) . » is Equal To « ( " classpath : " ) ; }
@Test { » Standard Script Evaluator « evaluator = new » Standard Script Evaluator « ( ) ; evaluator . » set Language « ( " Groovy " ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return 3 * 2 " ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Script Evaluator « evaluator = new » Standard Script Evaluator « ( ) ; Object result = evaluator . evaluate ( new » Resource Script Source « ( new » Class Path Resource « ( " simple . groovy " , » get Class « ( ) ) ) ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » Standard Script Evaluator « evaluator = new » Standard Script Evaluator « ( ) ; evaluator . » set Language « ( " Groovy " ) ; Map < String , Object > arguments = new » Hash Map « < > ( ) ; arguments . put ( " a " , 3 ) ; arguments . put ( " b " , 2 ) ; Object result = evaluator . evaluate ( new » Static Script Source « ( " return a * b " ) , arguments ) ; » assert That « ( result ) . » is Equal To « ( 6 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Refreshable Script Target Source « ( mock ( » Bean Factory « . class ) , " a . bean " , null , null , false ) ) ; }
@Test { Resource resource = mock ( Resource . class ) ; given ( resource . » last Modified « ( ) ) . » will Throw « ( new » IO Exception « ( ) ) ; » Resource Script Source « » script Source « = new » Resource Script Source « ( resource ) ; long » last Modified « = » script Source « . » retrieve Last Modified Time « ( ) ; » assert That « ( » last Modified « ) . » is Equal To « ( 0 ) ; }
@Test { Resource resource = mock ( Resource . class ) ; » Resource Script Source « » script Source « = new » Resource Script Source « ( resource ) ; » assert That « ( » script Source « . » is Modified « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( new » Script Factory Post Processor « ( ) . » post Process Before Instantiation « ( » get Class « ( ) , " a . bean " ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Script Factory Post Processor « ( ) . » set Bean Factory « ( mock ( » Bean Factory « . class ) ) ) ; }
@Test { new » Class Path Xml Application Context « ( " org / springframework / scripting / support / » groovy References « . xml " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Static Script Source « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Static Script Source « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Static Script Source « ( " \n \n \t \t \n " ) ) ; }
@Test { » assert That « ( source . » is Modified « ( ) ) . as ( " Script must be flagged as 'modified' when first created . " ) . » is True « ( ) ; }
@Test { source . » get Script As String « ( ) ; » assert That « ( source . » is Modified « ( ) ) . as ( " Script must be flagged as 'not modified' after script is read . " ) . » is False « ( ) ; }
@Test { boolean » is Modified State « = source . » is Modified « ( ) ; source . » to String « ( ) ; » assert That « ( source . » is Modified « ( ) ) . as ( " Script » ' s « » ' modified « ' flag must not change after script is read via » to String « ( ) . " ) . » is Equal To « ( » is Modified State « ) ; }
@Test { source . » set Script « ( " use warnings ; " ) ; » assert That « ( source . » is Modified « ( ) ) . as ( " Script must be flagged as 'modified' when different script is passed in . " ) . » is True « ( ) ; }
@Test { source . » set Script « ( » SCRIPT _ TEXT « ) ; » assert That « ( source . » is Modified « ( ) ) . as ( " Script must not be flagged as 'modified' when same script is passed in . " ) . » is False « ( ) ; }
@Test { » assert That « ( new » Model Map « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Model Map « model = new » Model Map « ( ) ; model . » add Attribute « ( " foo " , null ) ; » assert That « ( model . » contains Key « ( " foo " ) ) . » is True « ( ) ; » assert That « ( model . get ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Model Map « model = new » Model Map « ( " foo " , null ) ; » assert That « ( model . » contains Key « ( " foo " ) ) . » is True « ( ) ; » assert That « ( model . get ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Model Map « model = new » Model Map « ( " foo " , " bing " ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 1 ) ; String bing = ( String ) model . get ( " foo " ) ; » assert That « ( bing ) . » is Not Null « ( ) ; » assert That « ( bing ) . » is Equal To « ( " bing " ) ; }
@Test { » Model Map « model = new » Model Map « ( " bing " ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 1 ) ; String string = ( String ) model . get ( " string " ) ; » assert That « ( string ) . » is Not Null « ( ) ; » assert That « ( string ) . » is Equal To « ( " bing " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Model Map « ( null ) ) ; }
@Test { » Model Map « model = new » Model Map « ( new » Hash Set « < > ( ) ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Model Map « model = new » Model Map « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> model . » add Attribute « ( null ) ) ; }
@Test { » Model Map « model = new » Model Map « ( new int [ ] { } ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 1 ) ; int [ ] ints = ( int [ ] ) model . get ( " » int List « " ) ; » assert That « ( ints ) . » is Not Null « ( ) ; » assert That « ( ints . length ) . » is Equal To « ( 0 ) ; }
@Test { » Model Map « model = new » Model Map « ( ) ; model . » add All Attributes « ( ( Map < String , ? > ) null ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Model Map « model = new » Model Map « ( ) ; model . » add All Attributes « ( ( Collection < Object > ) null ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Model Map « model = new » Model Map « ( ) ; » Array List « < String > list = new » Array List « < > ( ) ; list . add ( " bing " ) ; list . add ( null ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> model . » add All Attributes « ( list ) ) ; }
@Test { » Model Map « model = new » Model Map « ( ) ; model . » add Attribute « ( " foo " ) ; model . » add Attribute « ( " bar " ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 1 ) ; String bar = ( String ) model . get ( " string " ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; }
@Test { List < » Test Bean « > beans = new » Array List « < > ( ) ; beans . add ( new » Test Bean « ( " one " ) ) ; beans . add ( new » Test Bean « ( " two " ) ) ; beans . add ( new » Test Bean « ( " three " ) ) ; » Model Map « model = new » Model Map « ( ) ; model . » add All Attributes « ( beans ) ; » assert That « ( model . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Model Map « map = new » Model Map « ( ) ; » Some Inner Class « inner = new » Some Inner Class « ( ) ; map . » add Attribute « ( inner ) ; » assert That « ( map . get ( " » some Inner Class « " ) ) . » is Same As « ( inner ) ; }
@Test { » Model Map « map = new » Model Map « ( ) ; » UK Inner Class « inner = new » UK Inner Class « ( ) ; map . » add Attribute « ( inner ) ; » assert That « ( map . get ( " » UK Inner Class « " ) ) . » is Same As « ( inner ) ; }
@Test { » Model Map « map = new » Model Map « ( ) ; » Proxy Factory « factory = new » Proxy Factory « ( ) ; » Some Inner Class « val = new » Some Inner Class « ( ) ; factory . » set Target « ( val ) ; factory . » set Proxy Target Class « ( true ) ; map . » add Attribute « ( factory . » get Proxy « ( ) ) ; » assert That « ( map . » contains Key « ( " » some Inner Class « " ) ) . » is True « ( ) ; » assert That « ( val ) . » is Equal To « ( map . get ( " » some Inner Class « " ) ) ; }
@Test { » Model Map « map = new » Model Map « ( ) ; » Proxy Factory « factory = new » Proxy Factory « ( ) ; Map < ? , ? > target = new » Hash Map « < > ( ) ; factory . » set Target « ( target ) ; factory . » add Interface « ( Map . class ) ; Object proxy = factory . » get Proxy « ( ) ; map . » add Attribute « ( proxy ) ; » assert That « ( map . get ( " map " ) ) . » is Same As « ( proxy ) ; }
@Test { » Model Map « map = new » Model Map « ( ) ; Map < ? , ? > target = new » Hash Map « < > ( ) ; » Proxy Factory « factory = new » Proxy Factory « ( target ) ; Object proxy = factory . » get Proxy « ( ) ; map . » add Attribute « ( proxy ) ; » assert That « ( map . get ( " map " ) ) . » is Same As « ( proxy ) ; }
@Test { » Model Map « map = new » Model Map « ( ) ; Object proxy = Proxy . » new Proxy Instance « ( » get Class « ( ) . » get Class Loader « ( ) , new Class < ? > [ ] { Map . class } , new » Invocation Handler « ( ) { @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) { return " proxy " ; } } ) ; map . » add Attribute « ( proxy ) ; » assert That « ( map . get ( " map " ) ) . » is Same As « ( proxy ) ; }
@Test { » Field Access Bean « rod = new » Field Access Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( rod , " person " ) ; binder . » set Auto Grow Nested Paths « ( false ) ; binder . » init Direct Field Access « ( ) ; » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . » add Property Value « ( new » Property Value « ( " spouse . name " , " Kerry " ) ) ; » assert That Exception Of Type « ( » Null Value In Nested Path Exception « . class ) . » is Thrown By « ( ( ) -> binder . bind ( pvs ) ) ; }
@Test { String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " ) ; » assert That « ( codes ) . » contains Exactly « ( " » error Code « . » object Name « " , " » error Code « " ) ; }
@Test { String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " , " field " , » Test Bean « . class ) ; » assert That « ( codes ) . » contains Exactly « ( " » error Code « . » object Name « . field " , " » error Code « . field " , " » error Code « . org . springframework . beans . testfixture . beans . » Test Bean « " , " » error Code « " ) ; }
@Test { resolver . » set Prefix « ( " prefix . " ) ; String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " ) ; » assert That « ( codes ) . » contains Exactly « ( " prefix . » error Code « . » object Name « " , " prefix . » error Code « " ) ; }
@Test { resolver . » set Prefix « ( " prefix . " ) ; String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " , " field " , » Test Bean « . class ) ; » assert That « ( codes ) . » contains Exactly « ( " prefix . » error Code « . » object Name « . field " , " prefix . » error Code « . field " , " prefix . » error Code « . org . springframework . beans . testfixture . beans . » Test Bean « " , " prefix . » error Code « " ) ; }
@Test { resolver . » set Prefix « ( null ) ; String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " , " field " , » Test Bean « . class ) ; » assert That « ( codes ) . » contains Exactly « ( " » error Code « . » object Name « . field " , " » error Code « . field " , " » error Code « . org . springframework . beans . testfixture . beans . » Test Bean « " , " » error Code « " ) ; }
@Test { String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " , " field [ " , » Test Bean « . class ) ; » assert That « ( codes ) . » contains Exactly « ( " » error Code « . » object Name « . field [ " , " » error Code « . field [ " , " » error Code « . org . springframework . beans . testfixture . beans . » Test Bean « " , " » error Code « " ) ; }
@Test { String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " , " field " , null ) ; » assert That « ( codes ) . » contains Exactly « ( " » error Code « . » object Name « . field " , " » error Code « . field " , " » error Code « " ) ; }
@Test { resolver . » set Message Code Formatter « ( Format . » POSTFIX _ ERROR _ CODE « ) ; String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " ) ; » assert That « ( codes ) . » contains Exactly « ( " » object Name « . » error Code « " , " » error Code « " ) ; }
@Test { resolver . » set Message Code Formatter « ( Format . » POSTFIX _ ERROR _ CODE « ) ; String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " , " field " , » Test Bean « . class ) ; » assert That « ( codes ) . » contains Exactly « ( " » object Name « . field . » error Code « " , " field . » error Code « " , " org . springframework . beans . testfixture . beans . » Test Bean « . » error Code « " , " » error Code « " ) ; }
@Test { resolver . » set Message Code Formatter « ( new » Message Code Formatter « ( ) { @ Override public String format ( String » error Code « , String » object Name « , String field ) { return » Default Message Codes Resolver « . Format . » to Delimited String « ( " CUSTOM - " + » error Code « , » object Name « , field ) ; } } ) ; String [ ] codes = resolver . » resolve Message Codes « ( " » error Code « " , " » object Name « " ) ; » assert That « ( codes ) . » contains Exactly « ( " CUSTOM - » error Code « . » object Name « " , " CUSTOM - » error Code « " ) ; }
@Test { » Test Bean « rod = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( rod , " person " ) ; binder . » set Ignore Unknown Fields « ( false ) ; » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . add ( " name " , " Rod " ) ; pvs . add ( " age " , 32 ) ; pvs . add ( " » non Existing « " , " » some Value « " ) ; » assert That Exception Of Type « ( » Not Writable Property Exception « . class ) . » is Thrown By « ( ( ) -> binder . bind ( pvs ) ) ; }
@Test { » Test Bean « rod = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( rod , " person " ) ; » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . add ( " name " , " Rod " ) ; pvs . add ( " spouse . age " , 32 ) ; » assert That Exception Of Type « ( » Null Value In Nested Path Exception « . class ) . » is Thrown By « ( ( ) -> binder . bind ( pvs ) ) ; }
@Test { » Test Bean « rod = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( rod , " person " ) ; binder . » set Ignore Invalid Fields « ( true ) ; » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . add ( " name " , " Rod " ) ; pvs . add ( " spouse . age " , 32 ) ; binder . bind ( pvs ) ; }
@Test { » Test Bean « rod = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( rod , " person " ) ; » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . add ( " class . » class Loader « . » UR Ls « [ 0 ] " , " https : » // myserver « " ) ; binder . » set Ignore Unknown Fields « ( false ) ; » assert That Exception Of Type « ( » Not Writable Property Exception « . class ) . » is Thrown By « ( ( ) -> binder . bind ( pvs ) ) . » with Message Containing « ( " » class Loader « " ) ; }
@Test { » Bean With Object Property « tb = new » Bean With Object Property « ( ) ; » Data Binder « binder = new » Data Binder « ( tb ) ; binder . » register Custom Editor « ( Integer . class , " object " , new » Custom Number Editor « ( Integer . class , true ) ) ; » Mutable Property Values « pvs = new » Mutable Property Values « ( ) ; pvs . add ( " object " , " 1 " ) ; binder . bind ( pvs ) ; » assert That « ( tb . » get Object « ( ) ) . » is Equal To « ( new Integer ( 1 ) ) ; }
@Test { » Test Bean « » test Bean « = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( » test Bean « , " » test Bean « " ) ; » Mutable Property Values « mpvs = new » Mutable Property Values « ( ) ; mpvs . add ( " friends [ 4 ] " , " " ) ; binder . bind ( mpvs ) ; » assert That « ( » test Bean « . » get Friends « ( ) . size ( ) ) . » is Equal To « ( 5 ) ; }
@Test { » Test Bean « » test Bean « = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( » test Bean « , " » test Bean « " ) ; » Mutable Property Values « mpvs = new » Mutable Property Values « ( ) ; mpvs . add ( " friends [ 256 ] " , " " ) ; » assert That Exception Of Type « ( » Invalid Property Exception « . class ) . » is Thrown By « ( ( ) -> binder . bind ( mpvs ) ) . satisfies ( ex -> » assert That « ( ex . » get Root Cause « ( ) ) . » is Instance Of « ( » Index Out Of Bounds Exception « . class ) ) ; }
@Test { » Test Bean « » test Bean « = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( » test Bean « , " » test Bean « " ) ; binder . » set Auto Grow Collection Limit « ( 10 ) ; » Mutable Property Values « mpvs = new » Mutable Property Values « ( ) ; mpvs . add ( " friends [ 4 ] " , " " ) ; binder . bind ( mpvs ) ; » assert That « ( » test Bean « . » get Friends « ( ) . size ( ) ) . » is Equal To « ( 5 ) ; }
@Test { » Data Binder « binder = new » Data Binder « ( new » Bean With Integer List « ( ) ) ; binder . » register Custom Editor « ( String . class , new » String Trimmer Editor « ( true ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> binder . » set Auto Grow Collection Limit « ( 257 ) ) . » with Message Containing « ( " » Data Binder « is already initialized - call » set Auto Grow Collection Limit « before other configuration methods " ) ; }
@Test { » Test Bean « » test Bean « = new » Test Bean « ( ) ; » Data Binder « binder = new » Data Binder « ( » test Bean « , " » test Bean « " ) ; binder . » set Message Codes Resolver « ( new » Default Message Codes Resolver « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> binder . » set Message Codes Resolver « ( new » Default Message Codes Resolver « ( ) ) ) . » with Message Containing « ( " » Data Binder « is already initialized with » Message Codes Resolver « " ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; Errors errors = new » Bean Property Binding Result « ( tb , " tb " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Validation Utils « . » invoke Validator « ( null , tb , errors ) ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Validation Utils « . » invoke Validator « ( new » Empty Validator « ( ) , tb , null ) ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; Errors errors = new » Bean Property Binding Result « ( tb , " tb " ) ; » Validation Utils « . » invoke Validator « ( new » Empty Validator « ( ) , tb , errors ) ; » assert That « ( errors . » has Field Errors « ( " name " ) ) . » is True « ( ) ; » assert That « ( errors . » get Field Error « ( " name " ) . » get Code « ( ) ) . » is Equal To « ( " EMPTY " ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( ) ; Errors errors = new » Bean Property Binding Result « ( tb , " tb " ) ; Validator » test Validator « = new » Empty Validator « ( ) ; » test Validator « . validate ( tb , errors ) ; » assert That « ( errors . » has Field Errors « ( " name " ) ) . » is True « ( ) ; » assert That « ( errors . » get Field Error « ( " name " ) . » get Code « ( ) ) . » is Equal To « ( " EMPTY " ) ; }
@Test { » Test Bean « tb = new » Test Bean « ( " " ) ; Errors errors = new » Bean Property Binding Result « ( tb , " tb " ) ; Validator » test Validator « = new » Empty Validator « ( ) ; » test Validator « . validate ( tb , errors ) ; » assert That « ( errors . » has Field Errors « ( " name " ) ) . » is True « ( ) ; » assert That « ( errors . » get Field Error « ( " name " ) . » get Code « ( ) ) . » is Equal To « ( " EMPTY " ) ; }
@Test { » My Valid Bean « bean = new » My Valid Bean « ( ) ; » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( bean ) ; » proxy Factory « . » add Advice « ( new » Method Validation Interceptor « ( ) ) ; » proxy Factory « . » add Advisor « ( new » Async Annotation Advisor « ( ) ) ; » do Test Proxy Validation « ( ( » My Valid Interface « < ? > ) » proxy Factory « . » get Proxy « ( ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Lazy Method Validation Config « . class , » Custom Validator Bean « . class , » My Valid Bean « . class , » My Valid Factory Bean « . class ) ; ctx . » get Beans Of Type « ( » My Valid Interface « . class ) . values ( ) . » for Each « ( bean -> bean . » my Valid Method « ( " value " , 5 ) ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Lazy Method Validation Config With Proxy Target Class « . class , » Custom Validator Bean « . class , » My Valid Bean « . class , » My Valid Factory Bean « . class ) ; ctx . » get Beans Of Type « ( » My Valid Interface « . class ) . values ( ) . » for Each « ( bean -> bean . » my Valid Method « ( " value " , 5 ) ) ; }
@Test { » assert That « ( » application Context « . » get Parent « ( ) != null ) . as ( " parent is » n ' t « null " ) . » is True « ( ) ; }
@Test { » assert That « ( » application Context « . » get Parent « ( ) . » get Parent « ( ) == null ) . as ( " grandparent is null " ) . » is True « ( ) ; }
@Test { » Test Bean « rod = ( » Test Bean « ) » application Context « . » get Parent « ( ) . » get Bean « ( " rod " ) ; » assert That « ( rod . » get Name « ( ) . equals ( " Roderick " ) ) . as ( " Parent » ' s « name differs " ) . » is True « ( ) ; }
@Test { » Test Bean « dad = ( » Test Bean « ) » application Context « . » get Bean « ( " father " ) ; » assert That « ( dad . » get Name « ( ) . equals ( " Albert " ) ) . as ( " Dad has correct name " ) . » is True « ( ) ; }
@Test { » Test Bean « dad = » application Context « . » get Bean « ( " father " , » Test Bean « . class ) ; » assert That « ( dad . » get Name « ( ) . equals ( " Albert " ) ) . as ( " Dad has correct name " ) . » is True « ( ) ; }
@Test { » do Test Events « ( this . listener , this . » parent Listener « , new » My Event « ( this ) ) ; }
@Test { » My Event « event = new » My Event « ( this ) ; » Byte Array Output Stream « bos = new » Byte Array Output Stream « ( ) ; » Object Output Stream « oos = new » Object Output Stream « ( bos ) ; oos . » write Object « ( event ) ; oos . close ( ) ; event = ( » My Event « ) new » Object Input Stream « ( new » Byte Array Input Stream « ( bos . » to Byte Array « ( ) ) ) . » read Object « ( ) ; » do Test Events « ( this . listener , this . » parent Listener « , event ) ; }
@Test { » Bean That Listens « b = ( » Bean That Listens « ) » application Context « . » get Bean « ( " » bean That Listens « " ) ; b . zero ( ) ; » assert That « ( b . » get Event Count « ( ) == 0 ) . as ( " 0 events before publication " ) . » is True « ( ) ; this . » application Context « . » publish Event « ( new » My Event « ( this ) ) ; » assert That « ( b . » get Event Count « ( ) == 1 ) . as ( " 1 events after publication , not " + b . » get Event Count « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Cache « ( ) . » get Name « ( ) ) . » is Equal To « ( » CACHE _ NAME « ) ; }
@Test { » assert That « ( » get Cache « ( ) . » get Native Cache « ( ) ) . » is Same As « ( » get Native Cache « ( ) ) ; }
@Test { T cache = » get Cache « ( ) ; String key = » create Random Key « ( ) ; Object value = " george " ; » assert That « ( ( Object ) cache . get ( key ) ) . » is Null « ( ) ; cache . put ( key , value ) ; }
@Test { T cache = » get Cache « ( ) ; » assert That « ( ( Object ) cache . get ( " enescu " ) ) . » is Null « ( ) ; cache . put ( " enescu " , " george " ) ; » assert That « ( ( Object ) cache . get ( " vlaicu " ) ) . » is Null « ( ) ; cache . put ( " vlaicu " , " aurel " ) ; cache . clear ( ) ; » assert That « ( ( Object ) cache . get ( " vlaicu " ) ) . » is Null « ( ) ; » assert That « ( ( Object ) cache . get ( " enescu " ) ) . » is Null « ( ) ; }
@Test { » do Test Cache Get Callable « ( " test " ) ; }
@Test { » do Test Cache Get Callable « ( null ) ; }
@Test { » do Test Cache Get Callable Not Invoked With Hit « ( " existing " ) ; }
@Test { » do Test Cache Get Callable Not Invoked With Hit « ( null ) ; }
@Test { T cache = » get Cache « ( ) ; String key = » create Random Key « ( ) ; » assert That « ( ( Object ) cache . get ( key ) ) . » is Null « ( ) ; try { cache . get ( key , ( ) -> { throw new » Unsupported Operation Exception « ( " Expected exception " ) ; } ) ; } catch ( Cache . » Value Retrieval Exception « ex ) { » assert That « ( ex . » get Cause « ( ) ) . » is Not Null « ( ) ; » assert That « ( ex . » get Cause « ( ) . » get Class « ( ) ) . » is Equal To « ( » Unsupported Operation Exception « . class ) ; } }
@Test { T cache = » get Cache « ( false ) ; String key = » create Random Key « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> cache . put ( key , null ) ) . » with Message Containing « ( » CACHE _ NAME _ NO _ NULL « ) . » with Message Containing « ( " is configured to not allow null values but null was provided " ) ; }
@Test { » Parameter Name Discoverer « pnd = new » Prioritized Parameter Name Discoverer « ( ) ; » assert That « ( pnd . » get Parameter Names « ( » any Method « ) ) . » is Null « ( ) ; » assert That « ( pnd . » get Parameter Names « ( ( Constructor < ? > ) null ) ) . » is Null « ( ) ; }
@Test { List < Integer > sequence = Arrays . » as List « ( 1 , 2 , 3 ) ; Publisher < Integer > source = Flowable . » from Iterable « ( sequence ) ; Object target = » get Adapter « ( Flux . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof Flux ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Flux < Integer > ) target ) . » collect List « ( ) . block ( Duration . » of Millis « ( 1000 ) ) ) . » is Equal To « ( sequence ) ; }
@Test { Publisher < Integer > source = Flowable . » from Array « ( 1 , 2 , 3 ) ; Object target = » get Adapter « ( Mono . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof Mono ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Mono < Integer > ) target ) . block ( Duration . » of Millis « ( 1000 ) ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Publisher < Integer > source = Flowable . » from Array « ( 1 , 2 , 3 ) ; Object target = » get Adapter « ( » Completable Future « . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof » Completable Future « ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( » Completable Future « < Integer > ) target ) . get ( ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { List < Integer > sequence = Arrays . » as List « ( 1 , 2 , 3 ) ; Publisher < Integer > source = Flowable . » from Iterable « ( sequence ) ; Object target = » get Adapter « ( rx . Observable . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof Observable ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Observable < ? > ) target ) . » to List « ( ) . » to Blocking « ( ) . first ( ) ) . » is Equal To « ( sequence ) ; }
@Test { Publisher < Integer > source = Flowable . » from Array « ( 1 ) ; Object target = » get Adapter « ( rx . Single . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof Single ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Single < Integer > ) target ) . » to Blocking « ( ) . value ( ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Publisher < Integer > source = Flowable . » from Array « ( 1 , 2 , 3 ) ; Object target = » get Adapter « ( rx . Completable . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof Completable ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Completable ) target ) . get ( ) ) . » is Null « ( ) ; }
@Test { List < Integer > sequence = Arrays . » as List « ( 1 , 2 , 3 ) ; Publisher < Integer > source = Flux . » from Iterable « ( sequence ) ; Object target = » get Adapter « ( io . reactivex . Flowable . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof Flowable ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Flowable < ? > ) target ) . » to List « ( ) . » blocking Get « ( ) ) . » is Equal To « ( sequence ) ; }
@Test { List < Integer > sequence = Arrays . » as List « ( 1 , 2 , 3 ) ; Publisher < Integer > source = Flowable . » from Iterable « ( sequence ) ; Object target = » get Adapter « ( io . reactivex . Observable . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof io . reactivex . Observable ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( io . reactivex . Observable < ? > ) target ) . » to List « ( ) . » blocking Get « ( ) ) . » is Equal To « ( sequence ) ; }
@Test { Publisher < Integer > source = Flowable . » from Array « ( 1 ) ; Object target = » get Adapter « ( io . reactivex . Single . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof io . reactivex . Single ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( io . reactivex . Single < Integer > ) target ) . » blocking Get « ( ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Publisher < Integer > source = Flowable . » from Array « ( 1 , 2 , 3 ) ; Object target = » get Adapter « ( io . reactivex . Completable . class ) . » from Publisher « ( source ) ; boolean condition = target instanceof io . reactivex . Completable ; » assert That « ( condition ) . » is True « ( ) ; ( ( io . reactivex . Completable ) target ) . » blocking Await « ( ) ; }
@Test { Object source = rx . Single . just ( 1 ) ; Object target = » get Adapter « ( rx . Single . class ) . » to Publisher « ( source ) ; boolean condition = target instanceof Mono ; » assert That « ( condition ) . as ( " Expected Mono Publisher : " + target . » get Class « ( ) . » get Name « ( ) ) . » is True « ( ) ; » assert That « ( ( ( Mono < Integer > ) target ) . block ( Duration . » of Millis « ( 1000 ) ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Object source = rx . Completable . complete ( ) ; Object target = » get Adapter « ( rx . Completable . class ) . » to Publisher « ( source ) ; boolean condition = target instanceof Mono ; » assert That « ( condition ) . as ( " Expected Mono Publisher : " + target . » get Class « ( ) . » get Name « ( ) ) . » is True « ( ) ; ( ( Mono < Void > ) target ) . block ( Duration . » of Millis « ( 1000 ) ) ; }
@Test { Object source = io . reactivex . Single . just ( 1 ) ; Object target = » get Adapter « ( io . reactivex . Single . class ) . » to Publisher « ( source ) ; boolean condition = target instanceof Mono ; » assert That « ( condition ) . as ( " Expected Mono Publisher : " + target . » get Class « ( ) . » get Name « ( ) ) . » is True « ( ) ; » assert That « ( ( ( Mono < Integer > ) target ) . block ( Duration . » of Millis « ( 1000 ) ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Object source = io . reactivex . Completable . complete ( ) ; Object target = » get Adapter « ( io . reactivex . Completable . class ) . » to Publisher « ( source ) ; boolean condition = target instanceof Mono ; » assert That « ( condition ) . as ( " Expected Mono Publisher : " + target . » get Class « ( ) . » get Name « ( ) ) . » is True « ( ) ; ( ( Mono < Void > ) target ) . block ( Duration . » of Millis « ( 1000 ) ) ; }
@Test { » Completable Future « < Integer > future = new » Completable Future « < > ( ) ; future . complete ( 1 ) ; Object target = » get Adapter « ( » Completable Future « . class ) . » to Publisher « ( future ) ; boolean condition = target instanceof Mono ; » assert That « ( condition ) . as ( " Expected Mono Publisher : " + target . » get Class « ( ) . » get Name « ( ) ) . » is True « ( ) ; » assert That « ( ( ( Mono < Integer > ) target ) . block ( Duration . » of Millis « ( 1000 ) ) ) . » is Equal To « ( Integer . » value Of « ( 1 ) ) ; }
@Test { Type type = » Serializable Type Wrapper « . » for Field « ( Fields . class . » get Field « ( " » parameterized Type « " ) ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . util . List < java . lang . String > " ) ; » assert Serializable « ( type ) ; }
@Test { Method method = Methods . class . » get Declared Method « ( " method " , Class . class , Object . class ) ; Type type = » Serializable Type Wrapper « . » for Method Parameter « ( » Method Parameter « . » for Executable « ( method , 0 ) ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . lang . Class < T > " ) ; » assert Serializable « ( type ) ; }
@Test { Constructor < ? > constructor = Constructors . class . » get Declared Constructor « ( List . class ) ; Type type = » Serializable Type Wrapper « . » for Method Parameter « ( » Method Parameter « . » for Executable « ( constructor , 0 ) ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . util . List < java . lang . String > " ) ; » assert Serializable « ( type ) ; }
@Test { Type type = » Serializable Type Wrapper « . » for Field « ( Fields . class . » get Field « ( " » class Type « " ) ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " class java . lang . String " ) ; » assert Serializable « ( type ) ; }
@Test { » Generic Array Type « type = ( » Generic Array Type « ) » Serializable Type Wrapper « . » for Field « ( Fields . class . » get Field « ( " » generic Array Type « " ) ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . util . List < java . lang . String > [ ] " ) ; » assert Serializable « ( type ) ; » assert Serializable « ( type . » get Generic Component Type « ( ) ) ; }
@Test { » Type Variable « < ? > type = ( » Type Variable « < ? > ) » Serializable Type Wrapper « . » for Field « ( Fields . class . » get Field « ( " » type Variable Type « " ) ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " T " ) ; » assert Serializable « ( type ) ; » assert Serializable « ( type . » get Bounds « ( ) ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Message Service « . class , " » send Message « " , String . class ) ; String [ ] » actual Params « = » parameter Name Discoverer « . » get Parameter Names « ( method ) ; » assert That « ( » actual Params « ) . » is Equal To « ( new String [ ] { " message " } ) ; }
@Test { Method » bridge Method « = » Delay Queue « . class . » get Method « ( " add " , Object . class ) ; » assert That « ( » bridge Method « . » is Bridge « ( ) ) . » is True « ( ) ; Method » actual Method « = » Delay Queue « . class . » get Method « ( " add " , Delayed . class ) ; » assert That « ( » actual Method « . » is Bridge « ( ) ) . » is False « ( ) ; » assert That « ( » Bridge Method Resolver « . » find Bridged Method « ( » bridge Method « ) ) . » is Equal To « ( » actual Method « ) ; }
@Test { Method [ ] methods = » String List « . class . » get Methods « ( ) ; for ( Method method : methods ) { » assert That « ( » Bridge Method Resolver « . » find Bridged Method « ( method ) ) . » is Not Null « ( ) ; } }
@Test { Method » object Bridge « = » Your Homer « . class . » get Declared Method « ( " foo " , Bounded . class ) ; Method » abstract Bounded Foo « = » Your Homer « . class . » get Declared Method « ( " foo " , » Abstract Bounded « . class ) ; Method » bridged Method « = » Bridge Method Resolver « . » find Bridged Method « ( » object Bridge « ) ; » assert That « ( » bridged Method « ) . as ( " foo ( » Abstract Bounded « ) not resolved . " ) . » is Equal To « ( » abstract Bounded Foo « ) ; }
@Test { Method » bridged Method « = » Abstract Dao « . class . » get Declared Method « ( " save " , Object . class ) ; » assert That « ( » bridged Method « . » is Bridge « ( ) ) . » is False « ( ) ; Method » bridge Method « = » User Dao Impl « . class . » get Declared Method « ( " save " , User . class ) ; » assert That « ( » bridge Method « . » is Bridge « ( ) ) . » is True « ( ) ; » assert That « ( » Bridge Method Resolver « . » find Bridged Method « ( » bridge Method « ) ) . » is Equal To « ( » bridged Method « ) ; }
@Test { Method » bridged Method « = » Business Dao « . class . » get Declared Method « ( " save " , Business . class ) ; » assert That « ( » bridged Method « . » is Bridge « ( ) ) . » is False « ( ) ; Method » bridge Method « = » Business Dao « . class . » get Declared Method « ( " save " , Object . class ) ; » assert That « ( » bridge Method « . » is Bridge « ( ) ) . » is True « ( ) ; » assert That « ( » Bridge Method Resolver « . » find Bridged Method « ( » bridge Method « ) ) . » is Equal To « ( » bridged Method « ) ; }
@Test { Method » bridged Method « = » Business Dao « . class . » get Declared Method « ( " get " , Long . class ) ; » assert That « ( » bridged Method « . » is Bridge « ( ) ) . » is False « ( ) ; Method » bridge Method « = » Business Dao « . class . » get Declared Method « ( " get " , Object . class ) ; » assert That « ( » bridge Method « . » is Bridge « ( ) ) . » is True « ( ) ; » assert That « ( » Bridge Method Resolver « . » find Bridged Method « ( » bridge Method « ) ) . » is Equal To « ( » bridged Method « ) ; }
@Test { » do Test Hierarchy Resolution « ( » Foo Class « . class ) ; }
@Test { » do Test Hierarchy Resolution « ( » Foo Interface « . class ) ; }
@Test { » assert That Thrown By « ( ( ) -> » test Non Blocking Task « ( ( ) -> Thread . sleep ( 10 ) ) ) . » has Message Containing « ( " Blocking call ! " ) ; }
@Test { » test Non Blocking Task « ( ( ) -> { Method » set Name « = » Test Object « . class . » get Method « ( " » set Name « " , String . class ) ; String [ ] names = new » Local Variable Table Parameter Name Discoverer « ( ) . » get Parameter Names « ( » set Name « ) ; » assert That « ( names ) . » is Equal To « ( new String [ ] { " name " } ) ; } ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Conventions . » get Variable Name « ( new » Array List « < > ( ) ) ) ; }
@Test { » assert That « ( Conventions . » attribute Name To Property Name « ( " transaction - manager " ) ) . » is Equal To « ( " » transaction Manager « " ) ; » assert That « ( Conventions . » attribute Name To Property Name « ( " pointcut - ref " ) ) . » is Equal To « ( " » pointcut Ref « " ) ; » assert That « ( Conventions . » attribute Name To Property Name « ( " lookup - on - startup " ) ) . » is Equal To « ( " » lookup On Startup « " ) ; }
@Test { String » base Name « = " foo " ; Class < String > cls = String . class ; String » desired Result « = " java . lang . String . foo " ; » assert That « ( Conventions . » get Qualified Attribute Name « ( cls , » base Name « ) ) . » is Equal To « ( » desired Result « ) ; }
@Test { Method » get Name « = » Test Object « . class . » get Method « ( " » get Name « " ) ; String [ ] names = discoverer . » get Parameter Names « ( » get Name « ) ; » assert That « ( names ) . as ( " should find method info " ) . » is Not Null « ( ) ; » assert That « ( names . length ) . as ( " no argument names " ) . » is Equal To « ( 0 ) ; }
@Test { Method » set Name « = » Test Object « . class . » get Method « ( " » set Name « " , String . class ) ; String [ ] names = discoverer . » get Parameter Names « ( » set Name « ) ; » assert That « ( names ) . as ( " should find method info " ) . » is Not Null « ( ) ; » assert That « ( names . length ) . as ( " one argument " ) . » is Equal To « ( 1 ) ; » assert That « ( names [ 0 ] ) . » is Equal To « ( " name " ) ; }
@Test { Constructor < » Test Object « > » no Args Cons « = » Test Object « . class . » get Constructor « ( ) ; String [ ] names = discoverer . » get Parameter Names « ( » no Args Cons « ) ; » assert That « ( names ) . as ( " should find cons info " ) . » is Not Null « ( ) ; » assert That « ( names . length ) . as ( " no argument names " ) . » is Equal To « ( 0 ) ; }
@Test { Method m = » get Class « ( ) . » get Method « ( " » static Method No Local Vars « " ) ; String [ ] names = discoverer . » get Parameter Names « ( m ) ; » assert That « ( names ) . as ( " should find method info " ) . » is Not Null « ( ) ; » assert That « ( names . length ) . as ( " no argument names " ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Method Parameter « ( method , 2 ) ) ; }
@Test { Constructor < ? > constructor = » Nested Class « . class . » get Declared Constructor « ( String . class ) ; » Method Parameter « » method Parameter « = » Method Parameter « . » for Executable « ( constructor , 0 ) ; » assert That « ( » method Parameter « . » get Parameter Type « ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( » method Parameter « . » get Parameter Annotation « ( Param . class ) ) . as ( " Failed to find @ Param annotation " ) . » is Not Null « ( ) ; }
@Test { » Parameterized Type Reference « < String > » type Reference « = new » Parameterized Type Reference « < String > ( ) { } ; » assert That « ( » type Reference « . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { Type » map Type « = » get Class « ( ) . » get Method « ( " » map Method « " ) . » get Generic Return Type « ( ) ; » Parameterized Type Reference « < Map < Object , String > > » type Reference « = new » Parameterized Type Reference « < Map < Object , String > > ( ) { } ; » assert That « ( » type Reference « . » get Type « ( ) ) . » is Equal To « ( » map Type « ) ; }
@Test { Type » list Type « = » get Class « ( ) . » get Method « ( " » list Method « " ) . » get Generic Return Type « ( ) ; » Parameterized Type Reference « < List < String > > » type Reference « = new » Parameterized Type Reference « < List < String > > ( ) { } ; » assert That « ( » type Reference « . » get Type « ( ) ) . » is Equal To « ( » list Type « ) ; }
@Test { Type » list Type « = » get Class « ( ) . » get Method « ( " » list Method « " ) . » get Generic Return Type « ( ) ; » Parameterized Type Reference « < List < String > > » type Reference « = » Parameterized Type Reference « . » for Type « ( » list Type « ) ; » assert That « ( » type Reference « . » get Type « ( ) ) . » is Equal To « ( » list Type « ) ; }
@Test { Type » list Type « = » get Class « ( ) . » get Method « ( " » list Method « " ) . » get Generic Return Type « ( ) ; » Parameterized Type Reference « < ? > » type Reference « = » Parameterized Type Reference « . » for Type « ( » list Type « ) ; » assert That « ( » type Reference « . » get Type « ( ) ) . » is Equal To « ( » list Type « ) ; }
@Test { this . » attribute Accessor « . » set Attribute « ( NAME , VALUE ) ; » assert That « ( this . » attribute Accessor « . » get Attribute « ( NAME ) ) . » is Equal To « ( VALUE ) ; }
@Test { » assert That « ( this . » attribute Accessor « . » has Attribute « ( NAME ) ) . » is False « ( ) ; this . » attribute Accessor « . » set Attribute « ( NAME , VALUE ) ; » assert That « ( this . » attribute Accessor « . » has Attribute « ( NAME ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . » attribute Accessor « . » has Attribute « ( NAME ) ) . » is False « ( ) ; this . » attribute Accessor « . » set Attribute « ( NAME , VALUE ) ; » assert That « ( this . » attribute Accessor « . » remove Attribute « ( NAME ) ) . » is Equal To « ( VALUE ) ; » assert That « ( this . » attribute Accessor « . » has Attribute « ( NAME ) ) . » is False « ( ) ; }
@Test { this . » attribute Accessor « . » set Attribute « ( NAME , VALUE ) ; this . » attribute Accessor « . » set Attribute « ( " abc " , " 123 " ) ; String [ ] » attribute Names « = this . » attribute Accessor « . » attribute Names « ( ) ; Arrays . sort ( » attribute Names « ) ; » assert That « ( Arrays . » binary Search « ( » attribute Names « , NAME ) > - 1 ) . » is True « ( ) ; » assert That « ( Arrays . » binary Search « ( » attribute Names « , " abc " ) > - 1 ) . » is True « ( ) ; }
@Test { » assert That « ( » resolve Type Argument « ( » My Simple Interface Type « . class , » My Interface Type « . class ) ) . » is Equal To « ( String . class ) ; }
@Test { » assert That « ( » resolve Type Argument « ( » My Collection Interface Type « . class , » My Interface Type « . class ) ) . » is Equal To « ( Collection . class ) ; }
@Test { » assert That « ( » resolve Type Argument « ( » My Simple Superclass Type « . class , » My Superclass Type « . class ) ) . » is Equal To « ( String . class ) ; }
@Test { » assert That « ( » resolve Type Argument « ( » My Collection Superclass Type « . class , » My Superclass Type « . class ) ) . » is Equal To « ( Collection . class ) ; }
@Test { » Generic Class « < String > obj = new » Generic Class « < > ( ) ; » assert That « ( ( Object ) » resolve Type Argument « ( obj . » get Class « ( ) , » Generic Class « . class ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » resolve Type Argument « ( » Test Impl « . class , » Test Ifc « . class ) ) . » is Equal To « ( B . class ) ; }
@Test { Class < ? > [ ] resolved = » Generic Type Resolver « . » resolve Type Arguments « ( List . class , Iterable . class ) ; » assert That « ( ( Object ) resolved ) . » is Null « ( ) ; }
@Test { Class < ? > [ ] resolved = » Generic Type Resolver « . » resolve Type Arguments « ( Map . class , Map . class ) ; » assert That « ( ( Object ) resolved ) . » is Null « ( ) ; }
@Test { » Method Parameter « » method Parameter « = » Method Parameter « . » for Executable « ( » With Array Base « . class . » get Declared Method « ( " array " , Object [ ] . class ) , 0 ) ; Class < ? > resolved = » Generic Type Resolver « . » resolve Parameter Type « ( » method Parameter « , » With Array « . class ) ; » assert That « ( resolved ) . » is Equal To « ( Object [ ] . class ) ; }
@Test { Class < ? > resolved = » Generic Type Resolver « . » resolve Return Type « ( » With Array Base « . class . » get Declared Method « ( " array " , Object [ ] . class ) , » With Array « . class ) ; » assert That « ( resolved ) . » is Equal To « ( Object [ ] . class ) ; }
@Test { Class < ? > [ ] resolved = » Generic Type Resolver « . » resolve Type Arguments « ( » Id Fixing Repository « . class , Repository . class ) ; » assert That « ( resolved ) . » is Not Null « ( ) ; » assert That « ( resolved . length ) . » is Equal To « ( 2 ) ; » assert That « ( resolved [ 0 ] ) . » is Equal To « ( Object . class ) ; » assert That « ( resolved [ 1 ] ) . » is Equal To « ( Long . class ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Ordered « ( 100 ) , new » Stub Ordered « ( 2000 ) ) ) . » is Equal To « ( - 1 ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Ordered « ( 100 ) , new » Stub Ordered « ( 100 ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Ordered « ( 982300 ) , new » Stub Ordered « ( 100 ) ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . comparator . compare ( null , new » Stub Ordered « ( 100 ) ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Ordered « ( 100 ) , null ) ) . » is Equal To « ( - 1 ) ; }
@Test { » assert That « ( this . comparator . compare ( null , null ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . comparator . compare ( new Object ( ) , new Object ( ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Priority Ordered « ( 100 ) , new » Stub Priority Ordered « ( 2000 ) ) ) . » is Equal To « ( - 1 ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Priority Ordered « ( 100 ) , new » Stub Priority Ordered « ( 100 ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . comparator . compare ( new » Stub Priority Ordered « ( 982300 ) , new » Stub Priority Ordered « ( 100 ) ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That Priority Ordered Always Wins « ( new » Stub Priority Ordered « ( 200 ) , new » Stub Ordered « ( 100 ) ) ; }
@Test { » assert That Priority Ordered Always Wins « ( new » Stub Priority Ordered « ( 100 ) , new » Stub Ordered « ( 100 ) ) ; }
@Test { » assert That Priority Ordered Always Wins « ( new » Stub Priority Ordered « ( 100 ) , new » Stub Ordered « ( 200 ) ) ; }
@Test { Comparator < Object > » custom Comparator « = this . comparator . » with Source Provider « ( new » Test Source Provider « ( 5L , new » Stub Ordered « ( 25 ) ) ) ; » assert That « ( » custom Comparator « . compare ( new » Stub Ordered « ( 10 ) , 5L ) ) . » is Equal To « ( - 1 ) ; }
@Test { Comparator < Object > » custom Comparator « = this . comparator . » with Source Provider « ( new » Test Source Provider « ( 5L , new Object [ ] { new » Stub Ordered « ( 10 ) , new » Stub Ordered « ( - 25 ) } ) ) ; » assert That « ( » custom Comparator « . compare ( 5L , new Object ( ) ) ) . » is Equal To « ( - 1 ) ; }
@Test { Comparator < Object > » custom Comparator « = this . comparator . » with Source Provider « ( new » Test Source Provider « ( 5L , new Object [ ] { new Object ( ) , new Object ( ) } ) ) ; » assert That « ( » custom Comparator « . compare ( new Object ( ) , 5L ) ) . » is Equal To « ( 0 ) ; }
@Test { Comparator < Object > » custom Comparator « = this . comparator . » with Source Provider « ( new » Test Source Provider « ( 50L , new Object ( ) ) ) ; » assert That « ( » custom Comparator « . compare ( new Object ( ) , 5L ) ) . » is Equal To « ( 0 ) ; }
@Test { Constants c = new Constants ( A . class ) ; Set < ? > values = c . » get Values « ( null ) ; » assert That « ( values . size ( ) ) . as ( " Must have returned * all * public static final values " ) . » is Equal To « ( 7 ) ; }
@Test { Constants c = new Constants ( A . class ) ; Set < Object > values = c . » get Values « ( " " ) ; » assert That « ( values . size ( ) ) . as ( " Must have returned * all * public static final values " ) . » is Equal To « ( 7 ) ; }
@Test { Constants c = new Constants ( A . class ) ; Set < ? > values = c . » get Values « ( " " ) ; » assert That « ( values . size ( ) ) . as ( " Must have returned * all * public static final values " ) . » is Equal To « ( 7 ) ; }
@Test { Constants c = new Constants ( » No Constants « . class ) ; » assert That « ( c . » get Size « ( ) ) . » is Equal To « ( 0 ) ; final Set < ? > values = c . » get Values « ( " " ) ; » assert That « ( values ) . » is Not Null « ( ) ; » assert That « ( values . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new Constants ( null ) ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Target Exception « . class , » Same Depth Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Target Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Same Depth Exception « . class , » Target Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Target Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Lowest Depth Exception « . class , » Target Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Target Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Target Exception « . class , » Lowest Depth Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Target Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » No Depth Exception « . class , » Target Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Target Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » No Depth Exception « . class , » Highest Depth Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Highest Depth Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Highest Depth Exception « . class , » No Depth Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Highest Depth Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Highest Depth Exception « . class , » Lowest Depth Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Lowest Depth Exception « . class ) ; }
@Test { Class < ? extends Throwable > » found Class « = » find Closest Match « ( » Lowest Depth Exception « . class , » Highest Depth Exception « . class ) ; » assert That « ( » found Class « ) . » is Equal To « ( » Lowest Depth Exception « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( » Extends List « . class ) ; » assert That « ( type . » get Raw Class « ( ) ) . » is Equal To « ( » Extends List « . class ) ; » assert That « ( type . » is Assignable From « ( » Extends List « . class ) ) . » is True « ( ) ; » assert That « ( type . » is Assignable From « ( » Array List « . class ) ) . » is False « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( null ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( Object . class ) ; » assert That « ( type . » get Raw Class « ( ) ) . » is Equal To « ( Object . class ) ; » assert That « ( type . » is Assignable From « ( Object . class ) ) . » is True « ( ) ; » assert That « ( type . » is Assignable From « ( String . class ) ) . » is True « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Raw Class « ( » Extends List « . class ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( » Extends List « . class ) ; » assert That « ( type . » get Raw Class « ( ) ) . » is Equal To « ( » Extends List « . class ) ; » assert That « ( type . » is Assignable From « ( » Extends List « . class ) ) . » is True « ( ) ; » assert That « ( type . » is Assignable From « ( » Array List « . class ) ) . » is False « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Raw Class « ( null ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( Object . class ) ; » assert That « ( type . » get Raw Class « ( ) ) . » is Equal To « ( Object . class ) ; » assert That « ( type . » is Assignable From « ( Object . class ) ) . » is True « ( ) ; » assert That « ( type . » is Assignable From « ( String . class ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Instance « ( null ) ) . » with Message Containing « ( " Instance must not be null " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Instance « ( new Object ( ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( Object . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Object . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Instance « ( new » My Generic Interface Type « < > ( String . class ) ) ; » assert That « ( type . » get Raw Class « ( ) ) . » is Equal To « ( » My Generic Interface Type « . class ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Instance « ( new » My Generic Interface Type « < String > ( null ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( » My Generic Interface Type « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( » My Generic Interface Type « . class ) ; }
@Test { Field field = Fields . class . » get Field « ( " » char Sequence List « " ) ; » Resolvable Type « type = » Resolvable Type « . » for Field « ( field ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( field . » get Generic Type « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Field « ( null ) ) . » with Message Containing « ( " Field must not be null " ) ; }
@Test { Constructor < Constructors > constructor = Constructors . class . » get Constructor « ( List . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Constructor Parameter « ( constructor , 0 ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( constructor . » get Generic Parameter Types « ( ) [ 0 ] ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Constructor Parameter « ( null , 0 ) ) . » with Message Containing « ( " Constructor must not be null " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » char Sequence Parameter « " , List . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Parameter « ( method , 0 ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( method . » get Generic Parameter Types « ( ) [ 0 ] ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Method Parameter « ( null , 0 ) ) . » with Message Containing « ( " Method must not be null " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » char Sequence Parameter « " , List . class ) ; » Method Parameter « » method Parameter « = » Method Parameter « . » for Executable « ( method , 0 ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Parameter « ( » method Parameter « ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( method . » get Generic Parameter Types « ( ) [ 0 ] ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Method Parameter « ( null ) ) . » with Message Containing « ( " » Method Parameter « must not be null " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » char Sequence Return « " ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Return Type « ( method ) ; » assert That « ( type . » get Type « ( ) ) . » is Equal To « ( method . » get Generic Return Type « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Method Return Type « ( null ) ) . » with Message Containing « ( " Method must not be null " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » class Type « " ) ) ; » assert That « ( type . » get Type « ( ) . » get Class « ( ) ) . » is Equal To « ( Class . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » parameterized Type « " ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Instance Of « ( » Parameterized Type « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » array Class Type « " ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Instance Of « ( Class . class ) ; » assert That « ( ( ( Class ) type . » get Type « ( ) ) . » is Array « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » generic Array Type « " ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Instance Of « ( » Generic Array Type « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » wildcard Type « " ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Instance Of « ( » Parameterized Type « . class ) ; » assert That « ( type . » get Generic « ( ) . » get Type « ( ) ) . » is Instance Of « ( » Wildcard Type « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » type Variable Type « " ) ) ; » assert That « ( type . » get Type « ( ) ) . » is Instance Of « ( » Type Variable « . class ) ; }
@Test { Field field = Fields . class . » get Field « ( " » array Class Type « " ) ; » Resolvable Type « type = » Resolvable Type « . » for Field « ( field ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( type . » get Component Type « ( ) . » get Type « ( ) ) . » is Equal To « ( ( ( Class ) field . » get Generic Type « ( ) ) . » get Component Type « ( ) ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » generic Array Type « " ) ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( type . » get Component Type « ( ) . » get Type « ( ) ) . » is Equal To « ( ( ( » Generic Array Type « ) type . » get Type « ( ) ) . » get Generic Component Type « ( ) ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » List Of Generic Array « . class ) . » as Collection « ( ) . » get Generic « ( ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( type . » get Type « ( ) ) . » is Instance Of « ( » Type Variable « . class ) ; » assert That « ( type . » get Component Type « ( ) . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . List < java . lang . String > " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( String . class ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( false ) ; » assert That « ( type . » get Component Type « ( ) ) . » is Equal To « ( » Resolvable Type « . NONE ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) . » as Collection « ( ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Collection . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends Map « . class ) . » as Map « ( ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Map . class ) ; » assert That « ( type . » resolve Generic « ( 0 ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » resolve Generic « ( 1 ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) . as ( List . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . List < E > " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) . as ( Collection . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . Collection < E > " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) . as ( » Array List « . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . » Array List « < java . lang . » Char Sequence « > " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) . as ( Map . class ) ; » assert That « ( type ) . » is Same As « ( » Resolvable Type « . NONE ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) ; » assert That « ( type . as ( » Extends List « . class ) ) . » is Equal To « ( type ) ; }
@Test { » assert That « ( » Resolvable Type « . » for Class « ( Object . class ) . » get Super Type « ( ) ) . » is Equal To « ( » Resolvable Type « . NONE ) ; }
@Test { » assert That « ( » Resolvable Type « . » for Class « ( Object . class ) . » get Interfaces « ( ) ) . » is Empty « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " nested " ) ) ; type = type . » get Nested « ( 2 ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Map . class ) ; » assert That « ( type . » get Generic « ( 0 ) . resolve ( ) ) . » is Equal To « ( Byte . class ) ; » assert That « ( type . » get Generic « ( 1 ) . resolve ( ) ) . » is Equal To « ( Long . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " nested " ) ) ; type = type . » get Nested « ( 2 , Collections . » singleton Map « ( 2 , 0 ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Map . class ) ; » assert That « ( type . » get Generic « ( 0 ) . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Generic « ( 1 ) . resolve ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » generic Array Type « " ) ) ; type = type . » get Nested « ( 2 ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List « " ) ) ; » assert That « ( type . » get Generic « ( ) . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string Integer Multi Value Map « " ) ) ; » assert That « ( type . » get Generic « ( 0 ) . » get Type « ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Generic « ( 1 ) . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List List « " ) ) ; » assert That « ( type . » get Generic « ( ) . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . List < java . lang . String > " ) ; » assert That « ( type . » get Generic « ( ) . » get Generic « ( ) . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List List « " ) ) . » as Collection « ( ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . util . Collection < java . util . List < java . lang . String > > " ) ; » assert That « ( type . » get Generic « ( ) . » as Collection « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . Collection < java . lang . String > " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List List « " ) ) ; » assert That « ( type . » get Generic « ( 0 , 0 ) . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( List . class , » Extends List « . class ) ; » assert That « ( type . » get Generic « ( 0 ) ) . » is Not Equal To « ( » Resolvable Type « . NONE ) ; » assert That « ( type . » get Generic « ( 1 ) ) . » is Equal To « ( » Resolvable Type « . NONE ) ; » assert That « ( type . » get Generic « ( 0 , 1 ) ) . » is Equal To « ( » Resolvable Type « . NONE ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) ; » assert That « ( type . » has Generics « ( ) ) . » is Equal To « ( false ) ; » assert That « ( type . » as Collection « ( ) . » has Generics « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( List . class , » Extends List « . class ) ; » Resolvable Type « [ ] generics = type . » get Generics « ( ) ; » assert That « ( generics . length ) . » is Equal To « ( 1 ) ; » assert That « ( generics [ 0 ] . resolve ( ) ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( List . class ) ; » Resolvable Type « [ ] generics = type . » get Generics « ( ) ; » assert That « ( generics . length ) . » is Equal To « ( 1 ) ; » assert That « ( generics [ 0 ] . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " E " ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) ; » Resolvable Type « [ ] generics = type . » get Generics « ( ) ; » assert That « ( generics . length ) . » is Equal To « ( 0 ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( List . class , » Extends List « . class ) ; Class < ? > [ ] generics = type . » resolve Generics « ( ) ; » assert That « ( generics . length ) . » is Equal To « ( 1 ) ; » assert That « ( generics [ 0 ] ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » class Type « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » parameterized Type « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » array Class Type « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List [ ] . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » generic Array Type « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List [ ] . class ) ; » assert That « ( type . » get Component Type « ( ) . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Component Type « ( ) . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » generic Multi Array Type « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List [ ] [ ] [ ] . class ) ; » assert That « ( type . » get Component Type « ( ) . resolve ( ) ) . » is Equal To « ( List [ ] [ ] . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string Array List « " ) ) ; » Resolvable Type « generic = type . » as Collection « ( ) . » get Generic « ( ) ; » assert That « ( generic . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " E " ) ; » assert That « ( generic . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( generic . resolve ( ) ) . » is Equal To « ( String [ ] . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » variable Type Generic Array « " ) , » Typed Fields « . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T [ ] " ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( String [ ] . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » variable Type Generic Array « " ) ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T [ ] " ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » variable Type Generic Array « " ) ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T [ ] " ) ; » assert That « ( type . » is Array « ( ) ) . » is Equal To « ( true ) ; » assert That « ( type . » to Class « ( ) ) . » is Equal To « ( Object . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » wildcard Type « " ) ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( Number . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » wildcard Super Type « " ) ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( Number . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » parameterized Type « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Null « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string Integer Multi Value Map « " ) ) . as ( Map . class ) ; » assert That « ( type . » get Generic « ( 0 ) . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Generic « ( 1 ) . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( 1 , 0 ) . resolve ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string Integer Multi Value Map Switched « " ) ) . as ( Map . class ) ; » assert That « ( type . » get Generic « ( 0 ) . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Generic « ( 1 ) . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( 1 , 0 ) . resolve ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » list Of List Of Unknown « " ) ) . as ( Collection . class ) ; » assert That « ( type . » get Generic « ( 0 ) . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( 0 ) . as ( Collection . class ) . » get Generic « ( 0 ) . as ( Collection . class ) . resolve ( ) ) . » is Null « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Method Return Type « ( Methods . class . » get Method « ( " » bounded Type Variable Result « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Method Return Type « ( Methods . class . » get Method « ( " » bounded Type Variable Wildcard Result « " ) ) ; » assert That « ( type . » get Generic « ( 1 ) . » as Collection « ( ) . » resolve Generic « ( ) ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Method Return Type « ( Methods . class . » get Method « ( " » typed Return « " ) ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » My Simple Interface Type « . class ) . as ( » My Interface Type « . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » My Collection Interface Type « . class ) . as ( » My Interface Type « . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( Collection . class ) ; » assert That « ( type . » resolve Generic « ( 0 , 0 ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » My Simple Superclass Type « . class ) . as ( » My Superclass Type « . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » My Collection Superclass Type « . class ) . as ( » My Superclass Type « . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( Collection . class ) ; » assert That « ( type . » resolve Generic « ( 0 , 0 ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » parameterized Type « " ) , » Typed Fields « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « » implementation Type « = » Resolvable Type « . » for Class With Generics « ( Fields . class , Integer . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » parameterized Type « " ) , » implementation Type « ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends List « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( » Extends List « . class ) ; » assert That « ( type . » as Collection « ( ) . » resolve Generic « ( ) ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » My Superclass Type « . class , » My Collection Superclass Type « . class ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( Collection . class ) ; » assert That « ( type . » resolve Generic « ( 0 , 0 ) ) . » is Equal To « ( String . class ) ; }
@Test { Constructor < ? > constructor = Constructors . class . » get Constructor « ( List . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Constructor Parameter « ( constructor , 0 ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List . class ) ; » assert That « ( type . » resolve Generic « ( 0 ) ) . » is Equal To « ( » Char Sequence « . class ) ; }
@Test { Constructor < ? > constructor = Constructors . class . » get Constructor « ( Map . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Constructor Parameter « ( constructor , 0 ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Map . class ) ; » assert That « ( type . » resolve Generic « ( 0 ) ) . » is Null « ( ) ; }
@Test { Constructor < ? > constructor = Constructors . class . » get Constructor « ( Map . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Constructor Parameter « ( constructor , 0 , » Typed Constructors « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Map . class ) ; » assert That « ( type . » resolve Generic « ( 0 ) ) . » is Equal To « ( String . class ) ; }
@Test { Method method = Methods . class . » get Method « ( " » typed Parameter « " , Object . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Parameter « ( method , 0 ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » typed Parameter « " , Object . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Parameter « ( method , 0 , » Typed Methods « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » typed Parameter « " , Object . class ) ; » Method Parameter « » method Parameter « = » Method Parameter « . » for Executable « ( method , 0 ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Parameter « ( » method Parameter « ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » typed Parameter « " , Object . class ) ; » Method Parameter « » method Parameter « = » Method Parameter « . » for Executable « ( method , 0 ) ; » method Parameter « . » set Containing Class « ( » Typed Methods « . class ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Parameter « ( » method Parameter « ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » typed Return « " ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Return Type « ( method ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Method method = Methods . class . » get Method « ( " » typed Return « " ) ; » Resolvable Type « type = » Resolvable Type « . » for Method Return Type « ( method , » Typed Methods « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Type » source Type « = Methods . class . » get Method « ( " » typed Return « " ) . » get Generic Return Type « ( ) ; » Resolvable Type « type = » Resolvable Type « . » for Type « ( » source Type « ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Type » source Type « = Methods . class . » get Method « ( " » typed Return « " ) . » get Generic Return Type « ( ) ; » Resolvable Type « type = » Resolvable Type « . » for Type « ( » source Type « , » Resolvable Type « . » for Class « ( » Typed Methods « . class ) . as ( Methods . class ) . » as Variable Resolver « ( ) ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Type » source Type « = Methods . class . » get Method « ( " » typed Return « " ) . » get Generic Return Type « ( ) ; » Resolvable Type « type = » Resolvable Type « . » for Type « ( » Parameterized Type Reference « . » for Type « ( » source Type « ) ) ; » assert That « ( type . resolve ( ) ) . » is Null « ( ) ; » assert That « ( type . » get Type « ( ) . » to String « ( ) ) . » is Equal To « ( " T " ) ; }
@Test { Type » source Type « = Methods . class . » get Method « ( " » char Sequence Return « " ) . » get Generic Return Type « ( ) ; » Resolvable Type « » reflective Type « = » Resolvable Type « . » for Type « ( » source Type « ) ; » Resolvable Type « » declared Type « = » Resolvable Type « . » for Type « ( new » Parameterized Type Reference « < List < » Char Sequence « > > ( ) { } ) ; » assert That « ( » declared Type « ) . » is Equal To « ( » reflective Type « ) ; }
@Test { Field field = » Enclosed In Parameterized Type « . » Inner Typed « . class . » get Field « ( " field " ) ; » Resolvable Type « type = » Resolvable Type « . » for Field « ( field , » Typed Enclosed In Parameterized Type « . » Typed Inner Typed « . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Class « ( Object . class ) . » is Assignable From « ( ( » Resolvable Type « ) null ) ) . » with Message Containing « ( " Type must not be null " ) ; }
@Test { » Resolvable Type « » object Type « = » Resolvable Type « . » for Class « ( Object . class ) ; » assert That « ( » object Type « . » is Assignable From « ( » Resolvable Type « . NONE ) ) . » is Equal To « ( false ) ; » assert That « ( » Resolvable Type « . NONE . » is Assignable From « ( » object Type « ) ) . » is Equal To « ( false ) ; }
@Test { » Resolvable Type « » object Type « = » Resolvable Type « . » for Class « ( Object . class ) ; » Resolvable Type « » unresolvable Variable « = » Resolvable Type « . » for Field « ( » Assignment Base « . class . » get Field « ( " o " ) ) ; » assert That « ( » unresolvable Variable « . resolve ( ) ) . » is Null « ( ) ; » assert That Resolvable Type « ( » object Type « ) . » is Assignable From « ( » unresolvable Variable « ) ; » assert That Resolvable Type « ( » unresolvable Variable « ) . » is Assignable From « ( » object Type « ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class With Generics « ( » Multi Value Map « . class , Integer . class , String . class ) ; » assert That « ( type . » as Map « ( ) . » to String « ( ) ) . » is Equal To « ( " java . util . Map < java . lang . Integer , java . util . List < java . lang . String > > " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Resolvable Type « . » for Class With Generics « ( Map . class , Integer . class ) ) . » with Message Containing « ( " Mismatched number of generics specified " ) ; }
@Test { » Resolvable Type « » element Type « = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List « " ) ) ; » Resolvable Type « type = » Resolvable Type « . » for Array Component « ( » element Type « ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . util . List < java . lang . String > [ ] " ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( List [ ] . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( void . class ) ; » assert That « ( type . resolve ( ) ) . » is Equal To « ( void . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List « " ) ) ; » Resolvable Type « narrow = » Resolvable Type « . » for Type « ( » Array List « . class , type ) ; » assert That « ( narrow . » get Generic « ( ) . resolve ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( Fields . class . » get Field « ( " » string List « " ) ) ; » assert That « ( type . » has Unresolvable Generics « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( List . class ) ; » assert That « ( type . » has Unresolvable Generics « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( List . class ) . » get Generic « ( ) ; » assert That « ( type . » has Unresolvable Generics « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » My Simple Interface Type With Implements Raw « . class ) ; for ( » Resolvable Type « generic : type . » get Generics « ( ) ) { » assert That « ( generic . resolve ( ) ) . » is Not Null « ( ) ; } » assert That « ( type . » has Unresolvable Generics « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Class « ( » Extends My Simple Interface Type With Implements Raw « . class ) ; for ( » Resolvable Type « generic : type . » get Generics « ( ) ) { » assert That « ( generic . resolve ( ) ) . » is Not Null « ( ) ; } » assert That « ( type . » has Unresolvable Generics « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Resolvable Type « type = » Resolvable Type « . » for Field « ( » Base Provider « . class . » get Field « ( " stuff " ) , » Base Provider « . class ) ; » assert That « ( type . » get Nested « ( 2 ) . » is Assignable From « ( » Resolvable Type « . » for Class « ( » Base Implementation « . class ) ) ) . » is True « ( ) ; » assert That « ( type . » to String « ( ) ) . » is Equal To « ( " java . util . Collection < org . springframework . core . » Resolvable Type Tests $ I Base « < ? > > " ) ; }
@Test { » Resolvable Type « » generic Type « = » Resolvable Type « . » for Field « ( » Unresolved With Generics « . class . » get Declared Field « ( " set " ) ) . » as Collection « ( ) ; » Resolvable Type « type = » Resolvable Type « . » for Class With Generics « ( » Array List « . class , » generic Type « . » get Generic « ( ) ) ; » assert That « ( type . » resolve Generic « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » assert Keys « ( » create Sorted Props « ( ) ) ; }
@Test { » assert Keys « ( » create Sorted Props From Prototype « ( ) ) ; }
@Test { » assert Key Set « ( » create Sorted Props « ( ) ) ; }
@Test { » assert Key Set « ( » create Sorted Props From Prototype « ( ) ) ; }
@Test { » assert Entry Set « ( » create Sorted Props « ( ) ) ; }
@Test { » assert Entry Set « ( » create Sorted Props From Prototype « ( ) ) ; }
@Test { » Sorted Properties « » sorted Properties « = » create Sorted Props « ( ) ; » Byte Array Output Stream « baos = new » Byte Array Output Stream « ( ) ; » sorted Properties « . store ( baos , " custom comment " ) ; String [ ] lines = lines ( baos ) ; » assert That « ( lines ) . » has Size « ( 7 ) ; » assert That « ( lines [ 0 ] ) . » is Equal To « ( " # custom comment " ) ; » assert That « ( lines [ 1 ] ) . as ( " timestamp " ) . » starts With « ( " # " ) ; » assert Props Are Sorted « ( lines ) ; }
@Test { » Sorted Properties « » sorted Properties « = » create Sorted Props « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » sorted Properties « . store ( writer , " custom comment " ) ; String [ ] lines = lines ( writer ) ; » assert That « ( lines ) . » has Size « ( 7 ) ; » assert That « ( lines [ 0 ] ) . » is Equal To « ( " # custom comment " ) ; » assert That « ( lines [ 1 ] ) . as ( " timestamp " ) . » starts With « ( " # " ) ; » assert Props Are Sorted « ( lines ) ; }
@Test { » Sorted Properties « » sorted Properties « = » create Sorted Props « ( true ) ; » Byte Array Output Stream « baos = new » Byte Array Output Stream « ( ) ; » sorted Properties « . store ( baos , " custom comment " ) ; String [ ] lines = lines ( baos ) ; » assert That « ( lines ) . » has Size « ( 5 ) ; » assert Props Are Sorted « ( lines ) ; }
@Test { » Sorted Properties « » sorted Properties « = » create Sorted Props « ( true ) ; » String Writer « writer = new » String Writer « ( ) ; » sorted Properties « . store ( writer , " custom comment " ) ; String [ ] lines = lines ( writer ) ; » assert That « ( lines ) . » has Size « ( 5 ) ; » assert Props Are Sorted « ( lines ) ; }
@Test { Collection < Integer > ints = » create Approximate Collection « ( » Enum Set « . of ( Color . BLUE ) , 3 ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> ints . add ( 42 ) ) ; }
@Test { Collection < Integer > ints = » create Collection « ( » Enum Set « . class , Color . class , 3 ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> ints . add ( 42 ) ) ; }
@Test { » Enum Map « < Color , Integer > » enum Map « = new » Enum Map « < > ( Color . class ) ; » enum Map « . put ( Color . RED , 1 ) ; » enum Map « . put ( Color . BLUE , 2 ) ; Map < String , Integer > map = » create Approximate Map « ( » enum Map « , 3 ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> map . put ( " foo " , 1 ) ) ; }
@Test { Map < String , Integer > map = » create Map « ( » Enum Map « . class , Color . class , 3 ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> map . put ( " foo " , 1 ) ) ; }
@Test { Map < String , Integer > map = » create Map « ( » Multi Value Map « . class , null , 3 ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> map . put ( " foo " , 1 ) ) ; }
@Test { Collection < String > set = » create Approximate Collection « ( new » Hash Set « < String > ( ) , 2 ) ; Assertions . » assert That « ( set ) . » is Empty « ( ) ; }
@Test { » Hash Set « < String > » hash Set « = new » Hash Set « < > ( ) ; » hash Set « . add ( " foo " ) ; Collection < String > set = » create Approximate Collection « ( » hash Set « , 2 ) ; » assert That « ( set ) . » is Empty « ( ) ; }
@Test { Collection < Color > colors = » create Approximate Collection « ( » Enum Set « . » none Of « ( Color . class ) , 2 ) ; » assert That « ( colors ) . » is Empty « ( ) ; }
@Test { Collection < Color > colors = » create Approximate Collection « ( » Enum Set « . of ( Color . BLUE ) , 2 ) ; » assert That « ( colors ) . » is Empty « ( ) ; }
@Test { Map < String , String > map = » create Approximate Map « ( new » Hash Map « < String , String > ( ) , 2 ) ; » assert That « ( map ) . » is Empty « ( ) ; }
@Test { Map < String , String > » hash Map « = new » Hash Map « < > ( ) ; » hash Map « . put ( " foo " , " bar " ) ; Map < String , String > map = » create Approximate Map « ( » hash Map « , 2 ) ; » assert That « ( map ) . » is Empty « ( ) ; }
@Test { Map < Color , String > colors = » create Approximate Map « ( new » Enum Map « < Color , String > ( Color . class ) , 2 ) ; » assert That « ( colors ) . » is Empty « ( ) ; }
@Test { » Enum Map « < Color , String > » enum Map « = new » Enum Map « < > ( Color . class ) ; » enum Map « . put ( Color . BLUE , " blue " ) ; Map < Color , String > colors = » create Approximate Map « ( » enum Map « , 2 ) ; » assert That « ( colors ) . » is Empty « ( ) ; }
@Test { » assert That « ( » create Collection « ( » Enum Set « . class , Color . class , 0 ) ) . » is Instance Of « ( » Enum Set « . class ) ; }
@Test { » Enum Set « < Color > » enum Set « = » Enum Set « . » none Of « ( Color . class ) ; » assert That « ( » create Collection « ( » enum Set « . » get Class « ( ) , Color . class , 0 ) ) . » is Instance Of « ( » enum Set « . » get Class « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Collection « ( » Enum Set « . class , Object . class , 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Collection « ( » Enum Set « . class , null , 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Collection « ( null , Object . class , 0 ) ) ; }
@Test { » assert That « ( » create Map « ( » Enum Map « . class , Color . class , 0 ) ) . » is Instance Of « ( » Enum Map « . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Map « ( » Enum Map « . class , Object . class , 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Map « ( » Enum Map « . class , null , 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Map « ( null , Object . class , 0 ) ) ; }
@Test { Set < » Test Annotation « > set = stream ( ) . collect ( » Merged Annotation Collectors « . » to Annotation Set « ( ) ) ; » assert That « ( set ) . » is Instance Of « ( » Linked Hash Set « . class ) . » flat Extracting « ( » Test Annotation « :: value ) . » contains Exactly « ( " a " , " b " , " c " ) ; » assert That « ( set ) . » all Match « ( » Synthesized Annotation « . class :: » is Instance « ) ; }
@Test { Annotation [ ] array = stream ( ) . collect ( » Merged Annotation Collectors « . » to Annotation Array « ( ) ) ; » assert That « ( Arrays . stream ( array ) . map ( annotation -> ( ( » Test Annotation « ) annotation ) . value ( ) ) ) . » contains Exactly « ( " a " , " b " , " c " ) ; » assert That « ( array ) . » all Match « ( » Synthesized Annotation « . class :: » is Instance « ) ; }
@Test { » Test Annotation « [ ] array = stream ( ) . collect ( » Merged Annotation Collectors « . » to Annotation Array « ( » Test Annotation « [ ] :: new ) ) ; » assert That « ( Arrays . stream ( array ) . map ( » Test Annotation « :: value ) ) . » contains Exactly « ( " a " , " b " , " c " ) ; » assert That « ( array ) . » all Match « ( » Synthesized Annotation « . class :: » is Instance « ) ; }
@Test { » Multi Value Map « < String , Object > map = stream ( ) . map ( » Merged Annotation « :: » filter Default Values « ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( Adapt . » CLASS _ TO _ STRING « ) ) ; » assert That « ( map . get ( " value " ) ) . » contains Exactly « ( " a " , " b " , " c " ) ; » assert That « ( map . get ( " extra " ) ) . » contains Exactly « ( " java . lang . String " , " java . lang . Integer " ) ; }
@Test { » Multi Value Map « < String , Object > map = stream ( ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( result -> { result . add ( " finished " , true ) ; return result ; } ) ) ; » assert That « ( map . get ( " value " ) ) . » contains Exactly « ( " a " , " b " , " c " ) ; » assert That « ( map . get ( " extra " ) ) . » contains Exactly « ( void . class , String . class , Integer . class ) ; » assert That « ( map . get ( " finished " ) ) . » contains Exactly « ( true ) ; }
@Test { » assert Inherited Strategy Behavior « ( » Multiple Composed Caches Class « . class ) ; }
@Test { » assert Inherited Strategy Behavior « ( » Sub Multiple Composed Caches Class « . class ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Multiple Noninherited Composed Caches Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ; » assert That « ( stream ( annotations , " value " ) ) . » contains Exactly « ( " » noninherited Cache 1 « " , " » noninherited Cache 2 « " ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Sub Multiple Noninherited Composed Caches Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ; » assert That « ( annotations . stream ( Cacheable . class ) ) . » is Empty « ( ) ; }
@Test { » assert Inherited Strategy Behavior « ( » Composed Plus Local Caches Class « . class ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Multiple Composed Caches On Interface Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ; » assert That « ( annotations . stream ( Cacheable . class ) ) . » is Empty « ( ) ; }
@Test { » assert Inherited Strategy Behavior « ( » get Class « ( ) . » get Declared Method « ( " » multiple Composed Caches Method « " ) ) ; }
@Test { » assert Inherited Strategy Behavior « ( » get Class « ( ) . » get Declared Method « ( " » composed Plus Local Caches Method « " ) ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » Multiple Composed Caches Class « . class ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » Sub Multiple Composed Caches Class « . class ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Multiple Noninherited Composed Caches Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) ; » assert That « ( stream ( annotations , " value " ) ) . » contains Exactly « ( " » noninherited Cache 1 « " , " » noninherited Cache 2 « " ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Sub Multiple Noninherited Composed Caches Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) ; » assert That « ( stream ( annotations , " value " ) ) . » contains Exactly « ( " » noninherited Cache 1 « " , " » noninherited Cache 2 « " ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » Composed Plus Local Caches Class « . class ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » Multiple Composed Caches On Interface Class « . class ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » Composed Cache On Interface And Local Cache Class « . class ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » get Class « ( ) . » get Declared Method « ( " » multiple Composed Caches Method « " ) ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » get Class « ( ) . » get Declared Method « ( " » composed Plus Local Caches Method « " ) ) ; }
@Test { » assert Type Hierarchy Strategy Behavior « ( » get Bridge Method « ( ) ) ; }
@Test { attributes . put ( " » unresolvable Class « " , new » Class Not Found Exception « ( " myclass " ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> attributes . » get Class « ( " » unresolvable Class « " ) ) . » with Message Containing « ( " myclass " ) . » with Cause Instance Of « ( » Class Not Found Exception « . class ) ; }
@Test { attributes . put ( " » unresolvable Class « " , new » Linkage Error « ( " myclass " ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> attributes . » get Class « ( " » unresolvable Class « " ) ) . » with Message Containing « ( " myclass " ) . » with Cause Instance Of « ( » Linkage Error « . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> attributes . » get Enum « ( null ) ) . » with Message Containing « ( " must not be null or empty " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> attributes . » get Enum « ( " " ) ) . » with Message Containing « ( " must not be null or empty " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> attributes . » get Enum « ( " bogus " ) ) . » with Message Containing « ( " Attribute 'bogus' not found " ) ; }
@Test { attributes . put ( " color " , " RED " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> attributes . » get Enum « ( " color " ) ) . » with Message Containing « ( " Attribute 'color' is of type String , but Enum was expected " ) ; }
@Test { » Default Value Annotation « synthesized = » Merged Annotations « . from ( » With Default Value « . class ) . get ( » Default Value Annotation « . class ) . synthesize ( ) ; » assert That « ( synthesized ) . » is Instance Of « ( » Synthesized Annotation « . class ) ; Object » default Value « = » Annotation Utils « . » get Default Value « ( synthesized , " » enum Value « " ) ; » assert That « ( » default Value « ) . » is Equal To « ( » Test Enum « . ONE ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Packages Annotation Filter « ( ( String [ ] ) null ) ) . » with Message « ( " Packages array must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Packages Annotation Filter « ( ( String ) null ) ) . » with Message « ( " Packages array must not have empty elements " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Packages Annotation Filter « ( " " ) ) . » with Message « ( " Packages array must not have empty elements " ) ; }
@Test { » Packages Annotation Filter « filter = new » Packages Annotation Filter « ( " com . example " ) ; » assert That « ( filter . matches ( " com . example . Component " ) ) . » is True « ( ) ; }
@Test { » Packages Annotation Filter « filter = new » Packages Annotation Filter « ( " com . example " ) ; » assert That « ( filter . matches ( " org . springframework . sterotype . Component " ) ) . » is False « ( ) ; }
@Test { » Packages Annotation Filter « filter = new » Packages Annotation Filter « ( " com . example " ) ; » assert That « ( filter . matches ( " com . examples . Component " ) ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Synthesizing Method Parameter « ( method , 2 ) ) ; }
@Test { » assert That « ( » Annotation Aware Order Comparator « . INSTANCE ) . » is Instance Of « ( » Annotation Aware Order Comparator « . class ) ; }
@Test { List < Object > list = new » Array List « < > ( ) ; list . add ( new B ( ) ) ; list . add ( new A ( ) ) ; » Annotation Aware Order Comparator « . sort ( list ) ; » assert That « ( list . get ( 0 ) instanceof A ) . » is True « ( ) ; » assert That « ( list . get ( 1 ) instanceof B ) . » is True « ( ) ; }
@Test { List < Object > list = new » Array List « < > ( ) ; list . add ( new » B 2 « ( ) ) ; list . add ( new » A 2 « ( ) ) ; » Annotation Aware Order Comparator « . sort ( list ) ; » assert That « ( list . get ( 0 ) instanceof » A 2 « ) . » is True « ( ) ; » assert That « ( list . get ( 1 ) instanceof » B 2 « ) . » is True « ( ) ; }
@Test { List < Object > list = new » Array List « < > ( ) ; list . add ( new B ( ) ) ; list . add ( new » A 2 « ( ) ) ; » Annotation Aware Order Comparator « . sort ( list ) ; » assert That « ( list . get ( 0 ) instanceof » A 2 « ) . » is True « ( ) ; » assert That « ( list . get ( 1 ) instanceof B ) . » is True « ( ) ; }
@Test { List < Object > list = new » Array List « < > ( ) ; list . add ( new B ( ) ) ; list . add ( new C ( ) ) ; » Annotation Aware Order Comparator « . sort ( list ) ; » assert That « ( list . get ( 0 ) instanceof C ) . » is True « ( ) ; » assert That « ( list . get ( 1 ) instanceof B ) . » is True « ( ) ; }
@Test { List < Object > list = new » Array List « < > ( ) ; list . add ( B . class ) ; list . add ( A . class ) ; » Annotation Aware Order Comparator « . sort ( list ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( A . class ) ; » assert That « ( list . get ( 1 ) ) . » is Equal To « ( B . class ) ; }
@Test { List < Object > list = new » Array List « < > ( ) ; list . add ( B . class ) ; list . add ( C . class ) ; » Annotation Aware Order Comparator « . sort ( list ) ; » assert That « ( list . get ( 0 ) ) . » is Equal To « ( C . class ) ; » assert That « ( list . get ( 1 ) ) . » is Equal To « ( B . class ) ; }
@Test { » assert Get All Merged Annotations Behavior « ( » Multiple Composed Caches Class « . class ) ; }
@Test { » assert Get All Merged Annotations Behavior « ( » Sub Multiple Composed Caches Class « . class ) ; }
@Test { Class < ? > element = » Sub Multiple Noninherited Composed Caches Class « . class ; Set < Cacheable > cacheables = » get All Merged Annotations « ( element , Cacheable . class ) ; » assert That « ( cacheables ) . » is Not Null « ( ) ; » assert That « ( cacheables . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert Get All Merged Annotations Behavior « ( » Composed Plus Local Caches Class « . class ) ; }
@Test { Class < » Multiple Composed Caches On Interface Class « > element = » Multiple Composed Caches On Interface Class « . class ; Set < Cacheable > cacheables = » get All Merged Annotations « ( element , Cacheable . class ) ; » assert That « ( cacheables ) . » is Not Null « ( ) ; » assert That « ( cacheables . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Annotated Element « element = » get Class « ( ) . » get Declared Method « ( " » multiple Composed Caches Method « " ) ; » assert Get All Merged Annotations Behavior « ( element ) ; }
@Test { » Annotated Element « element = » get Class « ( ) . » get Declared Method « ( " » composed Plus Local Caches Method « " ) ; » assert Get All Merged Annotations Behavior « ( element ) ; }
@Test { Set < Cacheable > cacheables = » get All Merged Annotations « ( » get Bridge Method « ( ) , Cacheable . class ) ; » assert That « ( cacheables ) . » is Not Null « ( ) ; » assert That « ( cacheables . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert Find All Merged Annotations Behavior « ( » Multiple Composed Caches Class « . class ) ; }
@Test { » assert Find All Merged Annotations Behavior « ( » Sub Multiple Composed Caches Class « . class ) ; }
@Test { » assert Find All Merged Annotations Behavior « ( » Composed Plus Local Caches Class « . class ) ; }
@Test { » assert Find All Merged Annotations Behavior « ( » Multiple Composed Caches On Interface Class « . class ) ; }
@Test { » assert Find All Merged Annotations Behavior « ( » Composed Cache On Interface And Local Cache Class « . class ) ; }
@Test { » Annotated Element « element = » get Class « ( ) . » get Declared Method « ( " » multiple Composed Caches Method « " ) ; » assert Find All Merged Annotations Behavior « ( element ) ; }
@Test { » Annotated Element « element = » get Class « ( ) . » get Declared Method « ( " » composed Plus Local Caches Method « " ) ; » assert Find All Merged Annotations Behavior « ( element ) ; }
@Test { » assert Find All Merged Annotations Behavior « ( » get Bridge Method « ( ) ) ; }
@Test { » assert That « ( » get Meta Annotation Types « ( » Non Annotated Class « . class , » Transactional Component « . class ) . » is Empty « ( ) ) . » is True « ( ) ; » assert That « ( » get Meta Annotation Types « ( » Non Annotated Class « . class , » Transactional Component « . class . » get Name « ( ) ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { Set < String > names = » get Meta Annotation Types « ( » Transactional Component Class « . class , » Transactional Component « . class ) ; » assert That « ( names ) . » is Equal To « ( names ( Transactional . class , Component . class , Indexed . class ) ) ; names = » get Meta Annotation Types « ( » Transactional Component Class « . class , » Transactional Component « . class . » get Name « ( ) ) ; » assert That « ( names ) . » is Equal To « ( names ( Transactional . class , Component . class , Indexed . class ) ) ; }
@Test { Set < String > names = » get Meta Annotation Types « ( » Composed Transactional Component Class « . class , » Composed Transactional Component « . class ) ; » assert That « ( names ) . » is Equal To « ( names ( » Transactional Component « . class , Transactional . class , Component . class , Indexed . class ) ) ; names = » get Meta Annotation Types « ( » Composed Transactional Component Class « . class , » Composed Transactional Component « . class . » get Name « ( ) ) ; » assert That « ( names ) . » is Equal To « ( names ( » Transactional Component « . class , Transactional . class , Component . class , Indexed . class ) ) ; }
@Test { » assert That « ( » has Meta Annotation Types « ( » Non Annotated Class « . class , » TX _ NAME « ) ) . » is False « ( ) ; }
@Test { » assert That « ( » has Meta Annotation Types « ( » Transactional Component Class « . class , » Transactional Component « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( » has Meta Annotation Types « ( » Transactional Component Class « . class , » TX _ NAME « ) ) . » is True « ( ) ; » assert That « ( » has Meta Annotation Types « ( » Transactional Component Class « . class , Component . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( » has Meta Annotation Types « ( » Composed Transactional Component Class « . class , » TX _ NAME « ) ) . » is True « ( ) ; » assert That « ( » has Meta Annotation Types « ( » Composed Transactional Component Class « . class , Component . class . » get Name « ( ) ) ) . » is True « ( ) ; » assert That « ( » has Meta Annotation Types « ( » Composed Transactional Component Class « . class , » Composed Transactional Component « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( » is Annotated « ( » Non Annotated Class « . class , Transactional . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » is Annotated « ( Order . class , Documented . class ) ) . » is True « ( ) ; » assert That « ( » is Annotated « ( » Non Null Api « . class , Documented . class ) ) . » is True « ( ) ; » assert That « ( » is Annotated « ( » Non Null Api « . class , Nonnull . class ) ) . » is True « ( ) ; » assert That « ( » is Annotated « ( » Parameters Are Nonnull By Default « . class , Nonnull . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » is Annotated « ( » Non Annotated Class « . class , » TX _ NAME « ) ) . » is False « ( ) ; }
@Test { » assert That « ( » has Annotation « ( » Non Annotated Class « . class , Transactional . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » has Annotation « ( Order . class , Documented . class ) ) . » is True « ( ) ; » assert That « ( » has Annotation « ( » Non Null Api « . class , Documented . class ) ) . » is True « ( ) ; » assert That « ( » has Annotation « ( » Non Null Api « . class , Nonnull . class ) ) . » is True « ( ) ; » assert That « ( » has Annotation « ( » Parameters Are Nonnull By Default « . class , Nonnull . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get All Annotation Attributes « ( » Non Annotated Class « . class , » TX _ NAME « ) ) . » is Null « ( ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Tx Config « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Transactional on » Tx Config « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " value " ) ) . as ( " value for » Tx Config « " ) . » is Equal To « ( » as List « ( " » Tx Config « " ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Sub Class With Inherited Annotation « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Transactional on » Sub Class With Inherited Annotation « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " qualifier " ) ) . » is Equal To « ( » as List « ( " » composed 2 « " , " » transaction Manager « " ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Sub Sub Class With Inherited Annotation « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Transactional on » Sub Sub Class With Inherited Annotation « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " qualifier " ) ) . » is Equal To « ( » as List « ( " » transaction Manager « " ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Sub Sub Class With Inherited Composed Annotation « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Transactional on » Sub Sub Class With Inherited Composed Annotation « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " qualifier " ) ) . » is Equal To « ( » as List « ( " » composed 1 « " ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Derived Tx Config « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Transactional on » Derived Tx Config « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " value " ) ) . as ( " value for » Derived Tx Config « " ) . » is Equal To « ( » as List « ( " » Derived Tx Config « " ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Tx From Multiple Composed Annotations « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Transactional on » Tx From Multiple Composed Annotations « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " value " ) ) . as ( " value for » Tx From Multiple Composed Annotations « . " ) . » is Equal To « ( » as List « ( " » Tx Inherited Composed « " , " » Tx Composed « " ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Non Null Api « . class , Nonnull . class . » get Name « ( ) ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Nonnull on » Non Null Api « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " when " ) ) . as ( " value for » Non Null Api « " ) . » is Equal To « ( » as List « ( When . ALWAYS ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get All Annotation Attributes « ( » Parameters Are Nonnull By Default « . class , Nonnull . class . » get Name « ( ) ) ; » assert That « ( attributes ) . as ( " Annotation attributes map for @ Nonnull on » Non Null Api « " ) . » is Not Null « ( ) ; » assert That « ( attributes . get ( " when " ) ) . as ( " value for » Non Null Api « " ) . » is Equal To « ( » as List « ( When . ALWAYS ) ) ; }
@Test { Class < ? > element = » Tx Config « . class ; String name = » TX _ NAME « ; » Annotation Attributes « attributes = » get Merged Annotation Attributes « ( element , name ) ; » assert That « ( attributes ) . as ( " Annotation attributes for @ Transactional on » Tx Config « " ) . » is Not Null « ( ) ; » assert That « ( attributes . » get String « ( " value " ) ) . as ( " value for » Tx Config « " ) . » is Equal To « ( " » Tx Config « " ) ; » assert That « ( » is Annotated « ( element , name ) ) . » is True « ( ) ; }
@Test { Class < ? > element = » Derived Tx Config « . class ; String name = » TX _ NAME « ; » Annotation Attributes « attributes = » get Merged Annotation Attributes « ( element , name ) ; » assert That « ( attributes ) . as ( " Annotation attributes for @ Transactional on » Derived Tx Config « " ) . » is Not Null « ( ) ; » assert That « ( attributes . » get String « ( " value " ) ) . as ( " value for » Derived Tx Config « " ) . » is Equal To « ( " » Derived Tx Config « " ) ; » assert That « ( » is Annotated « ( element , name ) ) . » is True « ( ) ; }
@Test { » Annotation Attributes « attributes = » get Merged Annotation Attributes « ( » Meta Cycle Annotated Class « . class , » TX _ NAME « ) ; » assert That « ( attributes ) . as ( " Should not find annotation attributes for @ Transactional on » Meta Cycle Annotated Class « " ) . » is Null « ( ) ; }
@Test { Class < ? > element = » Concrete Class With Inherited Annotation « . class ; String name = » TX _ NAME « ; » Annotation Attributes « attributes = » get Merged Annotation Attributes « ( element , name ) ; » assert That « ( attributes ) . as ( " Should not find @ Transactional on » Concrete Class With Inherited Annotation « " ) . » is Null « ( ) ; » assert That « ( » is Annotated « ( element , name ) ) . » is False « ( ) ; }
@Test { Class < ? > element = » Inherited Annotation Interface « . class ; String name = » TX _ NAME « ; » Annotation Attributes « attributes = » get Merged Annotation Attributes « ( element , name ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on » Inherited Annotation Interface « " ) . » is Not Null « ( ) ; » assert That « ( » is Annotated « ( element , name ) ) . » is True « ( ) ; }
@Test { Class < ? > element = » Non Inherited Annotation Interface « . class ; String name = Order . class . » get Name « ( ) ; » Annotation Attributes « attributes = » get Merged Annotation Attributes « ( element , name ) ; » assert That « ( attributes ) . as ( " Should find @ Order on » Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; » assert That « ( » is Annotated « ( element , name ) ) . » is True « ( ) ; }
@Test { for ( Class < ? > clazz : » as List « ( » Half Convention Based And Half Aliased Composed Context Config Class V 1 « . class , » Half Convention Based And Half Aliased Composed Context Config Class V 2 « . class ) ) { » get Merged Annotation Attributes With Half Convention Based And Half Aliased Composed Annotation « ( clazz ) ; } }
@Test { » assert Get Merged Annotation « ( » Aliased Value Composed Context Config Class « . class , " test . xml " ) ; }
@Test { » assert Get Merged Annotation « ( » Implicit Aliases Context Config Class 1 « . class , " foo . xml " ) ; » assert Get Merged Annotation « ( » Implicit Aliases Context Config Class 2 « . class , " bar . xml " ) ; » assert Get Merged Annotation « ( » Implicit Aliases Context Config Class 3 « . class , " baz . xml " ) ; }
@Test { » assert Get Merged Annotation « ( » Transitive Implicit Aliases Context Config Class « . class , " test . groovy " ) ; }
@Test { » assert Get Merged Annotation « ( » Single Location Transitive Implicit Aliases Context Config Class « . class , " test . groovy " ) ; }
@Test { » assert Get Merged Annotation « ( » Transitive Implicit Aliases With Skipped Level Context Config Class « . class , " test . xml " ) ; }
@Test { » assert Get Merged Annotation « ( » Single Location Transitive Implicit Aliases With Skipped Level Context Config Class « . class , " test . xml " ) ; }
@Test { Class < ? > element = » Invalid Convention Based Composed Context Config Class « . class ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » get Merged Annotation Attributes « ( element , » Context Config « . class ) ) . » with Message Containing « ( " Different @ » Alias For « mirror values for annotation " ) . » with Message Containing « ( " attribute 'locations' and its alias 'value' " ) . » with Message Containing « ( " values of [ { » required Locations Declaration « } ] and [ { » duplicate Declaration « } ] " ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Inherited Annotation Interface « . class , Transactional . class ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on » Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Sub Inherited Annotation Interface « . class , Transactional . class ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on » Sub Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Sub Sub Inherited Annotation Interface « . class , Transactional . class ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on » Sub Sub Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Non Inherited Annotation Interface « . class , Order . class ) ; » assert That « ( attributes ) . as ( " Should find @ Order on » Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Sub Non Inherited Annotation Interface « . class , Order . class ) ; » assert That « ( attributes ) . as ( " Should find @ Order on » Sub Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Sub Sub Non Inherited Annotation Interface « . class , Order . class ) ; » assert That « ( attributes ) . as ( " Should find @ Order on » Sub Sub Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { Method method = » Concrete Class With Inherited Annotation « . class . » get Method « ( " » handle From Interface « " ) ; » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( method , Order . class ) ; » assert That « ( attributes ) . as ( " Should find @ Order on » Concrete Class With Inherited Annotation « . » handle From Interface « ( ) method " ) . » is Not Null « ( ) ; }
@Test { Method method = » Concrete Class With Inherited Annotation « . class . » get Method « ( " handle " ) ; » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( method , Transactional . class ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on » Concrete Class With Inherited Annotation « . handle ( ) method " ) . » is Not Null « ( ) ; }
@Test { Method method = » Concrete Class With Inherited Annotation « . class . » get Method « ( " » handle Parameterized « " , String . class ) ; » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( method , Transactional . class ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on bridged » Concrete Class With Inherited Annotation « . » handle Parameterized « ( ) " ) . » is Not Null « ( ) ; }
@Test { » Annotation Attributes « attributes = » find Merged Annotation Attributes « ( » Meta And Local Tx Config Class « . class , Transactional . class ) ; » assert That « ( attributes ) . as ( " Should find @ Transactional on » Meta And Local Tx Config Class « " ) . » is Not Null « ( ) ; » assert That « ( attributes . » get String « ( " qualifier " ) ) . as ( " TX qualifier for » Meta And Local Tx Config Class « . " ) . » is Equal To « ( " » local Tx Mgr « " ) ; }
@Test { » Annotation Attributes « attributes = » assert Component Scan Attributes « ( » Test Component Scan Class « . class , " com . example . app . test " ) ; Filter [ ] » exclude Filters « = attributes . » get Annotation Array « ( " » exclude Filters « " , Filter . class ) ; » assert That « ( » exclude Filters « ) . » is Not Null « ( ) ; List < String > patterns = stream ( » exclude Filters « ) . map ( Filter :: pattern ) . collect ( » to List « ( ) ) ; » assert That « ( patterns ) . » is Equal To « ( » as List « ( " * Test " , " * Tests " ) ) ; }
@Test { » assert Component Scan Attributes « ( » Component Scan With Base Packages And Value Alias Class « . class , " com . example . app . test " ) ; }
@Test { Class < ? > clazz = » Composed Transactional Class « . class ; » Aliased Transactional « annotation = » find Merged Annotation « ( clazz , » Aliased Transactional « . class ) ; » assert That « ( annotation ) . as ( " Should find @ » Aliased Transactional « on " + clazz ) . » is Not Null « ( ) ; » assert That « ( annotation . value ( ) ) . as ( " TX qualifier for " + clazz ) . » is Equal To « ( " » another Transaction Manager « " ) ; » assert That « ( annotation . qualifier ( ) ) . as ( " TX qualifier for " + clazz ) . » is Equal To « ( " » another Transaction Manager « " ) ; }
@Test { » assert Component Scan Attributes « ( » Convention Based Single Package Component Scan Class « . class , " com . example . app . test " ) ; }
@Test { » assert Component Scan Attributes « ( » Alias For Based Single Package Component Scan Class « . class , " com . example . app . test " ) ; }
@Test { Class < ? > element = » Aliased Transactional Component Class « . class ; » Aliased Transactional « annotation = » find Merged Annotation « ( element , » Aliased Transactional « . class ) ; » assert That « ( annotation ) . as ( " @ » Aliased Transactional « on " + element ) . » is Not Null « ( ) ; » assert That « ( annotation . value ( ) ) . as ( " TX value via synthesized annotation . " ) . » is Equal To « ( " » alias For Qualifier « " ) ; » assert That « ( annotation . qualifier ( ) ) . as ( " TX qualifier via synthesized annotation . " ) . » is Equal To « ( " » alias For Qualifier « " ) ; }
@Test { » assert Web Mapping « ( » Web Controller « . class . » get Method « ( " » post Mapped With Path Attribute « " ) ) ; }
@Test { » assert Web Mapping « ( » Web Controller « . class . » get Method « ( " » get Mapped With Value Attribute « " ) ) ; » assert Web Mapping « ( » Web Controller « . class . » get Method « ( " » get Mapped With Path Attribute « " ) ) ; }
@Test { Constructor < ? > » deprecated Ctor « = Date . class . » get Constructor « ( String . class ) ; » assert That « ( » find Merged Annotation « ( » deprecated Ctor « , Deprecated . class ) ) . » is Equal To « ( » deprecated Ctor « . » get Annotation « ( Deprecated . class ) ) ; » assert That « ( » find Merged Annotation « ( Date . class , Deprecated . class ) ) . » is Equal To « ( Date . class . » get Annotation « ( Deprecated . class ) ) ; }
@Test { » assert That « ( » find Merged Annotation « ( » Resource Holder « . class , Resource . class ) ) . » is Equal To « ( » Resource Holder « . class . » get Annotation « ( Resource . class ) ) ; » assert That « ( » find Merged Annotation « ( » Spring App Config Class « . class , Resource . class ) ) . » is Equal To « ( » Spring App Config Class « . class . » get Annotation « ( Resource . class ) ) ; }
@Test { » assert That « ( » find Merged Annotation « ( » Parameters Are Nonnull By Default « . class , Nonnull . class ) ) . » is Equal To « ( » Parameters Are Nonnull By Default « . class . » get Annotation « ( Nonnull . class ) ) ; » assert That « ( » find Merged Annotation « ( » Resource Holder « . class , Nonnull . class ) ) . » is Equal To « ( » Parameters Are Nonnull By Default « . class . » get Annotation « ( Nonnull . class ) ) ; }
@Test { Method method = » Transactional Service Impl « . class . » get Method « ( " » do It « " ) ; » assert That « ( » find Merged Annotation « ( method , Resource . class ) ) . » is Equal To « ( method . » get Annotation « ( Resource . class ) ) ; }
@Test { Method method = » Transactional Service Impl « . class . » get Method « ( " » do It « " ) ; Set < Transactional > » all Merged Annotations « = » get All Merged Annotations « ( method , Transactional . class ) ; » assert That « ( » all Merged Annotations « . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { Method method = » Transactional Service Impl « . class . » get Method « ( " » do It « " ) ; Set < Transactional > » all Merged Annotations « = » find All Merged Annotations « ( method , Transactional . class ) ; » assert That « ( » all Merged Annotations « . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = » Implements Interface With Generic Annotated Method « . class . » get Method « ( " foo " , String . class ) ; Order order = » find Merged Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { Method method = » Extends Base Class With Generic Annotated Method « . class . » get Method « ( " foo " , String . class ) ; Order order = » find Merged Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { » Annotated Element « element = » Annotated Element Utils « . » for Annotations « ( » For Annotations Class « . class . » get Declared Annotations « ( ) ) ; » Annotations Scanner « . » get Declared Annotations « ( element , false ) ; » Annotations Scanner « . » get Declared Annotations « ( element , false ) ; » assert That « ( element . » get Declared Annotations « ( ) ) . » is Not Same As « ( element . » get Declared Annotations « ( ) ) ; }
@Test { » Value Attribute « annotation = » Annotated Element Utils « . » get Merged Annotation « ( » Value Attribute Meta Meta Class « . class , » Value Attribute « . class ) ; » assert That « ( annotation . value ( ) ) . » contains Exactly « ( " » From Value Attribute Meta « " ) ; }
@Test { » assert That « ( » Merged Annotations « . from ( » Non Annotated Class « . class ) . stream ( » Transactional Component « . class ) ) . » is Empty « ( ) ; }
@Test { Stream < Class < ? > > classes = » Merged Annotations « . from ( » Transactional Component « . class ) . stream ( ) . map ( » Merged Annotation « :: » get Type « ) ; » assert That « ( classes ) . » contains Exactly « ( Transactional . class , Component . class , Indexed . class ) ; }
@Test { Stream < Class < ? > > classes = » Merged Annotations « . from ( » Composed Transactional Component « . class ) . stream ( ) . map ( » Merged Annotation « :: » get Type « ) ; » assert That « ( classes ) . » contains Exactly « ( » Transactional Component « . class , Transactional . class , Component . class , Indexed . class ) ; }
@Test { » assert That « ( » Merged Annotations « . from ( » Non Annotated Class « . class ) . » is Present « ( Transactional . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Merged Annotations « . from ( » Transactional Component « . class ) . » is Present « ( » Transactional Component « . class ) ) . » is False « ( ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Transactional Component « . class ) ; » assert That « ( annotations . » is Present « ( Transactional . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( Component . class ) ) . » is True « ( ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Composed Transactional Component « . class ) ; » assert That « ( annotations . » is Present « ( Transactional . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( Component . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( » Composed Transactional Component « . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Merged Annotations « . from ( » Transactional Component Class « . class ) . » is Present « ( » Transactional Component « . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Merged Annotations « . from ( » Sub Transactional Component Class « . class ) . » is Present « ( » Transactional Component « . class ) ) . » is False « ( ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Transactional Component Class « . class ) ; » assert That « ( annotations . » is Present « ( Transactional . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( Component . class ) ) . » is True « ( ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Composed Transactional Component Class « . class ) ; » assert That « ( annotations . » is Present « ( Transactional . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( Component . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( » Composed Transactional Component « . class ) ) . » is True « ( ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Composed Transactional Component Class « . class ) ; » assert That « ( annotations . get ( » Transactional Component « . class ) . » get Meta Source « ( ) . » get Type « ( ) ) . » is Equal To « ( » Composed Transactional Component « . class ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Composed Transactional Component Class « . class ) ; » Merged Annotation « < ? > annotation = annotations . get ( » Transactional Component « . class ) ; » assert That « ( annotation . » get Distance « ( ) ) . » is Greater Than « ( 0 ) ; » assert That « ( annotation . » get Root « ( ) . » get Type « ( ) ) . » is Equal To « ( » Composed Transactional Component « . class ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations « . from ( » Composed Transactional Component Class « . class ) ; » Merged Annotation « < ? > annotation = annotations . get ( » Composed Transactional Component « . class ) ; » assert That « ( annotation . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( annotation . » get Root « ( ) ) . » is Same As « ( annotation ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Composed Transactional Component Class « . class ) . get ( » Transactional Component « . class ) ; » assert That « ( annotation . » get Meta Types « ( ) ) . » contains Exactly « ( » Composed Transactional Component « . class , » Transactional Component « . class ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Non Annotated Class « . class ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . » is Empty « ( ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Tx Config « . class ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . contains ( entry ( " value " , Arrays . » as List « ( " » Tx Config « " ) ) ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Sub Class With Inherited Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . contains ( entry ( " qualifier " , Arrays . » as List « ( " » composed 2 « " , " » transaction Manager « " ) ) ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Sub Sub Class With Inherited Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . contains ( entry ( " qualifier " , Arrays . » as List « ( " » transaction Manager « " ) ) ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Sub Sub Class With Inherited Composed Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . contains ( entry ( " qualifier " , Arrays . » as List « ( " » composed 1 « " ) ) ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Derived Tx Config « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . contains ( entry ( " value " , Arrays . » as List « ( " » Derived Tx Config « " ) ) ) ; }
@Test { » Multi Value Map « < String , Object > map = » Merged Annotations « . from ( » Tx From Multiple Composed Annotations « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . stream ( Transactional . class ) . collect ( » Merged Annotation Collectors « . » to Multi Value Map « ( ) ) ; » assert That « ( map ) . contains ( entry ( " value " , Arrays . » as List « ( " » Tx Inherited Composed « " , " » Tx Composed « " ) ) ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Tx Config « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » Tx Config « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Derived Tx Config « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » Derived Tx Config « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Meta Cycle Annotated Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is False « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Class With Inherited Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Boolean « ( " » read Only « " ) ) . » is True « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Class With Inherited Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Boolean « ( " » read Only « " ) ) . » is False « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Class With Inherited Composed Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Boolean « ( " » read Only « " ) ) . » is False « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Concrete Class With Inherited Annotation « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is False « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Inherited Annotation Interface « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Non Inherited Annotation Interface « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( Order . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Convention Based Composed Context Configuration Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » contains Exactly « ( " » explicit Declaration « " ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " » explicit Declaration « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Half Convention Based And Half Aliased Composed Context Configuration Class 1 « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » contains Exactly « ( " » explicit Declaration « " ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " » explicit Declaration « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Half Convention Based And Half Aliased Composed Context Configuration Class 2 « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » is Empty « ( ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » is Empty « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Aliased Composed Context Configuration Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " test . xml " ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » contains Exactly « ( " test . xml " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Aliased Value Composed Context Configuration Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " test . xml " ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » contains Exactly « ( " test . xml " ) ; }
@Test { » test Get With Inherited « ( » Aliased Value Composed Context Configuration Class « . class , " test . xml " ) ; }
@Test { » test Get With Inherited « ( » Implicit Aliases Context Configuration Class 1 « . class , " foo . xml " ) ; » test Get With Inherited « ( » Implicit Aliases Context Configuration Class 2 « . class , " bar . xml " ) ; » test Get With Inherited « ( » Implicit Aliases Context Configuration Class 3 « . class , " baz . xml " ) ; }
@Test { » test Get With Inherited « ( » Transitive Implicit Aliases Context Configuration Class « . class , " test . groovy " ) ; }
@Test { » test Get With Inherited « ( » Single Location Transitive Implicit Aliases Context Configuration Class « . class , " test . groovy " ) ; }
@Test { » test Get With Inherited « ( » Transitive Implicit Aliases With Skipped Level Context Configuration Class « . class , " test . xml " ) ; }
@Test { » test Get With Inherited « ( » Single Location Transitive Implicit Aliases With Skipped Level Context Configuration Class « . class , " test . xml " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Merged Annotations « . from ( » Invalid Convention Based Composed Context Configuration Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Shadowed Alias Composed Context Configuration Class « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » contains Exactly « ( " test . xml " ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " test . xml " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Non Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Non Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Non Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { Method method = » Concrete Class With Inherited Annotation « . class . » get Method « ( " » handle From Interface « " ) ; » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = » Concrete Class With Inherited Annotation « . class . » get Method « ( " handle " ) ; » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = » Concrete Class With Inherited Annotation « . class . » get Method « ( " » handle Parameterized « " , String . class ) ; » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is True « ( ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Meta And Local Tx Config Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get String « ( " qualifier " ) ) . » is Equal To « ( " » local Tx Mgr « " ) ; }
@Test { » Merged Annotation « < » Aliased Transactional « > » merged Annotation « = » Merged Annotations « . from ( » Composed Transactional Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( » Aliased Transactional « . class ) ; » assert That « ( » merged Annotation « . » get String « ( " value " ) ) . » is Equal To « ( " » another Transaction Manager « " ) ; » assert That « ( » merged Annotation « . » get String « ( " qualifier " ) ) . » is Equal To « ( " » another Transaction Manager « " ) ; }
@Test { » Merged Annotation « < » Aliased Transactional « > » merged Annotation « = » Merged Annotations « . from ( » Meta Meta Aliased Transactional Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( » Aliased Transactional « . class ) ; » assert That « ( » merged Annotation « . » get String « ( " value " ) ) . » is Equal To « ( " meta " ) ; » assert That « ( » merged Annotation « . » get String « ( " qualifier " ) ) . » is Equal To « ( " meta " ) ; }
@Test { » Merged Annotation « < ? > annotation = » test Get With Type Hierarchy « ( » Test Component Scan Class « . class , " com . example . app . test " ) ; » Merged Annotation « < Filter > [ ] » exclude Filters « = annotation . » get Annotation Array « ( " » exclude Filters « " , Filter . class ) ; » assert That « ( Arrays . stream ( » exclude Filters « ) . map ( filter -> filter . » get String « ( " pattern " ) ) ) . » contains Exactly « ( " * Test " , " * Tests " ) ; }
@Test { » test Get With Type Hierarchy « ( » Component Scan With Base Packages And Value Alias Class « . class , " com . example . app . test " ) ; }
@Test { » test Get With Type Hierarchy « ( » Convention Based Single Package Component Scan Class « . class , " com . example . app . test " ) ; }
@Test { » test Get With Type Hierarchy « ( » Alias For Based Single Package Component Scan Class « . class , " com . example . app . test " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Spring Application Configuration Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( » Context Configuration « . class ) ; » assert That « ( annotation . » get String Array « ( " locations " ) ) . » is Empty « ( ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » is Empty « ( ) ; » assert That « ( annotation . » get Class Array « ( " classes " ) ) . » contains Exactly « ( Number . class ) ; }
@Test { » test Get With Type Hierarchy Web Mapping « ( » Web Controller « . class . » get Method « ( " » post Mapped With Path Attribute « " ) ) ; }
@Test { » test Get With Type Hierarchy Web Mapping « ( » Web Controller « . class . » get Method « ( " » get Mapped With Value Attribute « " ) ) ; » test Get With Type Hierarchy Web Mapping « ( » Web Controller « . class . » get Method « ( " » get Mapped With Path Attribute « " ) ) ; }
@Test { » assert That « ( » Merged Annotations « . from ( » Resource Holder « . class ) . get ( Resource . class ) . » get String « ( " name " ) ) . » is Equal To « ( " x " ) ; }
@Test { Method method = » Transactional Service Impl « . class . » get Method « ( " » do It « " ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) . stream ( Transactional . class ) ) . » is Empty « ( ) ; }
@Test { Method method = » Transactional Service Impl « . class . » get Method « ( " » do It « " ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . stream ( Transactional . class ) ) . » has Size « ( 1 ) ; }
@Test { Stream < Class < ? > > classes = » Merged Annotations « . from ( » Annotated Class « . » Non Annotated Inner Class « . class , » Search Strategy « . » TYPE _ HIERARCHY _ AND _ ENCLOSING _ CLASSES « ) . stream ( ) . map ( » Merged Annotation « :: » get Type « ) ; » assert That « ( classes ) . » contains Exactly « ( Component . class , Indexed . class ) ; }
@Test { Stream < Class < ? > > classes = » Merged Annotations « . from ( » Annotated Class « . » Non Annotated Static Nested Class « . class , » Search Strategy « . » TYPE _ HIERARCHY _ AND _ ENCLOSING _ CLASSES « ) . stream ( ) . map ( » Merged Annotation « :: » get Type « ) ; » assert That « ( classes ) . » contains Exactly « ( Component . class , Indexed . class ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » annotated On Leaf « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » from Interface Implemented By Root « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( - 1 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » meta Annotated On Leaf « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » meta Meta Annotated On Leaf « " ) ; » assert That « ( method . » get Annotation « ( Component . class ) ) . » is Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Component . class ) . » get Distance « ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) . » get Distance « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » annotated On Root « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » meta Annotated On Root « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » override Without New Annotation « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( - 1 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = Leaf . class . » get Method « ( " » not Annotated « " ) ; » assert That « ( method . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » Merged Annotations « . from ( method ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( - 1 ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { Method method = » Implements Interface With Annotated Method « . class . » get Method « ( " foo " ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = » Implements Interface With Generic Annotated Method « . class . » get Method « ( " foo " , String . class ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = » Extends Base Class With Generic Annotated Method « . class . » get Method « ( " foo " , String . class ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = » Sub Of Implements Interface With Annotated Method « . class . » get Method « ( " foo " ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Method method = » Sub Of Abstract Implements Interface With Annotated Method « . class . » get Method « ( " foo " ) ; » assert That « ( » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Class With Local Meta Annotation And Meta Annotated Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Class With Inherited Annotation « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Boolean « ( " » read Only « " ) ) . » is True « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Class With Inherited Meta Annotation « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Meta Meta Annotated Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Meta Meta Meta Annotated Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Transactional Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is False « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Meta Cycle Annotated Class « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Component . class ) ; » assert That « ( annotation . » is Present « ( ) ) . » is False « ( ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Transactional . class ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Non Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Non Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Sub Sub Non Inherited Annotation Interface « . class , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » get Aggregate Index « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Web Controller « . class ) . get ( Component . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " » web Controller « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Component Scan Class « . class ) . get ( » Component Scan « . class ) ; » Merged Annotation « < Filter > [ ] filters = annotation . » get Annotation Array « ( " » exclude Filters « " , Filter . class ) ; » assert That « ( Arrays . stream ( filters ) . map ( filter -> filter . » get String « ( " pattern " ) ) ) . » contains Exactly « ( " * Foo " , " * Bar " ) ; }
@Test { Method method = » Web Controller « . class . » get Method « ( " » handle Mapped With Value Attribute « " ) ; » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( method ) . get ( » Request Mapping « . class ) ; » assert That « ( annotation . » get String « ( " name " ) ) . » is Equal To « ( " foo " ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " / test " ) ; » assert That « ( annotation . » get String Array « ( " path " ) ) . » contains Exactly « ( " / test " ) ; }
@Test { Method method = » Web Controller « . class . » get Method « ( " » handle Mapped With Path Attribute « " ) ; » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( method ) . get ( » Request Mapping « . class ) ; » assert That « ( annotation . » get String « ( " name " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( annotation . » get String Array « ( " value " ) ) . » contains Exactly « ( " / test " ) ; » assert That « ( annotation . » get String Array « ( " path " ) ) . » contains Exactly « ( " / test " ) ; }
@Test { Method method = » Web Controller « . class . » get Method « ( " » handle Mapped With Different Path And Value Attributes « " ) ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Merged Annotations « . from ( method ) . get ( » Request Mapping « . class ) ) . » with Message Containing « ( " attribute 'path' and its alias 'value' " ) . » with Message Containing « ( " values of [ { / test } ] and [ { / enigma } ] " ) ; }
@Test { Method method = » Transactional String Generic « . class . » get Method « ( " something " , Object . class ) ; » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » get Int « ( " value " ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = » Transactional String Generic « . class . » get Method « ( " something " , Object . class ) ; » Merged Annotation « < Order > annotation = » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . get ( Order . class ) ; » assert That « ( annotation . » get Default Value « ( " value " ) ) . contains ( Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotation « . of ( Order . class ) ; » assert That « ( annotation . » get Default Value « ( " value " ) ) . contains ( Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { Method method = » Interface With Repeated « . class . » get Method « ( " foo " ) ; Stream < » Merged Annotation « < » My Repeatable « > > annotations = » Merged Annotations « . from ( method , » Search Strategy « . » TYPE _ HIERARCHY « ) . stream ( » My Repeatable « . class ) ; Stream < String > values = annotations . map ( annotation -> annotation . » get String « ( " value " ) ) ; » assert That « ( values ) . » contains Exactly « ( " A " , " B " , " C " , " » meta 1 « " ) ; }
@Test { Class < ? > element = » My Repeatable Class « . class ; String [ ] » expected Values Java « = { " A " , " B " , " C " } ; String [ ] » expected Values Spring « = { " A " , " B " , " C " , " » meta 1 « " } ; » test Repeatables « ( » Search Strategy « . SUPERCLASS , element , » expected Values Java « , » expected Values Spring « ) ; }
@Test { Class < ? > element = » Sub My Repeatable Class « . class ; String [ ] » expected Values Java « = { " A " , " B " , " C " } ; String [ ] » expected Values Spring « = { " A " , " B " , " C " , " » meta 1 « " } ; » test Repeatables « ( » Search Strategy « . SUPERCLASS , element , » expected Values Java « , » expected Values Spring « ) ; }
@Test { Class < ? > element = » Sub My Repeatable With Additional Local Declarations Class « . class ; String [ ] » expected Values Java « = { " X " , " Y " , " Z " } ; String [ ] » expected Values Spring « = { " X " , " Y " , " Z " , " » meta 2 « " } ; » test Repeatables « ( » Search Strategy « . SUPERCLASS , element , » expected Values Java « , » expected Values Spring « ) ; }
@Test { Class < ? > element = » Sub Sub My Repeatable With Additional Local Declarations Class « . class ; String [ ] » expected Values Java « = { " X " , " Y " , " Z " } ; String [ ] » expected Values Spring « = { " X " , " Y " , " Z " , " » meta 2 « " } ; » test Repeatables « ( » Search Strategy « . SUPERCLASS , element , » expected Values Java « , » expected Values Spring « ) ; }
@Test { Class < ? > element = » My Repeatable Class « . class ; String [ ] » expected Values Java « = { " A " , " B " , " C " } ; String [ ] » expected Values Spring « = { " A " , " B " , " C " , " » meta 1 « " } ; » test Repeatables « ( » Search Strategy « . DIRECT , element , » expected Values Java « , » expected Values Spring « ) ; }
@Test { Class < ? > element = » Sub My Repeatable Class « . class ; String [ ] » expected Values Java « = { } ; String [ ] » expected Values Spring « = { } ; » test Repeatables « ( » Search Strategy « . DIRECT , element , » expected Values Java « , » expected Values Spring « ) ; }
@Test { Component component = » Web Controller « . class . » get Annotation « ( Component . class ) ; » assert That « ( component ) . » is Not Null « ( ) ; Component » synthesized Component « = » Merged Annotation « . from ( component ) . synthesize ( ) ; » assert That « ( » synthesized Component « ) . » is Not Null « ( ) ; » assert That « ( » synthesized Component « ) . » is Equal To « ( component ) ; » assert That « ( » synthesized Component « . value ( ) ) . » is Equal To « ( " » web Controller « " ) ; }
@Test { » Alias For With Missing Attribute Declaration « annotation = » Alias For With Missing Attribute Declaration Class « . class . » get Annotation « ( » Alias For With Missing Attribute Declaration « . class ) ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Merged Annotation « . from ( annotation ) ) . » with Message Starting With « ( " @ » Alias For « declaration on attribute 'foo' in annotation " ) . » with Message Containing « ( » Alias For With Missing Attribute Declaration « . class . » get Name « ( ) ) . » with Message Containing « ( " points to itself " ) ; }
@Test { » Alias For Nonexistent Attribute « annotation = » Alias For Nonexistent Attribute Class « . class . » get Annotation « ( » Alias For Nonexistent Attribute « . class ) ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Merged Annotation « . from ( annotation ) ) . » with Message Starting With « ( " @ » Alias For « declaration on attribute 'foo' in annotation " ) . » with Message Containing « ( » Alias For Nonexistent Attribute « . class . » get Name « ( ) ) . » with Message Containing « ( " declares an alias for 'bar' which is not present " ) ; }
@Test { » Alias For With Mirrored Alias For Wrong Attribute « annotation = » Alias For With Mirrored Alias For Wrong Attribute Class « . class . » get Annotation « ( » Alias For With Mirrored Alias For Wrong Attribute « . class ) ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Merged Annotation « . from ( annotation ) ) . » with Message « ( " @ » Alias For « declaration on attribute 'bar' in annotation [ " + » Alias For With Mirrored Alias For Wrong Attribute « . class . » get Name « ( ) + " ] declares an alias for 'quux' which is not present . " ) ; }
@Test { » test Synthesis With Implicit Aliases « ( » Value Implicit Aliases Test Configuration Class « . class , " value " ) ; » test Synthesis With Implicit Aliases « ( » Location 1 Implicit Aliases Test Configuration Class « . class , " » location 1 « " ) ; » test Synthesis With Implicit Aliases « ( » Xml Implicit Aliases Test Configuration Class « . class , " » xml File « " ) ; » test Synthesis With Implicit Aliases « ( » Groovy Implicit Aliases Simple Test Configuration Class « . class , " » groovy Script « " ) ; }
@Test { » test Synthesis With Implicit Aliases With Implied Alias Names Omitted « ( » Value Implicit Aliases With Implied Alias Names Omitted Test Configuration Class « . class , " value " ) ; » test Synthesis With Implicit Aliases With Implied Alias Names Omitted « ( » Locations Implicit Aliases With Implied Alias Names Omitted Test Configuration Class « . class , " location " ) ; » test Synthesis With Implicit Aliases With Implied Alias Names Omitted « ( » Xml Files Implicit Aliases With Implied Alias Names Omitted Test Configuration Class « . class , " » xml File « " ) ; }
@Test { » Implicit Aliases For Alias Pair Test Configuration « config = » Implicit Aliases For Alias Pair Test Configuration Class « . class . » get Annotation « ( » Implicit Aliases For Alias Pair Test Configuration « . class ) ; » Implicit Aliases For Alias Pair Test Configuration « synthesized = » Merged Annotation « . from ( config ) . synthesize ( ) ; » assert That « ( synthesized ) . » is Instance Of « ( » Synthesized Annotation « . class ) ; » assert That « ( synthesized . » xml File « ( ) ) . » is Equal To « ( " test . xml " ) ; » assert That « ( synthesized . » groovy Script « ( ) ) . » is Equal To « ( " test . xml " ) ; }
@Test { » Transitive Implicit Aliases Test Configuration « config = » Transitive Implicit Aliases Test Configuration Class « . class . » get Annotation « ( » Transitive Implicit Aliases Test Configuration « . class ) ; » Transitive Implicit Aliases Test Configuration « synthesized = » Merged Annotation « . from ( config ) . synthesize ( ) ; » assert That « ( synthesized ) . » is Instance Of « ( » Synthesized Annotation « . class ) ; » assert That « ( synthesized . xml ( ) ) . » is Equal To « ( " test . xml " ) ; » assert That « ( synthesized . groovy ( ) ) . » is Equal To « ( " test . xml " ) ; }
@Test { » Transitive Implicit Aliases For Alias Pair Test Configuration « config = » Transitive Implicit Aliases For Alias Pair Test Configuration Class « . class . » get Annotation « ( » Transitive Implicit Aliases For Alias Pair Test Configuration « . class ) ; » Transitive Implicit Aliases For Alias Pair Test Configuration « synthesized = » Merged Annotation « . from ( config ) . synthesize ( ) ; » assert That « ( synthesized ) . » is Instance Of « ( » Synthesized Annotation « . class ) ; » assert That « ( synthesized . xml ( ) ) . » is Equal To « ( " test . xml " ) ; » assert That « ( synthesized . groovy ( ) ) . » is Equal To « ( " test . xml " ) ; }
@Test { » Merged Annotation « < » Annotation With Defaults « > annotation = » Merged Annotation « . of ( » Annotation With Defaults « . class ) ; » Annotation With Defaults « synthesized = annotation . synthesize ( ) ; » assert That « ( synthesized . text ( ) ) . » is Equal To « ( " enigma " ) ; » assert That « ( synthesized . predicate ( ) ) . » is True « ( ) ; » assert That « ( synthesized . characters ( ) ) . » contains Exactly « ( ' a ' , ' b ' , ' c ' ) ; }
@Test { » Merged Annotation « < » Test Configuration « > annotation = » Merged Annotation « . of ( » Test Configuration « . class ) ; » Test Configuration « synthesized = annotation . synthesize ( ) ; » assert That « ( synthesized . value ( ) ) . » is Equal To « ( " " ) ; » assert That « ( synthesized . location ( ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Merged Annotation « . from ( » Test Configuration Mismatch « . class . » get Annotation « ( » Test Configuration « . class ) ) . synthesize ( ) ) ; }
@Test { Map < String , Object > map = Collections . » singleton Map « ( " location " , " test . xml " ) ; » Merged Annotation « < » Test Configuration « > annotation = » Merged Annotation « . of ( » Test Configuration « . class , map ) ; » Test Configuration « synthesized = annotation . synthesize ( ) ; » assert That « ( synthesized . value ( ) ) . » is Equal To « ( " test . xml " ) ; » assert That « ( synthesized . location ( ) ) . » is Equal To « ( " test . xml " ) ; }
@Test { » synthesize From Map With Attribute Aliases That Override Arrays With Single Elements « ( Collections . » singleton Map « ( " value " , " / foo " ) ) ; » synthesize From Map With Attribute Aliases That Override Arrays With Single Elements « ( Collections . » singleton Map « ( " path " , " / foo " ) ) ; }
@Test { » test Synthesis From Map With Implicit Aliases « ( " value " ) ; » test Synthesis From Map With Implicit Aliases « ( " » location 1 « " ) ; » test Synthesis From Map With Implicit Aliases « ( " » location 2 « " ) ; » test Synthesis From Map With Implicit Aliases « ( " » location 3 « " ) ; » test Synthesis From Map With Implicit Aliases « ( " » xml File « " ) ; » test Synthesis From Map With Implicit Aliases « ( " » groovy Script « " ) ; }
@Test { » test Missing Text Attribute « ( Collections . » empty Map « ( ) ) ; }
@Test { Map < String , Object > map = Collections . » singleton Map « ( " text " , null ) ; » assert That « ( map ) . » contains Key « ( " text " ) ; » test Missing Text Attribute « ( map ) ; }
@Test { Map < String , Object > map = Collections . » singleton Map « ( " value " , 42L ) ; » Merged Annotation « < Component > annotation = » Merged Annotation « . of ( Component . class , map ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> annotation . synthesize ( ) . value ( ) ) . » with Message « ( " Attribute 'value' in annotation " + " org . springframework . core . testfixture . stereotype . Component should be " + " compatible with java . lang . String but a java . lang . Long value was returned " ) ; }
@Test { Component component = » Web Controller « . class . » get Annotation « ( Component . class ) ; » assert That « ( component ) . » is Not Null « ( ) ; Map < String , Object > attributes = » Merged Annotation « . from ( component ) . » as Map « ( ) ; Component synthesized = » Merged Annotation « . of ( Component . class , attributes ) . synthesize ( ) ; » assert That « ( synthesized ) . » is Instance Of « ( » Synthesized Annotation « . class ) ; » assert That « ( synthesized ) . » is Equal To « ( component ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Default Override Class « . class ) . get ( » Default Override Root « . class ) ; » assert That « ( annotation . » get String « ( " text " ) ) . » is Equal To « ( " metameta " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Default Override Explicit Alias Root Meta Meta Class « . class ) . get ( » Default Override Explicit Alias Root « . class ) ; » assert That « ( annotation . » get String « ( " text " ) ) . » is Equal To « ( " meta " ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " meta " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Value Attribute Meta Meta Class « . class ) . get ( » Value Attribute « . class ) ; » assert That « ( annotation . » get String Array « ( » Merged Annotation « . VALUE ) ) . » contains Exactly « ( " » From Value Attribute Meta « " ) ; }
@Test { » Merged Annotation « < ? > annotation = » Merged Annotations « . from ( » Spring Application Configuration Class « . class ) . get ( » Spring Application Configuration « . class ) ; » Annotation Attributes « attributes = annotation . » as Annotation Attributes « ( Adapt . » CLASS _ TO _ STRING « ) ; » assert That « ( attributes ) . » contains Entry « ( " classes " , new String [ ] { Number . class . » get Name « ( ) } ) ; » assert That « ( attributes . » annotation Type « ( ) ) . » is Equal To « ( » Spring Application Configuration « . class ) ; }
@Test { » Test Annotation « annotation = » With Test Annotation « . class . » get Declared Annotation « ( » Test Annotation « . class ) ; » assert That « ( FILTER . matches ( annotation ) ) . » is True « ( ) ; }
@Test { » Other Annotation « annotation = » With Other Annotation « . class . » get Declared Annotation « ( » Other Annotation « . class ) ; » assert That « ( FILTER . matches ( annotation ) ) . » is False « ( ) ; }
@Test { Class < » Test Annotation « > » annotation Type « = » Test Annotation « . class ; » assert That « ( FILTER . matches ( » annotation Type « ) ) . » is True « ( ) ; }
@Test { Class < » Other Annotation « > » annotation Type « = » Other Annotation « . class ; » assert That « ( FILTER . matches ( » annotation Type « ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . PLAIN . matches ( Retention . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . PLAIN . matches ( Nullable . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . PLAIN . matches ( » Test Annotation « . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . JAVA . matches ( Retention . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . JAVA . matches ( Nonnull . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . JAVA . matches ( Nullable . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . JAVA . matches ( » Test Annotation « . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Annotation Filter « . NONE . matches ( Retention . class ) ) . » is False « ( ) ; » assert That « ( » Annotation Filter « . NONE . matches ( Nullable . class ) ) . » is False « ( ) ; » assert That « ( » Annotation Filter « . NONE . matches ( » Test Annotation « . class ) ) . » is False « ( ) ; }
@Test { List < Object > items = new » Array List « < > ( ) ; C c = new C ( 5 ) ; C » c 2 « = new C ( - 5 ) ; items . add ( c ) ; items . add ( » c 2 « ) ; Collections . sort ( items , comparator ) ; » assert Order « ( items , » c 2 « , c ) ; }
@Test { A a = new A ( ) ; C c = new C ( - 50 ) ; B b = new B ( ) ; List < ? > items = Arrays . » as List « ( a , c , b ) ; Collections . sort ( items , comparator . » with Source Provider « ( obj -> null ) ) ; » assert Order « ( items , c , a , b ) ; }
@Test { A a = new A ( ) ; C c = new C ( 3 ) ; B b = new B ( ) ; List < ? > items = Arrays . » as List « ( a , c , b ) ; Collections . sort ( items , comparator . » with Source Provider « ( obj -> { if ( obj == a ) { return new C ( 4 ) ; } if ( obj == b ) { return new C ( 2 ) ; } return null ; } ) ) ; » assert Order « ( items , b , c , a ) ; }
@Test { A a = new A ( ) ; C c = new C ( 5 ) ; C » c 2 « = new C ( - 5 ) ; List < ? > items = Arrays . » as List « ( a , c , » c 2 « ) ; Collections . sort ( items , comparator . » with Source Provider « ( obj -> { if ( obj == a ) { return 4 ; } if ( obj == » c 2 « ) { return 2 ; } return null ; } ) ) ; » assert Order « ( items , » c 2 « , a , c ) ; }
@Test { A a = new A ( ) ; C c = new C ( - 50 ) ; B b = new B ( ) ; Object [ ] items = new Object [ ] { a , c , b } ; Arrays . sort ( items , comparator . » with Source Provider « ( obj -> null ) ) ; » assert Order « ( items , c , a , b ) ; }
@Test { A a = new A ( ) ; C c = new C ( 3 ) ; B b = new B ( ) ; Object [ ] items = new Object [ ] { a , c , b } ; Arrays . sort ( items , comparator . » with Source Provider « ( obj -> { if ( obj == a ) { return new C ( 4 ) ; } if ( obj == b ) { return new C ( 2 ) ; } return null ; } ) ) ; » assert Order « ( items , b , c , a ) ; }
@Test { A a = new A ( ) ; C c = new C ( 5 ) ; C » c 2 « = new C ( - 5 ) ; Object [ ] items = new Object [ ] { a , c , » c 2 « } ; Arrays . sort ( items , comparator . » with Source Provider « ( obj -> { if ( obj == a ) { return 4 ; } if ( obj == » c 2 « ) { return 2 ; } return null ; } ) ) ; » assert Order « ( items , » c 2 « , a , c ) ; }
@Test { » expect Non Repeatable Annotation « ( ( ) -> » get Merged Repeatable Annotations « ( » get Class « ( ) , » Non Repeatable « . class ) ) ; }
@Test { » expect Container Missing Value Attribute « ( ( ) -> » get Merged Repeatable Annotations « ( » get Class « ( ) , » Invalid Repeatable « . class , » Container Missing Value Attribute « . class ) ) ; }
@Test { » expect Container With Non Array Value Attribute « ( ( ) -> » get Merged Repeatable Annotations « ( » get Class « ( ) , » Invalid Repeatable « . class , » Container With Non Array Value Attribute « . class ) ) ; }
@Test { » expect Container With Array Value Attribute But Wrong Component Type « ( ( ) -> » get Merged Repeatable Annotations « ( » get Class « ( ) , » Invalid Repeatable « . class , » Container With Array Value Attribute But Wrong Component Type « . class ) ) ; }
@Test { » assert Get Repeatable Annotations « ( » Repeatable Class « . class ) ; }
@Test { » assert Get Repeatable Annotations « ( » Sub Repeatable Class « . class ) ; }
@Test { » assert Get Repeatable Annotations « ( » Composed Repeatable Class « . class ) ; }
@Test { » assert Get Repeatable Annotations « ( » Composed Repeatable Mixed With Container Class « . class ) ; }
@Test { » assert Get Repeatable Annotations « ( » Composed Container Class « . class ) ; }
@Test { Class < ? > element = » Noninherited Repeatable Class « . class ; Set < Noninherited > annotations = » get Merged Repeatable Annotations « ( element , Noninherited . class ) ; » assert Noninherited Repeatable Annotations « ( annotations ) ; }
@Test { Class < ? > element = » Sub Noninherited Repeatable Class « . class ; Set < Noninherited > annotations = » get Merged Repeatable Annotations « ( element , Noninherited . class ) ; » assert That « ( annotations ) . » is Not Null « ( ) ; » assert That « ( annotations . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » expect Non Repeatable Annotation « ( ( ) -> » find Merged Repeatable Annotations « ( » get Class « ( ) , » Non Repeatable « . class ) ) ; }
@Test { » expect Container Missing Value Attribute « ( ( ) -> » find Merged Repeatable Annotations « ( » get Class « ( ) , » Invalid Repeatable « . class , » Container Missing Value Attribute « . class ) ) ; }
@Test { » expect Container With Non Array Value Attribute « ( ( ) -> » find Merged Repeatable Annotations « ( » get Class « ( ) , » Invalid Repeatable « . class , » Container With Non Array Value Attribute « . class ) ) ; }
@Test { » expect Container With Array Value Attribute But Wrong Component Type « ( ( ) -> » find Merged Repeatable Annotations « ( » get Class « ( ) , » Invalid Repeatable « . class , » Container With Array Value Attribute But Wrong Component Type « . class ) ) ; }
@Test { » assert Find Repeatable Annotations « ( » Repeatable Class « . class ) ; }
@Test { » assert Find Repeatable Annotations « ( » Sub Repeatable Class « . class ) ; }
@Test { » assert Find Repeatable Annotations « ( » Composed Repeatable Class « . class ) ; }
@Test { » assert Find Repeatable Annotations « ( » Composed Repeatable Mixed With Container Class « . class ) ; }
@Test { Class < ? > element = » Noninherited Repeatable Class « . class ; Set < Noninherited > annotations = » find Merged Repeatable Annotations « ( element , Noninherited . class ) ; » assert Noninherited Repeatable Annotations « ( annotations ) ; }
@Test { Class < ? > element = » Sub Noninherited Repeatable Class « . class ; Set < Noninherited > annotations = » find Merged Repeatable Annotations « ( element , Noninherited . class ) ; » assert Noninherited Repeatable Annotations « ( annotations ) ; }
@Test { » assert Find Repeatable Annotations « ( » Composed Container Class « . class ) ; }
@Test { » assert That « ( » Order Utils « . » get Order « ( » Simple Order « . class , null ) ) . » is Equal To « ( Integer . » value Of « ( 50 ) ) ; » assert That « ( » Order Utils « . » get Order « ( » Simple Order « . class , null ) ) . » is Equal To « ( Integer . » value Of « ( 50 ) ) ; }
@Test { » assert That « ( » Order Utils « . » get Order « ( » Simple Priority « . class , null ) ) . » is Equal To « ( Integer . » value Of « ( 55 ) ) ; » assert That « ( » Order Utils « . » get Order « ( » Simple Priority « . class , null ) ) . » is Equal To « ( Integer . » value Of « ( 55 ) ) ; }
@Test { » assert That « ( » Order Utils « . » get Order « ( » Order And Priority « . class , null ) ) . » is Equal To « ( Integer . » value Of « ( 50 ) ) ; » assert That « ( » Order Utils « . » get Order « ( » Order And Priority « . class , null ) ) . » is Equal To « ( Integer . » value Of « ( 50 ) ) ; }
@Test { » assert That « ( » Order Utils « . » get Order « ( » No Order « . class , 33 ) ) . » is Equal To « ( 33 ) ; » assert That « ( » Order Utils « . » get Order « ( » No Order « . class , 33 ) ) . » is Equal To « ( 33 ) ; }
@Test { » assert That « ( » Order Utils « . » get Priority « ( » Simple Order « . class ) ) . » is Null « ( ) ; » assert That « ( » Order Utils « . » get Priority « ( » Simple Order « . class ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » Order Utils « . » get Priority « ( » Order And Priority « . class ) ) . » is Equal To « ( Integer . » value Of « ( 55 ) ) ; » assert That « ( » Order Utils « . » get Priority « ( » Order And Priority « . class ) ) . » is Equal To « ( Integer . » value Of « ( 55 ) ) ; }
@Test { Class < ? > source = » With No Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » is Empty « ( ) ; }
@Test { Class < ? > source = » With Single Annotation « . class ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Multiple Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Superclass « . class ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Single Interface « . class ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Hierarchy « . class ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With No Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » is Empty « ( ) ; }
@Test { Class < ? > source = » With Single Annotation « . class ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Multiple Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Superclass « . class ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Interface « . class ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Hierarchy « . class ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Superclass And Double Inherited « . class ; » assert That « ( Arrays . stream ( source . » get Annotations « ( ) ) . map ( Annotation :: » annotation Type « ) . map ( Class :: » get Name « ) ) . » contains Exactly « ( » Test Inherited Annotation 2 « . class . » get Name « ( ) ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Only « ( " 0 : » Test Inherited Annotation 2 « " ) ; }
@Test { Class < ? > source = » With No Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » is Empty « ( ) ; }
@Test { Class < ? > source = » With Single Annotation « . class ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Multiple Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Superclass « . class ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Interface « . class ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Hierarchy « . class ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " , " 2 : » Test Annotation 3 « " ) ; }
@Test { Class < ? > source = » With No Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » is Empty « ( ) ; }
@Test { Class < ? > source = » With Single Annotation « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » With Multiple Annotations « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Superclass « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Single Interface « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Class < ? > source = » With Hierarchy « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 5 « " , " 1 : » Test Inherited Annotation 5 « " , " 2 : » Test Annotation 6 « " , " 3 : » Test Annotation 2 « " , " 3 : » Test Inherited Annotation 2 « " , " 4 : » Test Annotation 3 « " , " 5 : » Test Annotation 4 « " ) ; }
@Test { Method source = » method From « ( » With No Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » is Empty « ( ) ; }
@Test { Method source = » method From « ( » With Single Annotation « . class ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Multiple Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Single Superclass « . class ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Single Interface « . class ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Hierarchy « . class ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With No Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » is Empty « ( ) ; }
@Test { Method source = » method From « ( » With Single Annotation « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Multiple Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Single Superclass « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Single Interface « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Hierarchy « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » INHERITED _ ANNOTATIONS « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With No Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » is Empty « ( ) ; }
@Test { Method source = » method From « ( » With Single Annotation « . class ) ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Multiple Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Single Superclass « . class ) ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Single Interface « . class ) ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Hierarchy « . class ) ; » assert That « ( scan ( source , » Search Strategy « . SUPERCLASS ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " , " 2 : » Test Annotation 3 « " ) ; }
@Test { Method source = » method From « ( » With No Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » is Empty « ( ) ; }
@Test { Method source = » method From « ( » With Single Annotation « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » With Multiple Annotations « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 0 : » Test Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Single Superclass « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Single Interface « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " , " 1 : » Test Inherited Annotation 2 « " ) ; }
@Test { Method source = » method From « ( » With Hierarchy « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 5 « " , " 1 : » Test Inherited Annotation 5 « " , " 2 : » Test Annotation 6 « " , " 3 : » Test Annotation 2 « " , " 3 : » Test Inherited Annotation 2 « " , " 4 : » Test Annotation 3 « " , " 5 : » Test Annotation 4 « " ) ; }
@Test { Method source = » Bridged Method « . class . » get Declared Method « ( " method " , Object . class ) ; » assert That « ( source . » is Bridge « ( ) ) . » is True « ( ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " ) ; }
@Test { Method source = » Bridged Method « . class . » get Declared Method « ( " method " , String . class ) ; » assert That « ( source . » is Bridge « ( ) ) . » is False « ( ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " ) ; }
@Test { Method source = » Bridged Method « . class . » get Declared Method « ( " method " , Object . class ) ; » assert That « ( source . » is Bridge « ( ) ) . » is True « ( ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » Bridged Method « . class . » get Declared Method « ( " method " , String . class ) ; » assert That « ( source . » is Bridge « ( ) ) . » is False « ( ) ; » assert That « ( scan ( source , » Search Strategy « . DIRECT ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( Ignorable . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » method From « ( » Multiple Methods « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Method source = » Reflection Utils « . » find Method « ( » Generic Override « . class , " method " , String . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 2 « " ) ; }
@Test { Method source = » Reflection Utils « . » find Method « ( » Generic Non Override « . class , " method " , » String Builder « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " ) ; }
@Test { Class < ? > source = » Annotation Enclosing Class Sample « . » Enclosed Static « . » Enclosed Static Static « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY _ AND _ ENCLOSING _ CLASSES « ) ) . » contains Exactly « ( " 0 : » Enclosed Three « " , " 1 : » Enclosed Two « " , " 2 : » Enclosed One « " ) ; }
@Test { Class < ? > source = » Annotation Enclosing Class Sample « . » Enclosed Inner « . » Enclosed Inner Inner « . class ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY _ AND _ ENCLOSING _ CLASSES « ) ) . » contains Exactly « ( " 0 : » Enclosed Three « " , " 1 : » Enclosed Two « " , " 2 : » Enclosed One « " ) ; }
@Test { Method source = » method From « ( » With Hierarchy « . class ) ; » assert That « ( scan ( source , » Search Strategy « . » TYPE _ HIERARCHY _ AND _ ENCLOSING _ CLASSES « ) ) . » contains Exactly « ( " 0 : » Test Annotation 1 « " , " 1 : » Test Annotation 5 « " , " 1 : » Test Inherited Annotation 5 « " , " 2 : » Test Annotation 6 « " , " 3 : » Test Annotation 2 « " , " 3 : » Test Inherited Annotation 2 « " , " 4 : » Test Annotation 3 « " , " 5 : » Test Annotation 4 « " ) ; }
@Test { String result = » Annotations Scanner « . scan ( this , » With Single Superclass « . class , » Search Strategy « . » TYPE _ HIERARCHY « , new » Annotations Processor « < Object , String > ( ) { @ Override @ Nullable public String » do With Aggregate « ( Object context , int » aggregate Index « ) { return " " ; } @ Override @ Nullable public String » do With Annotations « ( Object context , int » aggregate Index « , Object source , Annotation [ ] annotations ) { throw new » Illegal State Exception « ( " Should not call " ) ; } } ) ; » assert That « ( result ) . » is Empty « ( ) ; }
@Test { List < Integer > indexes = new » Array List « < > ( ) ; String result = » Annotations Scanner « . scan ( this , » With Single Superclass « . class , » Search Strategy « . » TYPE _ HIERARCHY « , ( context , » aggregate Index « , source , annotations ) -> { indexes . add ( » aggregate Index « ) ; return " " ; } ) ; » assert That « ( result ) . » is Empty « ( ) ; » assert That « ( indexes ) . » contains Only « ( 0 ) ; }
@Test { String result = » Annotations Scanner « . scan ( this , » With Single Superclass « . class , » Search Strategy « . » TYPE _ HIERARCHY « , new » Annotations Processor « < Object , String > ( ) { @ Override @ Nullable public String » do With Annotations « ( Object context , int » aggregate Index « , Object source , Annotation [ ] annotations ) { return " K " ; } @ Override @ Nullable public String finish ( String result ) { return " O " + result ; } } ) ; » assert That « ( result ) . » is Equal To « ( " OK " ) ; }
@Test { » test Explicit Mirror « ( » With Explicit Mirror A « . class ) ; » test Explicit Mirror « ( » With Explicit Mirror B « . class ) ; }
@Test { » Type Mapped Annotation « < ? > annotation = » get Type Mapped Annotation « ( » With Explicit Alias To Meta Annotation « . class , » Explicit Alias To Meta Annotation « . class , » Explicit Alias Meta Annotation Target « . class ) ; » assert That « ( annotation . » get String « ( " aliased " ) ) . » is Equal To « ( " aliased " ) ; » assert That « ( annotation . » get String « ( " » non Aliased « " ) ) . » is Equal To « ( " » non Aliased « " ) ; }
@Test { » Type Mapped Annotation « < ? > annotation = » get Type Mapped Annotation « ( » With Convention Alias To Meta Annotation « . class , » Convention Alias To Meta Annotation « . class , » Convention Alias Meta Annotation Target « . class ) ; » assert That « ( annotation . » get String « ( " value " ) ) . » is Equal To « ( " " ) ; » assert That « ( annotation . » get String « ( " convention " ) ) . » is Equal To « ( " convention " ) ; }
@Test { » Merged Annotation « < Nested > nested = » Merged Annotation « . of ( Nested . class ) ; » Merged Annotation « < ? > annotation = » Type Mapped Annotation « . of ( null , null , » Nested Container « . class , Collections . » singleton Map « ( " value " , nested ) ) ; » assert That « ( annotation . » get Annotation « ( " value " , Nested . class ) ) . » is Same As « ( nested ) ; }
@Test { » Merged Annotation « < ? > annotation = » Type Mapped Annotation « . of ( null , null , » Class Attributes « . class , Collections . » singleton Map « ( " » class Value « " , » Input Stream « . class . » get Name « ( ) ) ) ; » assert That « ( annotation . » get String « ( " » class Value « " ) ) . » is Equal To « ( » Input Stream « . class . » get Name « ( ) ) ; » assert That « ( annotation . » get Class « ( " » class Value « " ) ) . » is Equal To « ( » Input Stream « . class ) ; }
@Test { » Merged Annotation « < ? > annotation = » Type Mapped Annotation « . of ( null , null , » Class Attributes « . class , Collections . » singleton Map « ( " » class Array Value « " , new String [ ] { » Input Stream « . class . » get Name « ( ) } ) ) ; » assert That « ( annotation . » get String Array « ( " » class Array Value « " ) ) . » contains Exactly « ( » Input Stream « . class . » get Name « ( ) ) ; » assert That « ( annotation . » get Class Array « ( " » class Array Value « " ) ) . » contains Exactly « ( » Input Stream « . class ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( » Test Annotation « . class . » get Name « ( ) ) ) . accepts ( annotation ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( » Missing Annotation « . class . » get Name « ( ) ) ) . rejects ( annotation ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( » Test Annotation « . class ) ) . accepts ( annotation ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( » Missing Annotation « . class ) ) . rejects ( annotation ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( Collections . singleton ( » Test Annotation « . class . » get Name « ( ) ) ) ) . accepts ( annotation ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( Collections . singleton ( » Test Annotation « . class ) ) ) . accepts ( annotation ) ; }
@Test { » Merged Annotation « < » Test Annotation « > annotation = » Merged Annotations « . from ( » With Test Annotation « . class ) . get ( » Test Annotation « . class ) ; » assert That « ( » Merged Annotation Predicates « . » type In « ( Arrays . » as List « ( » Missing Annotation « . class . » get Name « ( ) , » Missing Annotation « . class ) ) ) . rejects ( annotation ) ; }
@Test { List < » Merged Annotation « < » Test Annotation « > > filtered = » Merged Annotations « . from ( » With Multiple Test Annotation « . class ) . stream ( » Test Annotation « . class ) . filter ( » Merged Annotation Predicates « . » first Run Of « ( this :: » first Char Of Value « ) ) . collect ( Collectors . » to List « ( ) ) ; » assert That « ( filtered . stream ( ) . map ( annotation -> annotation . » get String « ( " value " ) ) ) . » contains Exactly « ( " » a 1 « " , " » a 2 « " , " » a 3 « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Merged Annotation Predicates « . » first Run Of « ( null ) ) ; }
@Test { List < » Merged Annotation « < » Test Annotation « > > filtered = » Merged Annotations « . from ( » With Multiple Test Annotation « . class ) . stream ( » Test Annotation « . class ) . filter ( » Merged Annotation Predicates « . unique ( this :: » first Char Of Value « ) ) . collect ( Collectors . » to List « ( ) ) ; » assert That « ( filtered . stream ( ) . map ( annotation -> annotation . » get String « ( " value " ) ) ) . » contains Exactly « ( " » a 1 « " , " » b 1 « " , " » c 1 « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Merged Annotation Predicates « . unique ( null ) ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . » standard Repeatables « ( ) , » With Non Repeatable « . class , » Non Repeatable « . class ) ; » assert That « ( values ) . » is Null « ( ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . » standard Repeatables « ( ) , » With Single Standard Repeatable « . class , » Standard Repeatable « . class ) ; » assert That « ( values ) . » is Null « ( ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . » standard Repeatables « ( ) , » With Standard Repeatables « . class , » Standard Container « . class ) ; » assert That « ( values ) . » contains Exactly « ( " a " , " b " ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . » standard Repeatables « ( ) , » With Explicit Repeatables « . class , » Explicit Container « . class ) ; » assert That « ( values ) . » is Null « ( ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . of ( » Explicit Repeatable « . class , » Explicit Container « . class ) , » With Non Repeatable « . class , » Non Repeatable « . class ) ; » assert That « ( values ) . » is Null « ( ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . of ( » Explicit Repeatable « . class , » Explicit Container « . class ) , » With Standard Repeatables « . class , » Standard Container « . class ) ; » assert That « ( values ) . » is Null « ( ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . of ( » Explicit Repeatable « . class , » Explicit Container « . class ) , » With Explicit Repeatables « . class , » Explicit Container « . class ) ; » assert That « ( values ) . » contains Exactly « ( " a " , " b " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Repeatable Containers « . of ( » Explicit Repeatable « . class , » Invalid No Value « . class ) ) . » with Message Containing « ( " Invalid declaration of container type [ " + » Invalid No Value « . class . » get Name « ( ) + " ] for repeatable annotation [ " + » Explicit Repeatable « . class . » get Name « ( ) + " ] " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Repeatable Containers « . of ( » Explicit Repeatable « . class , » Invalid Not Array « . class ) ) . » with Message « ( " Container type [ " + » Invalid Not Array « . class . » get Name « ( ) + " ] must declare a 'value' attribute for an array of type [ " + » Explicit Repeatable « . class . » get Name « ( ) + " ] " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Repeatable Containers « . of ( » Explicit Repeatable « . class , » Invalid Wrong Array Type « . class ) ) . » with Message « ( " Container type [ " + » Invalid Wrong Array Type « . class . » get Name « ( ) + " ] must declare a 'value' attribute for an array of type [ " + » Explicit Repeatable « . class . » get Name « ( ) + " ] " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Repeatable Containers « . of ( null , null ) ) . » with Message « ( " Repeatable must not be null " ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . of ( » Standard Repeatable « . class , null ) , » With Standard Repeatables « . class , » Standard Container « . class ) ; » assert That « ( values ) . » contains Exactly « ( " a " , " b " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Repeatable Containers « . of ( » Explicit Repeatable « . class , null ) ) . » with Message « ( " Annotation type must be a repeatable annotation : " + " failed to resolve container type for " + » Explicit Repeatable « . class . » get Name « ( ) ) ; }
@Test { » Repeatable Containers « » repeatable Containers « = » Repeatable Containers « . » standard Repeatables « ( ) . and ( » Explicit Container « . class , » Explicit Repeatable « . class ) ; » assert That « ( » find Repeated Annotation Values « ( » repeatable Containers « , » With Standard Repeatables « . class , » Standard Container « . class ) ) . » contains Exactly « ( " a " , " b " ) ; » assert That « ( » find Repeated Annotation Values « ( » repeatable Containers « , » With Explicit Repeatables « . class , » Explicit Container « . class ) ) . » contains Exactly « ( " a " , " b " ) ; }
@Test { Object [ ] values = » find Repeated Annotation Values « ( » Repeatable Containers « . none ( ) , » With Standard Repeatables « . class , » Standard Container « . class ) ; » assert That « ( values ) . » is Null « ( ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Simple Annotation « . class ) ; » assert That « ( mappings . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( mappings . get ( 0 ) . » get Annotation Type « ( ) ) . » is Equal To « ( » Simple Annotation « . class ) ; » assert That « ( » get All « ( mappings ) ) . » flat Extracting « ( » Annotation Type Mapping « :: » get Annotation Type « ) . » contains Exactly « ( » Simple Annotation « . class ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » With Spring Lang Annotation « . class ) ; » assert That « ( mappings . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Meta Annotated « . class ) ; » assert That « ( mappings . size ( ) ) . » is Equal To « ( 6 ) ; » assert That « ( » get All « ( mappings ) ) . » flat Extracting « ( » Annotation Type Mapping « :: » get Annotation Type « ) . » contains Exactly « ( » Meta Annotated « . class , A . class , B . class , AA . class , AB . class , ABC . class ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » With Repeated Meta Annotations « . class ) ; » assert That « ( mappings . size ( ) ) . » is Equal To « ( 3 ) ; » assert That « ( » get All « ( mappings ) ) . » flat Extracting « ( » Annotation Type Mapping « :: » get Annotation Type « ) . » contains Exactly « ( » With Repeated Meta Annotations « . class , Repeating . class , Repeating . class ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Self Annotated « . class ) ; » assert That « ( mappings . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » get All « ( mappings ) ) . » flat Extracting « ( » Annotation Type Mapping « :: » get Annotation Type « ) . » contains Exactly « ( » Self Annotated « . class ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Loop A « . class ) ; » assert That « ( mappings . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( » get All « ( mappings ) ) . » flat Extracting « ( » Annotation Type Mapping « :: » get Annotation Type « ) . » contains Exactly « ( » Loop A « . class , » Loop B « . class ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For With Both Value And Attribute « . class ) ) . » with Message « ( " In @ » Alias For « declared on attribute 'test' in annotation [ " + » Alias For With Both Value And Attribute « . class . » get Name « ( ) + " ] , attribute 'attribute' and its alias 'value' are present with values of 'foo' and 'bar' , but only one is permitted . " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For To Self Non Existing Attribute « . class ) ) . » with Message « ( " @ » Alias For « declaration on attribute 'test' in annotation [ " + » Alias For To Self Non Existing Attribute « . class . » get Name « ( ) + " ] declares an alias for 'missing' which is not present . " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For To Other Non Existing Attribute « . class ) ) . » with Message « ( " Attribute 'test' in annotation [ " + » Alias For To Other Non Existing Attribute « . class . » get Name « ( ) + " ] is declared as an @ » Alias For « nonexistent " + " attribute 'missing' in annotation [ " + » Alias For To Other Non Existing Attribute Target « . class . » get Name « ( ) + " ] . " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For To Self « . class ) ) . » with Message « ( " @ » Alias For « declaration on attribute 'test' in annotation [ " + » Alias For To Self « . class . » get Name « ( ) + " ] points to itself . Specify 'annotation' to point to " + " a same - named attribute on a meta - annotation . " ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Alias For With Array Compatible Return Types « . class ) ; » Annotation Type Mapping « mapping = » get Mapping « ( mappings , » Alias For With Array Compatible Return Types Target « . class ) ; » assert That « ( » get Alias Mapping « ( mapping , 0 ) . » get Name « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For With Incompatible Return Types « . class ) ) . » with Message « ( " Misconfigured aliases : attribute 'test' in annotation [ " + » Alias For With Incompatible Return Types « . class . » get Name « ( ) + " ] and attribute 'test' in annotation [ " + » Alias For With Incompatible Return Types Target « . class . » get Name « ( ) + " ] must declare the same return type . " ) ; }
@Test { String » annotation Type « = » Alias For To Self Annotated To Other Attribute « . class . » get Name « ( ) ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For To Self Annotated To Other Attribute « . class ) ) . » with Message « ( " Attribute 'b' in annotation [ " + » annotation Type « + " ] must be declared as an @ » Alias For « attribute 'a' in annotation [ " + » annotation Type « + " ] , not attribute 'c' in annotation [ " + » annotation Type « + " ] . " ) ; }
@Test { » assert Mixed Implicit And Explicit Aliases « ( » Alias For With Mixed Implicit And Explicit Aliases V 1 « . class , " b " ) ; » assert Mixed Implicit And Explicit Aliases « ( » Alias For With Mixed Implicit And Explicit Aliases V 2 « . class , " a " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For Non Meta Annotated « . class ) ) . » with Message « ( " @ » Alias For « declaration on attribute 'test' in annotation [ " + » Alias For Non Meta Annotated « . class . » get Name « ( ) + " ] declares an alias for attribute 'test' in annotation [ " + » Alias For Non Meta Annotated Target « . class . » get Name « ( ) + " ] which is not meta - present . " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For Self With Different Defaults « . class ) ) . » with Message « ( " Misconfigured aliases : attribute 'a' in annotation [ " + » Alias For Self With Different Defaults « . class . » get Name « ( ) + " ] and attribute 'b' in annotation [ " + » Alias For Self With Different Defaults « . class . » get Name « ( ) + " ] must declare the same default value . " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias For Self With Missing Default « . class ) ) . » with Message « ( " Misconfigured aliases : attribute 'a' in annotation [ " + » Alias For Self With Missing Default « . class . » get Name « ( ) + " ] and attribute 'b' in annotation [ " + » Alias For Self With Missing Default « . class . » get Name « ( ) + " ] must declare default values . " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » Annotation Type Mappings « . » for Annotation Type « ( » Alias With Explicit Mirror And Different Defaults « . class ) ) . » with Message « ( " Misconfigured aliases : attribute 'a' in annotation [ " + » Alias With Explicit Mirror And Different Defaults « . class . » get Name « ( ) + " ] and attribute 'c' in annotation [ " + » Alias With Explicit Mirror And Different Defaults « . class . » get Name « ( ) + " ] must declare the same default value . " ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) ; » assert That « ( mappings . get ( 0 ) . » get Distance « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( mappings . get ( 1 ) . » get Distance « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) ; » assert That « ( mappings . get ( 0 ) . » get Annotation Type « ( ) ) . » is Equal To « ( Mapped . class ) ; » assert That « ( mappings . get ( 1 ) . » get Annotation Type « ( ) ) . » is Equal To « ( » Mapped Target « . class ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Three Deep A « . class ) ; » Annotation Type Mapping « » mapping C « = mappings . get ( 2 ) ; » assert That « ( » mapping C « . » get Meta Types « ( ) ) . » contains Exactly « ( » Three Deep A « . class , » Three Deep B « . class , » Three Deep C « . class ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) ; » assert That « ( mappings . get ( 0 ) . » get Annotation « ( ) ) . » is Null « ( ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) ; » assert That « ( mappings . get ( 1 ) . » get Annotation « ( ) ) . » is Equal To « ( Mapped . class . » get Annotation « ( » Mapped Target « . class ) ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) . get ( 0 ) ; » Attribute Methods « attributes = mapping . » get Attributes « ( ) ; » assert That « ( attributes . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( attributes . get ( 0 ) . » get Name « ( ) ) . » is Equal To « ( " alias " ) ; » assert That « ( attributes . get ( 1 ) . » get Name « ( ) ) . » is Equal To « ( " convention " ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) . get ( 1 ) ; » assert That « ( » get Alias Mapping « ( mapping , 0 ) ) . » is Equal To « ( Mapped . class . » get Declared Method « ( " alias " ) ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( Mapped . class ) . get ( 1 ) ; » assert That « ( » get Convention Mapping « ( mapping , 1 ) ) . » is Equal To « ( Mapped . class . » get Declared Method « ( " convention " ) ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Defined Attributes « . class ) . get ( 1 ) ; » assert That « ( » get Alias Mapping « ( mapping , 0 ) ) . » is Null « ( ) ; » assert That « ( » get Alias Mapping « ( mapping , 1 ) . » get Name « ( ) ) . » is Equal To « ( " value " ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Alias Pair « . class ) . get ( 0 ) ; Method [ ] resolved = » resolve Mirror Sets « ( mapping , » With Same Value Alias Pair « . class , » Alias Pair « . class ) ; » assert That « ( resolved [ 0 ] . » get Name « ( ) ) . » is Equal To « ( " a " ) ; » assert That « ( resolved [ 1 ] . » get Name « ( ) ) . » is Equal To « ( " a " ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Alias Pair « . class ) . get ( 0 ) ; Method [ ] resolved = » resolve Mirror Sets « ( mapping , » With Default Value Alias Pair « . class , » Alias Pair « . class ) ; » assert That « ( resolved [ 0 ] . » get Name « ( ) ) . » is Equal To « ( " a " ) ; » assert That « ( resolved [ 1 ] . » get Name « ( ) ) . » is Equal To « ( " a " ) ; }
@Test { » Annotation Type Mappings « mappings = » Annotation Type Mappings « . » for Annotation Type « ( » Convention To Explicit Aliases « . class ) ; » Annotation Type Mapping « mapping = » get Mapping « ( mappings , » Convention To Explicit Aliases Target « . class ) ; » assert That « ( mapping . » get Convention Mapping « ( 0 ) ) . » is Equal To « ( 0 ) ; » assert That « ( mapping . » get Convention Mapping « ( 1 ) ) . » is Equal To « ( 0 ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Class Value « . class ) . get ( 0 ) ; » assert That « ( mapping . » is Equivalent To Default Value « ( 0 , null , » Reflection Utils « :: » invoke Method « ) ) . » is True « ( ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Class Value With Default « . class ) . get ( 0 ) ; » assert That « ( mapping . » is Equivalent To Default Value « ( 0 , » Input Stream « . class , » Reflection Utils « :: » invoke Method « ) ) . » is True « ( ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Class Value With Default « . class ) . get ( 0 ) ; » assert That « ( mapping . » is Equivalent To Default Value « ( 0 , " java . io . » Input Stream « " , » Reflection Utils « :: » invoke Method « ) ) . » is True « ( ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Class Array Value With Default « . class ) . get ( 0 ) ; » assert That « ( mapping . » is Equivalent To Default Value « ( 0 , new String [ ] { " java . io . » Input Stream « " , " java . io . » Output Stream « " } , » Reflection Utils « :: » invoke Method « ) ) . » is True « ( ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Nested Value « . class ) . get ( 0 ) ; Map < String , Object > value = Collections . » singleton Map « ( " value " , " java . io . » Input Stream « " ) ; » assert That « ( mapping . » is Equivalent To Default Value « ( 0 , value , » Type Mapped Annotation « :: » extract From Map « ) ) . » is True « ( ) ; }
@Test { » Annotation Type Mapping « mapping = » Annotation Type Mappings « . » for Annotation Type « ( » Class Value With Default « . class ) . get ( 0 ) ; » assert That « ( mapping . » is Equivalent To Default Value « ( 0 , » Output Stream « . class , » Reflection Utils « :: » invoke Method « ) ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Merged Annotations Collection « . of ( null ) ) . » with Message « ( " Annotations must not be null " ) ; }
@Test { » Merged Annotations « annotations = » Merged Annotations Collection « . of ( new » Array List « < > ( ) ) ; » assert That « ( annotations ) . » is Same As « ( » Type Mapped Annotations « . NONE ) ; }
@Test { » Merged Annotation « < ? > annotation = mock ( » Merged Annotation « . class ) ; given ( annotation . » is Directly Present « ( ) ) . » will Return « ( false ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Merged Annotations Collection « . of ( Collections . singleton ( annotation ) ) ) . » with Message « ( " Annotation must be directly present " ) ; }
@Test { » Merged Annotation « < ? > annotation = mock ( » Merged Annotation « . class ) ; given ( annotation . » is Directly Present « ( ) ) . » will Return « ( true ) ; given ( annotation . » get Aggregate Index « ( ) ) . » will Return « ( 1 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Merged Annotations Collection « . of ( Collections . singleton ( annotation ) ) ) . » with Message « ( " Annotation must have aggregate index of zero " ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; List < Class < ? > > types = new » Array List « < > ( ) ; for ( » Merged Annotation « < ? > annotation : annotations ) { types . add ( annotation . » get Type « ( ) ) ; } » assert That « ( types ) . » contains Exactly « ( Direct . class , Simple . class , » Meta 1 « . class , » Meta 2 « . class , » Meta 11 « . class ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; Spliterator < » Merged Annotation « < Annotation > > spliterator = annotations . spliterator ( ) ; List < Class < ? > > types = new » Array List « < > ( ) ; spliterator . » for Each Remaining « ( annotation -> types . add ( annotation . » get Type « ( ) ) ) ; » assert That « ( types ) . » contains Exactly « ( Direct . class , Simple . class , » Meta 1 « . class , » Meta 2 « . class , » Meta 11 « . class ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; Spliterator < » Merged Annotation « < Annotation > > spliterator = annotations . spliterator ( ) ; » assert That « ( spliterator . » estimate Size « ( ) ) . » is Equal To « ( 5 ) ; spliterator . » try Advance « ( annotation -> » assert That « ( annotation . » get Type « ( ) ) . » is Equal To « ( Direct . class ) ) ; » assert That « ( spliterator . » estimate Size « ( ) ) . » is Equal To « ( 4 ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . » is Present « ( Direct . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( Direct . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . » is Present « ( » Meta 11 « . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Present « ( » Meta 11 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . » is Present « ( Missing . class ) ) . » is False « ( ) ; » assert That « ( annotations . » is Present « ( Missing . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . » is Directly Present « ( Direct . class ) ) . » is True « ( ) ; » assert That « ( annotations . » is Directly Present « ( Direct . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . » is Directly Present « ( » Meta 11 « . class ) ) . » is False « ( ) ; » assert That « ( annotations . » is Directly Present « ( » Meta 11 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . » is Directly Present « ( Missing . class ) ) . » is False « ( ) ; » assert That « ( annotations . » is Directly Present « ( Missing . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » Merged Annotations « annotations = » get Muti Route 1 « ( ) ; » assert That « ( annotations . get ( » Muti Route Target « . class ) . » get String « ( » Merged Annotation « . VALUE ) ) . » is Equal To « ( " 12 " ) ; » assert That « ( annotations . get ( » Muti Route Target « . class . » get Name « ( ) ) . » get String « ( » Merged Annotation « . VALUE ) ) . » is Equal To « ( " 12 " ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; » assert That « ( annotations . get ( Missing . class ) ) . » is Equal To « ( » Merged Annotation « . missing ( ) ) ; }
@Test { » Merged Annotations « annotations = » get Muti Route 1 « ( ) ; » assert That « ( annotations . get ( » Muti Route Target « . class , annotation -> annotation . » get Distance « ( ) >= 3 ) . » get String « ( » Merged Annotation « . VALUE ) ) . » is Equal To « ( " 111 " ) ; }
@Test { » Merged Annotations « annotations = » get Muti Route 1 « ( ) ; » Merged Annotation Selector « < » Muti Route Target « > deepest = ( existing , candidate ) -> candidate . » get Distance « ( ) > existing . » get Distance « ( ) ? candidate : existing ; » assert That « ( annotations . get ( » Muti Route Target « . class , null , deepest ) . » get String « ( » Merged Annotation « . VALUE ) ) . » is Equal To « ( " 111 " ) ; }
@Test { » Merged Annotations « annotations = » get Direct And Simple « ( ) ; List < Class < ? > > types = new » Array List « < > ( ) ; annotations . stream ( ) . » for Each « ( annotation -> types . add ( annotation . » get Type « ( ) ) ) ; » assert That « ( types ) . » contains Exactly « ( Direct . class , Simple . class , » Meta 1 « . class , » Meta 2 « . class , » Meta 11 « . class ) ; }
@Test { » Merged Annotations « annotations = » get Muti Route 1 « ( ) ; List < String > values = new » Array List « < > ( ) ; annotations . stream ( » Muti Route Target « . class ) . » for Each « ( annotation -> values . add ( annotation . » get String « ( » Merged Annotation « . VALUE ) ) ) ; » assert That « ( values ) . » contains Exactly « ( " 12 " , " 111 " ) ; }
@Test { » Merged Annotation « < Alaised > root = » Merged Annotation « . of ( null , null , Alaised . class , Collections . » singleton Map « ( " » test Alias « " , " test " ) ) ; » Merged Annotations « annotations = » Merged Annotations Collection « . of ( Collections . singleton ( root ) ) ; » Merged Annotation « < » Alais Target « > » meta Annotation « = annotations . get ( » Alais Target « . class ) ; » assert That « ( » meta Annotation « . » get String « ( " test " ) ) . » is Equal To « ( " test " ) ; }
@Test { » Merged Annotation « < Alaised > root = » Merged Annotation « . of ( null , null , Alaised . class , Collections . » empty Map « ( ) ) ; » Merged Annotations « annotations = » Merged Annotations Collection « . of ( Collections . singleton ( root ) ) ; » Merged Annotation « < » Alais Target « > » meta Annotation « = annotations . get ( » Alais Target « . class ) ; » assert That « ( root . » get String « ( " » test Alias « " ) ) . » is Equal To « ( " newdefault " ) ; » assert That « ( » meta Annotation « . » get String « ( " test " ) ) . » is Equal To « ( " newdefault " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( null , » Non Repeatable « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » get Class « ( ) ) ) . satisfies ( this :: » non Repeatable Requirements « ) ; }
@Test { » assert That Annotation Configuration Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( » Container Missing Value Attribute « . class , » Invalid Repeatable « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » get Class « ( ) ) ) . satisfies ( this :: » missing Value Attribute Requirements « ) ; }
@Test { » assert That Annotation Configuration Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( » Container With Non Array Value Attribute « . class , » Invalid Repeatable « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » get Class « ( ) ) ) . satisfies ( this :: » non Array Value Attribute Requirements « ) ; }
@Test { » assert That Annotation Configuration Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( » Container With Array Value Attribute But Wrong Component Type « . class , » Invalid Repeatable « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » get Class « ( ) ) ) . satisfies ( this :: » wrong Component Type Requirements « ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Sub Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Composed Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Composed Repeatable Mixed With Container Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Composed Container Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < Noninherited > annotations = » get Annotations « ( null , Noninherited . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Noninherited Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( Noninherited :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < Noninherited > annotations = » get Annotations « ( null , Noninherited . class , » Search Strategy « . » INHERITED _ ANNOTATIONS « , » Sub Noninherited Repeatable Class « . class ) ; » assert That « ( annotations ) . » is Empty « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( null , » Non Repeatable « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » get Class « ( ) ) ) . satisfies ( this :: » non Repeatable Requirements « ) ; }
@Test { » assert That Annotation Configuration Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( » Container Missing Value Attribute « . class , » Invalid Repeatable « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » get Class « ( ) ) ) . satisfies ( this :: » missing Value Attribute Requirements « ) ; }
@Test { » assert That Annotation Configuration Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( » Container With Non Array Value Attribute « . class , » Invalid Repeatable « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » get Class « ( ) ) ) . satisfies ( this :: » non Array Value Attribute Requirements « ) ; }
@Test { » assert That Annotation Configuration Exception « ( ) . » is Thrown By « ( ( ) -> » get Annotations « ( » Container With Array Value Attribute But Wrong Component Type « . class , » Invalid Repeatable « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » get Class « ( ) ) ) . satisfies ( this :: » wrong Component Type Requirements « ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Sub Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Composed Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Composed Repeatable Mixed With Container Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < » Pete Repeat « > annotations = » get Annotations « ( null , » Pete Repeat « . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Composed Container Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( » Pete Repeat « :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < Noninherited > annotations = » get Annotations « ( null , Noninherited . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Noninherited Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( Noninherited :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { Set < Noninherited > annotations = » get Annotations « ( null , Noninherited . class , » Search Strategy « . » TYPE _ HIERARCHY « , » Sub Noninherited Repeatable Class « . class ) ; » assert That « ( annotations . stream ( ) . map ( Noninherited :: value ) ) . » contains Exactly « ( " A " , " B " , " C " ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( null ) ; » assert That « ( methods ) . » is Same As « ( » Attribute Methods « . NONE ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » No Attributes « . class ) ; » assert That « ( methods ) . » is Same As « ( » Attribute Methods « . NONE ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Multiple Attributes « . class ) ; » assert That « ( methods . get ( " value " ) . » get Name « ( ) ) . » is Equal To « ( " value " ) ; » assert That « ( methods . get ( " » int Value « " ) . » get Name « ( ) ) . » is Equal To « ( " » int Value « " ) ; » assert That « ( » get All « ( methods ) ) . » flat Extracting « ( Method :: » get Name « ) . » contains Exactly « ( " » int Value « " , " value " ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Value Only « . class ) ; » assert That « ( methods . » has Only Value Attribute « ( ) ) . » is True « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Non Value Only « . class ) ; » assert That « ( methods . » has Only Value Attribute « ( ) ) . » is False « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Multiple Attributes « . class ) ; » assert That « ( methods . » has Only Value Attribute « ( ) ) . » is False « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Multiple Attributes « . class ) ; » assert That « ( methods . » index Of « ( " value " ) ) . » is Equal To « ( 1 ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Multiple Attributes « . class ) ; Method method = » Multiple Attributes « . class . » get Declared Method « ( " value " ) ; » assert That « ( methods . » index Of « ( method ) ) . » is Equal To « ( 1 ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Multiple Attributes « . class ) ; » assert That « ( methods . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Class Value « . class ) ; » assert That « ( methods . » can Throw Type Not Present Exception « ( 0 ) ) . » is True « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Class Array Value « . class ) ; » assert That « ( methods . » can Throw Type Not Present Exception « ( 0 ) ) . » is True « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Value Only « . class ) ; » assert That « ( methods . » can Throw Type Not Present Exception « ( 0 ) ) . » is False « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Default Value Attribute « . class ) ; » assert That « ( methods . » has Default Value Method « ( ) ) . » is True « ( ) ; }
@Test { » Attribute Methods « methods = » Attribute Methods « . » for Annotation Type « ( » Multiple Attributes « . class ) ; » assert That « ( methods . » has Default Value Method « ( ) ) . » is False « ( ) ; }
@Test { » Class Value « annotation = » mock Annotation « ( » Class Value « . class ) ; given ( annotation . value ( ) ) . » will Throw « ( » Type Not Present Exception « . class ) ; » Attribute Methods « attributes = » Attribute Methods « . » for Annotation Type « ( annotation . » annotation Type « ( ) ) ; » assert That « ( attributes . » is Valid « ( annotation ) ) . » is False « ( ) ; }
@Test { » Class Value « annotation = mock ( » Class Value « . class ) ; given ( annotation . value ( ) ) . » will Return « ( ( Class ) » Input Stream « . class ) ; » Attribute Methods « attributes = » Attribute Methods « . » for Annotation Type « ( annotation . » annotation Type « ( ) ) ; » assert That « ( attributes . » is Valid « ( annotation ) ) . » is True « ( ) ; }
@Test { » Class Value « annotation = » mock Annotation « ( » Class Value « . class ) ; given ( annotation . value ( ) ) . » will Throw « ( » Type Not Present Exception « . class ) ; » Attribute Methods « attributes = » Attribute Methods « . » for Annotation Type « ( annotation . » annotation Type « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> attributes . validate ( annotation ) ) ; }
@Test { » Class Value « annotation = » mock Annotation « ( » Class Value « . class ) ; given ( annotation . value ( ) ) . » will Return « ( ( Class ) » Input Stream « . class ) ; » Attribute Methods « attributes = » Attribute Methods « . » for Annotation Type « ( annotation . » annotation Type « ( ) ) ; attributes . validate ( annotation ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( this . missing :: » get Type « ) ; }
@Test { » assert That « ( this . missing . » get Meta Types « ( ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( this . missing . » is Present « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . missing . » is Directly Present « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . missing . » is Meta Present « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . missing . » get Distance « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { » assert That « ( this . missing . » get Aggregate Index « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { » assert That « ( this . missing . » get Source « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( this . missing . » get Meta Source « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( this . missing . » get Root « ( ) ) . » is Same As « ( this . missing ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » has Non Default Value « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » has Default Value « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Byte « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Byte Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Boolean « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Boolean Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Char « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Char Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Short « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Short Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Int « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Int Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Long « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Long Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Double « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Double Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Float « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Float Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get String « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get String Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Class « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Class Array « ( " value " ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Enum « ( " value " , » Test Enum « . class ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Enum Array « ( " value " , » Test Enum « . class ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Annotation « ( " value " , » Test Annotation « . class ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . » get Annotation Array « ( " value " , » Test Annotation « . class ) ) ; }
@Test { » assert That « ( this . missing . » get Value « ( " value " , Integer . class ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( this . missing . » get Default Value « ( " value " , Integer . class ) ) . » is Empty « ( ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . synthesize ( ) ) ; }
@Test { » assert That No Such Element Exception « ( ) . » is Thrown By « ( ( ) -> this . missing . synthesize ( annotation -> true ) ) ; }
@Test { » assert That « ( this . missing . synthesize ( annotation -> false ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( this . missing . » to String « ( ) ) . » is Equal To « ( " ( missing ) " ) ; }
@Test { » Annotation Attributes « attributes = this . missing . » as Annotation Attributes « ( ) ; » assert That « ( attributes ) . » is Empty « ( ) ; » assert That « ( this . missing . » as Annotation Attributes « ( ) ) . » is Not Same As « ( attributes ) ; }
@Test { Map < String , Object > map = this . missing . » as Map « ( ) ; » assert That « ( map ) . » is Same As « ( Collections . » EMPTY _ MAP « ) ; }
@Test { Map < String , Object > map = this . missing . » as Map « ( annotation -> new » Concurrent Reference Hash Map « < > ( ) ) ; » assert That « ( map ) . » is Instance Of « ( » Concurrent Reference Hash Map « . class ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » annotated On Leaf « " ) ; » assert That « ( m . » get Annotation « ( Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » get Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » from Interface Implemented By Root « " ) ; » assert That « ( m . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » get Annotation « ( m , Order . class ) ) . » is Null « ( ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » meta Annotated On Leaf « " ) ; » assert That « ( m . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » get Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » meta Meta Annotated On Leaf « " ) ; » assert That « ( m . » get Annotation « ( Component . class ) ) . » is Null « ( ) ; » assert That « ( » get Annotation « ( m , Component . class ) ) . » is Null « ( ) ; » assert That « ( » find Annotation « ( m , Component . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » annotated On Root « " ) ; » assert That « ( m . » get Annotation « ( Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » get Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » meta Annotated On Root « " ) ; » assert That « ( m . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » get Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » override Without New Annotation « " ) ; » assert That « ( m . » get Annotation « ( Order . class ) ) . » is Null « ( ) ; » assert That « ( » get Annotation « ( m , Order . class ) ) . » is Null « ( ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Not Null « ( ) ; }
@Test { Method m = Leaf . class . » get Method « ( " » not Annotated « " ) ; » assert That « ( » find Annotation « ( m , Order . class ) ) . » is Null « ( ) ; }
@Test { Method method = » Implements Interface With Annotated Method « . class . » get Method « ( " foo " ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { Method method = » Implements Interface With Generic Annotated Method « . class . » get Method « ( " foo " , String . class ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { Method method = » Extends Base Class With Generic Annotated Method « . class . » get Method « ( " foo " , String . class ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { Method method = » Sub Of Implements Interface With Annotated Method « . class . » get Method « ( " foo " ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { Method method = » Sub Of Abstract Implements Interface With Annotated Method « . class . » get Method « ( " foo " ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( order ) . » is Not Null « ( ) ; }
@Test { Component component = » find Annotation « ( » Class With Local Meta Annotation And Meta Annotated Interface « . class , Component . class ) ; » assert That « ( component ) . » is Not Null « ( ) ; » assert That « ( component . value ( ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { Transactional transactional = » find Annotation « ( » Sub Sub Class With Inherited Annotation « . class , Transactional . class ) ; » assert That « ( transactional ) . » is Not Null « ( ) ; » assert That « ( transactional . » read Only « ( ) ) . as ( " » read Only « flag for » Sub Sub Class With Inherited Annotation « " ) . » is True « ( ) ; }
@Test { Component component = » find Annotation « ( » Sub Sub Class With Inherited Meta Annotation « . class , Component . class ) ; » assert That « ( component ) . » is Not Null « ( ) ; » assert That « ( component . value ( ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { Component component = » find Annotation « ( » Meta Meta Annotated Class « . class , Component . class ) ; » assert That « ( component ) . as ( " Should find meta - annotation on composed annotation on class " ) . » is Not Null « ( ) ; » assert That « ( component . value ( ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { Component component = » find Annotation « ( » Meta Meta Meta Annotated Class « . class , Component . class ) ; » assert That « ( component ) . as ( " Should find meta - annotation on meta - annotation on composed annotation on class " ) . » is Not Null « ( ) ; » assert That « ( component . value ( ) ) . » is Equal To « ( " » meta 2 « " ) ; }
@Test { Component component = » find Annotation « ( » Transactional Class « . class , Component . class ) ; » assert That « ( component ) . as ( " Should not find @ Component on » Transactional Class « " ) . » is Null « ( ) ; }
@Test { Component component = » find Annotation « ( » Meta Cycle Annotated Class « . class , Component . class ) ; » assert That « ( component ) . as ( " Should not find @ Component on » Meta Cycle Annotated Class « " ) . » is Null « ( ) ; }
@Test { Transactional tx = » find Annotation « ( » Inherited Annotation Interface « . class , Transactional . class ) ; » assert That « ( tx ) . as ( " Should find @ Transactional on » Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { Transactional tx = » find Annotation « ( » Sub Inherited Annotation Interface « . class , Transactional . class ) ; » assert That « ( tx ) . as ( " Should find @ Transactional on » Sub Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { Transactional tx = » find Annotation « ( » Sub Sub Inherited Annotation Interface « . class , Transactional . class ) ; » assert That « ( tx ) . as ( " Should find @ Transactional on » Sub Sub Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { Order order = » find Annotation « ( » Non Inherited Annotation Interface « . class , Order . class ) ; » assert That « ( order ) . as ( " Should find @ Order on » Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { Order order = » find Annotation « ( » Sub Non Inherited Annotation Interface « . class , Order . class ) ; » assert That « ( order ) . as ( " Should find @ Order on » Sub Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { Order order = » find Annotation « ( » Sub Sub Non Inherited Annotation Interface « . class , Order . class ) ; » assert That « ( order ) . as ( " Should find @ Order on » Sub Sub Non Inherited Annotation Interface « " ) . » is Not Null « ( ) ; }
@Test { » assert That « ( » is Annotation Meta Present « ( Order . class , Documented . class ) ) . » is True « ( ) ; » assert That « ( » is Annotation Meta Present « ( » Non Null Api « . class , Documented . class ) ) . » is True « ( ) ; » assert That « ( » is Annotation Meta Present « ( » Non Null Api « . class , Nonnull . class ) ) . » is True « ( ) ; » assert That « ( » is Annotation Meta Present « ( » Parameters Are Nonnull By Default « . class , Nonnull . class ) ) . » is True « ( ) ; }
@Test { Component component = » Web Controller « . class . » get Annotation « ( Component . class ) ; » assert That « ( component ) . » is Not Null « ( ) ; » Annotation Attributes « attributes = ( » Annotation Attributes « ) » get Annotation Attributes « ( component ) ; » assert That « ( attributes ) . » is Not Null « ( ) ; » assert That « ( attributes . » get String « ( VALUE ) ) . as ( " value attribute : " ) . » is Equal To « ( " » web Controller « " ) ; » assert That « ( attributes . » annotation Type « ( ) ) . » is Equal To « ( Component . class ) ; }
@Test { Method method = » Web Controller « . class . » get Method « ( " » handle Mapped With Different Path And Value Attributes « " ) ; » Web Mapping « » web Mapping « = method . » get Annotation « ( » Web Mapping « . class ) ; » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » get Annotation Attributes « ( » web Mapping « ) ) . » with Message Containing « ( " attribute 'path' and its alias 'value' " ) . » with Message Containing « ( " values of [ { / test } ] and [ { / enigma } ] " ) ; }
@Test { Method method = » Simple Foo « . class . » get Method « ( " something " , Object . class ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( » get Value « ( order , VALUE ) ) . » is Equal To « ( 1 ) ; » assert That « ( » get Value « ( order ) ) . » is Equal To « ( 1 ) ; }
@Test { Method method = » Simple Foo « . class . » get Method « ( " something " , Object . class ) ; Order order = » find Annotation « ( method , Order . class ) ; » assert That « ( » get Default Value « ( order , VALUE ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; » assert That « ( » get Default Value « ( order ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { » assert That « ( » get Default Value « ( Order . class , VALUE ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; » assert That « ( » get Default Value « ( Order . class ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { Repeatable repeatable = » find Annotation « ( » My Repeatable « . class , Repeatable . class ) ; » assert That « ( repeatable ) . » is Not Null « ( ) ; » assert That « ( repeatable . value ( ) ) . » is Equal To « ( » My Repeatable Container « . class ) ; }
@Test { Method method = » Interface With Repeated « . class . » get Method « ( " foo " ) ; Set < » My Repeatable « > annotations = » get Repeatable Annotations « ( method , » My Repeatable « . class , » My Repeatable Container « . class ) ; » assert That « ( annotations ) . » is Not Null « ( ) ; List < String > values = annotations . stream ( ) . map ( » My Repeatable « :: value ) . collect ( » to List « ( ) ) ; » assert That « ( values ) . » is Equal To « ( » as List « ( " A " , " B " , " C " , " » meta 1 « " ) ) ; }
@Test { » Context Config « » context Config « = » synthesize Annotation « ( » Context Config « . class ) ; » assert That « ( » context Config « ) . » is Not Null « ( ) ; » assert That « ( » context Config « . value ( ) ) . as ( " value : " ) . » is Equal To « ( " " ) ; » assert That « ( » context Config « . location ( ) ) . as ( " location : " ) . » is Equal To « ( " " ) ; }
@Test { Map < String , Object > map = Collections . » singleton Map « ( " location " , " test . xml " ) ; » Context Config « » context Config « = » synthesize Annotation « ( map , » Context Config « . class , null ) ; » assert That « ( » context Config « ) . » is Not Null « ( ) ; » assert That « ( » context Config « . value ( ) ) . as ( " value : " ) . » is Equal To « ( " test . xml " ) ; » assert That « ( » context Config « . location ( ) ) . as ( " location : " ) . » is Equal To « ( " test . xml " ) ; }
@Test { » assert Annotation Synthesis From Map With Implicit Aliases « ( " value " ) ; » assert Annotation Synthesis From Map With Implicit Aliases « ( " » location 1 « " ) ; » assert Annotation Synthesis From Map With Implicit Aliases « ( " » location 2 « " ) ; » assert Annotation Synthesis From Map With Implicit Aliases « ( " » location 3 « " ) ; » assert Annotation Synthesis From Map With Implicit Aliases « ( " » xml File « " ) ; » assert Annotation Synthesis From Map With Implicit Aliases « ( " » groovy Script « " ) ; }
@Test { » assert Missing Text Attribute « ( Collections . » empty Map « ( ) ) ; }
@Test { Map < String , Object > map = Collections . » singleton Map « ( " text " , null ) ; » assert That « ( map . » contains Key « ( " text " ) ) . » is True « ( ) ; » assert Missing Text Attribute « ( map ) ; }
@Test { Map < String , Object > map = Collections . » singleton Map « ( VALUE , 42L ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » synthesize Annotation « ( map , Component . class , null ) . value ( ) ) . » with Message Containing « ( " Attribute 'value' in annotation org . springframework . core . testfixture . stereotype . Component " + " should be compatible with java . lang . String but a java . lang . Long value was returned " ) ; }
@Test { » assert That « ( » Annotation Utils « . » find Annotation « ( » Test Repeatables Class « . class , » Test Repeatable « . class ) ) . » is Null « ( ) ; » assert That « ( » Annotation Utils « . » find Annotation « ( » Test Repeatables Class « . class , » Test Repeatable Container « . class ) ) . » is Not Null « ( ) ; }
@Test { » My Repeatable Container « annotation = » Annotation Utils « . » find Annotation « ( » My Repeatable Meta 1 And 2 « . class , » My Repeatable Container « . class ) ; » assert That « ( annotation ) . » is Not Null « ( ) ; » assert That « ( annotation . value ( ) ) . extracting ( » My Repeatable « :: value ) . » contains Exactly « ( " » meta 1 « " , " » meta 2 « " ) ; }
@Test { Method method = » get Class « ( ) . » get Declared Method « ( " » method With Composed Annotation Meta Annotated With Repeatable Annotations « " ) ; » My Repeatable Container « annotation = » Annotation Utils « . » find Annotation « ( method , » My Repeatable Container « . class ) ; » assert That « ( annotation ) . » is Not Null « ( ) ; » assert That « ( annotation . value ( ) ) . extracting ( » My Repeatable « :: value ) . » contains Exactly « ( " » meta 1 « " , " » meta 2 « " ) ; }
@Test { » assert That « ( » get Annotation « ( » Deprecated Class « . class , Deprecated . class ) ) . » is Not Null « ( ) ; » assert That « ( » get Annotation « ( » Subclass Of Deprecated Class « . class , Deprecated . class ) ) . » is Null « ( ) ; » assert That « ( » find Annotation « ( » Deprecated Class « . class , Deprecated . class ) ) . » is Not Null « ( ) ; » assert That « ( » find Annotation « ( » Subclass Of Deprecated Class « . class , Deprecated . class ) ) . » is Not Null « ( ) ; }
@Test { Flux < » Data Buffer « > input = Flux . concat ( » data Buffer « ( this . » foo Bytes « ) , » data Buffer « ( this . » bar Bytes « ) ) ; » test Decode All « ( input , byte [ ] . class , step -> step . » consume Next With « ( » expect Bytes « ( this . » foo Bytes « ) ) . » consume Next With « ( » expect Bytes « ( this . » bar Bytes « ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < byte [ ] > input = Flux . just ( this . » foo Bytes « , this . » bar Bytes « ) ; » test Encode All « ( input , byte [ ] . class , step -> step . » consume Next With « ( » expect Bytes « ( this . » foo Bytes « ) ) . » consume Next With « ( » expect Bytes « ( this . » bar Bytes « ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Byte Buffer « > input = Flux . just ( this . » foo Bytes « , this . » bar Bytes « ) . map ( » Byte Buffer « :: wrap ) ; » test Encode All « ( input , » Byte Buffer « . class , step -> step . » consume Next With « ( » expect Bytes « ( this . » foo Bytes « ) ) . » consume Next With « ( » expect Bytes « ( this . » bar Bytes « ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( this . » buffer Factory « . wrap ( this . » foo Bytes « ) , this . » buffer Factory « . wrap ( this . » bar Bytes « ) ) ; » test Decode All « ( input , » Data Buffer « . class , step -> step . » consume Next With « ( » expect Data Buffer « ( this . » foo Bytes « ) ) . » consume Next With « ( » expect Data Buffer « ( this . » bar Bytes « ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < Resource > input = Flux . just ( new » Byte Array Resource « ( this . bytes ) ) ; » test Encode All « ( input , Resource . class , step -> step . » consume Next With « ( » expect Bytes « ( this . bytes ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . concat ( » data Buffer « ( this . » foo Bytes « ) , » data Buffer « ( this . » bar Bytes « ) ) ; » test Decode All « ( input , » Byte Buffer « . class , step -> step . » consume Next With « ( » expect Byte Buffer « ( » Byte Buffer « . wrap ( this . » foo Bytes « ) ) ) . » consume Next With « ( » expect Byte Buffer « ( » Byte Buffer « . wrap ( this . » bar Bytes « ) ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . concat ( » data Buffer « ( this . » foo Bytes « ) , » data Buffer « ( this . » bar Bytes « ) ) ; » Byte Buffer « expected = » Byte Buffer « . allocate ( this . » foo Bytes « . length + this . » bar Bytes « . length ) ; expected . put ( this . » foo Bytes « ) . put ( this . » bar Bytes « ) . flip ( ) ; » test Decode To Mono All « ( input , » Byte Buffer « . class , step -> step . » consume Next With « ( » expect Byte Buffer « ( expected ) ) . » verify Complete « ( ) ) ; }
@Test { String u = " ü " ; String e = " é " ; String o = " ø " ; String s = String . format ( " % s \n % s \n % s " , u , e , o ) ; Flux < » Data Buffer « > input = » to Data Buffers « ( s , 1 , » UTF _ 8 « ) ; » test Decode All « ( input , TYPE , step -> step . » expect Next « ( u , e , o ) . » verify Complete « ( ) , null , null ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( » string Buffer « ( " abc \n " ) , » string Buffer « ( " defg \n " ) , » string Buffer « ( " hijkl \n " ) ) ; this . decoder . » set Max In Memory Size « ( 5 ) ; » test Decode « ( input , String . class , step -> step . » expect Next « ( " abc " , " defg " ) . » verify Error « ( » Data Buffer Limit Exception « . class ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( » string Buffer « ( " TOO MUCH DATA \n another line \n \n and another \n " ) ) ; this . decoder . » set Max In Memory Size « ( 5 ) ; » test Decode « ( input , String . class , step -> step . » verify Error « ( » Data Buffer Limit Exception « . class ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( » string Buffer « ( " Line 1 \n Line 2 \n Line 3 \n " ) ) ; this . decoder . » set Max In Memory Size « ( - 1 ) ; » test Decode Cancel « ( input , » Resolvable Type « . » for Class « ( String . class ) , null , Collections . » empty Map « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . empty ( ) ; » test Decode « ( input , String . class , step -> step . » expect Complete « ( ) . verify ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( » string Buffer « ( " " ) ) ; Flux < String > output = this . decoder . decode ( input , TYPE , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( output ) . » expect Next « ( " " ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( » string Buffer « ( " foo " ) , » string Buffer « ( " bar " ) , » string Buffer « ( " baz " ) ) ; » test Decode To Mono All « ( input , String . class , step -> step . » expect Next « ( " foobarbaz " ) . » expect Complete « ( ) . verify ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . empty ( ) ; » test Decode To Mono « ( input , String . class , step -> step . » expect Complete « ( ) . verify ( ) ) ; }
@Test { Flux < » Char Sequence « > input = Flux . just ( this . foo , this . bar ) ; » test Encode All « ( input , » Char Sequence « . class , step -> step . » consume Next With « ( » expect String « ( this . foo ) ) . » consume Next With « ( » expect String « ( this . bar ) ) . » verify Complete « ( ) ) ; }
@Test { String sequence = " Hello World ! " ; Stream . of ( » UTF _ 8 « , » UTF _ 16 « , » ISO _ 8859 _ 1 « , » US _ ASCII « , Charset . » for Name « ( " » BIG 5 « " ) ) . » for Each « ( charset -> { int capacity = this . encoder . » calculate Capacity « ( sequence , charset ) ; int length = sequence . length ( ) ; » assert That « ( capacity >= length ) . as ( String . format ( " % s has capacity % d ; length % d " , charset , capacity , length ) ) . » is True « ( ) ; } ) ; }
@Test { » Type Descriptor « t = new » Type Descriptor « ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test Annotated Method « " , String . class ) , 0 ) ) ; t . » get Annotations « ( ) [ 0 ] = null ; » assert That « ( t . » get Annotations « ( ) [ 0 ] ) . » is Not Null « ( ) ; }
@Test { » Generic Type « < Integer > » generic Bean « = new » Integer Type « ( ) ; Property property = new Property ( » get Class « ( ) , » generic Bean « . » get Class « ( ) . » get Method « ( " » get Property « " ) , » generic Bean « . » get Class « ( ) . » get Method « ( " » set Property « " , Integer . class ) ) ; » Type Descriptor « desc = new » Type Descriptor « ( property ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Generic Type « < Number > » generic Bean « = new » Number Type « ( ) ; Property property = new Property ( » get Class « ( ) , » generic Bean « . » get Class « ( ) . » get Method « ( " » get Property « " ) , » generic Bean « . » get Class « ( ) . » get Method « ( " » set Property « " , Number . class ) ) ; » Type Descriptor « desc = new » Type Descriptor « ( property ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » assert Annotation Found On Method « ( » Method Annotation 1 « . class , " » method With Local Annotation « " ) ; }
@Test { » assert Annotation Found On Method « ( » Method Annotation 1 « . class , " » method With Composed Annotation « " ) ; }
@Test { » assert Annotation Found On Method « ( » Method Annotation 1 « . class , " » method With Composed Composed Annotation « " ) ; }
@Test { » Type Descriptor « » type Descriptor « = new » Type Descriptor « ( » Type Descriptor Tests « . class . » get Declared Field « ( " » int Array « " ) ) ; » assert That « ( » type Descriptor « . » is Array « ( ) ) . » is True « ( ) ; » assert That « ( » type Descriptor « . » get Element Type Descriptor « ( ) . » get Type « ( ) ) . » is Equal To « ( Integer . TYPE ) ; » assert That « ( » type Descriptor « . » to String « ( ) ) . » is Equal To « ( " int [ ] " ) ; }
@Test { » Type Descriptor « desc = new » Type Descriptor « ( » Type Descriptor Tests « . class . » get Field « ( " » field Map « " ) ) ; » assert That « ( desc . » is Map « ( ) ) . » is True « ( ) ; » assert That « ( desc . » get Map Key Type Descriptor « ( ) . » get Element Type Descriptor « ( ) . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; » assert That « ( desc . » get Map Value Type Descriptor « ( ) . » get Element Type Descriptor « ( ) . » get Type « ( ) ) . » is Equal To « ( Long . class ) ; }
@Test { » Type Descriptor « » type Descriptor « = new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » field Annotated « " ) ) ; » assert That « ( » type Descriptor « . » get Annotations « ( ) . length ) . » is Equal To « ( 1 ) ; » assert That « ( » type Descriptor « . » get Annotation « ( » Field Annotation « . class ) ) . » is Not Null « ( ) ; }
@Test { » Type Descriptor « » type Descriptor « = » Type Descriptor « . » value Of « ( int [ ] . class ) ; » assert That « ( » type Descriptor « . » is Array « ( ) ) . » is True « ( ) ; » assert That « ( » type Descriptor « . » is Collection « ( ) ) . » is False « ( ) ; » assert That « ( » type Descriptor « . » is Map « ( ) ) . » is False « ( ) ; » assert That « ( » type Descriptor « . » get Element Type Descriptor « ( ) . » get Type « ( ) ) . » is Equal To « ( Integer . TYPE ) ; }
@Test { » Type Descriptor « » type Descriptor « = » Type Descriptor « . » value Of « ( Collection . class ) ; » assert That « ( » type Descriptor « . » is Collection « ( ) ) . » is True « ( ) ; » assert That « ( » type Descriptor « . » is Array « ( ) ) . » is False « ( ) ; » assert That « ( » type Descriptor « . » is Map « ( ) ) . » is False « ( ) ; » assert That « ( ( Object ) » type Descriptor « . » get Element Type Descriptor « ( ) ) . » is Null « ( ) ; }
@Test { » Type Descriptor « desc = » Type Descriptor « . » for Object « ( " 3 " ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Type Descriptor « desc = » Type Descriptor « . » for Object « ( null ) ; » assert That « ( ( Object ) desc ) . » is Null « ( ) ; }
@Test { » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 2 « " , List . class ) , 0 ) , 2 ) ; » assert That « ( » t 1 « . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 3 « " , Map . class ) , 0 ) , 1 ) ; » assert That « ( » t 1 « . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 4 « " , List . class ) , 0 ) , 2 ) ; » assert That « ( » t 1 « . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 4 « " , List . class ) , 0 , 2 ) , 2 ) ) ; }
@Test { » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 4 « " , List . class ) , 0 ) , 3 ) ; » assert That « ( ( Object ) » t 1 « ) . » is Null « ( ) ; }
@Test { » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 5 « " , String . class ) , 0 ) , 2 ) ; » assert That « ( ( Object ) » t 1 « ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Type Descriptor « . nested ( new » Method Parameter « ( » get Class « ( ) . » get Method « ( " » test 5 « " , String . class ) , 0 , 2 ) , 2 ) ) ; }
@Test { » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( » get Class « ( ) . » get Field « ( " » test 4 « " ) , 2 ) ; » assert That « ( » t 1 « . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { Property property = new Property ( » get Class « ( ) , » get Class « ( ) . » get Method « ( " » get Test 4 « " ) , » get Class « ( ) . » get Method « ( " » set Test 4 « " , List . class ) ) ; » Type Descriptor « » t 1 « = » Type Descriptor « . nested ( property , 2 ) ; » assert That « ( » t 1 « . » get Type « ( ) ) . » is Equal To « ( String . class ) ; }
@Test { » Type Descriptor « desc = » Type Descriptor « . » value Of « ( Number . class ) ; Integer value = Integer . » value Of « ( 3 ) ; desc = desc . narrow ( value ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Type Descriptor « desc = » Type Descriptor « . » value Of « ( List . class ) ; Integer value = Integer . » value Of « ( 3 ) ; desc = desc . » element Type Descriptor « ( value ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Type Descriptor « desc = » Type Descriptor « . » value Of « ( Map . class ) ; Integer value = Integer . » value Of « ( 3 ) ; desc = desc . » get Map Key Type Descriptor « ( value ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Type Descriptor « desc = » Type Descriptor « . » value Of « ( Map . class ) ; Integer value = Integer . » value Of « ( 3 ) ; desc = desc . » get Map Value Type Descriptor « ( value ) ; » assert That « ( desc . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { Property property = new Property ( » get Class « ( ) , » get Class « ( ) . » get Method « ( " » get Property « " ) , » get Class « ( ) . » get Method « ( " » set Property « " , Map . class ) ) ; » Type Descriptor « » type Descriptor « = new » Type Descriptor « ( property ) ; » Type Descriptor « » up Cast « = » type Descriptor « . upcast ( Object . class ) ; » assert That « ( » up Cast « . » get Annotation « ( » Method Annotation 1 « . class ) != null ) . » is True « ( ) ; }
@Test { Property property = new Property ( » get Class « ( ) , » get Class « ( ) . » get Method « ( " » get Property « " ) , » get Class « ( ) . » get Method « ( " » set Property « " , Map . class ) ) ; » Type Descriptor « » type Descriptor « = new » Type Descriptor « ( property ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » type Descriptor « . upcast ( Collection . class ) ) . » with Message « ( " interface java . util . Map is not assignable to interface java . util . Collection " ) ; }
@Test { @ » Suppress Warnings « ( " serial " ) class » Custom Set « extends » Hash Set « < String > { } » assert That « ( » Type Descriptor « . » value Of « ( String . class ) ) . » is Equal To « ( » Type Descriptor « . » value Of « ( » Custom Set « . class ) . » get Element Type Descriptor « ( ) ) ; » assert That « ( » Type Descriptor « . » value Of « ( String . class ) ) . » is Equal To « ( » Type Descriptor « . » for Object « ( new » Custom Set « ( ) ) . » get Element Type Descriptor « ( ) ) ; }
@Test { » Type Descriptor « » map Type « = » Type Descriptor « . map ( » Linked Hash Map « . class , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( Integer . class ) ) ; » Type Descriptor « » array Type « = » Type Descriptor « . array ( » map Type « ) ; » assert That « ( » Linked Hash Map « [ ] . class ) . » is Equal To « ( » array Type « . » get Type « ( ) ) ; » assert That « ( » map Type « ) . » is Equal To « ( » array Type « . » get Element Type Descriptor « ( ) ) ; }
@Test { » Type Descriptor « » array Type « = » Type Descriptor « . array ( » Type Descriptor « . » value Of « ( String . class ) ) ; » assert That « ( » Type Descriptor « . » value Of « ( String [ ] . class ) ) . » is Equal To « ( » array Type « ) ; }
@Test { » assert That « ( ( Object ) » Type Descriptor « . array ( null ) ) . » is Null « ( ) ; }
@Test { » Type Descriptor « » type Descriptor « = » Type Descriptor « . collection ( List . class , null ) ; » assert That « ( » type Descriptor « . » get Element Type Descriptor « ( ) ) . » is Null « ( ) ; }
@Test { » Type Descriptor « » type Descriptor « = » Type Descriptor « . map ( » Linked Hash Map « . class , null , null ) ; » assert That « ( » type Descriptor « . » get Map Key Type Descriptor « ( ) ) . » is Null « ( ) ; » assert That « ( » type Descriptor « . » get Map Value Type Descriptor « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Converting Comparator « < > ( null , this . converter ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Converting Comparator « < String , Integer > ( this . comparator , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Converting Comparator « < String , Integer > ( this . comparator , null , Integer . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Converting Comparator « < String , Integer > ( this . comparator , this . » conversion Service « , null ) ) ; }
@Test { » Converting Comparator « < String , Integer > » converting Comparator « = new » Converting Comparator « < > ( this . comparator , this . converter ) ; » test Conversion « ( » converting Comparator « ) ; }
@Test { » Converting Comparator « < String , Integer > » converting Comparator « = new » Converting Comparator « < > ( comparator , » conversion Service « , Integer . class ) ; » test Conversion « ( » converting Comparator « ) ; }
@Test { » test Conversion « ( new » Converting Comparator « < > ( comparator , converter ) ) ; }
@Test { » Array List « < Entry < String , Integer > > list = » create Reverse Order Map Entry List « ( ) ; Comparator < Map . Entry < String , Integer > > comparator = » Converting Comparator « . » map Entry Keys « ( new » Comparable Comparator « < String > ( ) ) ; Collections . sort ( list , comparator ) ; » assert That « ( list . get ( 0 ) . » get Key « ( ) ) . » is Equal To « ( " a " ) ; }
@Test { » Array List « < Entry < String , Integer > > list = » create Reverse Order Map Entry List « ( ) ; Comparator < Map . Entry < String , Integer > > comparator = » Converting Comparator « . » map Entry Values « ( new » Comparable Comparator « < Integer > ( ) ) ; Collections . sort ( list , comparator ) ; » assert That « ( list . get ( 0 ) . » get Value « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1 " , Character . class ) ) . » is Equal To « ( Character . » value Of « ( ' 1 ' ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " " , Character . class ) ) . » is Equal To « ( null ) ; }
@Test { » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " invalid " , Character . class ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( ' 3 ' , String . class ) ) . » is Equal To « ( " 3 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " " , Boolean . class ) ) . » is Equal To « ( null ) ; }
@Test { » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " invalid " , Boolean . class ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( true , String . class ) ) . » is Equal To « ( " true " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1 " , Byte . class ) ) . » is Equal To « ( ( byte ) 1 ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " A " . » get Bytes « ( ) [ 0 ] , String . class ) ) . » is Equal To « ( " 65 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1 " , Short . class ) ) . » is Equal To « ( ( short ) 1 ) ; }
@Test { short three = 3 ; » assert That « ( » conversion Service « . convert ( three , String . class ) ) . » is Equal To « ( " 3 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1 " , Integer . class ) ) . » is Equal To « ( ( int ) Integer . » value Of « ( 1 ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( 3 , String . class ) ) . » is Equal To « ( " 3 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1 " , Long . class ) ) . » is Equal To « ( Long . » value Of « ( 1 ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( 3L , String . class ) ) . » is Equal To « ( " 3 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1.0 " , Float . class ) ) . » is Equal To « ( Float . » value Of « ( " 1.0 " ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( Float . » value Of « ( " 1.0 " ) , String . class ) ) . » is Equal To « ( " 1.0 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1.0 " , Double . class ) ) . » is Equal To « ( Double . » value Of « ( " 1.0 " ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( Double . » value Of « ( " 1.0 " ) , String . class ) ) . » is Equal To « ( " 1.0 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1 " , » Big Integer « . class ) ) . » is Equal To « ( new » Big Integer « ( " 1 " ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( new » Big Integer « ( " 100 " ) , String . class ) ) . » is Equal To « ( " 100 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1.0 " , » Big Decimal « . class ) ) . » is Equal To « ( new » Big Decimal « ( " 1.0 " ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( new » Big Decimal « ( " 100.00 " ) , String . class ) ) . » is Equal To « ( " 100.00 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " 1.0 " , Number . class ) ) . » is Equal To « ( new » Big Decimal « ( " 1.0 " ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " " , Number . class ) ) . » is Equal To « ( null ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " BAR " , Foo . class ) ) . » is Equal To « ( Foo . BAR ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " BAZ " , » Sub Foo « . BAR . » get Class « ( ) ) ) . » is Equal To « ( » Sub Foo « . BAZ ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " " , Foo . class ) ) . » is Equal To « ( null ) ; }
@Test { » assert That « ( » conversion Service « . convert ( Foo . BAR , String . class ) ) . » is Equal To « ( " BAR " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( 0 , Foo . class ) ) . » is Equal To « ( Foo . BAR ) ; }
@Test { » assert That « ( » conversion Service « . convert ( 1 , » Sub Foo « . BAR . » get Class « ( ) ) ) . » is Equal To « ( » Sub Foo « . BAZ ) ; }
@Test { » assert That « ( » conversion Service « . convert ( null , Foo . class ) ) . » is Equal To « ( null ) ; }
@Test { » assert That « ( » conversion Service « . convert ( Foo . BAR , Integer . class ) ) . » is Equal To « ( ( int ) Integer . » value Of « ( 0 ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " BAR " , » Type Descriptor « . » value Of « ( String . class ) , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » enum Set « " ) ) ) ) . » is Equal To « ( » Enum Set « . of ( Foo . BAR ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " en " , Locale . class ) ) . » is Equal To « ( Locale . ENGLISH ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " » en _ US « " , Locale . class ) ) . » is Equal To « ( Locale . US ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " en - US " , Locale . class ) ) . » is Equal To « ( Locale . US ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " UTF - 8 " , Charset . class ) ) . » is Equal To « ( » Standard Charsets « . » UTF _ 8 « ) ; }
@Test { » assert That « ( » conversion Service « . convert ( » Standard Charsets « . » UTF _ 8 « , String . class ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " EUR " , Currency . class ) ) . » is Equal To « ( Currency . » get Instance « ( " EUR " ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( Currency . » get Instance « ( " USD " ) , String . class ) ) . » is Equal To « ( " USD " ) ; }
@Test { String str = " test " ; » assert That « ( » conversion Service « . convert ( str , String . class ) ) . » is Same As « ( str ) ; }
@Test { UUID uuid = UUID . » random UUID « ( ) ; String » convert To String « = » conversion Service « . convert ( uuid , String . class ) ; UUID » convert To UUID « = » conversion Service « . convert ( » convert To String « , UUID . class ) ; » assert That « ( » convert To UUID « ) . » is Equal To « ( uuid ) ; }
@Test { » assert That « ( » conversion Service « . convert ( 1 , Long . class ) ) . » is Equal To « ( Long . » value Of « ( 1 ) ) ; }
@Test { » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( 1 , » Custom Number « . class ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( 65 , Character . class ) ) . » is Equal To « ( Character . » value Of « ( ' A ' ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( ' A ' , Integer . class ) ) . » is Equal To « ( 65 ) ; }
@Test { List < ? > result = » conversion Service « . convert ( new String [ ] { " 1 " , " 2 " , " 3 " } , List . class ) ; » assert That « ( result . get ( 0 ) ) . » is Equal To « ( " 1 " ) ; » assert That « ( result . get ( 1 ) ) . » is Equal To « ( " 2 " ) ; » assert That « ( result . get ( 2 ) ) . » is Equal To « ( " 3 " ) ; }
@Test { String [ ] source = { " 1 " , " 3 " , " 4 " } ; @ » Suppress Warnings « ( " unchecked " ) Stream < Integer > result = ( Stream < Integer > ) this . » conversion Service « . convert ( source , » Type Descriptor « . » value Of « ( String [ ] . class ) , new » Type Descriptor « ( » get Class « ( ) . » get Declared Field « ( " » generic Stream « " ) ) ) ; » assert That « ( result . » map To Int « ( x -> x ) . sum ( ) ) . » is Equal To « ( 8 ) ; }
@Test { » Linked List « < ? > result = » conversion Service « . convert ( new String [ ] { " 1 " , " 2 " , " 3 " } , » Linked List « . class ) ; » assert That « ( result . get ( 0 ) ) . » is Equal To « ( " 1 " ) ; » assert That « ( result . get ( 1 ) ) . » is Equal To « ( " 2 " ) ; » assert That « ( result . get ( 2 ) ) . » is Equal To « ( " 3 " ) ; }
@Test { » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( new String [ ] { " 1 " , " 2 " , " 3 " } , » Abstract List « . class ) ) ; }
@Test { String result = » conversion Service « . convert ( new String [ ] { " 1 " , " 2 " , " 3 " } , String . class ) ; » assert That « ( result ) . » is Equal To « ( " 1 , 2 , 3 " ) ; }
@Test { String result = » conversion Service « . convert ( new Integer [ ] { 1 , 2 , 3 } , String . class ) ; » assert That « ( result ) . » is Equal To « ( " 1 , 2 , 3 " ) ; }
@Test { String result = » conversion Service « . convert ( new String [ 0 ] , String . class ) ; » assert That « ( result ) . » is Equal To « ( " " ) ; }
@Test { String [ ] result = » conversion Service « . convert ( " 1 , 2 , 3 " , String [ ] . class ) ; » assert That « ( result . length ) . » is Equal To « ( 3 ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( " 1 " ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( " 2 " ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( " 3 " ) ; }
@Test { int [ ] result = » conversion Service « . convert ( " 1 , 2 , 3 " , int [ ] . class ) ; » assert That « ( result . length ) . » is Equal To « ( 3 ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( 1 ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( 2 ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( 3 ) ; }
@Test { String [ ] result = » conversion Service « . convert ( " " , String [ ] . class ) ; » assert That « ( result . length ) . » is Equal To « ( 0 ) ; }
@Test { Object [ ] array = new Object [ ] { 3L } ; Object result = » conversion Service « . convert ( array , Long . class ) ; » assert That « ( result ) . » is Equal To « ( 3L ) ; }
@Test { String [ ] array = new String [ ] { " 3 " } ; Integer result = » conversion Service « . convert ( array , Integer . class ) ; » assert That « ( ( int ) result ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { Long [ ] array = new Long [ ] { 3L } ; Long [ ] result = ( Long [ ] ) » conversion Service « . convert ( array , Object . class ) ; » assert That « ( result ) . » is Equal To « ( array ) ; }
@Test { Object [ ] result = » conversion Service « . convert ( 3L , Object [ ] . class ) ; » assert That « ( result . length ) . » is Equal To « ( 1 ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( 3L ) ; }
@Test { Integer [ ] result = » conversion Service « . convert ( 3L , Integer [ ] . class ) ; » assert That « ( result . length ) . » is Equal To « ( 1 ) ; » assert That « ( ( int ) result [ 0 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { List < String > list = new » Array List « < > ( ) ; list . add ( " 1 " ) ; list . add ( " 2 " ) ; list . add ( " 3 " ) ; String [ ] result = » conversion Service « . convert ( list , String [ ] . class ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( " 1 " ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( " 2 " ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( " 3 " ) ; }
@Test { List < String > list = Arrays . » as List « ( " foo " , " bar " ) ; String result = » conversion Service « . convert ( list , String . class ) ; » assert That « ( result ) . » is Equal To « ( " foo , bar " ) ; }
@Test { List < Integer > list = Arrays . » as List « ( 3 , 5 ) ; String result = ( String ) » conversion Service « . convert ( list , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » generic List « " ) ) , » Type Descriptor « . » value Of « ( String . class ) ) ; » assert That « ( result ) . » is Equal To « ( " 3 , 5 " ) ; }
@Test { List < ? > result = » conversion Service « . convert ( " 1 , 2 , 3 " , List . class ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 3 ) ; » assert That « ( result . get ( 0 ) ) . » is Equal To « ( " 1 " ) ; » assert That « ( result . get ( 1 ) ) . » is Equal To « ( " 2 " ) ; » assert That « ( result . get ( 2 ) ) . » is Equal To « ( " 3 " ) ; }
@Test { Collection < ? > result = » conversion Service « . convert ( " " , Collection . class ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { List < Long > list = Collections . » singleton List « ( 3L ) ; Long result = » conversion Service « . convert ( list , Long . class ) ; » assert That « ( result ) . » is Equal To « ( Long . » value Of « ( 3 ) ) ; }
@Test { List < String > list = Collections . » singleton List « ( " 3 " ) ; Integer result = » conversion Service « . convert ( list , Integer . class ) ; » assert That « ( ( int ) result ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { Collection < String > source = new » Array List « < > ( ) ; source . add ( " foo " ) ; Object result = » conversion Service « . convert ( source , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » assignable Target « " ) ) ) ; » assert That « ( result ) . » is Equal To « ( source ) ; }
@Test { List < String > source = new » Array List « < > ( ) ; source . add ( " A " ) ; source . add ( " B " ) ; » conversion Service « . » add Converter « ( List . class , » List Wrapper « . class , » List Wrapper « :: new ) ; » List Wrapper « result = » conversion Service « . convert ( source , » List Wrapper « . class ) ; » assert That « ( result . » get List « ( ) ) . » is Same As « ( source ) ; }
@Test { List < ? > result = » conversion Service « . convert ( 3L , List . class ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( result . get ( 0 ) ) . » is Equal To « ( 3L ) ; }
@Test { @ » Suppress Warnings « ( " unchecked " ) List < Integer > result = ( List < Integer > ) » conversion Service « . convert ( 3L , » Type Descriptor « . » value Of « ( Long . class ) , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » generic List « " ) ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( ( int ) result . get ( 0 ) ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { Integer [ ] result = » conversion Service « . convert ( new String [ ] { " 1 " , " 2 " , " 3 " } , Integer [ ] . class ) ; » assert That « ( ( int ) result [ 0 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 1 ) ) ; » assert That « ( ( int ) result [ 1 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 2 ) ) ; » assert That « ( ( int ) result [ 2 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { int [ ] result = » conversion Service « . convert ( new String [ ] { " 1 " , " 2 " , " 3 " } , int [ ] . class ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( 1 ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( 2 ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( 3 ) ; }
@Test { Integer [ ] result = » conversion Service « . convert ( new Integer [ ] { 1 , 2 , 3 } , Integer [ ] . class ) ; » assert That « ( ( int ) result [ 0 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 1 ) ) ; » assert That « ( ( int ) result [ 1 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 2 ) ) ; » assert That « ( ( int ) result [ 2 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { int [ ] result = » conversion Service « . convert ( new Integer [ ] { 1 , 2 , 3 } , int [ ] . class ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( 1 ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( 2 ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( 3 ) ; }
@Test { Integer [ ] result = » conversion Service « . convert ( new Object [ ] { 1 , 2 , 3 } , Integer [ ] . class ) ; » assert That « ( ( int ) result [ 0 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 1 ) ) ; » assert That « ( ( int ) result [ 1 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 2 ) ) ; » assert That « ( ( int ) result [ 2 ] ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { int [ ] result = » conversion Service « . convert ( new Object [ ] { 1 , 2 , 3 } , int [ ] . class ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( 1 ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( 2 ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( 3 ) ; }
@Test { byte [ ] » byte Array « = new byte [ ] { 1 , 2 , 3 } ; Byte [ ] converted = » conversion Service « . convert ( » byte Array « , Byte [ ] . class ) ; » assert That « ( converted ) . » is Equal To « ( new Byte [ ] { 1 , 2 , 3 } ) ; }
@Test { int [ ] result = » conversion Service « . convert ( new int [ ] { 1 , 2 , 3 } , int [ ] . class ) ; » assert That « ( result [ 0 ] ) . » is Equal To « ( 1 ) ; » assert That « ( result [ 1 ] ) . » is Equal To « ( 2 ) ; » assert That « ( result [ 2 ] ) . » is Equal To « ( 3 ) ; }
@Test { List < String > list = Arrays . » as List « ( " Foo " , " Bar " ) ; » assert That « ( » conversion Service « . » can Convert « ( list . » get Class « ( ) , String . class ) ) . » is True « ( ) ; String result = » conversion Service « . convert ( list , String . class ) ; » assert That « ( result ) . » is Equal To « ( " Foo , Bar " ) ; }
@Test { @ » Suppress Warnings « ( " unchecked " ) List < Integer > bar = ( List < Integer > ) » conversion Service « . convert ( null , » Type Descriptor « . » value Of « ( » Linked Hash Set « . class ) , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » generic List « " ) ) ) ; » assert That « ( ( Object ) bar ) . » is Null « ( ) ; }
@Test { Map < String , Integer > » hash Map « = new » Linked Hash Map « < > ( ) ; » hash Map « . put ( " 1 " , 1 ) ; » hash Map « . put ( " 2 " , 2 ) ; List < ? > converted = » conversion Service « . convert ( » hash Map « . values ( ) , List . class ) ; » assert That « ( converted ) . » is Equal To « ( Arrays . » as List « ( 1 , 2 ) ) ; }
@Test { Properties foo = new Properties ( ) ; foo . » set Property « ( " 1 " , " BAR " ) ; foo . » set Property « ( " 2 " , " BAZ " ) ; String result = » conversion Service « . convert ( foo , String . class ) ; » assert That « ( result . contains ( " 1 = BAR " ) ) . » is True « ( ) ; » assert That « ( result . contains ( " 2 = BAZ " ) ) . » is True « ( ) ; }
@Test { Properties result = » conversion Service « . convert ( " a = b \n c = 2 \n d = " , Properties . class ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 3 ) ; » assert That « ( result . » get Property « ( " a " ) ) . » is Equal To « ( " b " ) ; » assert That « ( result . » get Property « ( " c " ) ) . » is Equal To « ( " 2 " ) ; » assert That « ( result . » get Property « ( " d " ) ) . » is Equal To « ( " " ) ; }
@Test { Properties result = » conversion Service « . convert ( " foo = bar \n bar = baz \n baz = boop " , Properties . class ) ; » assert That « ( result . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( result . get ( " bar " ) ) . » is Equal To « ( " baz " ) ; » assert That « ( result . get ( " baz " ) ) . » is Equal To « ( " boop " ) ; }
@Test { ISBN . reset ( ) ; » assert That « ( » conversion Service « . convert ( new ISBN ( " 123456789 " ) , String . class ) ) . » is Equal To « ( " 123456789 " ) ; » assert That « ( ISBN . » constructor Count « ) . as ( " constructor invocations " ) . » is Equal To « ( 1 ) ; » assert That « ( ISBN . » value Of Count « ) . as ( " » value Of « ( ) invocations " ) . » is Equal To « ( 0 ) ; » assert That « ( ISBN . » to String Count « ) . as ( " » to String « ( ) invocations " ) . » is Equal To « ( 1 ) ; }
@Test { ISBN . reset ( ) ; » assert That « ( » conversion Service « . convert ( " 123456789 " , ISBN . class ) ) . » is Equal To « ( new ISBN ( " 123456789 " ) ) ; » assert That « ( ISBN . » value Of Count « ) . as ( " » value Of « ( ) invocations " ) . » is Equal To « ( 1 ) ; » assert That « ( ISBN . » constructor Count « ) . as ( " constructor invocations " ) . » is Equal To « ( 2 ) ; » assert That « ( ISBN . » to String Count « ) . as ( " » to String « ( ) invocations " ) . » is Equal To « ( 0 ) ; }
@Test { SSN . reset ( ) ; » assert That « ( » conversion Service « . convert ( new SSN ( " 123456789 " ) , String . class ) ) . » is Equal To « ( " 123456789 " ) ; » assert That « ( SSN . » constructor Count « ) . as ( " constructor invocations " ) . » is Equal To « ( 1 ) ; » assert That « ( SSN . » to String Count « ) . as ( " » to String « ( ) invocations " ) . » is Equal To « ( 1 ) ; }
@Test { SSN . reset ( ) ; » assert That « ( » conversion Service « . convert ( " 123456789 " , SSN . class ) ) . » is Equal To « ( new SSN ( " 123456789 " ) ) ; » assert That « ( SSN . » constructor Count « ) . as ( " constructor invocations " ) . » is Equal To « ( 2 ) ; » assert That « ( SSN . » to String Count « ) . as ( " » to String « ( ) invocations " ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " GMT + 2 " , » Time Zone « . class ) . » get ID « ( ) ) . » is Equal To « ( " GMT + 02 : 00 " ) ; }
@Test { » assert That « ( » conversion Service « . convert ( » Zone Id « . of ( " GMT + 1 " ) , String . class ) . » starts With « ( " GMT + " ) ) . » is True « ( ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( » Test Entity « . class , String . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » conversion Service « . convert ( " GMT + 1 " , » Zone Id « . class ) ) . » is Equal To « ( » Zone Id « . of ( " GMT + 1 " ) ) ; }
@Test { » assert That Exception Of Type « ( » Converter Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( Long . » value Of « ( 3 ) , SSN . class ) ) ; }
@Test { » Test Entity « e = » conversion Service « . convert ( 1L , » Test Entity « . class ) ; » assert That « ( e . » get Id « ( ) ) . » is Equal To « ( Long . » value Of « ( 1 ) ) ; }
@Test { » Test Entity « entity = ( » Test Entity « ) » conversion Service « . convert ( null , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( » Test Entity « . class ) ) ; » assert That « ( ( Object ) entity ) . » is Null « ( ) ; }
@Test { » Test Entity « entity = » conversion Service « . convert ( " 1 " , » Test Entity « . class ) ; » assert That « ( entity . » get Id « ( ) ) . » is Equal To « ( Long . » value Of « ( 1 ) ) ; }
@Test { String converted = » conversion Service « . convert ( new char [ ] { ' a ' , ' b ' , ' c ' } , String . class ) ; » assert That « ( converted ) . » is Equal To « ( " a , b , c " ) ; }
@Test { char [ ] converted = » conversion Service « . convert ( " a , b , c " , char [ ] . class ) ; » assert That « ( converted ) . » is Equal To « ( new char [ ] { ' a ' , ' b ' , ' c ' } ) ; }
@Test { » conversion Service « . » add Converter « ( String . class , char [ ] . class , String :: » to Char Array « ) ; char [ ] converted = » conversion Service « . convert ( " abc " , char [ ] . class ) ; » assert That « ( converted ) . » is Equal To « ( new char [ ] { ' a ' , ' b ' , ' c ' } ) ; }
@Test { » conversion Service « . » add Converter « ( Byte . class , Byte . class , source -> ( byte ) ( source + 1 ) ) ; byte [ ] » byte Array « = new byte [ ] { 1 , 2 , 3 } ; byte [ ] converted = » conversion Service « . convert ( » byte Array « , byte [ ] . class ) ; » assert That « ( converted ) . » is Not Same As « ( » byte Array « ) ; » assert That « ( converted ) . » is Equal To « ( new byte [ ] { 2 , 3 , 4 } ) ; }
@Test { » assert That « ( » conversion Service « . convert ( null , » Type Descriptor « . » value Of « ( Object . class ) , » Type Descriptor « . » value Of « ( Optional . class ) ) ) . » is Same As « ( Optional . empty ( ) ) ; » assert That « ( ( Object ) » conversion Service « . convert ( null , Optional . class ) ) . » is Same As « ( Optional . empty ( ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( Optional . empty ( ) , » Type Descriptor « . » value Of « ( Object . class ) , » Type Descriptor « . » value Of « ( Optional . class ) ) ) . » is Same As « ( Optional . empty ( ) ) ; » assert That « ( ( Object ) » conversion Service « . convert ( Optional . empty ( ) , Optional . class ) ) . » is Same As « ( Optional . empty ( ) ) ; }
@Test { » Stop Watch « watch = new » Stop Watch « ( " integer -> string » conversion Performance « " ) ; watch . start ( " convert 4 , 000 , 000 with conversion service " ) ; for ( int i = 0 ; i < 4000000 ; i ++ ) { » conversion Service « . convert ( 3 , String . class ) ; } watch . stop ( ) ; watch . start ( " convert 4 , 000 , 000 manually " ) ; for ( int i = 0 ; i < 4000000 ; i ++ ) { Integer . » value Of « ( 3 ) . » to String « ( ) ; } watch . stop ( ) ; }
@Test { byte [ ] bytes = new byte [ ] { 1 , 2 , 3 } ; » Byte Buffer « convert = this . » conversion Service « . convert ( bytes , » Byte Buffer « . class ) ; » assert That « ( convert . array ( ) ) . » is Not Same As « ( bytes ) ; » assert That « ( convert . array ( ) ) . » is Equal To « ( bytes ) ; }
@Test { byte [ ] bytes = new byte [ ] { 1 , 2 , 3 } ; » Byte Buffer « » byte Buffer « = » Byte Buffer « . wrap ( bytes ) ; byte [ ] convert = this . » conversion Service « . convert ( » byte Buffer « , byte [ ] . class ) ; » assert That « ( convert ) . » is Not Same As « ( bytes ) ; » assert That « ( convert ) . » is Equal To « ( bytes ) ; }
@Test { byte [ ] bytes = new byte [ ] { 1 , 2 , 3 } ; » Byte Buffer « » byte Buffer « = » Byte Buffer « . wrap ( bytes ) ; » Other Type « convert = this . » conversion Service « . convert ( » byte Buffer « , » Other Type « . class ) ; » assert That « ( convert . bytes ) . » is Not Same As « ( bytes ) ; » assert That « ( convert . bytes ) . » is Equal To « ( bytes ) ; }
@Test { byte [ ] bytes = new byte [ ] { 1 , 2 , 3 } ; » Other Type « » other Type « = new » Other Type « ( bytes ) ; » Byte Buffer « convert = this . » conversion Service « . convert ( » other Type « , » Byte Buffer « . class ) ; » assert That « ( convert . array ( ) ) . » is Not Same As « ( bytes ) ; » assert That « ( convert . array ( ) ) . » is Equal To « ( bytes ) ; }
@Test { Map < String , String > map = new » Hash Map « < > ( ) ; map . put ( " 1 " , " 9 " ) ; map . put ( " 2 " , " 37 " ) ; » assert That « ( » conversion Service « . » can Convert « ( Map . class , Map . class ) ) . » is True « ( ) ; » assert That « ( ( Map < ? , ? > ) » conversion Service « . convert ( map , Map . class ) ) . » is Same As « ( map ) ; }
@Test { Map < String , List < String > > map = new » Hash Map « < > ( ) ; map . put ( " 1 " , Arrays . » as List « ( " 9 " , " 12 " ) ) ; map . put ( " 2 " , Arrays . » as List « ( " 37 " , " 23 " ) ) ; » assert That « ( » conversion Service « . » can Convert « ( Map . class , Map . class ) ) . » is True « ( ) ; » assert That « ( ( Map < ? , ? > ) » conversion Service « . convert ( map , Map . class ) ) . » is Same As « ( map ) ; }
@Test { Map < String , String > map = new » Hash Map « < > ( ) ; » Type Descriptor « » source Type « = » Type Descriptor « . » for Object « ( map ) ; » Type Descriptor « » target Type « = new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » empty Map Target « " ) ) ; » assert That « ( » conversion Service « . » can Convert « ( » source Type « , » target Type « ) ) . » is True « ( ) ; » assert That « ( » conversion Service « . convert ( map , » source Type « , » target Type « ) ) . » is Same As « ( map ) ; }
@Test { Map < String , String > map = new » Hash Map « < > ( ) ; » assert That « ( » conversion Service « . » can Convert « ( Map . class , Map . class ) ) . » is True « ( ) ; » assert That « ( ( Map < ? , ? > ) » conversion Service « . convert ( map , Map . class ) ) . » is Same As « ( map ) ; }
@Test { Vector < String > vector = new Vector < > ( ) ; vector . add ( " Element " ) ; » test Collection Conversion To Array List « ( vector ) ; }
@Test { » Collection To Collection Converter « converter = new » Collection To Collection Converter « ( new » Generic Conversion Service « ( ) ) ; » Type Descriptor « type = new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " list " ) ) ; converter . convert ( list , type , » Type Descriptor « . » value Of « ( Class . » for Name « ( " java . util . » Collections $ Empty List « " ) ) ) ; }
@Test { List < ? > input = new » Array List « < > ( Arrays . » as List « ( " foo " , " bar " ) ) ; » assert That « ( » conversion Service « . convert ( input , » Type Descriptor « . » for Object « ( input ) , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » wildcard Collection « " ) ) ) ) . » is Same As « ( input ) ; }
@Test { List < Resource > resources = new » Array List « < > ( ) ; resources . add ( new » Class Path Resource « ( " test " ) ) ; resources . add ( new » File System Resource « ( " test " ) ) ; resources . add ( new » Test Resource « ( ) ) ; » Type Descriptor « » source Type « = » Type Descriptor « . » for Object « ( resources ) ; » assert That « ( » conversion Service « . convert ( resources , » source Type « , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " resources " ) ) ) ) . » is Same As « ( resources ) ; }
@Test { List < Resource > resources = new » Array List « < > ( ) ; resources . add ( new » Class Path Resource « ( " test " ) ) ; resources . add ( null ) ; resources . add ( new » File System Resource « ( " test " ) ) ; resources . add ( new » Test Resource « ( ) ) ; » Type Descriptor « » source Type « = » Type Descriptor « . » for Object « ( resources ) ; » assert That « ( » conversion Service « . convert ( resources , » source Type « , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " resources " ) ) ) ) . » is Same As « ( resources ) ; }
@Test { List < Resource > resources = new » Array List « < > ( ) ; resources . add ( null ) ; resources . add ( null ) ; » Type Descriptor « » source Type « = » Type Descriptor « . » for Object « ( resources ) ; » assert That « ( » conversion Service « . convert ( resources , » source Type « , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " resources " ) ) ) ) . » is Same As « ( resources ) ; }
@Test { List < String > resources = new » Array List « < > ( ) ; resources . add ( null ) ; resources . add ( null ) ; » Type Descriptor « » source Type « = new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " strings " ) ) ; » assert That Exception Of Type « ( » Converter Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( resources , » source Type « , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " resources " ) ) ) ) ; }
@Test { List < Object > resources = new » Array List « < > ( ) ; resources . add ( new » Class Path Resource « ( " test " ) ) ; resources . add ( 3 ) ; » Type Descriptor « » source Type « = » Type Descriptor « . » for Object « ( resources ) ; » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( resources , » source Type « , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " resources " ) ) ) ) ; }
@Test { » conversion Service « . » add Converter Factory « ( new » String To Enum Converter Factory « ( ) ) ; List < String > list = new » Array List « < > ( ) ; list . add ( " A " ) ; list . add ( " C " ) ; » assert That « ( » conversion Service « . convert ( list , » Type Descriptor « . » for Object « ( list ) , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » enum Set « " ) ) ) ) . » is Equal To « ( » Enum Set « . of ( » My Enum « . A , » My Enum « . C ) ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( String . class , Integer . class ) ) . » is False « ( ) ; » conversion Service « . » add Converter Factory « ( new » String To Number Converter Factory « ( ) ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , Integer . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( String . class , String . class ) ) . » is True « ( ) ; » assert That « ( » conversion Service « . » can Convert « ( Integer . class , Number . class ) ) . » is True « ( ) ; » assert That « ( » conversion Service « . » can Convert « ( boolean . class , boolean . class ) ) . » is True « ( ) ; » assert That « ( » conversion Service « . » can Convert « ( boolean . class , Boolean . class ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . » can Convert « ( String . class , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . » can Convert « ( » Type Descriptor « . » value Of « ( String . class ) , null ) ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( null , Integer . class ) ) . » is True « ( ) ; » assert That « ( » conversion Service « . » can Convert « ( null , » Type Descriptor « . » value Of « ( Integer . class ) ) ) . » is True « ( ) ; }
@Test { » conversion Service « . » add Converter Factory « ( new » String To Number Converter Factory « ( ) ) ; » assert That « ( » conversion Service « . convert ( " 3 " , Integer . class ) ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( null , Integer . class ) ) . » is Equal To « ( null ) ; }
@Test { » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( null , int . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( null , » Type Descriptor « . » value Of « ( String . class ) , » Type Descriptor « . » value Of « ( int . class ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " 3 " , null , » Type Descriptor « . » value Of « ( int . class ) ) ) ; }
@Test { » assert That « ( » conversion Service « . convert ( false , boolean . class ) ) . » is Equal To « ( Boolean . FALSE ) ; » assert That « ( » conversion Service « . convert ( false , Boolean . class ) ) . » is Equal To « ( Boolean . FALSE ) ; }
@Test { » assert That Exception Of Type « ( » Converter Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " 3 " , Integer . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . » add Converter « ( new » Untyped Converter « ( ) ) ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( void . class , String . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( String . class , void . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » conversion Service « . convert ( null , Integer . class ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " 3 " , ( Class < ? > ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " 3 " , » Type Descriptor « . » value Of « ( String . class ) , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " 3 " , » Type Descriptor « . » value Of « ( Integer . class ) , » Type Descriptor « . » value Of « ( Long . class ) ) ) ; }
@Test { » conversion Service « . » add Converter Factory « ( new » String To Number Converter Factory « ( ) ) ; » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " BOGUS " , Integer . class ) ) ; }
@Test { » conversion Service « . » add Converter « ( new Converter < » Char Sequence « , Integer > ( ) { @ Override public Integer convert ( » Char Sequence « source ) { return Integer . » value Of « ( source . » to String « ( ) ) ; } } ) ; Integer result = » conversion Service « . convert ( " 3 " , Integer . class ) ; » assert That « ( ( int ) result ) . » is Equal To « ( ( int ) Integer . » value Of « ( 3 ) ) ; }
@Test { » conversion Service « . » add Converter « ( new » Color Converter « ( ) ) ; » assert That Exception Of Type « ( » Converter Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " # 000000 " , » System Color « . class ) ) ; }
@Test { » assert That « ( » conversion Service « . » can Convert « ( String . class , int . class ) ) . » is False « ( ) ; » conversion Service « . » add Converter Factory « ( new » String To Number Converter Factory « ( ) ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , int . class ) ) . » is True « ( ) ; Integer three = » conversion Service « . convert ( " 3 " , int . class ) ; » assert That « ( three . » int Value « ( ) ) . » is Equal To « ( 3 ) ; }
@Test { » conversion Service « . » add Converter « ( new » Object To Array Converter « ( » conversion Service « ) ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , Integer [ ] . class ) ) . » is False « ( ) ; » assert That Exception Of Type « ( » Converter Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » conversion Service « . convert ( " 3 , 4 , 5 " , Integer [ ] . class ) ) ; }
@Test { List < Object > raw = new » Array List « < > ( ) ; raw . add ( " one " ) ; raw . add ( " two " ) ; Object converted = » conversion Service « . convert ( raw , Iterable . class ) ; » assert That « ( converted ) . » is Same As « ( raw ) ; }
@Test { List < Object > raw = new » Array List « < > ( ) ; raw . add ( " one " ) ; raw . add ( " two " ) ; Object converted = » conversion Service « . convert ( raw , Object . class ) ; » assert That « ( converted ) . » is Same As « ( raw ) ; }
@Test { Map < Object , Object > raw = new » Hash Map « < > ( ) ; raw . put ( " key " , " value " ) ; Object converted = » conversion Service « . convert ( raw , Object . class ) ; » assert That « ( converted ) . » is Same As « ( raw ) ; }
@Test { » conversion Service « . » add Converter « ( new » My Base Interface To String Converter « ( ) ) ; » conversion Service « . » add Converter « ( new » Object To String Converter « ( ) ) ; Object converted = » conversion Service « . convert ( new » My Interface Implementer « ( ) , String . class ) ; » assert That « ( converted ) . » is Equal To « ( " RESULT " ) ; }
@Test { » conversion Service « . » add Converter « ( new » My Base Interface To String Converter « ( ) ) ; » conversion Service « . » add Converter « ( new » Array To Array Converter « ( » conversion Service « ) ) ; String [ ] converted = » conversion Service « . convert ( new » My Interface « [ ] { new » My Interface Implementer « ( ) } , String [ ] . class ) ; » assert That « ( converted [ 0 ] ) . » is Equal To « ( " RESULT " ) ; }
@Test { » conversion Service « . » add Converter « ( new » My Base Interface To String Converter « ( ) ) ; » conversion Service « . » add Converter « ( new » Array To Array Converter « ( » conversion Service « ) ) ; String [ ] converted = » conversion Service « . convert ( new » My Interface Implementer « [ ] { new » My Interface Implementer « ( ) } , String [ ] . class ) ; » assert That « ( converted [ 0 ] ) . » is Equal To « ( " RESULT " ) ; }
@Test { » conversion Service « . » add Converter « ( new » My String Array To Resource Array Converter « ( ) ) ; Resource [ ] converted = » conversion Service « . convert ( new String [ ] { " » x 1 « " , " » z 3 « " } , Resource [ ] . class ) ; List < String > descriptions = Arrays . stream ( converted ) . map ( Resource :: » get Description « ) . sorted ( » natural Order « ( ) ) . collect ( » to List « ( ) ) ; » assert That « ( descriptions ) . » is Equal To « ( Arrays . » as List « ( " 1 " , " 3 " ) ) ; }
@Test { » conversion Service « . » add Converter « ( new » My String Array To Integer Array Converter « ( ) ) ; Integer [ ] converted = » conversion Service « . convert ( new String [ ] { " » x 1 « " , " » z 3 « " } , Integer [ ] . class ) ; » assert That « ( converted ) . » is Equal To « ( new Integer [ ] { 1 , 3 } ) ; }
@Test { » conversion Service « . » add Converter « ( new » My String To Integer Array Converter « ( ) ) ; Integer [ ] converted = » conversion Service « . convert ( " » x 1 « , » z 3 « " , Integer [ ] . class ) ; » assert That « ( converted ) . » is Equal To « ( new Integer [ ] { 1 , 3 } ) ; }
@Test { Map < String , String > input = new » Linked Hash Map « < > ( ) ; input . put ( " key " , " value " ) ; Object converted = » conversion Service « . convert ( input , » Type Descriptor « . » for Object « ( input ) , new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » wildcard Map « " ) ) ) ; » assert That « ( converted ) . » is Equal To « ( input ) ; }
@Test { String value = " » my Value « " ; String result = » conversion Service « . convert ( value , String . class ) ; » assert That « ( result ) . » is Same As « ( value ) ; }
@Test { String value = " » my Value « " ; Object result = » conversion Service « . convert ( value , Object . class ) ; » assert That « ( result ) . » is Same As « ( value ) ; }
@Test { » With Copy Constructor « value = new » With Copy Constructor « ( ) ; Object result = » conversion Service « . convert ( value , » With Copy Constructor « . class ) ; » assert That « ( result ) . » is Same As « ( value ) ; }
@Test { » conversion Service « . » add Converter « ( new » String To Array Converter « ( » conversion Service « ) ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , Integer [ ] . class ) ) . » is False « ( ) ; » conversion Service « . » add Converter Factory « ( new » String To Number Converter Factory « ( ) ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , Integer [ ] . class ) ) . » is True « ( ) ; }
@Test { Set < » Generic Converter « . » Convertible Pair « > set = new » Hash Set « < > ( ) ; set . add ( new » Generic Converter « . » Convertible Pair « ( Number . class , String . class ) ) ; assert set . contains ( new » Generic Converter « . » Convertible Pair « ( Number . class , String . class ) ) ; }
@Test { » Generic Converter « . » Convertible Pair « pair = new » Generic Converter « . » Convertible Pair « ( Number . class , String . class ) ; » Generic Converter « . » Convertible Pair « » pair Equal « = new » Generic Converter « . » Convertible Pair « ( Number . class , String . class ) ; » assert That « ( » pair Equal « ) . » is Equal To « ( pair ) ; » assert That « ( » pair Equal « . » hash Code « ( ) ) . » is Equal To « ( pair . » hash Code « ( ) ) ; }
@Test { » Generic Converter « . » Convertible Pair « pair = new » Generic Converter « . » Convertible Pair « ( Number . class , String . class ) ; » Generic Converter « . » Convertible Pair « » pair Opposite « = new » Generic Converter « . » Convertible Pair « ( String . class , Number . class ) ; » assert That « ( pair . equals ( » pair Opposite « ) ) . » is False « ( ) ; » assert That « ( pair . » hash Code « ( ) == » pair Opposite « . » hash Code « ( ) ) . » is False « ( ) ; }
@Test { » conversion Service « . » add Converter « ( new » Color Converter « ( ) ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , Color . class ) ) . » is True « ( ) ; » conversion Service « . » remove Convertible « ( String . class , Color . class ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , Color . class ) ) . » is False « ( ) ; }
@Test { » My Conditional Converter « converter = new » My Conditional Converter « ( ) ; » conversion Service « . » add Converter « ( new » Color Converter « ( ) ) ; » conversion Service « . » add Converter « ( converter ) ; » assert That « ( » conversion Service « . convert ( " # 000000 " , Color . class ) ) . » is Equal To « ( Color . BLACK ) ; » assert That « ( converter . » get Match Attempts « ( ) > 0 ) . » is True « ( ) ; }
@Test { » My Conditional Converter Factory « converter = new » My Conditional Converter Factory « ( ) ; » conversion Service « . » add Converter « ( new » Color Converter « ( ) ) ; » conversion Service « . » add Converter Factory « ( converter ) ; » assert That « ( » conversion Service « . convert ( " # 000000 " , Color . class ) ) . » is Equal To « ( Color . BLACK ) ; » assert That « ( converter . » get Match Attempts « ( ) > 0 ) . » is True « ( ) ; » assert That « ( converter . » get Nested Match Attempts « ( ) > 0 ) . » is True « ( ) ; }
@Test { » Generic Converter « converter = new » Non Conditional Generic Converter « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » conversion Service « . » add Converter « ( converter ) ) . » with Message « ( " Only conditional converters may return null convertible types " ) ; }
@Test { » My Conditional Generic Converter « converter = new » My Conditional Generic Converter « ( ) ; » conversion Service « . » add Converter « ( converter ) ; » assert That « ( » conversion Service « . convert ( 3 , Integer . class ) ) . » is Equal To « ( 3 ) ; » assert That « ( converter . » get Source Types « ( ) . size ( ) ) . » is Greater Than « ( 2 ) ; » assert That « ( converter . » get Source Types « ( ) . stream ( ) . » all Match « ( td -> Integer . class . equals ( td . » get Type « ( ) ) ) ) . » is True « ( ) ; }
@Test { byte [ ] » byte Array « = new byte [ ] { 1 , 2 , 3 } ; byte [ ] converted = » conversion Service « . convert ( » byte Array « , byte [ ] . class ) ; » assert That « ( converted ) . » is Same As « ( » byte Array « ) ; }
@Test { » conversion Service « . » add Converter « ( new » Enum To String Converter « ( » conversion Service « ) ) ; » assert That « ( » conversion Service « . convert ( » My Enum « . A , String . class ) ) . » is Equal To « ( " A " ) ; }
@Test { » conversion Service « . » add Converter « ( new » Enum To String Converter « ( » conversion Service « ) ) ; » assert That « ( » conversion Service « . convert ( » Enum With Subclass « . FIRST , String . class ) ) . » is Equal To « ( " FIRST " ) ; }
@Test { » conversion Service « . » add Converter « ( new » Enum To String Converter « ( » conversion Service « ) ) ; » conversion Service « . » add Converter « ( new » My Enum Interface To String Converter « < » My Enum « > ( ) ) ; » assert That « ( » conversion Service « . convert ( » My Enum « . A , String . class ) ) . » is Equal To « ( " 1 " ) ; }
@Test { » conversion Service « . » add Converter Factory « ( new » String To Enum Converter Factory « ( ) ) ; » conversion Service « . » add Converter Factory « ( new » String To My Enum Interface Converter Factory « ( ) ) ; » assert That « ( » conversion Service « . convert ( " 1 " , » My Enum « . class ) ) . » is Equal To « ( » My Enum « . A ) ; }
@Test { » conversion Service « . » add Converter Factory « ( new » String To Enum Converter Factory « ( ) ) ; » conversion Service « . » add Converter Factory « ( new » String To My Enum Base Interface Converter Factory « ( ) ) ; » assert That « ( » conversion Service « . convert ( " » base 1 « " , » My Enum « . class ) ) . » is Equal To « ( » My Enum « . A ) ; }
@Test { String source = null ; » Type Descriptor « » source Type « = new » Type Descriptor « ( » get Class « ( ) . » get Field « ( " » annotated String « " ) ) ; » Type Descriptor « » target Type « = » Type Descriptor « . » value Of « ( String . class ) ; » conversion Service « . convert ( source , » source Type « , » target Type « ) ; }
@Test { Stream < Integer > stream = Arrays . » as List « ( 1 , 2 , 3 ) . stream ( ) ; » Type Descriptor « » array Of Longs « = new » Type Descriptor « ( Types . class . » get Field « ( " » array Of Longs « " ) ) ; » assert That Exception Of Type « ( » Conversion Failed Exception « . class ) . » is Thrown By « ( ( ) -> this . » conversion Service « . convert ( stream , » array Of Longs « ) ) . » with Cause Instance Of « ( » Converter Not Found Exception « . class ) ; }
@Test { » assert That « ( this . » stream Converter « . matches ( new » Type Descriptor « ( Types . class . » get Field « ( " » list Of Strings « " ) ) , new » Type Descriptor « ( Types . class . » get Field « ( " » array Of Longs « " ) ) ) ) . as ( " Should not match non stream type " ) . » is False « ( ) ; }
@Test { » Type Descriptor « » source Type « = new » Type Descriptor « ( Types . class . » get Field « ( " » list Of Strings « " ) ) ; » Type Descriptor « » target Type « = new » Type Descriptor « ( Types . class . » get Field « ( " » array Of Longs « " ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » stream Converter « . convert ( new Object ( ) , » source Type « , » target Type « ) ) ; }
@Test { » assert That « ( ps . » contains Property « ( " a . key " ) ) . » is Equal To « ( false ) ; » assert That « ( ps . » get Property « ( " a . key " ) ) . » is Null « ( ) ; }
@Test { » env Map « . put ( " akey " , " avalue " ) ; » assert That « ( ps . » contains Property « ( " akey " ) ) . » is Equal To « ( true ) ; » assert That « ( ps . » get Property « ( " akey " ) ) . » is Equal To « ( " avalue " ) ; }
@Test { » env Map « . put ( " a . key " , " a . value " ) ; » assert That « ( ps . » contains Property « ( " a . key " ) ) . » is Equal To « ( true ) ; » assert That « ( ps . » get Property « ( " a . key " ) ) . » is Equal To « ( " a . value " ) ; }
@Test { » env Map « . put ( " » a _ key « " , " » a _ value « " ) ; » env Map « . put ( " a . key " , " a . value " ) ; » assert That « ( ps . » get Property « ( " » a _ key « " ) ) . » is Equal To « ( " » a _ value « " ) ; » assert That « ( ps . » get Property « ( " a . key " ) ) . » is Equal To « ( " a . value " ) ; }
@Test { » assert That « ( » property Resolver « . » contains Property « ( " foo " ) ) . » is False « ( ) ; » test Properties « . put ( " foo " , " bar " ) ; » assert That « ( » property Resolver « . » contains Property « ( " foo " ) ) . » is True « ( ) ; }
@Test { » assert That « ( » property Resolver « . » get Property « ( " foo " ) ) . » is Null « ( ) ; » test Properties « . put ( " foo " , " bar " ) ; » assert That « ( » property Resolver « . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That « ( » property Resolver « . » get Property « ( " foo " , " » my Default « " ) ) . » is Equal To « ( " » my Default « " ) ; » test Properties « . put ( " foo " , " bar " ) ; » assert That « ( » property Resolver « . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { Map < String , Object > » nullable Properties « = new » Hash Map « < > ( ) ; » property Sources « . » add Last « ( new » Map Property Source « ( " » nullable Properties « " , » nullable Properties « ) ) ; » nullable Properties « . put ( " foo " , null ) ; » assert That « ( » property Resolver « . » get Property « ( " foo " ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » property Resolver « . » get Property « ( " foo " , Integer . class , 42 ) ) . » is Equal To « ( 42 ) ; » test Properties « . put ( " foo " , 13 ) ; » assert That « ( » property Resolver « . » get Property « ( " foo " , Integer . class , 42 ) ) . » is Equal To « ( 13 ) ; }
@Test { » test Properties « . put ( " foo " , " bar , baz " ) ; » assert That « ( » property Resolver « . » get Property « ( " foo " , String [ ] . class ) ) . » is Equal To « ( new String [ ] { " bar " , " baz " } ) ; }
@Test { » test Properties « . put ( " foo " , " bar " ) ; class » Test Type « { } » assert That Exception Of Type « ( » Converter Not Found Exception « . class ) . » is Thrown By « ( ( ) -> » property Resolver « . » get Property « ( " foo " , » Test Type « . class ) ) ; }
@Test { » test Properties « . put ( " exists " , " xyz " ) ; » assert That « ( » property Resolver « . » get Required Property « ( " exists " ) ) . » is Equal To « ( " xyz " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » property Resolver « . » get Required Property « ( " bogus " ) ) ; }
@Test { » test Properties « . put ( " exists " , " abc , 123 " ) ; » assert That « ( » property Resolver « . » get Required Property « ( " exists " , String [ ] . class ) ) . » is Equal To « ( new String [ ] { " abc " , " 123 " } ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » property Resolver « . » get Required Property « ( " bogus " , String [ ] . class ) ) ; }
@Test { » Mutable Property Sources « » property Sources « = new » Mutable Property Sources « ( ) ; » property Sources « . » add First « ( new » Mock Property Source « ( ) . » with Property « ( " key " , " value " ) ) ; » Property Resolver « resolver = new » Property Sources Property Resolver « ( » property Sources « ) ; » assert That « ( resolver . » resolve Placeholders « ( " Replace this $ { key } " ) ) . » is Equal To « ( " Replace this value " ) ; }
@Test { » Mutable Property Sources « » property Sources « = new » Mutable Property Sources « ( ) ; » property Sources « . » add First « ( new » Mock Property Source « ( ) . » with Property « ( " key " , " value " ) ) ; » Property Resolver « resolver = new » Property Sources Property Resolver « ( » property Sources « ) ; » assert That « ( resolver . » resolve Placeholders « ( " Replace this $ { key } plus $ { unknown } " ) ) . » is Equal To « ( " Replace this value plus $ { unknown } " ) ; }
@Test { » Mutable Property Sources « » property Sources « = new » Mutable Property Sources « ( ) ; » property Sources « . » add First « ( new » Mock Property Source « ( ) . » with Property « ( " key " , " value " ) ) ; » Property Resolver « resolver = new » Property Sources Property Resolver « ( » property Sources « ) ; » assert That « ( resolver . » resolve Placeholders « ( " Replace this $ { key } plus $ { unknown : » default Value « } " ) ) . » is Equal To « ( " Replace this value plus » default Value « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Property Sources Property Resolver « ( new » Mutable Property Sources « ( ) ) . » resolve Placeholders « ( null ) ) ; }
@Test { » Mutable Property Sources « » property Sources « = new » Mutable Property Sources « ( ) ; » property Sources « . » add First « ( new » Mock Property Source « ( ) . » with Property « ( " key " , " value " ) ) ; » Property Resolver « resolver = new » Property Sources Property Resolver « ( » property Sources « ) ; » assert That « ( resolver . » resolve Required Placeholders « ( " Replace this $ { key } " ) ) . » is Equal To « ( " Replace this value " ) ; }
@Test { » Mutable Property Sources « » property Sources « = new » Mutable Property Sources « ( ) ; » property Sources « . » add First « ( new » Mock Property Source « ( ) . » with Property « ( " key " , " value " ) ) ; » Property Resolver « resolver = new » Property Sources Property Resolver « ( » property Sources « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> resolver . » resolve Required Placeholders « ( " Replace this $ { key } plus $ { unknown } " ) ) ; }
@Test { » Mutable Property Sources « » property Sources « = new » Mutable Property Sources « ( ) ; » property Sources « . » add First « ( new » Mock Property Source « ( ) . » with Property « ( " key " , " value " ) ) ; » Property Resolver « resolver = new » Property Sources Property Resolver « ( » property Sources « ) ; » assert That « ( resolver . » resolve Required Placeholders « ( " Replace this $ { key } plus $ { unknown : » default Value « } " ) ) . » is Equal To « ( " Replace this value plus » default Value « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Property Sources Property Resolver « ( new » Mutable Property Sources « ( ) ) . » resolve Required Placeholders « ( null ) ) ; }
@Test { Environment env = new » Abstract Environment « ( ) { } ; » assert That « ( env . » accepts Profiles « ( » default Profile « ( ) ) ) . » is True « ( ) ; }
@Test { class » Custom Environment « extends » Abstract Environment « { @ Override protected Set < String > » get Reserved Default Profiles « ( ) { return Collections . » empty Set « ( ) ; } } Environment env = new » Custom Environment « ( ) ; » assert That « ( env . » accepts Profiles « ( » default Profile « ( ) ) ) . » is False « ( ) ; }
@Test { class » Custom Environment « extends » Abstract Environment « { @ Override protected Set < String > » get Reserved Default Profiles « ( ) { return Collections . singleton ( " » rd 1 « " ) ; } } Environment env = new » Custom Environment « ( ) ; » assert That « ( env . » accepts Profiles « ( » default Profile « ( ) ) ) . » is False « ( ) ; » assert That « ( env . » accepts Profiles « ( Profiles . of ( " » rd 1 « " ) ) ) . » is True « ( ) ; }
@Test { » Configurable Environment « env = new » Standard Environment « ( ) ; » Mutable Property Sources « sources = env . » get Property Sources « ( ) ; » assert That « ( sources . » precedence Of « ( » Property Source « . named ( » Standard Environment « . » SYSTEM _ PROPERTIES _ PROPERTY _ SOURCE _ NAME « ) ) ) . » is Equal To « ( 0 ) ; » assert That « ( sources . » precedence Of « ( » Property Source « . named ( » Standard Environment « . » SYSTEM _ ENVIRONMENT _ PROPERTY _ SOURCE _ NAME « ) ) ) . » is Equal To « ( 1 ) ; » assert That « ( sources ) . » has Size « ( 2 ) ; }
@Test { » Configurable Environment « env = new » Standard Environment « ( ) ; » Mutable Property Sources « sources = env . » get Property Sources « ( ) ; » assert That « ( sources . get ( » Standard Environment « . » SYSTEM _ ENVIRONMENT _ PROPERTY _ SOURCE _ NAME « ) ) . » is Instance Of « ( » System Environment Property Source « . class ) ; }
@Test { » assert That « ( environment . » get Active Profiles « ( ) . length ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( environment . » get Default Profiles « ( ) . length ) . » is Equal To « ( 1 ) ; » assert That « ( environment . » get Default Profiles « ( ) [ 0 ] ) . » is Equal To « ( " default " ) ; }
@Test { environment . » set Active Profiles « ( " local " , " embedded " ) ; String [ ] » active Profiles « = environment . » get Active Profiles « ( ) ; » assert That « ( » active Profiles « ) . contains ( " local " , " embedded " ) ; » assert That « ( » active Profiles « . length ) . » is Equal To « ( 2 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Active Profiles « ( ( String [ ] ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Active Profiles « ( ( String ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Active Profiles « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Active Profiles « ( " » p 1 « " , " ! » p 2 « " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Default Profiles « ( ( String [ ] ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Default Profiles « ( ( String ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Default Profiles « ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » set Default Profiles « ( " » d 1 « " , " ! » d 2 « " ) ) ; }
@Test { try { System . » set Property « ( » DEFAULT _ PROFILES _ PROPERTY _ NAME « , " $ { spring . profiles . default } " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » get Default Profiles « ( ) ) ; } finally { System . » clear Property « ( » DEFAULT _ PROFILES _ PROPERTY _ NAME « ) ; } }
@Test { » assert That « ( environment . » get Active Profiles « ( ) . length ) . » is Equal To « ( 0 ) ; System . » set Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « , " " ) ; » assert That « ( environment . » get Active Profiles « ( ) . length ) . » is Equal To « ( 0 ) ; System . » clear Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « ) ; }
@Test { System . » set Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « , " foo " ) ; » assert That « ( Arrays . » as List « ( environment . » get Active Profiles « ( ) ) ) . contains ( " foo " ) ; System . » clear Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « ) ; }
@Test { System . » set Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « , " foo , bar " ) ; » assert That « ( environment . » get Active Profiles « ( ) ) . contains ( " foo " , " bar " ) ; System . » clear Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « ) ; }
@Test { System . » set Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « , " bar , baz " ) ; » assert That « ( environment . » get Active Profiles « ( ) ) . contains ( " bar " , " baz " ) ; System . » clear Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( environment :: » accepts Profiles « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » accepts Profiles « ( ( String [ ] ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » accepts Profiles « ( ( String ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » accepts Profiles « ( " " ) ) ; }
@Test { » assert That « ( environment . » accepts Profiles « ( " » p 1 « " ) ) . » is False « ( ) ; environment . » get Property Sources « ( ) . » add First « ( new » Mock Property Source « ( ) . » with Property « ( » ACTIVE _ PROFILES _ PROPERTY _ NAME « , " » p 1 « " ) ) ; » assert That « ( environment . » accepts Profiles « ( " » p 1 « " ) ) . » is True « ( ) ; }
@Test { » assert That « ( environment . » accepts Profiles « ( " pd " ) ) . » is False « ( ) ; environment . » set Default Profiles « ( " pd " ) ; » assert That « ( environment . » accepts Profiles « ( " pd " ) ) . » is True « ( ) ; environment . » set Active Profiles « ( " » p 1 « " ) ; » assert That « ( environment . » accepts Profiles « ( " pd " ) ) . » is False « ( ) ; » assert That « ( environment . » accepts Profiles « ( " » p 1 « " ) ) . » is True « ( ) ; }
@Test { » assert That « ( environment . » accepts Profiles « ( " » p 1 « " ) ) . » is False « ( ) ; » assert That « ( environment . » accepts Profiles « ( " ! » p 1 « " ) ) . » is True « ( ) ; environment . » add Active Profile « ( " » p 1 « " ) ; » assert That « ( environment . » accepts Profiles « ( " » p 1 « " ) ) . » is True « ( ) ; » assert That « ( environment . » accepts Profiles « ( " ! » p 1 « " ) ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> environment . » accepts Profiles « ( " » p 1 « " , " ! " ) ) ; }
@Test { » assert That « ( environment . » accepts Profiles « ( Profiles . of ( " » p 1 « & » p 2 « " ) ) ) . » is False « ( ) ; environment . » add Active Profile « ( " » p 1 « " ) ; » assert That « ( environment . » accepts Profiles « ( Profiles . of ( " » p 1 « & » p 2 « " ) ) ) . » is False « ( ) ; environment . » add Active Profile « ( " » p 2 « " ) ; » assert That « ( environment . » accepts Profiles « ( Profiles . of ( " » p 1 « & » p 2 « " ) ) ) . » is True « ( ) ; }
@Test { System . » set Property « ( " spring . getenv . ignore " , " true " ) ; » assert That « ( environment . » get System Environment « ( ) . » is Empty « ( ) ) . » is True « ( ) ; System . » clear Property « ( " spring . getenv . ignore " ) ; }
@Test { » Spring Properties « . » set Property « ( " spring . getenv . ignore " , " true " ) ; » assert That « ( environment . » get System Environment « ( ) . » is Empty « ( ) ) . » is True « ( ) ; » Spring Properties « . » set Property « ( " spring . getenv . ignore " , null ) ; }
@Test { » Spring Properties « . » set Flag « ( " spring . getenv . ignore " ) ; » assert That « ( environment . » get System Environment « ( ) . » is Empty « ( ) ) . » is True « ( ) ; » Spring Properties « . » set Property « ( " spring . getenv . ignore " , null ) ; }
@Test { » Property Source « < ? > ps = new » Simple Command Line Property Source « ( ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( » Command Line Property Source « . » COMMAND _ LINE _ PROPERTY _ SOURCE _ NAME « ) ; }
@Test { » Property Source « < ? > ps = new » Simple Command Line Property Source « ( " » ps 1 « " , new String [ 0 ] ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( " » ps 1 « " ) ; }
@Test { » Property Source « < ? > ps = new » Simple Command Line Property Source « ( ) ; » assert That « ( ps . » contains Property « ( " foo " ) ) . » is False « ( ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Enumerable Property Source « < ? > ps = new » Simple Command Line Property Source « ( " -- foo = " ) ; » assert That « ( ps . » contains Property « ( " foo " ) ) . » is True « ( ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Profiles . of ( ( String [ ] ) null ) ) . » with Message Containing « ( " Must specify at least one profile " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Profiles . of ( ) ) . » with Message Containing « ( " Must specify at least one profile " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Profiles . of ( ( String ) null ) ) . » with Message Containing « ( " must contain text " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Profiles . of ( " " ) ) . » with Message Containing « ( " must contain text " ) ; }
@Test { Profiles profiles = Profiles . of ( " spring " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is True « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is False « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " ! spring " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is False « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is True « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " spring " , " framework " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is True « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is True « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " java " ) ) ) . » is False « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " ! spring " , " framework " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is False « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " , " framework " ) ) ) . » is True « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is True « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " java " ) ) ) . » is True « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " ( spring ) " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is True « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is False « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " ! ( spring ) " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is False « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is True « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " ( ! spring ) " ) ; » assert That « ( profiles . matches ( » active Profiles « ( " spring " ) ) ) . » is False « ( ) ; » assert That « ( profiles . matches ( » active Profiles « ( " framework " ) ) ) . » is True « ( ) ; }
@Test { Profiles profiles = Profiles . of ( " ( spring | framework ) " ) ; » assert Or Expression « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ( spring & framework ) " ) ; » assert And Expression « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " spring & framework ) " ) ; » assert And Expression « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " spring & framework " ) ; » assert And Expression « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ! ( spring & framework ) " ) ; » assert Of Not And Expression « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ! spring & framework " ) ; » assert Of And Expression With Inverted Single Element « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ( ! spring ) & framework " ) ; » assert Of And Expression With Inverted Single Element « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ! ( spring ) & framework " ) ; » assert Of And Expression With Inverted Single Element « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ! spring | framework " ) ; » assert Of Or Expression With Inverted Single Element « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ! ( spring | framework ) " ) ; » assert Of Not Or Expression « ( profiles ) ; }
@Test { Profiles profiles = Profiles . of ( " ( spring & framework ) | ( spring & java ) " ) ; » assert Complex Expression « ( profiles ) ; }
@Test { » assert Malformed « ( ( ) -> Profiles . of ( " ( " ) ) ; » assert Malformed « ( ( ) -> Profiles . of ( " ) " ) ) ; » assert Malformed « ( ( ) -> Profiles . of ( " a & b | c " ) ) ; }
@Test { » assert That « ( Profiles . of ( " spring & framework " , " java | kotlin " ) . » to String « ( ) ) . » is Equal To « ( " spring & framework or java | kotlin " ) ; }
@Test { » assert That « ( parser . parse ( ) . » get Option Values « ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Command Line Args « args = parser . parse ( " -- » o 1 « " ) ; » assert That « ( args . » contains Option « ( " » o 1 « " ) ) . » is True « ( ) ; » assert That « ( args . » get Option Values « ( " » o 1 « " ) ) . » is Equal To « ( Collections . » EMPTY _ LIST « ) ; }
@Test { » Command Line Args « args = parser . parse ( " -- » o 1 « = » v 1 « " ) ; » assert That « ( args . » contains Option « ( " » o 1 « " ) ) . » is True « ( ) ; » assert That « ( args . » get Option Values « ( " » o 1 « " ) ) . » contains Exactly « ( " » v 1 « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parser . parse ( " -- " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parser . parse ( " -- = » v 1 « " ) ) ; }
@Test { » Command Line Args « args = parser . parse ( " -- » o 1 « = " ) ; » assert That « ( args . » contains Option « ( " » o 1 « " ) ) . » is True « ( ) ; » assert That « ( args . » get Option Values « ( " » o 1 « " ) ) . » contains Exactly « ( " " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parser . parse ( " -- = " ) ) ; }
@Test { » Command Line Args « args = new » Simple Command Line Args Parser « ( ) . parse ( ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> args . » get Option Names « ( ) . add ( " bogus " ) ) ; }
@Test { » Command Line Args « args = new » Simple Command Line Args Parser « ( ) . parse ( ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> args . » get Non Option Args « ( ) . add ( " foo " ) ) ; }
@Test { » Mutable Property Sources « sources = new » Mutable Property Sources « ( ) ; » assert That « ( sources . get ( " bogus " ) ) . » is Null « ( ) ; }
@Test { » Mutable Property Sources « sources = new » Mutable Property Sources « ( ) ; Iterator < » Property Source « < ? > > it = sources . iterator ( ) ; » assert That « ( it . » has Next « ( ) ) . » is False « ( ) ; }
@Test { » Mutable Property Sources « sources = new » Mutable Property Sources « ( ) ; » assert That « ( sources . stream ( ) ) . » is Not Null « ( ) ; » assert That « ( sources . stream ( ) . count ( ) ) . » is Equal To « ( 0L ) ; }
@Test { » Option Parser « parser = new » Option Parser « ( ) ; parser . accepts ( " foo " ) . » with Required Arg « ( ) ; » Option Set « options = parser . parse ( " -- foo = bar " ) ; » Property Source « < ? > ps = new » J Opt Command Line Property Source « ( options ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Option Parser « parser = new » Option Parser « ( ) ; parser . accepts ( " foo " ) . » with Optional Arg « ( ) ; » Option Set « options = parser . parse ( " -- foo " ) ; » Property Source « < ? > ps = new » J Opt Command Line Property Source « ( options ) ; » assert That « ( ps . » contains Property « ( " foo " ) ) . » is True « ( ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " " ) ; }
@Test { » Option Parser « parser = new » Option Parser « ( ) ; parser . accepts ( " foo " ) . » with Optional Arg « ( ) ; » Option Set « options = parser . parse ( " -- foo = " ) ; » Property Source « < ? > ps = new » J Opt Command Line Property Source « ( options ) ; » assert That « ( ps . » contains Property « ( " foo " ) ) . » is True « ( ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " " ) ; }
@Test { » Option Parser « parser = new » Option Parser « ( ) ; parser . accepts ( " foo " ) . » with Required Arg « ( ) . » with Values Separated By « ( ' , ' ) ; » Option Set « options = parser . parse ( ) ; » Property Source « < ? > ps = new » J Opt Command Line Property Source « ( options ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Option Parser « parser = new » Option Parser « ( ) ; parser . accepts ( " spring . profiles . active " ) . » with Required Arg « ( ) ; » Option Set « options = parser . parse ( " -- spring . profiles . active = » p 1 « " ) ; » Command Line Property Source « < ? > ps = new » J Opt Command Line Property Source « ( options ) ; » assert That « ( ps . » get Property « ( " spring . profiles . active " ) ) . » is Equal To « ( " » p 1 « " ) ; }
@Test { » Option Parser « parser = new » Option Parser « ( ) ; parser . accepts ( " » o 1 « " ) . » with Required Arg « ( ) . » of Type « ( » Option Enum « . class ) ; » Option Set « options = parser . parse ( " -- » o 1 « = » VAL _ 1 « " ) ; » Property Source « < ? > ps = new » J Opt Command Line Property Source « ( options ) ; » assert That « ( ps . » get Property « ( " » o 1 « " ) ) . » is Equal To « ( " » VAL _ 1 « " ) ; }
@Test { » assert Exception Contains Fully Qualified Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH « ) ) ; }
@Test { » assert Exception Contains Fully Qualified Path « ( new » Class Path Resource « ( » NONEXISTENT _ RESOURCE _ NAME « , » get Class « ( ) ) ) ; }
@Test { » assert Exception Contains Fully Qualified Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH « , » get Class « ( ) . » get Class Loader « ( ) ) ) ; }
@Test { » assert Description Contains Expected Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH « ) , » FQ _ RESOURCE _ PATH « ) ; }
@Test { » assert Description Contains Expected Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH _ WITH _ LEADING _ SLASH « ) , » FQ _ RESOURCE _ PATH « ) ; }
@Test { » assert Description Contains Expected Path « ( new » Class Path Resource « ( » NONEXISTENT _ RESOURCE _ NAME « , » get Class « ( ) ) , » FQ _ RESOURCE _ PATH « ) ; }
@Test { » assert Description Contains Expected Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH _ WITH _ LEADING _ SLASH « , » get Class « ( ) ) , » FQ _ RESOURCE _ PATH « ) ; }
@Test { » assert Description Contains Expected Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH « , » get Class « ( ) . » get Class Loader « ( ) ) , » FQ _ RESOURCE _ PATH « ) ; }
@Test { » assert Description Contains Expected Path « ( new » Class Path Resource « ( » FQ _ RESOURCE _ PATH _ WITH _ LEADING _ SLASH « , » get Class « ( ) . » get Class Loader « ( ) ) , » FQ _ RESOURCE _ PATH « ) ; }
@Test { » assert That « ( new » Class Path Resource « ( " / test . html " ) . » get Path « ( ) ) . » is Equal To « ( " test . html " ) ; » assert That « ( ( ( » Class Path Resource « ) new » Class Path Resource « ( " " ) . » create Relative « ( " / test . html " ) ) . » get Path « ( ) ) . » is Equal To « ( " test . html " ) ; }
@Test { » assert That « ( new » Class Path Resource « ( " / test . html " , » get Class « ( ) ) . » get Path « ( ) ) . » is Equal To « ( " / test . html " ) ; » assert That « ( ( ( » Class Path Resource « ) new » Class Path Resource « ( " " , » get Class « ( ) ) . » create Relative « ( " / test . html " ) ) . » get Path « ( ) ) . » is Equal To « ( " / test . html " ) ; }
@Test { Resource » file Dir « = new » Class Path Resource « ( " org / springframework / core " ) ; » assert That « ( » file Dir « . exists ( ) ) . » is True « ( ) ; » assert That « ( » file Dir « . » is Readable « ( ) ) . » is False « ( ) ; Resource » jar Dir « = new » Class Path Resource « ( " reactor / core " ) ; » assert That « ( » jar Dir « . exists ( ) ) . » is True « ( ) ; » assert That « ( » jar Dir « . » is Readable « ( ) ) . » is False « ( ) ; }
@Test { » Property Editor « editor = new » Resource Editor « ( ) ; editor . » set As Text « ( " classpath : org / springframework / core / io / » Resource Editor Tests « . class " ) ; Resource resource = ( Resource ) editor . » get Value « ( ) ; » assert That « ( resource ) . » is Not Null « ( ) ; » assert That « ( resource . exists ( ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Resource Editor « ( null , null ) ) ; }
@Test { » Property Editor « editor = new » Resource Editor « ( ) ; editor . » set As Text « ( null ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Property Editor « editor = new » Resource Editor « ( ) ; editor . » set As Text « ( " " ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Property Editor « editor = new » Resource Editor « ( ) ; System . » set Property « ( " test . prop " , " foo " ) ; try { editor . » set As Text « ( " $ { test . prop } " ) ; Resource resolved = ( Resource ) editor . » get Value « ( ) ; » assert That « ( resolved . » get Filename « ( ) ) . » is Equal To « ( " foo " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { » Property Editor « editor = new » Resource Editor « ( ) ; System . » set Property « ( " test . prop " , " foo " ) ; try { editor . » set As Text « ( " $ { test . prop } - $ { bar } " ) ; Resource resolved = ( Resource ) editor . » get Value « ( ) ; » assert That « ( resolved . » get Filename « ( ) ) . » is Equal To « ( " foo - $ { bar } " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { » Property Editor « editor = new » Resource Editor « ( new » Default Resource Loader « ( ) , new » Standard Environment « ( ) , false ) ; System . » set Property « ( " test . prop " , " foo " ) ; try { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { editor . » set As Text « ( " $ { test . prop } - $ { bar } " ) ; editor . » get Value « ( ) ; } ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { Resource resource = new » Class Path Resource « ( " org / springframework / core / io / Resource . class " , » get Class « ( ) . » get Class Loader « ( ) ) ; » do Test Resource « ( resource ) ; » assert That « ( new » Class Path Resource « ( " org / springframework / core / . . / core / io / . / Resource . class " , » get Class « ( ) . » get Class Loader « ( ) ) ) . » is Equal To « ( resource ) ; }
@Test { Resource resource = new » Class Path Resource « ( " Resource . class " , » get Class « ( ) ) ; » do Test Resource « ( resource ) ; » assert That « ( new » Class Path Resource « ( " Resource . class " , » get Class « ( ) ) ) . » is Equal To « ( resource ) ; }
@Test { String file = » get Class « ( ) . » get Resource « ( " Resource . class " ) . » get File « ( ) ; Resource resource = new » File System Resource « ( file ) ; » do Test Resource « ( resource ) ; » assert That « ( resource ) . » is Equal To « ( new » File System Resource « ( file ) ) ; }
@Test { File file = new File ( » get Class « ( ) . » get Resource « ( " Resource . class " ) . » get File « ( ) ) ; Resource resource = new » File System Resource « ( file ) ; » do Test Resource « ( resource ) ; » assert That « ( resource ) . » is Equal To « ( new » File System Resource « ( file ) ) ; }
@Test { Path » file Path « = Paths . get ( » get Class « ( ) . » get Resource « ( " Resource . class " ) . » to URI « ( ) ) ; Resource resource = new » File System Resource « ( » file Path « ) ; » do Test Resource « ( resource ) ; » assert That « ( resource ) . » is Equal To « ( new » File System Resource « ( » file Path « ) ) ; }
@Test { Resource resource = new » File System Resource « ( " core / io / Resource . class " ) ; » assert That « ( new » File System Resource « ( " core / . . / core / io / . / Resource . class " ) ) . » is Equal To « ( resource ) ; }
@Test { Resource resource = new » Class Path Resource « ( " dir / " ) ; Resource relative = resource . » create Relative « ( " subdir " ) ; » assert That « ( relative ) . » is Equal To « ( new » Class Path Resource « ( " dir / subdir " ) ) ; }
@Test { Resource resource = new » File System Resource « ( " dir / " ) ; Resource relative = resource . » create Relative « ( " subdir " ) ; » assert That « ( relative ) . » is Equal To « ( new » File System Resource « ( " dir / subdir " ) ) ; }
@Test { Resource resource = new » Url Resource « ( " file : dir / " ) ; Resource relative = resource . » create Relative « ( " subdir " ) ; » assert That « ( relative ) . » is Equal To « ( new » Url Resource « ( " file : dir / subdir " ) ) ; }
@Test { URL url = new URL ( " https : » // spring . io / « " ) ; » assume True « ( » url Is Reachable « ( url ) ) ; Resource resource = new » Url Resource « ( url ) ; » assert That « ( resource . exists ( ) ) . » is True « ( ) ; }
@Test { » Abstract Resource « resource = new » Abstract Resource « ( ) { @ Override public » Input Stream « » get Input Stream « ( ) { return new » Byte Array Input Stream « ( new byte [ ] { ' a ' , ' b ' , ' c ' } ) ; } @ Override public String » get Description « ( ) { return " " ; } } ; » assert That « ( resource . » content Length « ( ) ) . » is Equal To « ( 3L ) ; }
@Test { Resource resource = new » File System Resource « ( » get Class « ( ) . » get Resource « ( " Resource . class " ) . » get File « ( ) ) ; » Readable Byte Channel « channel = null ; try { channel = resource . » readable Channel « ( ) ; » Byte Buffer « buffer = » Byte Buffer « . allocate ( ( int ) resource . » content Length « ( ) ) ; channel . read ( buffer ) ; buffer . rewind ( ) ; » assert That « ( buffer . limit ( ) > 0 ) . » is True « ( ) ; } finally { if ( channel != null ) { channel . close ( ) ; } } }
@Test { » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( ( ) -> new » File System Resource « ( » get Class « ( ) . » get Resource « ( " Resource . class " ) . » get File « ( ) ) . » create Relative « ( " X " ) . » get Input Stream « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( ( ) -> new » File System Resource « ( » get Class « ( ) . » get Resource « ( " Resource . class " ) . » get File « ( ) ) . » create Relative « ( " X " ) . » readable Channel « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Resource « ( " Resource . class " , » get Class « ( ) ) . » create Relative « ( " X " ) . » get Input Stream « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( ( ) -> new » Class Path Resource « ( " Resource . class " , » get Class « ( ) ) . » create Relative « ( " X " ) . » readable Channel « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Path Resource « ( ( Path ) null ) ) . » with Message Containing « ( " Path must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Path Resource « ( ( String ) null ) ) . » with Message Containing « ( " Path must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Path Resource « ( ( URI ) null ) ) . » with Message Containing « ( " URI must not be null " ) ; }
@Test { Path path = Paths . get ( » TEST _ FILE « ) ; » Path Resource « resource = new » Path Resource « ( path ) ; » assert That « ( resource . » get Path « ( ) ) . » is Equal To « ( » TEST _ FILE « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » get Path « ( ) ) . » is Equal To « ( » TEST _ FILE « ) ; }
@Test { File file = new File ( » TEST _ FILE « ) ; » Path Resource « resource = new » Path Resource « ( file . » to URI « ( ) ) ; » assert That « ( resource . » get Path « ( ) ) . » is Equal To « ( file . » get Absolute File « ( ) . » to String « ( ) ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; » assert That « ( resource . » get Path « ( ) ) . » is Equal To « ( » TEST _ DIR « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . exists ( ) ) . » is Equal To « ( true ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; » assert That « ( resource . exists ( ) ) . » is Equal To « ( true ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » NON _ EXISTING _ FILE « ) ; » assert That « ( resource . exists ( ) ) . » is Equal To « ( false ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » is Readable « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » NON _ EXISTING _ FILE « ) ; » assert That « ( resource . » is Readable « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; » assert That « ( resource . » is Readable « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; byte [ ] bytes = » File Copy Utils « . » copy To Byte Array « ( resource . » get Input Stream « ( ) ) ; » assert That « ( bytes . length ) . » is Greater Than « ( 0 ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( resource :: » get Input Stream « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » NON _ EXISTING _ FILE « ) ; » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( resource :: » get Input Stream « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » get URL « ( ) . » to String « ( ) ) . » ends With « ( " core / io / example . properties " ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » get URI « ( ) . » to String « ( ) ) . » ends With « ( " core / io / example . properties " ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; File file = new File ( » TEST _ FILE « ) ; » assert That « ( resource . » get File « ( ) . » get Absolute File « ( ) ) . » is Equal To « ( file . » get Absolute File « ( ) ) ; }
@Test { Path path = mock ( Path . class ) ; given ( path . normalize ( ) ) . » will Return « ( path ) ; given ( path . » to File « ( ) ) . » will Throw « ( new » Unsupported Operation Exception « ( ) ) ; » Path Resource « resource = new » Path Resource « ( path ) ; » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( resource :: » get File « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; File file = new File ( » TEST _ FILE « ) ; » assert That « ( resource . » content Length « ( ) ) . » is Equal To « ( file . length ( ) ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; File file = new File ( » TEST _ DIR « ) ; » assert That « ( resource . » content Length « ( ) ) . » is Equal To « ( file . length ( ) ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; File file = new File ( » TEST _ FILE « ) ; » assert That « ( resource . » last Modified « ( ) / 1000 ) . » is Equal To « ( file . » last Modified « ( ) / 1000 ) ; }
@Test { Resource resource = new » Path Resource « ( » TEST _ DIR « ) . » create Relative « ( " example . properties " ) ; » assert That « ( resource ) . » is Equal To « ( new » Path Resource « ( » TEST _ FILE « ) ) ; }
@Test { Resource resource = new » Path Resource « ( » TEST _ FILE « ) . » create Relative « ( " . . / example . properties " ) ; » assert That « ( resource ) . » is Equal To « ( new » Path Resource « ( » TEST _ FILE « ) ) ; }
@Test { Resource resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » get Filename « ( ) ) . » is Equal To « ( " example . properties " ) ; }
@Test { Resource resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » get Description « ( ) ) . contains ( " path [ " ) ; » assert That « ( resource . » get Description « ( ) ) . contains ( » TEST _ FILE « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » assert That « ( resource . » is Writable « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; » assert That « ( resource . » is Writable « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( resource :: » get Output Stream « ) ; }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ FILE « ) ; » Readable Byte Channel « channel = null ; try { channel = resource . » readable Channel « ( ) ; » Byte Buffer « buffer = » Byte Buffer « . allocate ( ( int ) resource . » content Length « ( ) ) ; channel . read ( buffer ) ; buffer . rewind ( ) ; » assert That « ( buffer . limit ( ) ) . » is Greater Than « ( 0 ) ; } finally { if ( channel != null ) { channel . close ( ) ; } } }
@Test { » Path Resource « resource = new » Path Resource « ( » TEST _ DIR « ) ; try { resource . » readable Channel « ( ) ; } catch ( » Access Denied Exception « ex ) { } }
@Test { » Path Resource « resource = new » Path Resource « ( » NON _ EXISTING _ FILE « ) ; » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( resource :: » readable Channel « ) ; }
@Test { » Data Buffer « » data Buffer « = this . » buffer Factory « . » allocate Buffer « ( ) ; try { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( this . » buffer Factory « :: » check For Leaks « ) ; } finally { release ( » data Buffer « ) ; } }
@Test { » Data Buffer « » data Buffer « = this . » buffer Factory « . » allocate Buffer « ( ) ; release ( » data Buffer « ) ; this . » buffer Factory « . » check For Leaks « ( ) ; }
@Test { » Pooled Data Buffer « buffer = » create Data Buffer « ( 1 ) ; buffer . write ( ( byte ) ' a ' ) ; buffer . retain ( ) ; » assert That « ( buffer . release ( ) ) . » is False « ( ) ; » assert That « ( buffer . release ( ) ) . » is True « ( ) ; }
@Test { » Pooled Data Buffer « buffer = » create Data Buffer « ( 1 ) ; buffer . write ( ( byte ) ' a ' ) ; buffer . release ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( buffer :: release ) ; }
@Test { Assertions . » assert That Thrown By « ( ( ) -> new » Limited Data Buffer List « ( 5 ) . add ( » to Data Buffer « ( " 123456 " ) ) ) . » is Instance Of « ( » Data Buffer Limit Exception « . class ) ; }
@Test { new » Limited Data Buffer List « ( - 1 ) . add ( » to Data Buffer « ( " 123456 " ) ) ; }
@Test { » Limited Data Buffer List « list = new » Limited Data Buffer List « ( 5 ) ; list . add ( » to Data Buffer « ( " 12345 " ) ) ; list . clear ( ) ; list . add ( » to Data Buffer « ( " 12345 " ) ) ; }
@Test { » assert That Exception Of Type « ( » File Not Found Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » get Resources « ( " xx * * : * * / * » . xy « " ) ) ; }
@Test { Resource [ ] resources = resolver . » get Resources « ( " org / springframework / core / io / support / » Path Matching Resource Pattern Resolver Tests « . class " ) ; » assert That « ( resources . length ) . » is Equal To « ( 1 ) ; » assert Protocol And Filenames « ( resources , " file " , " » Path Matching Resource Pattern Resolver Tests « . class " ) ; }
@Test { Resource [ ] resources = resolver . » get Resources « ( " org / reactivestreams / Publisher . class " ) ; » assert That « ( resources . length ) . » is Equal To « ( 1 ) ; » assert Protocol And Filenames « ( resources , " jar " , " Publisher . class " ) ; }
@Test { Resource [ ] resources = resolver . » get Resources « ( " classpath * : » org / springframework / core / io / « * * » / resource « # test * » . txt « " ) ; » assert That « ( resources ) . extracting ( Resource :: » get File « ) . extracting ( File :: » get Name « ) . » contains Exactly In Any Order « ( " resource # » test 1 . txt « " , " resource # » test 2 . txt « " ) ; }
@Test { Resource [ ] resources = resolver . » get Resources « ( " classpath : » reactor / util / annotation / « * » . class « " ) ; » assert Protocol And Filenames « ( resources , " jar " , » CLASSES _ IN _ REACTOR _ UTIL _ ANNOTATIONS « ) ; }
@Test { Resource [ ] resources = resolver . » get Resources « ( " classpath * : » reactor / util / annotation / « * » . class « " ) ; » assert Protocol And Filenames « ( resources , " jar " , » CLASSES _ IN _ REACTOR _ UTIL _ ANNOTATIONS « ) ; }
@Test { Resource [ ] resources = resolver . » get Resources « ( " classpath * : * . dtd " ) ; boolean found = false ; for ( Resource resource : resources ) { if ( resource . » get Filename « ( ) . equals ( " » aspectj _ 1 _ 5 _ 0 « . dtd " ) ) { found = true ; break ; } } » assert That « ( found ) . as ( " Could not find » aspectj _ 1 _ 5 _ 0 « . dtd in the root of the aspectjweaver jar " ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Resource Region « ( null , 0 , 1 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Resource Region « ( mock ( Resource . class ) , - 1 , 1 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Resource Region « ( mock ( Resource . class ) , 0 , - 1 ) ) ; }
@Test { » Property Editor « editor = new » Resource Array Property Editor « ( ) ; editor . » set As Text « ( " classpath : org / springframework / core / io / support / » Resource Array Property Editor « . class " ) ; Resource [ ] resources = ( Resource [ ] ) editor . » get Value « ( ) ; » assert That « ( resources ) . » is Not Null « ( ) ; » assert That « ( resources [ 0 ] . exists ( ) ) . » is True « ( ) ; }
@Test { » Property Editor « editor = new » Resource Array Property Editor « ( ) ; editor . » set As Text « ( " classpath * : org / springframework / core / io / support / Resource * Editor . class " ) ; Resource [ ] resources = ( Resource [ ] ) editor . » get Value « ( ) ; » assert That « ( resources ) . » is Not Null « ( ) ; » assert That « ( resources [ 0 ] . exists ( ) ) . » is True « ( ) ; }
@Test { » Property Editor « editor = new » Resource Array Property Editor « ( ) ; System . » set Property « ( " test . prop " , " foo " ) ; try { editor . » set As Text « ( " $ { test . prop } " ) ; Resource [ ] resources = ( Resource [ ] ) editor . » get Value « ( ) ; » assert That « ( resources [ 0 ] . » get Filename « ( ) ) . » is Equal To « ( " foo " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { » Property Editor « editor = new » Resource Array Property Editor « ( new » Path Matching Resource Pattern Resolver « ( ) , new » Standard Environment « ( ) , false ) ; System . » set Property « ( " test . prop " , " foo " ) ; try { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( " $ { test . prop } - $ { bar } " ) ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { List < » Dummy Factory « > factories = » Spring Factories Loader « . » load Factories « ( » Dummy Factory « . class , null ) ; » assert That « ( factories . size ( ) ) . » is Equal To « ( 2 ) ; boolean » condition 1 « = factories . get ( 0 ) instanceof » My Dummy Factory 1 « ; » assert That « ( » condition 1 « ) . » is True « ( ) ; boolean condition = factories . get ( 1 ) instanceof » My Dummy Factory 2 « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { List < » Dummy Package Private Factory « > factories = » Spring Factories Loader « . » load Factories « ( » Dummy Package Private Factory « . class , null ) ; » assert That « ( factories . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( Modifier . » is Public « ( factories . get ( 0 ) . » get Class « ( ) . » get Modifiers « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Spring Factories Loader « . » load Factories « ( String . class , null ) ) . » with Message Containing « ( " Unable to instantiate factory class " + " [ org . springframework . core . io . support . » My Dummy Factory 1 « ] for factory type [ java . lang . String ] " ) ; }
@Test { » assert That « ( new » Encoded Resource « ( resource ) . equals ( null ) ) . » is False « ( ) ; }
@Test { » Encoded Resource « » er 1 « = new » Encoded Resource « ( resource , » UTF 8 « ) ; » Encoded Resource « » er 2 « = new » Encoded Resource « ( resource , » UTF 8 « ) ; » assert That « ( » er 2 « ) . » is Equal To « ( » er 1 « ) ; }
@Test { » Encoded Resource « » er 1 « = new » Encoded Resource « ( resource , » UTF 8 « ) ; » Encoded Resource « » er 2 « = new » Encoded Resource « ( resource , » UTF 16 « ) ; » assert That « ( » er 2 « ) . » is Not Equal To « ( » er 1 « ) ; }
@Test { » Encoded Resource « » er 1 « = new » Encoded Resource « ( resource , » UTF 8 _ CS « ) ; » Encoded Resource « » er 2 « = new » Encoded Resource « ( resource , » UTF 8 _ CS « ) ; » assert That « ( » er 2 « ) . » is Equal To « ( » er 1 « ) ; }
@Test { » Encoded Resource « » er 1 « = new » Encoded Resource « ( resource , » UTF 8 _ CS « ) ; » Encoded Resource « » er 2 « = new » Encoded Resource « ( resource , » UTF 16 _ CS « ) ; » assert That « ( » er 2 « ) . » is Not Equal To « ( » er 1 « ) ; }
@Test { » Encoded Resource « » er 1 « = new » Encoded Resource « ( resource , » UTF 8 « ) ; » Encoded Resource « » er 2 « = new » Encoded Resource « ( resource , » UTF 8 _ CS « ) ; » assert That « ( » er 2 « ) . » is Not Equal To « ( » er 1 « ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( » PROPERTIES _ LOCATION « ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( » PROPERTIES _ RESOURCE _ DESCRIPTION « ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( » XML _ PROPERTIES _ LOCATION « ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( » XML _ PROPERTIES _ RESOURCE _ DESCRIPTION « ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( " » ps 1 « " , » PROPERTIES _ LOCATION « ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( " » ps 1 « " ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( " » ps 1 « " , » PROPERTIES _ LOCATION « , » get Class « ( ) . » get Class Loader « ( ) ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( " » ps 1 « " ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( » PROPERTIES _ LOCATION « , » get Class « ( ) . » get Class Loader « ( ) ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( » PROPERTIES _ RESOURCE _ DESCRIPTION « ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( new » Class Path Resource « ( » PROPERTIES _ PATH « ) ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( » PROPERTIES _ RESOURCE _ DESCRIPTION « ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( " » ps 1 « " , new » Class Path Resource « ( » PROPERTIES _ PATH « ) ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( " » ps 1 « " ) ; }
@Test { » Property Source « < ? > ps = new » Resource Property Source « ( new » Byte Array Resource « ( " foo = bar " . » get Bytes « ( ) , " " ) ) ; » assert That « ( ps . » get Property « ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( ps . » get Name « ( ) ) . » is Equal To « ( " Byte array resource [ ] " ) ; }
@Test { » Log Message « msg = » Log Message « . of ( ( ) -> new » String Builder « ( " a " ) . append ( " b " ) ) ; » assert That « ( msg . » to String « ( ) ) . » is Equal To « ( " a b " ) ; » assert That « ( msg . » to String « ( ) ) . » is Same As « ( msg . » to String « ( ) ) ; }
@Test { » Log Message « msg = » Log Message « . format ( " a % s " , " b " ) ; » assert That « ( msg . » to String « ( ) ) . » is Equal To « ( " a b " ) ; » assert That « ( msg . » to String « ( ) ) . » is Same As « ( msg . » to String « ( ) ) ; }
@Test { » Log Message « msg = » Log Message « . format ( " a % s % s " , " b " , " c " ) ; » assert That « ( msg . » to String « ( ) ) . » is Equal To « ( " a b c " ) ; » assert That « ( msg . » to String « ( ) ) . » is Same As « ( msg . » to String « ( ) ) ; }
@Test { » Log Message « msg = » Log Message « . format ( " a % s % s % s " , " b " , " c " , " d " ) ; » assert That « ( msg . » to String « ( ) ) . » is Equal To « ( " a b c d " ) ; » assert That « ( msg . » to String « ( ) ) . » is Same As « ( msg . » to String « ( ) ) ; }
@Test { » Log Message « msg = » Log Message « . format ( " a % s % s % s % s " , " b " , " c " , " d " , " e " ) ; » assert That « ( msg . » to String « ( ) ) . » is Equal To « ( " a b c d e " ) ; » assert That « ( msg . » to String « ( ) ) . » is Same As « ( msg . » to String « ( ) ) ; }
@Test { » Log Message « msg = » Log Message « . format ( " a % s % s % s % s % s " , " b " , " c " , " d " , " e " , " f " ) ; » assert That « ( msg . » to String « ( ) ) . » is Equal To « ( " a b c d e f " ) ; » assert That « ( msg . » to String « ( ) ) . » is Same As « ( msg . » to String « ( ) ) ; }
@Test { » Serializing Converter « » to Bytes « = new » Serializing Converter « ( ) ; byte [ ] bytes = » to Bytes « . convert ( " Testing " ) ; » Deserializing Converter « » from Bytes « = new » Deserializing Converter « ( ) ; » assert That « ( » from Bytes « . convert ( bytes ) ) . » is Equal To « ( " Testing " ) ; }
@Test { » Serializing Converter « » to Bytes « = new » Serializing Converter « ( ) ; » assert That Exception Of Type « ( » Serialization Failed Exception « . class ) . » is Thrown By « ( ( ) -> » to Bytes « . convert ( new Object ( ) ) ) . » with Cause Instance Of « ( » Illegal Argument Exception « . class ) ; }
@Test { » Serializing Converter « » to Bytes « = new » Serializing Converter « ( ) ; » assert That Exception Of Type « ( » Serialization Failed Exception « . class ) . » is Thrown By « ( ( ) -> » to Bytes « . convert ( new » Un Serializable « ( ) ) ) . » with Cause Instance Of « ( » Not Serializable Exception « . class ) ; }
@Test { » Deserializing Converter « » from Bytes « = new » Deserializing Converter « ( ) ; » assert That Exception Of Type « ( » Serialization Failed Exception « . class ) . » is Thrown By « ( ( ) -> » from Bytes « . convert ( " Junk " . » get Bytes « ( ) ) ) ; }
@Test { » assert That « ( styler . style ( null ) ) . » is Equal To « ( " [ null ] " ) ; » assert That « ( styler . style ( " str " ) ) . » is Equal To « ( " 'str' " ) ; » assert That « ( styler . style ( String . class ) ) . » is Equal To « ( " String " ) ; » assert That « ( styler . style ( String . class . » get Method « ( " » to String « " ) ) ) . » is Equal To « ( " » to String « @ String " ) ; }
@Test { Object obj = new Object ( ) ; » assert That « ( styler . style ( obj ) ) . » is Equal To « ( String . » value Of « ( obj ) ) ; }
@Test { Map < String , Integer > map = new » Linked Hash Map « < > ( ) ; map . put ( " » key 1 « " , 1 ) ; map . put ( " » key 2 « " , 2 ) ; Iterator < Map . Entry < String , Integer > > entries = map . » entry Set « ( ) . iterator ( ) ; » assert That « ( styler . style ( entries . next ( ) ) ) . » is Equal To « ( " 'key1' -> 1 " ) ; » assert That « ( styler . style ( entries . next ( ) ) ) . » is Equal To « ( " 'key2' -> 2 " ) ; }
@Test { List < Integer > list = Collections . » empty List « ( ) ; » assert That « ( styler . style ( list ) ) . » is Equal To « ( " list [ [ empty ] ] " ) ; list = Collections . » singleton List « ( 1 ) ; » assert That « ( styler . style ( list ) ) . » is Equal To « ( " list [ 1 ] " ) ; list = Arrays . » as List « ( 1 , 2 ) ; » assert That « ( styler . style ( list ) ) . » is Equal To « ( " list [ 1 , 2 ] " ) ; }
@Test { int [ ] array = new int [ 0 ] ; » assert That « ( styler . style ( array ) ) . » is Equal To « ( " array < Object > [ [ empty ] ] " ) ; array = new int [ ] { 1 } ; » assert That « ( styler . style ( array ) ) . » is Equal To « ( " array < Integer > [ 1 ] " ) ; array = new int [ ] { 1 , 2 } ; » assert That « ( styler . style ( array ) ) . » is Equal To « ( " array < Integer > [ 1 , 2 ] " ) ; }
@Test { String [ ] array = new String [ 0 ] ; » assert That « ( styler . style ( array ) ) . » is Equal To « ( " array < String > [ [ empty ] ] " ) ; array = new String [ ] { " » str 1 « " } ; » assert That « ( styler . style ( array ) ) . » is Equal To « ( " array < String > [ 'str1' ] " ) ; array = new String [ ] { " » str 1 « " , " » str 2 « " } ; » assert That « ( styler . style ( array ) ) . » is Equal To « ( " array < String > [ 'str1' , 'str2' ] " ) ; }
@Test { final Map < String , String > map = » get Map « ( ) ; Object stringy = new Object ( ) { @ Override public String » to String « ( ) { return new » To String Creator « ( this ) . append ( " » family Favorite Sport « " , map ) . » to String « ( ) ; } } ; » assert That « ( stringy . » to String « ( ) ) . » is Equal To « ( ( " [ » To String Creator Tests « .4 @ " + » Object Utils « . » get Identity Hex String « ( stringy ) + " » family Favorite Sport « = map [ 'Keri' -> 'Softball' , 'Scot' -> 'Fishing' , 'Keith' -> 'Flag Football' ] ] " ) ) ; }
@Test { » Some Object « [ ] array = new » Some Object « [ ] { » s 1 « , » s 2 « , » s 3 « } ; String str = new » To String Creator « ( array ) . » to String « ( ) ; » assert That « ( str ) . » is Equal To « ( ( " [ @ " + » Object Utils « . » get Identity Hex String « ( array ) + " array < » To String Creator Tests « . » Some Object « > [ A , B , C ] ] " ) ) ; }
@Test { int [ ] integers = new int [ ] { 0 , 1 , 2 , 3 , 4 } ; String str = new » To String Creator « ( integers ) . » to String « ( ) ; » assert That « ( str ) . » is Equal To « ( ( " [ @ " + » Object Utils « . » get Identity Hex String « ( integers ) + " array < Integer > [ 0 , 1 , 2 , 3 , 4 ] ] " ) ) ; }
@Test { List < » Some Object « > list = new » Array List « < > ( ) ; list . add ( » s 1 « ) ; list . add ( » s 2 « ) ; list . add ( » s 3 « ) ; String str = new » To String Creator « ( this ) . append ( " » my Letters « " , list ) . » to String « ( ) ; » assert That « ( str ) . » is Equal To « ( ( " [ » To String Creator Tests « @ " + » Object Utils « . » get Identity Hex String « ( this ) + " » my Letters « = list [ A , B , C ] ] " ) ) ; }
@Test { Set < » Some Object « > set = new » Linked Hash Set « < > ( ) ; set . add ( » s 1 « ) ; set . add ( » s 2 « ) ; set . add ( » s 3 « ) ; String str = new » To String Creator « ( this ) . append ( " » my Letters « " , set ) . » to String « ( ) ; » assert That « ( str ) . » is Equal To « ( ( " [ » To String Creator Tests « @ " + » Object Utils « . » get Identity Hex String « ( this ) + " » my Letters « = set [ A , B , C ] ] " ) ) ; }
@Test { String str = new » To String Creator « ( this ) . append ( " » my Class « " , this . » get Class « ( ) ) . » to String « ( ) ; » assert That « ( str ) . » is Equal To « ( ( " [ » To String Creator Tests « @ " + » Object Utils « . » get Identity Hex String « ( this ) + " » my Class « = » To String Creator Tests « ] " ) ) ; }
@Test { String str = new » To String Creator « ( this ) . append ( " » my Method « " , this . » get Class « ( ) . » get Declared Method « ( " » append Method « " ) ) . » to String « ( ) ; » assert That « ( str ) . » is Equal To « ( ( " [ » To String Creator Tests « @ " + » Object Utils « . » get Identity Hex String « ( this ) + " » my Method « = » append Method « @ » To String Creator Tests « ] " ) ) ; }
@Test { » Simple Async Task Executor « executor = new » Simple Async Task Executor « ( ) ; executor . » set Concurrency Limit « ( » Concurrency Throttle Support « . » NO _ CONCURRENCY « ) ; » assert That « ( executor . » is Throttle Active « ( ) ) . » is True « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> executor . execute ( new » No Op Runnable « ( ) ) ) ; }
@Test { » Simple Async Task Executor « executor = new » Simple Async Task Executor « ( ) ; » assert That « ( executor . » is Throttle Active « ( ) ) . as ( " Concurrency throttle must not default to being active ( on ) " ) . » is False « ( ) ; }
@Test { final String » custom Prefix « = " » chank Pop « # " ; final Object monitor = new Object ( ) ; » Simple Async Task Executor « executor = new » Simple Async Task Executor « ( » custom Prefix « ) ; » Thread Name Harvester « task = new » Thread Name Harvester « ( monitor ) ; » execute And Wait « ( executor , task , monitor ) ; » assert That « ( task . » get Thread Name « ( ) ) . » starts With « ( » custom Prefix « ) ; }
@Test { final Object monitor = new Object ( ) ; » Simple Async Task Executor « executor = new » Simple Async Task Executor « ( new » Thread Factory « ( ) { @ Override public Thread » new Thread « ( Runnable r ) { return new Thread ( r , " test " ) ; } } ) ; » Thread Name Harvester « task = new » Thread Name Harvester « ( monitor ) ; » execute And Wait « ( executor , task , monitor ) ; » assert That « ( task . » get Thread Name « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Simple Async Task Executor « ( ) . execute ( null ) ) ; }
@Test { » set Test Groups « ( " " ) ; » assert That Exception Of Type « ( » Test Aborted Exception « . class ) . » is Thrown By « ( ( ) -> » assume Group « ( » LONG _ RUNNING « ) ) ; }
@Test { » set Test Groups « ( PERFORMANCE ) ; » assert That Exception Of Type « ( » Test Aborted Exception « . class ) . » is Thrown By « ( ( ) -> » assume Group « ( » LONG _ RUNNING « ) ) ; }
@Test { » set Test Groups « ( » LONG _ RUNNING « ) ; » assert That Code « ( ( ) -> » assume Group « ( » LONG _ RUNNING « ) ) . as ( " assumption should NOT have failed " ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert Bogus Active Test Group Behavior « ( " bogus " ) ; }
@Test { » assert Bogus Active Test Group Behavior « ( " all - bogus " ) ; }
@Test { » assert That « ( » Test Group « . parse ( null ) ) . » is Equal To « ( Collections . » empty Set « ( ) ) ; }
@Test { » assert That « ( » Test Group « . parse ( " " ) ) . » is Equal To « ( Collections . » empty Set « ( ) ) ; }
@Test { » assert That « ( » Test Group « . parse ( " PERFORMANCE , PERFORMANCE " ) ) . » contains Only « ( » Test Group « . PERFORMANCE ) ; }
@Test { » assert That « ( » Test Group « . parse ( " performance , » PER Forma NCE « " ) ) . » contains Only « ( » Test Group « . PERFORMANCE ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Test Group « . parse ( " performance , missing " ) ) . » with Message Containing « ( " Unable to find test group 'missing' when parsing " + " » test Groups « value : 'performance, missing' . Available groups include : " + " [ » LONG _ RUNNING « , PERFORMANCE ] " ) ; }
@Test { » assert That « ( » Test Group « . parse ( " all " ) ) . » is Equal To « ( » Enum Set « . » all Of « ( » Test Group « . class ) ) ; }
@Test { Set < » Test Group « > expected = » Enum Set « . » all Of « ( » Test Group « . class ) ; expected . remove ( » Test Group « . PERFORMANCE ) ; » assert That « ( » Test Group « . parse ( " all - performance " ) ) . » is Equal To « ( expected ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Test Group « . parse ( " all - missing " ) ) . » with Message Containing « ( " Unable to find test group 'missing' when parsing " + " » test Groups « value : 'all-missing' . Available groups include : " + " [ » LONG _ RUNNING « , PERFORMANCE ] " ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » get Method Name « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » get Declaring Class Name « ( ) ) . » is Equal To « ( » With Method « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » get Return Type Name « ( ) ) . » is Equal To « ( String . class . » get Name « ( ) ) ; }
@Test { » assert That « ( » get Tagged « ( » With Abstract Method « . class ) . » is Abstract « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » is Abstract « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Static Method « . class ) . » is Static « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » is Static « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Final Method « . class ) . » is Final « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » is Final « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » is Overridable « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Static Method « . class ) . » is Overridable « ( ) ) . » is False « ( ) ; » assert That « ( » get Tagged « ( » With Final Method « . class ) . » is Overridable « ( ) ) . » is False « ( ) ; » assert That « ( » get Tagged « ( » With Private Method « . class ) . » is Overridable « ( ) ) . » is False « ( ) ; }
@Test { » Method Metadata « metadata = » get Tagged « ( » With Direct Annotation « . class ) ; » assert That « ( metadata . » get Annotations « ( ) . stream ( ) . filter ( » Merged Annotation « :: » is Directly Present « ) . map ( a -> a . » get Type « ( ) . » get Name « ( ) ) ) . » contains Exactly In Any Order « ( Tag . class . » get Name « ( ) , » Direct Annotation « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( » get Tagged « ( » With Direct Annotation « . class ) . » is Annotated « ( » Direct Annotation « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Meta Annotation « . class ) . » is Annotated « ( » Direct Annotation « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Method « . class ) . » is Annotated « ( » Direct Annotation « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( » get Tagged « ( » With Annotation Attributes « . class ) . » get Annotation Attributes « ( » Annotation Attributes « . class . » get Name « ( ) ) ) . » contains Only « ( entry ( " name " , " test " ) , entry ( " size " , 1 ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = » get Tagged « ( » With Meta Annotation Attributes « . class ) . » get All Annotation Attributes « ( » Annotation Attributes « . class . » get Name « ( ) ) ; » assert That « ( attributes ) . » contains Only Keys « ( " name " , " size " ) ; » assert That « ( attributes . get ( " name " ) ) . » contains Exactly In Any Order « ( " » m 1 « " , " » m 2 « " ) ; » assert That « ( attributes . get ( " size " ) ) . » contains Exactly In Any Order « ( 1 , 2 ) ; }
@Test { » Annotation Metadata « » annotation Metadata « = get ( » Annotated Component « . class ) ; » assert That « ( » annotation Metadata « . » get Annotation Types « ( ) ) . » contains Exactly « ( » Enclosing Annotation « . class . » get Name « ( ) ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; String » class Under Test « = " example . type . » Annotation Type Filter Tests Types $ Some Component « " ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » class Under Test « ) ; » Annotation Type Filter « filter = new » Annotation Type Filter « ( » Inherited Annotation « . class ) ; » assert That « ( filter . match ( » metadata Reader « , » metadata Reader Factory « ) ) . » is True « ( ) ; » Classloading Assertions « . » assert Class Not Loaded « ( » class Under Test « ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; String » class Under Test « = " example . type . » Annotation Type Filter Tests Types $ Some Class With Some Component Interface « " ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » class Under Test « ) ; » Annotation Type Filter « filter = new » Annotation Type Filter « ( » Inherited Annotation « . class ) ; » assert That « ( filter . match ( » metadata Reader « , » metadata Reader Factory « ) ) . » is False « ( ) ; » Classloading Assertions « . » assert Class Not Loaded « ( » class Under Test « ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; String » class Under Test « = " example . type . » Annotation Type Filter Tests Types $ Some Subclass Of Some Component « " ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » class Under Test « ) ; » Annotation Type Filter « filter = new » Annotation Type Filter « ( » Inherited Annotation « . class ) ; » assert That « ( filter . match ( » metadata Reader « , » metadata Reader Factory « ) ) . » is True « ( ) ; » Classloading Assertions « . » assert Class Not Loaded « ( » class Under Test « ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; String » class Under Test « = " example . type . » Annotation Type Filter Tests Types $ Some Non Candidate Class « " ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » class Under Test « ) ; » Annotation Type Filter « filter = new » Annotation Type Filter « ( Component . class ) ; » assert That « ( filter . match ( » metadata Reader « , » metadata Reader Factory « ) ) . » is False « ( ) ; » Classloading Assertions « . » assert Class Not Loaded « ( » class Under Test « ) ; }
@Test { » assert That « ( » standard Metadata « . » get Annotation Types « ( ) ) . » contains Exactly In Any Order « ( » Named Annotation 3 « . class . » get Name « ( ) , » Inherited Composed Annotation « . class . » get Name « ( ) ) ; » assert That « ( » asm Metadata « . » get Annotation Types « ( ) ) . » contains Exactly « ( » Named Annotation 3 « . class . » get Name « ( ) ) ; }
@Test { Map < String , Object > » annotation Attributes « ; » annotation Attributes « = » standard Metadata « . » get Annotation Attributes « ( » Named Annotation 1 « . class . » get Name « ( ) ) ; » assert That « ( » annotation Attributes « . get ( " name " ) ) . » is Equal To « ( " name 1 " ) ; » annotation Attributes « = » asm Metadata « . » get Annotation Attributes « ( » Named Annotation 1 « . class . » get Name « ( ) ) ; » assert That « ( » annotation Attributes « ) . » is Null « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » get Class Name « ( ) ) . » is Equal To « ( » Test Class « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( » Test Interface « . class ) . » is Interface « ( ) ) . » is True « ( ) ; » assert That « ( get ( » Test Annotation « . class ) . » is Interface « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » is Interface « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » Test Annotation « . class ) . » is Annotation « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » is Annotation « ( ) ) . » is False « ( ) ; » assert That « ( get ( » Test Interface « . class ) . » is Annotation « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » Test Final Class « . class ) . » is Final « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » is Final « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » Abstract Annotation Metadata Tests « . class ) . » is Independent « ( ) ) . » is True « ( ) ; » assert That « ( get ( » Test Class « . class ) . » is Independent « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » Test Non Static Inner Class « . class ) . » is Independent « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » get Enclosing Class Name « ( ) ) . » is Equal To « ( » Abstract Annotation Metadata Tests « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( » Abstract Annotation Metadata Tests « . class ) . » get Enclosing Class Name « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( get ( » Test Subclass « . class ) . » get Super Class Name « ( ) ) . » is Equal To « ( » Test Class « . class . » get Name « ( ) ) ; » assert That « ( get ( » Test Class « . class ) . » get Super Class Name « ( ) ) . » is Equal To « ( Object . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( Object . class ) . » get Super Class Name « ( ) ) . » is Null « ( ) ; » assert That « ( get ( » Test Interface « . class ) . » get Super Class Name « ( ) ) . » is Null « ( ) ; » assert That « ( get ( » Test Sub Interface « . class ) . » get Super Class Name « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( get ( » Test Subclass « . class ) . » get Interface Names « ( ) ) . » contains Exactly In Any Order « ( » Test Interface « . class . » get Name « ( ) ) ; » assert That « ( get ( » Test Sub Interface « . class ) . » get Interface Names « ( ) ) . » contains Exactly In Any Order « ( » Test Interface « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » get Interface Names « ( ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( get ( » Test Member Class « . class ) . » get Member Class Names « ( ) ) . » contains Exactly In Any Order « ( » Test Member Class Inner Class « . class . » get Name « ( ) , » Test Member Class Inner Interface « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » get Member Class Names « ( ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( get ( » With Direct Annotations « . class ) . » get Annotations « ( ) . stream ( ) ) . » filtered On « ( » Merged Annotation « :: » is Directly Present « ) . extracting ( a -> a . » get Type « ( ) . » get Name « ( ) ) . » contains Exactly In Any Order « ( » Direct Annotation 1 « . class . » get Name « ( ) , » Direct Annotation 2 « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( » With Direct Annotations « . class ) . » is Annotated « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » With Meta Annotations « . class ) . » is Annotated « ( » Meta Annotation 2 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » is Annotated « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » With Annotation Attributes « . class ) . » get Annotation Attributes « ( » Annotation Attributes « . class . » get Name « ( ) ) ) . » contains Only « ( entry ( " name " , " test " ) , entry ( " size " , 1 ) ) ; }
@Test { » Multi Value Map « < String , Object > attributes = get ( » With Meta Annotation Attributes « . class ) . » get All Annotation Attributes « ( » Annotation Attributes « . class . » get Name « ( ) ) ; » assert That « ( attributes ) . » contains Only Keys « ( " name " , " size " ) ; » assert That « ( attributes . get ( " name " ) ) . » contains Exactly In Any Order « ( " » m 1 « " , " » m 2 « " ) ; » assert That « ( attributes . get ( " size " ) ) . » contains Exactly In Any Order « ( 1 , 2 ) ; }
@Test { » Annotation Metadata « metadata = get ( » With Direct Annotations « . class ) ; » assert That « ( metadata . » get Annotation Types « ( ) ) . » contains Exactly In Any Order « ( » Direct Annotation 1 « . class . » get Name « ( ) , » Direct Annotation 2 « . class . » get Name « ( ) ) ; }
@Test { » Annotation Metadata « metadata = get ( » With Meta Annotations « . class ) ; » assert That « ( metadata . » get Meta Annotation Types « ( » Meta Annotation Root « . class . » get Name « ( ) ) ) . » contains Exactly In Any Order « ( » Meta Annotation 1 « . class . » get Name « ( ) , » Meta Annotation 2 « . class . » get Name « ( ) ) ; }
@Test { » assert That « ( get ( » With Direct Annotations « . class ) . » has Annotation « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » With Meta Annotations « . class ) . » has Annotation « ( » Meta Annotation 1 « . class . » get Name « ( ) ) ) . » is False « ( ) ; » assert That « ( get ( » With Meta Annotations « . class ) . » has Annotation « ( » Meta Annotation 2 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » has Annotation « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » With Direct Annotations « . class ) . » has Meta Annotation « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » With Meta Annotations « . class ) . » has Meta Annotation « ( » Meta Annotation 1 « . class . » get Name « ( ) ) ) . » is True « ( ) ; » assert That « ( get ( » With Meta Annotations « . class ) . » has Meta Annotation « ( » Meta Annotation 2 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » Test Class « . class ) . » has Meta Annotation « ( » Meta Annotation 1 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » With Annotated Method « . class ) . » has Annotated Methods « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » With Meta Annotated Method « . class ) . » has Annotated Methods « ( » Meta Annotation 2 « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( get ( » With Annotated Method « . class ) . » has Annotated Methods « ( » Meta Annotation 2 « . class . » get Name « ( ) ) ) . » is False « ( ) ; » assert That « ( get ( » With Non Annotated Method « . class ) . » has Annotated Methods « ( » Direct Annotation 1 « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( get ( » With Direct And Meta Annotated Methods « . class ) . » get Annotated Methods « ( » Meta Annotation 2 « . class . » get Name « ( ) ) ) . extracting ( » Method Metadata « :: » get Method Name « ) . » contains Exactly In Any Order « ( " direct " , " meta " ) ; }
@Test { » Class Metadata « metadata = » get Class Metadata For « ( » L 0 _ a « . class ) ; String [ ] » nested Classes « = metadata . » get Member Class Names « ( ) ; » assert That « ( » nested Classes « ) . » is Equal To « ( new String [ ] { } ) ; }
@Test { » Class Metadata « metadata = » get Class Metadata For « ( » L 0 _ b « . class ) ; String [ ] » nested Classes « = metadata . » get Member Class Names « ( ) ; » assert That « ( » nested Classes « ) . » is Equal To « ( new String [ ] { » L 0 _ b « . » L 1 « . class . » get Name « ( ) } ) ; }
@Test { » Class Metadata « metadata = » get Class Metadata For « ( » L 0 _ c « . class ) ; String [ ] » nested Classes « = metadata . » get Member Class Names « ( ) ; » assert That « ( » nested Classes « ) . » is Equal To « ( new String [ ] { » L 0 _ c « . » L 1 « . class . » get Name « ( ) } ) ; }
@Test { » Class Metadata « metadata = » get Class Metadata For « ( » L 0 _ b « . » L 1 « . class ) ; String [ ] » nested Classes « = metadata . » get Member Class Names « ( ) ; » assert That « ( » nested Classes « ) . » is Equal To « ( new String [ ] { } ) ; }
@Test { » assert Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class « " , " example . type . » Aspect J Type Filter Tests Types « . » Some Class « " ) ; » assert Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class « " , " * " ) ; » assert Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class « " , " * . . » Some Class « " ) ; » assert Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class « " , " example . . » Some Class « " ) ; }
@Test { » assert No Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class « " , " example . type . » Aspect J Type Filter Tests Types « . » Some Class X « " ) ; }
@Test { » assert No Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class Extending Some Class « " , " java . lang . String + " ) ; }
@Test { » assert No Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class Annotated With Component « " , " @ org . springframework . stereotype . Repository * . . * " ) ; }
@Test { » assert No Match « ( " example . type . » Aspect J Type Filter Tests Types $ Some Class « " , " * . . Bogus && example . type . » Aspect J Type Filter Tests Types « . » Some Class « " ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( » Annotated Component « . class ) ; » do Test Annotation Info « ( metadata ) ; » do Test Method Annotation Info « ( metadata ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Annotated Component « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » do Test Annotation Info « ( metadata ) ; » do Test Method Annotation Info « ( metadata ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( » Annotated Component Sub Class « . class ) ; » do Test Sub Class Annotation Info « ( metadata , false ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Annotated Component Sub Class « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » do Test Sub Class Annotation Info « ( metadata , true ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( » Annotation Metadata « . class ) ; » do Test Metadata For Interface Class « ( metadata ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Annotation Metadata « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » do Test Metadata For Interface Class « ( metadata ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( Component . class ) ; » do Test Metadata For Annotation Class « ( metadata ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( Component . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » do Test Metadata For Annotation Class « ( metadata ) ; }
@Test { » Annotation Metadata « metadata = new » Standard Annotation Metadata « ( » Annotated Component « . class ) ; » Annotation Attributes « » special Attrs « = ( » Annotation Attributes « ) metadata . » get Annotation Attributes « ( » Special Attr « . class . » get Name « ( ) ) ; Annotation [ ] » nested Anno Array « = ( Annotation [ ] ) » special Attrs « . get ( " » nested Anno Array « " ) ; » assert That « ( » nested Anno Array « [ 0 ] ) . » is Instance Of « ( » Nested Anno « . class ) ; }
@Test { » Annotation Metadata « metadata = new » Standard Annotation Metadata « ( » Composed Configuration With Attribute Overrides Class « . class ) ; » assert Meta Annotation Overrides « ( metadata ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Composed Configuration With Attribute Overrides Class « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » assert Meta Annotation Overrides « ( metadata ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( » Named Annotations Class « . class ) ; » assert Multiple Annotations With Identical Attribute Names « ( metadata ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Named Annotations Class « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » assert Multiple Annotations With Identical Attribute Names « ( metadata ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( » Named Composed Annotation Class « . class ) ; » assert Multiple Annotations With Identical Attribute Names « ( metadata ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Named Composed Annotation Class « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » assert Multiple Annotations With Identical Attribute Names « ( metadata ) ; }
@Test { » Annotation Metadata « metadata = » Annotation Metadata « . introspect ( » Named Composed Annotation Extended « . class ) ; » assert That « ( metadata . » has Annotation « ( » Named Composed Annotation « . class . » get Name « ( ) ) ) . » is True « ( ) ; }
@Test { » Metadata Reader Factory « » metadata Reader Factory « = new » Simple Metadata Reader Factory « ( ) ; » Metadata Reader « » metadata Reader « = » metadata Reader Factory « . » get Metadata Reader « ( » Named Composed Annotation Extended « . class . » get Name « ( ) ) ; » Annotation Metadata « metadata = » metadata Reader « . » get Annotation Metadata « ( ) ; » assert That « ( metadata . » has Annotation « ( » Named Composed Annotation « . class . » get Name « ( ) ) ) . » is False « ( ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( super :: » get Annotations Returns Direct Annotations « ) ; }
@Test { » load From « ( » With Enum Annotation « . class ) ; » assert That « ( this . annotation . » get Type « ( ) ) . » is Equal To « ( » Enum Annotation « . class ) ; » assert That « ( this . annotation . » get Value « ( " » enum Value « " ) ) . contains ( » Example Enum « . ONE ) ; » assert That « ( this . annotation . » get Value « ( " » enum Array Value « " ) ) . contains ( new » Example Enum « [ ] { » Example Enum « . ONE , » Example Enum « . TWO } ) ; }
@Test { » Composite Iterator « < String > it = new » Composite Iterator « < > ( ) ; » assert That « ( it . » has Next « ( ) ) . » is False « ( ) ; » assert That Exception Of Type « ( » No Such Element Exception « . class ) . » is Thrown By « ( it :: next ) ; }
@Test { List < String > list = Arrays . » as List « ( " 0 " , " 1 " ) ; Iterator < String > iterator = list . iterator ( ) ; » Composite Iterator « < String > it = new » Composite Iterator « < > ( ) ; it . add ( iterator ) ; it . add ( list . iterator ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> it . add ( iterator ) ) ; }
@Test { byte [ ] expected = new byte [ ] { - 0x4f , 0xa , - 0x73 , - 0x4f , 0x64 , - 0x20 , 0x75 , 0x41 , 0x5 , - 0x49 , - 0x57 , - 0x65 , - 0x19 , 0x2e , 0x3f , - 0x1b } ; byte [ ] result = » Digest Utils « . » md 5 Digest « ( bytes ) ; » assert That « ( result ) . as ( " Invalid hash " ) . » is Equal To « ( expected ) ; result = » Digest Utils « . » md 5 Digest « ( new » Byte Array Input Stream « ( bytes ) ) ; » assert That « ( result ) . as ( " Invalid hash " ) . » is Equal To « ( expected ) ; }
@Test { String expected = " » b 10 a 8 db 164 e 0754105 b 7 a 99 be 72 e 3 fe 5 « " ; String hash = » Digest Utils « . » md 5 Digest As Hex « ( bytes ) ; » assert That « ( hash ) . as ( " Invalid hash " ) . » is Equal To « ( expected ) ; hash = » Digest Utils « . » md 5 Digest As Hex « ( new » Byte Array Input Stream « ( bytes ) ) ; » assert That « ( hash ) . as ( " Invalid hash " ) . » is Equal To « ( expected ) ; }
@Test { » Exception Type Filter « filter = new » Exception Type Filter « ( » as List « ( » Runtime Exception « . class ) , null , true ) ; » assert That « ( filter . match ( » Runtime Exception « . class ) ) . » is True « ( ) ; » assert That « ( filter . match ( » Illegal State Exception « . class ) ) . » is True « ( ) ; }
@Test { byte [ ] content = " content " . » get Bytes « ( ) ; » Byte Array Input Stream « in = new » Byte Array Input Stream « ( content ) ; » Byte Array Output Stream « out = new » Byte Array Output Stream « ( content . length ) ; int count = » File Copy Utils « . copy ( in , out ) ; » assert That « ( count ) . » is Equal To « ( content . length ) ; » assert That « ( Arrays . equals ( content , out . » to Byte Array « ( ) ) ) . » is True « ( ) ; }
@Test { byte [ ] content = " content " . » get Bytes « ( ) ; » Byte Array Output Stream « out = new » Byte Array Output Stream « ( content . length ) ; » File Copy Utils « . copy ( content , out ) ; » assert That « ( Arrays . equals ( content , out . » to Byte Array « ( ) ) ) . » is True « ( ) ; }
@Test { byte [ ] content = " content " . » get Bytes « ( ) ; » Byte Array Input Stream « in = new » Byte Array Input Stream « ( content ) ; byte [ ] result = » File Copy Utils « . » copy To Byte Array « ( in ) ; » assert That « ( Arrays . equals ( content , result ) ) . » is True « ( ) ; }
@Test { String content = " content " ; » String Reader « in = new » String Reader « ( content ) ; » String Writer « out = new » String Writer « ( ) ; int count = » File Copy Utils « . copy ( in , out ) ; » assert That « ( count ) . » is Equal To « ( content . length ( ) ) ; » assert That « ( out . » to String « ( ) ) . » is Equal To « ( content ) ; }
@Test { String content = " content " ; » String Writer « out = new » String Writer « ( ) ; » File Copy Utils « . copy ( content , out ) ; » assert That « ( out . » to String « ( ) ) . » is Equal To « ( content ) ; }
@Test { String content = " content " ; » String Reader « in = new » String Reader « ( content ) ; String result = » File Copy Utils « . » copy To String « ( in ) ; » assert That « ( result ) . » is Equal To « ( content ) ; }
@Test { » Fixed Back Off « » back Off « = new » Fixed Back Off « ( ) ; » Back Off Execution « execution = » back Off « . start ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( » Fixed Back Off « . » DEFAULT _ INTERVAL « ) ; } }
@Test { » Fixed Back Off « » back Off « = new » Fixed Back Off « ( 100L , 0L ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( » Back Off Execution « . STOP ) ; }
@Test { » Fixed Back Off « » back Off « = new » Fixed Back Off « ( 200L , 2 ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 200L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 200L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( » Back Off Execution « . STOP ) ; }
@Test { » Fixed Back Off « » back Off « = new » Fixed Back Off « ( 100L , 1 ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 100L ) ; » back Off « . » set Interval « ( 200L ) ; » back Off « . » set Max Attempts « ( 2 ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 200L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( » Back Off Execution « . STOP ) ; }
@Test { » assert That « ( map . » compute If Absent « ( " key " , » key 2 « -> " » value 1 « " ) ) . » is Equal To « ( " » value 1 « " ) ; » assert That « ( map . » compute If Absent « ( " KEY " , » key 1 « -> " » value 2 « " ) ) . » is Equal To « ( " » value 1 « " ) ; » assert That « ( map . » compute If Absent « ( " Key " , key -> " » value 3 « " ) ) . » is Equal To « ( " » value 1 « " ) ; }
@Test { map . put ( " key " , " value " ) ; map . » key Set « ( ) . clear ( ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; map . » key Set « ( ) . remove ( " key " ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; » next And Remove « ( map . » key Set « ( ) . iterator ( ) ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; map . values ( ) . clear ( ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; map . values ( ) . remove ( " value " ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; » next And Remove « ( map . values ( ) . iterator ( ) ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; map . » entry Set « ( ) . clear ( ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; map . » entry Set « ( ) . remove ( map . » entry Set « ( ) . iterator ( ) . next ( ) ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { map . put ( " key " , " value " ) ; » next And Remove « ( map . » entry Set « ( ) . iterator ( ) ) ; » assert That « ( map . size ( ) ) . » is Equal To « ( 0 ) ; map . » compute If Absent « ( " key " , k -> " newvalue " ) ; » assert That « ( map . get ( " key " ) ) . » is Equal To « ( " newvalue " ) ; }
@Test { » assert That « ( » Serialization Utils « . deserialize ( » Serialization Utils « . serialize ( " foo " ) ) ) . » is Equal To « ( " foo " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Serialization Utils « . deserialize ( FOO . » to Byte Array « ( ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Serialization Utils « . serialize ( new Object ( ) ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Serialization Utils « . deserialize ( " foo " . » get Bytes « ( ) ) ) ; }
@Test { » assert That « ( » Serialization Utils « . serialize ( null ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » Serialization Utils « . deserialize ( null ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » stop Watch « :: » get Last Task Time Millis « ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » stop Watch « :: stop ) ; }
@Test { » stop Watch « . start ( ) ; » assert That « ( » stop Watch « . » is Running « ( ) ) . » is True « ( ) ; » stop Watch « . stop ( ) ; » assert That « ( » stop Watch « . » is Running « ( ) ) . » is False « ( ) ; » stop Watch « . start ( ) ; » assert That « ( » stop Watch « . » is Running « ( ) ) . » is True « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( » stop Watch « :: start ) ; }
@Test { » assert That « ( » Collection Utils « . » contains Instance « ( null , this ) ) . as ( " Must return false if supplied Collection argument is null " ) . » is False « ( ) ; }
@Test { List < Instance > list = new » Array List « < > ( ) ; list . add ( new Instance ( " fiona " ) ) ; » assert That « ( » Collection Utils « . » contains Instance « ( list , new Instance ( " fiona " ) ) ) . as ( " Must return false if instance is not in the supplied Collection argument " ) . » is False « ( ) ; }
@Test { List < Instance > list = new » Array List « < > ( ) ; list . add ( new Instance ( " apple " ) ) ; Instance instance = new Instance ( " fiona " ) ; list . add ( instance ) ; » assert That « ( » Collection Utils « . » contains Instance « ( list , instance ) ) . as ( " Must return true if instance is in the supplied Collection argument " ) . » is True « ( ) ; }
@Test { List < Instance > list = new » Array List « < > ( ) ; list . add ( new Instance ( " apple " ) ) ; list . add ( new Instance ( " fiona " ) ) ; » assert That « ( » Collection Utils « . » contains Instance « ( list , null ) ) . as ( " Must return false if null instance is supplied " ) . » is False « ( ) ; }
@Test { List < String > source = new » Array List « < > ( ) ; source . add ( " abc " ) ; source . add ( " def " ) ; source . add ( " ghi " ) ; List < String > candidates = new » Array List « < > ( ) ; candidates . add ( " xyz " ) ; candidates . add ( " def " ) ; candidates . add ( " abc " ) ; » assert That « ( » Collection Utils « . » find First Match « ( source , candidates ) ) . » is Equal To « ( " def " ) ; }
@Test { » assert That « ( » path Matcher « . match ( " / test " , null ) ) . » is False « ( ) ; » assert That « ( » path Matcher « . match ( " / " , null ) ) . » is False « ( ) ; » assert That « ( » path Matcher « . match ( null , null ) ) . » is False « ( ) ; }
@Test { » path Matcher « . » set Trim Tokens « ( true ) ; » assert That « ( » path Matcher « . match ( " / foo / bar " , " / foo / bar " ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » path Matcher « . » extract Uri Template Variables « ( " / web / { id : foo ( bar ) ? } " , " / web / foobar " ) ) . » with Message Containing « ( " The number of capturing groups in the pattern " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » path Matcher « . combine ( " / * » . html « " , " / * » . txt « " ) ) ; }
@Test { » path Matcher « . » set Trim Tokens « ( false ) ; » assert That « ( » path Matcher « . match ( " / group / { » group Name « } / members " , " / group / sales / members " ) ) . » is True « ( ) ; » assert That « ( » path Matcher « . match ( " / group / { » group Name « } / members " , " / group / sales / members " ) ) . » is True « ( ) ; » assert That « ( » path Matcher « . match ( " / group / { » group Name « } / members " , " / Group / Sales / Members " ) ) . » is False « ( ) ; }
@Test { » path Matcher « . » set Case Sensitive « ( false ) ; » assert That « ( » path Matcher « . match ( " / group / { » group Name « } / members " , " / group / sales / members " ) ) . » is True « ( ) ; » assert That « ( » path Matcher « . match ( " / group / { » group Name « } / members " , " / Group / Sales / Members " ) ) . » is True « ( ) ; » assert That « ( » path Matcher « . match ( " / Group / { » group Name « } / Members " , " / group / Sales / members " ) ) . » is True « ( ) ; }
@Test { match ( ) ; » assert That « ( » path Matcher « . » string Matcher Cache « . size ( ) > 20 ) . » is True « ( ) ; for ( int i = 0 ; i < 65536 ; i ++ ) { » path Matcher « . match ( " test " + i , " test " ) ; } » assert That « ( » path Matcher « . » string Matcher Cache « . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » path Matcher « . » set Cache Patterns « ( true ) ; match ( ) ; » assert That « ( » path Matcher « . » string Matcher Cache « . size ( ) > 20 ) . » is True « ( ) ; for ( int i = 0 ; i < 65536 ; i ++ ) { » path Matcher « . match ( " test " + i , " test " + i ) ; } » assert That « ( » path Matcher « . » string Matcher Cache « . size ( ) > 65536 ) . » is True « ( ) ; }
@Test { » path Matcher « . » set Cache Patterns « ( false ) ; match ( ) ; » assert That « ( » path Matcher « . » string Matcher Cache « . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » path Matcher « . » set Path Separator « ( " . " ) ; » assert That « ( » path Matcher « . combine ( " / * » . html « " , " hotel . * " ) ) . as ( " Extension mapping should be disabled with \" . \" as path separator " ) . » is Equal To « ( " / * » . html . hotel « . * " ) ; }
@Test { » assert That « ( » path Matcher « . » is Pattern « ( null ) ) . » is False « ( ) ; }
@Test { » do Test With Class « ( new » Auto Populating List « < > ( » Test Object « . class ) ) ; }
@Test { » do Test With Class « ( new » Auto Populating List « < Object > ( new » Linked List « < > ( ) , » Test Object « . class ) ) ; }
@Test { » do Test With Element Factory « ( new » Auto Populating List « < > ( new » Mock Element Factory « ( ) ) ) ; }
@Test { » do Test With Element Factory « ( new » Auto Populating List « < Object > ( new » Linked List « < > ( ) , new » Mock Element Factory « ( ) ) ) ; }
@Test { » Auto Populating List « < ? > list = new » Auto Populating List « < Object > ( » Test Object « . class ) ; » assert That « ( » Serialization Test Utils « . » serialize And Deserialize « ( list ) ) . » is Equal To « ( list ) ; }
@Test { » Exponential Back Off « » back Off « = new » Exponential Back Off « ( ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 2000L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 3000L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 4500L ) ; }
@Test { » Exponential Back Off « » back Off « = new » Exponential Back Off « ( 100L , 2.0 ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 100L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 200L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 400L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 800L ) ; }
@Test { » Exponential Back Off « » back Off « = new » Exponential Back Off « ( 2000L , 2.0 ) ; » back Off « . » set Max Elapsed Time « ( 4000L ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 2000L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 4000L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( » Back Off Execution « . STOP ) ; }
@Test { » Exponential Back Off « » back Off « = new » Exponential Back Off « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » back Off « . » set Multiplier « ( 0.9 ) ) ; }
@Test { » Exponential Back Off « » back Off « = new » Exponential Back Off « ( 1000L , 2.0 ) ; » back Off « . » set Max Interval « ( 50L ) ; » Back Off Execution « execution = » back Off « . start ( ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 50L ) ; » assert That « ( execution . » next Back Off « ( ) ) . » is Equal To « ( 50L ) ; }
@Test { String text = " foo = $ { foo } " ; Properties props = new Properties ( ) ; props . » set Property « ( " foo " , " bar " ) ; » assert That « ( this . helper . » replace Placeholders « ( text , props ) ) . » is Equal To « ( " foo = bar " ) ; }
@Test { String text = " foo = $ { foo } , bar = $ { bar } " ; Properties props = new Properties ( ) ; props . » set Property « ( " foo " , " bar " ) ; props . » set Property « ( " bar " , " baz " ) ; » assert That « ( this . helper . » replace Placeholders « ( text , props ) ) . » is Equal To « ( " foo = bar , bar = baz " ) ; }
@Test { String text = " foo = $ { bar } " ; Properties props = new Properties ( ) ; props . » set Property « ( " bar " , " $ { baz } " ) ; props . » set Property « ( " baz " , " bar " ) ; » assert That « ( this . helper . » replace Placeholders « ( text , props ) ) . » is Equal To « ( " foo = bar " ) ; }
@Test { String text = " foo = $ { foo } " ; » Placeholder Resolver « resolver = » placeholder Name « -> " foo " . equals ( » placeholder Name « ) ? " bar " : null ; » assert That « ( this . helper . » replace Placeholders « ( text , resolver ) ) . » is Equal To « ( " foo = bar " ) ; }
@Test { String text = " foo = $ { foo } , bar = $ { bar } " ; Properties props = new Properties ( ) ; props . » set Property « ( " foo " , " bar " ) ; » assert That « ( this . helper . » replace Placeholders « ( text , props ) ) . » is Equal To « ( " foo = bar , bar = $ { bar } " ) ; }
@Test { String text = " foo = $ { foo } , bar = $ { bar } " ; Properties props = new Properties ( ) ; props . » set Property « ( " foo " , " bar " ) ; » Property Placeholder Helper « helper = new » Property Placeholder Helper « ( " $ { " , " } " , null , false ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> helper . » replace Placeholders « ( text , props ) ) ; }
@Test { map . add ( " key " , " » value 1 « " ) ; map . add ( " key " , " » value 2 « " ) ; » assert That « ( map ) . » has Size « ( 1 ) ; » assert That « ( map . get ( " key " ) ) . » contains Exactly « ( " » value 1 « " , " » value 2 « " ) ; }
@Test { map . » add If Absent « ( " key " , " » value 1 « " ) ; » assert That « ( map . get ( " key " ) ) . » contains Exactly « ( " » value 1 « " ) ; }
@Test { map . add ( " key " , " » value 1 « " ) ; map . » add If Absent « ( " key " , " » value 2 « " ) ; » assert That « ( map . get ( " key " ) ) . » contains Exactly « ( " » value 1 « " ) ; }
@Test { map . set ( " key " , " » value 1 « " ) ; map . set ( " key " , " » value 2 « " ) ; » assert That « ( map . get ( " key " ) ) . » contains Exactly « ( " » value 2 « " ) ; }
@Test { map . add ( " key " , " » value 1 « " ) ; map . » add All « ( " key " , Arrays . » as List « ( " » value 2 « " , " » value 3 « " ) ) ; » assert That « ( map ) . » has Size « ( 1 ) ; » assert That « ( map . get ( " key " ) ) . » contains Exactly « ( " » value 1 « " , " » value 2 « " , " » value 3 « " ) ; }
@Test { map . » add All « ( " key " , Collections . » empty List « ( ) ) ; » assert That « ( map ) . » has Size « ( 1 ) ; » assert That « ( map . get ( " key " ) ) . » is Empty « ( ) ; » assert That « ( map . » get First « ( " key " ) ) . » is Null « ( ) ; }
@Test { List < String > values = new » Array List « < > ( 2 ) ; values . add ( " » value 1 « " ) ; values . add ( " » value 2 « " ) ; map . put ( " key " , values ) ; » assert That « ( map . » get First « ( " key " ) ) . » is Equal To « ( " » value 1 « " ) ; » assert That « ( map . » get First « ( " other " ) ) . » is Null « ( ) ; }
@Test { map . put ( " key " , Collections . » empty List « ( ) ) ; » assert That « ( map . » get First « ( " key " ) ) . » is Null « ( ) ; » assert That « ( map . » get First « ( " other " ) ) . » is Null « ( ) ; }
@Test { List < String > values = new » Array List « < > ( 2 ) ; values . add ( " » value 1 « " ) ; values . add ( " » value 2 « " ) ; map . put ( " key " , values ) ; Map < String , String > » single Value Map « = map . » to Single Value Map « ( ) ; » assert That « ( » single Value Map « ) . » has Size « ( 1 ) ; » assert That « ( » single Value Map « . get ( " key " ) ) . » is Equal To « ( " » value 1 « " ) ; }
@Test { map . put ( " key " , Collections . » empty List « ( ) ) ; Map < String , String > » single Value Map « = map . » to Single Value Map « ( ) ; » assert That « ( » single Value Map « ) . » is Empty « ( ) ; » assert That « ( » single Value Map « . get ( " key " ) ) . » is Null « ( ) ; }
@Test { » Test Object « src = new » Test Object « ( ) ; String dest = new String ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Reflection Utils « . » shallow Copy Field State « ( src , dest ) ) ; }
@Test { » Test Object « src = null ; String dest = new String ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Reflection Utils « . » shallow Copy Field State « ( src , dest ) ) ; }
@Test { » Test Object « src = new » Test Object « ( ) ; String dest = null ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Reflection Utils « . » shallow Copy Field State « ( src , dest ) ) ; }
@Test { » Test Object « src = new » Test Object « ( ) ; » Test Object « dest = new » Test Object « ( ) ; » test Valid Copy « ( src , dest ) ; }
@Test { » Test Object Subclass With New Field « src = new » Test Object Subclass With New Field « ( ) ; » Test Object Subclass With New Field « dest = new » Test Object Subclass With New Field « ( ) ; src . magic = 11 ; » test Valid Copy « ( src , dest ) ; » assert That « ( dest . magic ) . » is Equal To « ( src . magic ) ; » assert That « ( dest . prot ) . » is Equal To « ( src . prot ) ; }
@Test { » Test Object « src = new » Test Object « ( ) ; » Test Object Subclass With New Field « dest = new » Test Object Subclass With New Field « ( ) ; dest . magic = 11 ; » test Valid Copy « ( src , dest ) ; » assert That « ( dest . magic ) . » is Equal To « ( 11 ) ; }
@Test { » Test Object Subclass With Final Field « src = new » Test Object Subclass With Final Field « ( ) ; » Test Object Subclass With Final Field « dest = new » Test Object Subclass With Final Field « ( ) ; » test Valid Copy « ( src , dest ) ; }
@Test { » List Saving Method Callback « mc = new » List Saving Method Callback « ( ) ; » Reflection Utils « . » do With Methods « ( » Test Object Subclass « . class , mc ) ; int » absquatulate Count « = 0 ; for ( String name : mc . » get Method Names « ( ) ) { if ( name . equals ( " absquatulate " ) ) { ++ » absquatulate Count « ; } } » assert That « ( » absquatulate Count « ) . as ( " Found 2 absquatulates " ) . » is Equal To « ( 2 ) ; }
@Test { » assert That « ( » Reflection Utils « . » find Method « ( B . class , " bar " , String . class ) ) . » is Not Null « ( ) ; » assert That « ( » Reflection Utils « . » find Method « ( B . class , " foo " , Integer . class ) ) . » is Not Null « ( ) ; » assert That « ( » Reflection Utils « . » find Method « ( B . class , " » get Class « " ) ) . » is Not Null « ( ) ; }
@Test { » assert That « ( » Reflection Utils « . » find Method « ( B . class , " add " , int . class , int . class , int . class ) ) . » is Not Null « ( ) ; }
@Test { class Foo { @ Override public String » to String « ( ) { return super . » to String « ( ) ; } } int » to String Method Count « = 0 ; for ( Method method : » Reflection Utils « . » get All Declared Methods « ( Foo . class ) ) { if ( method . » get Name « ( ) . equals ( " » to String « " ) ) { » to String Method Count « ++ ; } } » assert That « ( » to String Method Count « ) . » is Equal To « ( 2 ) ; }
@Test { class Foo { @ Override public String » to String « ( ) { return super . » to String « ( ) ; } } int » to String Method Count « = 0 ; for ( Method method : » Reflection Utils « . » get Unique Declared Methods « ( Foo . class ) ) { if ( method . » get Name « ( ) . equals ( " » to String « " ) ) { » to String Method Count « ++ ; } } » assert That « ( » to String Method Count « ) . » is Equal To « ( 1 ) ; }
@Test { Method [ ] » m 1 « = » Reflection Utils « . » get Declared Methods « ( A . class ) ; Method [ ] » m 2 « = » Reflection Utils « . » get Declared Methods « ( A . class ) ; » assert That « ( » m 1 « ) . » is Not Same As « ( » m 2 « ) ; }
@Test { » Instance Filter « < String > filter = new » Instance Filter « < > ( null , null , true ) ; match ( filter , " foo " ) ; match ( filter , " bar " ) ; }
@Test { » Instance Filter « < String > filter = new » Instance Filter « < > ( » as List « ( " First " , " Second " ) , null , true ) ; match ( filter , " Second " ) ; » do Not Match « ( filter , " foo " ) ; }
@Test { » Instance Filter « < String > filter = new » Instance Filter « < > ( null , » as List « ( " First " , " Second " ) , true ) ; » do Not Match « ( filter , " Second " ) ; match ( filter , " foo " ) ; }
@Test { » Instance Filter « < String > filter = new » Instance Filter « < > ( » as List « ( " foo " , " Bar " ) , » as List « ( " First " , " Second " ) , true ) ; » do Not Match « ( filter , " Second " ) ; match ( filter , " foo " ) ; }
@Test { » Instance Filter « < String > filter = new » Instance Filter « < > ( » as List « ( " First " ) , » as List « ( " First " ) , true ) ; » do Not Match « ( filter , " First " ) ; }
@Test { Double decimal = Double . » value Of « ( 3.14d ) ; » assert That « ( » Number Utils « . » convert Number To Target Class « ( decimal , » Big Integer « . class ) ) . » is Equal To « ( new » Big Integer « ( " 3 " ) ) ; }
@Test { String number = " 987459837583750387355346 " ; » Big Decimal « decimal = new » Big Decimal « ( number ) ; » assert That « ( » Number Utils « . » convert Number To Target Class « ( decimal , » Big Integer « . class ) ) . » is Equal To « ( new » Big Integer « ( number ) ) ; }
@Test { » Big Decimal « decimal = new » Big Decimal « ( " 987459837583750387355346.14 " ) ; » assert That « ( » Number Utils « . » convert Number To Target Class « ( decimal , » Big Integer « . class ) ) . » is Equal To « ( new » Big Integer « ( " 987459837583750387355346 " ) ) ; }
@Test { String » big Decimal As String « = " 0.10 " ; Number » big Decimal « = » Number Utils « . » parse Number « ( » big Decimal As String « , » Big Decimal « . class ) ; » assert That « ( » big Decimal « ) . » is Equal To « ( new » Big Decimal « ( » big Decimal As String « ) ) ; }
@Test { String » big Decimal As String « = " 0.001 " ; Number » big Decimal « = » Number Utils « . » parse Number « ( » big Decimal As String « , » Big Decimal « . class ) ; » assert That « ( » big Decimal « ) . » is Equal To « ( new » Big Decimal « ( » big Decimal As String « ) ) ; }
@Test { String » big Decimal As String « = " 3.14159265358979323846 " ; Number » big Decimal « = » Number Utils « . » parse Number « ( » big Decimal As String « , » Big Decimal « . class ) ; » assert That « ( » big Decimal « ) . » is Equal To « ( new » Big Decimal « ( » big Decimal As String « ) ) ; }
@Test { String » big Decimal As String « = " 0.10 " ; » Number Format « » number Format « = » Number Format « . » get Instance « ( Locale . ENGLISH ) ; Number » big Decimal « = » Number Utils « . » parse Number « ( » big Decimal As String « , » Big Decimal « . class , » number Format « ) ; » assert That « ( » big Decimal « ) . » is Equal To « ( new » Big Decimal « ( » big Decimal As String « ) ) ; }
@Test { String » big Decimal As String « = " 0.001 " ; » Number Format « » number Format « = » Number Format « . » get Instance « ( Locale . ENGLISH ) ; Number » big Decimal « = » Number Utils « . » parse Number « ( » big Decimal As String « , » Big Decimal « . class , » number Format « ) ; » assert That « ( » big Decimal « ) . » is Equal To « ( new » Big Decimal « ( » big Decimal As String « ) ) ; }
@Test { String » big Decimal As String « = " 3.14159265358979323846 " ; » Number Format « » number Format « = » Number Format « . » get Instance « ( Locale . ENGLISH ) ; Number » big Decimal « = » Number Utils « . » parse Number « ( » big Decimal As String « , » Big Decimal « . class , » number Format « ) ; » assert That « ( » big Decimal « ) . » is Equal To « ( new » Big Decimal « ( » big Decimal As String « ) ) ; }
@Test { System . » set Property « ( " test . prop " , " bar " ) ; try { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { test . prop } " ) ; » assert That « ( resolved ) . » is Equal To « ( " bar " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { System . » set Property « ( " test . prop " , " bar " ) ; try { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { test . prop : foo } " ) ; » assert That « ( resolved ) . » is Equal To « ( " bar " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { System . » set Property « ( " test . prop " , " bar " ) ; try { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { » test . prop « : # { » foo . bar « } } " ) ; » assert That « ( resolved ) . » is Equal To « ( " bar " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { System . » set Property « ( " test . prop " , " bar " ) ; try { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { » test . prop « : Y # { » foo . bar « } X } " ) ; » assert That « ( resolved ) . » is Equal To « ( " bar " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; } }
@Test { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { test . prop : foo } " ) ; » assert That « ( resolved ) . » is Equal To « ( " foo " ) ; }
@Test { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { » test . prop « : # { » foo . bar « } } " ) ; » assert That « ( resolved ) . » is Equal To « ( " # { » foo . bar « } " ) ; }
@Test { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { » test . prop « : Y # { » foo . bar « } X } " ) ; » assert That « ( resolved ) . » is Equal To « ( " Y # { » foo . bar « } X " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » System Property Utils « . » resolve Placeholders « ( " $ { test . prop } " ) ) ; }
@Test { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { test . prop } " , true ) ; » assert That « ( resolved ) . » is Equal To « ( " $ { test . prop } " ) ; }
@Test { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { test . prop : } " ) ; » assert That « ( resolved ) . » is Equal To « ( " " ) ; }
@Test { System . » set Property « ( " test . prop " , " foo = $ { bar } " ) ; System . » set Property « ( " bar " , " baz " ) ; try { String resolved = » System Property Utils « . » resolve Placeholders « ( " $ { test . prop } " ) ; » assert That « ( resolved ) . » is Equal To « ( " foo = baz " ) ; } finally { System . » get Properties « ( ) . remove ( " test . prop " ) ; System . » get Properties « ( ) . remove ( " bar " ) ; } }
@Test { Map < String , String > env = System . getenv ( ) ; if ( env . » contains Key « ( " PATH " ) ) { String text = " $ { PATH } " ; » assert That « ( » System Property Utils « . » resolve Placeholders « ( text ) ) . » is Equal To « ( env . get ( " PATH " ) ) ; } }
@Test { » assert That « ( » Pattern Match Utils « . » simple Match « ( ( String ) null , " " ) ) . » is Equal To « ( false ) ; » assert That « ( » Pattern Match Utils « . » simple Match « ( " 1 " , null ) ) . » is Equal To « ( false ) ; » do Test « ( " * " , " 123 " , true ) ; » do Test « ( " 123 " , " 123 " , true ) ; }
@Test { » do Test « ( " get * " , " » get Me « " , true ) ; » do Test « ( " get * " , " » set Me « " , false ) ; }
@Test { » do Test « ( " * Test " , " » get Me Test « " , true ) ; » do Test « ( " * Test " , " » set Me « " , false ) ; }
@Test { » do Test « ( " * stuff * " , " » get Me Test « " , false ) ; » do Test « ( " * stuff * " , " » getstuff Test « " , true ) ; » do Test « ( " * stuff * " , " » stuff Test « " , true ) ; » do Test « ( " * stuff * " , " getstuff " , true ) ; » do Test « ( " * stuff * " , " stuff " , true ) ; }
@Test { » do Test « ( " on * Event " , " » on My Event « " , true ) ; » do Test « ( " on * Event " , " » on Event « " , true ) ; » do Test « ( " 3 * 3 " , " 3 " , false ) ; » do Test « ( " 3 * 3 " , " 33 " , true ) ; }
@Test { » do Test « ( " 12 * 45 * 78 " , " 12345678 " , true ) ; » do Test « ( " 12 * 45 * 78 " , " 123456789 " , false ) ; » do Test « ( " 12 * 45 * 78 " , " 01234567 8 " , false ) ; » do Test « ( " 12 * 45 * 78 " , " 124578 " , true ) ; » do Test « ( " 12 * 45 * 78 " , " 1245457878 " , true ) ; » do Test « ( " 3 * 3 * 3 " , " 33 " , false ) ; » do Test « ( " 3 * 3 * 3 " , " 333 " , true ) ; }
@Test { » do Test « ( " * 1 * 2 * 3 * " , " 0011002001010030020201030 " , true ) ; » do Test « ( " 1 * 2 * 3 * 4 " , " 10300204 " , false ) ; » do Test « ( " 1 * 2 * 3 * 3 " , " 10300203 " , false ) ; » do Test « ( " * 1 * 2 * 3 * " , " 123 " , true ) ; » do Test « ( " * 1 * 2 * 3 * " , " 132 " , false ) ; }
@Test { » assert That « ( this . baos . capacity ( ) ) . » is Equal To « ( » INITIAL _ CAPACITY « ) ; this . baos . write ( » hello Bytes « ) ; int size = 64 ; this . baos . resize ( size ) ; » assert That « ( this . baos . capacity ( ) ) . » is Equal To « ( size ) ; » assert Byte Array Equals String « ( this . baos ) ; }
@Test { » assert That « ( this . baos . capacity ( ) ) . » is Equal To « ( » INITIAL _ CAPACITY « ) ; for ( int i = 0 ; i < 129 ; i ++ ) { this . baos . write ( 0 ) ; } » assert That « ( this . baos . capacity ( ) ) . » is Equal To « ( 256 ) ; }
@Test { » assert That « ( this . baos . capacity ( ) ) . » is Equal To « ( » INITIAL _ CAPACITY « ) ; this . baos . write ( » hello Bytes « ) ; this . baos . grow ( 1000 ) ; » assert That « ( this . baos . capacity ( ) ) . » is Equal To « ( ( this . » hello Bytes « . length + 1000 ) ) ; » assert Byte Array Equals String « ( this . baos ) ; }
@Test { this . baos . write ( » hello Bytes « ) ; » assert Byte Array Equals String « ( this . baos ) ; }
@Test { this . baos . write ( » hello Bytes « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . baos . resize ( 5 ) ) ; }
@Test { String » prop String « = " » code 1 « = » message 1 « \n » code 2 « : » message 2 « " ; Properties props = » load Properties « ( » prop String « , false ) ; String » prop Copy « = » store Properties « ( props , null , false ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « \t = \t » message 1 « \n » code 2 « \t : \t mess \\\n \t » age 2 « " ; Properties props = » load Properties « ( » prop String « , false ) ; String » prop Copy « = » store Properties « ( props , null , false ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « = » message 1 « \n » code 2 « : » message 2 « " ; Properties props = » load Properties « ( » prop String « , false ) ; String » prop Copy « = » store Properties « ( props , " » my Header « " , false ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « = » message 1 « \n » code 2 « : » message 2 « \n » code 3 « = " ; Properties props = » load Properties « ( » prop String « , false ) ; String » prop Copy « = » store Properties « ( props , null , false ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « = » message 1 « \n » code 2 « : » message 2 « " ; Properties props = » load Properties « ( » prop String « , true ) ; String » prop Copy « = » store Properties « ( props , null , true ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « \t = \t » message 1 « \n » code 2 « \t : \t mess \\\n \t » age 2 « " ; Properties props = » load Properties « ( » prop String « , true ) ; String » prop Copy « = » store Properties « ( props , null , true ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « \t = \t » message 1 « \n » code 2 « \t : \t » message 2 « " ; Properties props = » load Properties « ( » prop String « , true ) ; String » prop Copy « = » store Properties « ( props , " » my Header « " , true ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { String » prop String « = " » code 1 « = » message 1 « \n » code 2 « : » message 2 « \n » code 3 « = " ; Properties props = » load Properties « ( » prop String « , true ) ; String » prop Copy « = » store Properties « ( props , null , true ) ; » load Properties « ( » prop Copy « , false ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert That « ( this . » hello Bytes « . length ) . » is Equal To « ( this . os . size ( ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; int » size Before « = this . os . size ( ) ; this . os . resize ( 64 ) ; » assert Byte Array Equals String « ( this . os ) ; » assert That « ( this . os . size ( ) ) . » is Equal To « ( » size Before « ) ; }
@Test { this . os . resize ( 1 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { this . os . write ( 1 ) ; } » assert That « ( this . os . size ( ) ) . » is Equal To « ( 10 ) ; » assert That « ( new byte [ ] { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ) . » is Equal To « ( this . os . » to Byte Array « ( ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert Byte Array Equals String « ( this . os ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert Byte Array Equals String « ( this . os ) ; this . os . reset ( ) ; » assert That « ( this . os . size ( ) ) . » is Equal To « ( 0 ) ; this . os . write ( this . » hello Bytes « ) ; » assert Byte Array Equals String « ( this . os ) ; }
@Test { this . os . close ( ) ; » assert That IO Exception « ( ) . » is Thrown By « ( ( ) -> this . os . write ( this . » hello Bytes « ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert Byte Array Equals String « ( this . os ) ; » assert That « ( this . os . » to Byte Array Unsafe « ( ) ) . » is Same As « ( this . os . » to Byte Array Unsafe « ( ) ) ; » assert That « ( this . » hello Bytes « ) . » is Equal To « ( this . os . » to Byte Array « ( ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert Byte Array Equals String « ( this . os ) ; » Byte Array Output Stream « baos = new » Byte Array Output Stream « ( ) ; this . os . » write To « ( baos ) ; » assert That « ( this . » hello Bytes « ) . » is Equal To « ( baos . » to Byte Array « ( ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . os . resize ( 5 ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert That « ( this . os . » get Input Stream « ( ) ) . » is Not Null « ( ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » assert That « ( this . » hello Bytes « . length ) . » is Equal To « ( this . os . » get Input Stream « ( ) . available ( ) ) ; }
@Test { byte [ ] bytes = new byte [ ] { - 1 } ; this . os . write ( bytes ) ; » Input Stream « » input Stream « = this . os . » get Input Stream « ( ) ; » Byte Array Input Stream « bais = new » Byte Array Input Stream « ( bytes ) ; » assert That « ( » input Stream « . read ( ) ) . » is Equal To « ( bais . read ( ) ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » Input Stream « » input Stream « = this . os . » get Input Stream « ( ) ; byte [ ] actual = new byte [ » input Stream « . available ( ) ] ; int » bytes Read « = » input Stream « . read ( actual ) ; » assert That « ( » bytes Read « ) . » is Equal To « ( this . » hello Bytes « . length ) ; » assert That « ( actual ) . » is Equal To « ( this . » hello Bytes « ) ; » assert That « ( » input Stream « . available ( ) ) . » is Equal To « ( 0 ) ; }
@Test { this . os . write ( this . » hello Bytes « ) ; » Input Stream « » input Stream « = this . os . » get Input Stream « ( ) ; » assert That « ( this . » hello Bytes « . length ) . » is Equal To « ( » input Stream « . skip ( 1000 ) ) ; » assert That « ( » input Stream « . available ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » String Builder « builder = new » String Builder « ( " \" 0 " ) ; this . os . write ( this . » hello Bytes « ) ; » Input Stream « » input Stream « = this . os . » get Input Stream « ( ) ; » Digest Utils « . » append Md 5 Digest As Hex « ( » input Stream « , builder ) ; builder . append ( " \" " ) ; String actual = builder . » to String « ( ) ; » assert That « ( actual ) . » is Equal To « ( " \" 0b10 » a 8 db 164 e 0754105 b 7 a 99 be 72 e 3 fe 5 « \" " ) ; }
@Test { » String Builder « builder = new » String Builder « ( " \" 0 " ) ; for ( int i = 0 ; i < 30 ; i ++ ) { this . os . write ( this . » hello Bytes « ) ; } » Input Stream « » input Stream « = this . os . » get Input Stream « ( ) ; » Digest Utils « . » append Md 5 Digest As Hex « ( » input Stream « , builder ) ; builder . append ( " \" " ) ; String actual = builder . » to String « ( ) ; » assert That « ( actual ) . » is Equal To « ( " \" 06225 » ca 1 e 4533354 c 516 e 74512065331 d « \" " ) ; }
@Test { » Input Stream « » input Stream « = spy ( new » Byte Array Input Stream « ( bytes ) ) ; byte [ ] actual = » Stream Utils « . » copy To Byte Array « ( » input Stream « ) ; » assert That « ( actual ) . » is Equal To « ( bytes ) ; verify ( » input Stream « , never ( ) ) . close ( ) ; }
@Test { Charset charset = Charset . » default Charset « ( ) ; » Input Stream « » input Stream « = spy ( new » Byte Array Input Stream « ( string . » get Bytes « ( charset ) ) ) ; String actual = » Stream Utils « . » copy To String « ( » input Stream « , charset ) ; » assert That « ( actual ) . » is Equal To « ( string ) ; verify ( » input Stream « , never ( ) ) . close ( ) ; }
@Test { » Byte Array Output Stream « out = spy ( new » Byte Array Output Stream « ( ) ) ; » Stream Utils « . copy ( bytes , out ) ; » assert That « ( out . » to Byte Array « ( ) ) . » is Equal To « ( bytes ) ; verify ( out , never ( ) ) . close ( ) ; }
@Test { Charset charset = Charset . » default Charset « ( ) ; » Byte Array Output Stream « out = spy ( new » Byte Array Output Stream « ( ) ) ; » Stream Utils « . copy ( string , charset , out ) ; » assert That « ( out . » to Byte Array « ( ) ) . » is Equal To « ( string . » get Bytes « ( charset ) ) ; verify ( out , never ( ) ) . close ( ) ; }
@Test { » Byte Array Output Stream « out = spy ( new » Byte Array Output Stream « ( ) ) ; » Stream Utils « . copy ( new » Byte Array Input Stream « ( bytes ) , out ) ; » assert That « ( out . » to Byte Array « ( ) ) . » is Equal To « ( bytes ) ; verify ( out , never ( ) ) . close ( ) ; }
@Test { » Byte Array Output Stream « out = spy ( new » Byte Array Output Stream « ( ) ) ; » Stream Utils « . » copy Range « ( new » Byte Array Input Stream « ( bytes ) , out , 0 , 100 ) ; byte [ ] range = Arrays . » copy Of Range « ( bytes , 0 , 101 ) ; » assert That « ( out . » to Byte Array « ( ) ) . » is Equal To « ( range ) ; verify ( out , never ( ) ) . close ( ) ; }
@Test { » Concurrent Reference Hash Map « < Integer , String > map = new » Concurrent Reference Hash Map « < > ( ) ; » assert That « ( map . » get Segments Size « ( ) ) . » is Equal To « ( 16 ) ; » assert That « ( map . » get Segment « ( 0 ) . » get Size « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( map . » get Load Factor « ( ) ) . » is Equal To « ( 0.75f ) ; }
@Test { » Concurrent Reference Hash Map « < Integer , String > map = new » Concurrent Reference Hash Map « < > ( 32 ) ; » assert That « ( map . » get Segments Size « ( ) ) . » is Equal To « ( 16 ) ; » assert That « ( map . » get Segment « ( 0 ) . » get Size « ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( map . » get Load Factor « ( ) ) . » is Equal To « ( 0.75f ) ; }
@Test { » Concurrent Reference Hash Map « < Integer , String > map = new » Concurrent Reference Hash Map « < > ( 32 , 0.5f ) ; » assert That « ( map . » get Segments Size « ( ) ) . » is Equal To « ( 16 ) ; » assert That « ( map . » get Segment « ( 0 ) . » get Size « ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( map . » get Load Factor « ( ) ) . » is Equal To « ( 0.5f ) ; }
@Test { » Concurrent Reference Hash Map « < Integer , String > map = new » Concurrent Reference Hash Map « < > ( 16 , 2 ) ; » assert That « ( map . » get Segments Size « ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( map . » get Segment « ( 0 ) . » get Size « ( ) ) . » is Equal To « ( 8 ) ; » assert That « ( map . » get Load Factor « ( ) ) . » is Equal To « ( 0.75f ) ; }
@Test { » Concurrent Reference Hash Map « < Integer , String > map = new » Concurrent Reference Hash Map « < > ( 5 , 0.5f , 3 ) ; » assert That « ( map . » get Segments Size « ( ) ) . » is Equal To « ( 4 ) ; » assert That « ( map . » get Segment « ( 0 ) . » get Size « ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( map . » get Load Factor « ( ) ) . » is Equal To « ( 0.5f ) ; }
@Test { new » Concurrent Reference Hash Map « < Integer , String > ( 0 , 1 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Test Weak Concurrent Cache « < Integer , String > ( - 1 , 1 ) ) . » with Message Containing « ( " Initial capacity must not be negative " ) ; }
@Test { new » Concurrent Reference Hash Map « < Integer , String > ( 0 , 0.1f , 1 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Test Weak Concurrent Cache « < Integer , String > ( 0 , 0.0f , 1 ) ) . » with Message Containing « ( " Load factor must be positive " ) ; }
@Test { new » Concurrent Reference Hash Map « < Integer , String > ( 1 , 1 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Test Weak Concurrent Cache « < Integer , String > ( 1 , 0 ) ) . » with Message Containing « ( " Concurrency level must be positive " ) ; }
@Test { » assert That « ( this . map ) . » has Size « ( 0 ) ; this . map . put ( 123 , " 123 " ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map ) . » has Size « ( 1 ) ; this . map . put ( 123 , " 123 b " ) ; » assert That « ( this . map ) . » has Size « ( 1 ) ; this . map . put ( 123 , null ) ; » assert That « ( this . map ) . » has Size « ( 1 ) ; }
@Test { this . map . put ( 123 , " 321 " ) ; this . map . put ( 123 , " 123 " ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 123 " ) ; }
@Test { » assert That « ( this . map . get ( null ) ) . » is Null « ( ) ; » assert That « ( this . map . » get Or Default « ( null , " 456 " ) ) . » is Equal To « ( " 456 " ) ; this . map . put ( null , " 123 " ) ; » assert That « ( this . map . get ( null ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map . » get Or Default « ( null , " 456 " ) ) . » is Equal To « ( " 123 " ) ; }
@Test { » assert That « ( this . map . get ( 123 ) ) . » is Null « ( ) ; }
@Test { Integer key = 123 ; this . map . put ( key , " 123 " ) ; » assert That « ( this . map . » get Supplemental Hash « ( ) ) . » is Not Equal To « ( key . » hash Code « ( ) ) ; » assert That « ( this . map . » get Supplemental Hash « ( ) > > 30 & 0xFF ) . » is Not Equal To « ( 0 ) ; }
@Test { » assert That « ( this . map . » put If Absent « ( 123 , " 123 " ) ) . » is Null « ( ) ; » assert That « ( this . map . » put If Absent « ( 123 , " 123 b " ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 123 " ) ; }
@Test { » assert That « ( this . map . » put If Absent « ( 123 , null ) ) . » is Null « ( ) ; » assert That « ( this . map . » put If Absent « ( 123 , " 123 " ) ) . » is Null « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Null « ( ) ; }
@Test { » assert That « ( this . map . » put If Absent « ( null , " 123 " ) ) . » is Null « ( ) ; » assert That « ( this . map . » put If Absent « ( null , " 123 b " ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map . get ( null ) ) . » is Equal To « ( " 123 " ) ; }
@Test { this . map . put ( 123 , " 123 " ) ; » assert That « ( this . map . remove ( 123 , " 456 " ) ) . » is False « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map . remove ( 123 , " 123 " ) ) . » is True « ( ) ; » assert That « ( this . map . » contains Key « ( 123 ) ) . » is False « ( ) ; » assert That « ( this . map . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { this . map . put ( 123 , null ) ; » assert That « ( this . map . remove ( 123 , " 456 " ) ) . » is False « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Null « ( ) ; » assert That « ( this . map . remove ( 123 , null ) ) . » is True « ( ) ; » assert That « ( this . map . » contains Key « ( 123 ) ) . » is False « ( ) ; » assert That « ( this . map . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { this . map . put ( 123 , " 123 " ) ; » assert That « ( this . map . replace ( 123 , " 456 " , " 789 " ) ) . » is False « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map . replace ( 123 , " 123 " , " 789 " ) ) . » is True « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 789 " ) ; }
@Test { this . map . put ( 123 , null ) ; » assert That « ( this . map . replace ( 123 , " 456 " , " 789 " ) ) . » is False « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Null « ( ) ; » assert That « ( this . map . replace ( 123 , null , " 789 " ) ) . » is True « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 789 " ) ; }
@Test { this . map . put ( 123 , " 123 " ) ; » assert That « ( this . map . replace ( 123 , " 456 " ) ) . » is Equal To « ( " 123 " ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 456 " ) ; }
@Test { this . map . put ( 123 , null ) ; » assert That « ( this . map . replace ( 123 , " 456 " ) ) . » is Null « ( ) ; » assert That « ( this . map . get ( 123 ) ) . » is Equal To « ( " 456 " ) ; }
@Test { » assert That « ( this . map ) . » has Size « ( 0 ) ; this . map . put ( 123 , " 123 " ) ; this . map . put ( 123 , null ) ; this . map . put ( 456 , " 456 " ) ; » assert That « ( this . map ) . » has Size « ( 2 ) ; }
@Test { » assert That « ( this . map . » is Empty « ( ) ) . » is True « ( ) ; this . map . put ( 123 , " 123 " ) ; this . map . put ( 123 , null ) ; this . map . put ( 456 , " 456 " ) ; » assert That « ( this . map . » is Empty « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . map . » contains Key « ( 123 ) ) . » is False « ( ) ; » assert That « ( this . map . » contains Key « ( 456 ) ) . » is False « ( ) ; this . map . put ( 123 , " 123 " ) ; this . map . put ( 456 , null ) ; » assert That « ( this . map . » contains Key « ( 123 ) ) . » is True « ( ) ; » assert That « ( this . map . » contains Key « ( 456 ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . map . » contains Value « ( " 123 " ) ) . » is False « ( ) ; » assert That « ( this . map . » contains Value « ( null ) ) . » is False « ( ) ; this . map . put ( 123 , " 123 " ) ; this . map . put ( 456 , null ) ; » assert That « ( this . map . » contains Value « ( " 123 " ) ) . » is True « ( ) ; » assert That « ( this . map . » contains Value « ( null ) ) . » is True « ( ) ; }
@Test { this . map . put ( 123 , null ) ; this . map . put ( 456 , " 456 " ) ; this . map . put ( null , " 789 " ) ; » assert That « ( this . map . remove ( 123 ) ) . » is Null « ( ) ; » assert That « ( this . map . remove ( 456 ) ) . » is Equal To « ( " 456 " ) ; » assert That « ( this . map . remove ( null ) ) . » is Equal To « ( " 789 " ) ; » assert That « ( this . map . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . map . remove ( 123 ) ) . » is Null « ( ) ; » assert That « ( this . map . remove ( null ) ) . » is Null « ( ) ; » assert That « ( this . map . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { this . map . put ( 123 , " 123 " ) ; this . map . put ( 456 , null ) ; this . map . put ( null , " 789 " ) ; this . map . clear ( ) ; » assert That « ( this . map ) . » has Size « ( 0 ) ; » assert That « ( this . map . » contains Key « ( 123 ) ) . » is False « ( ) ; » assert That « ( this . map . » contains Key « ( 456 ) ) . » is False « ( ) ; » assert That « ( this . map . » contains Key « ( null ) ) . » is False « ( ) ; }
@Test { this . map . put ( 123 , " 123 " ) ; this . map . put ( 456 , null ) ; this . map . put ( null , " 789 " ) ; Set < Integer > expected = new » Hash Set « < > ( ) ; expected . add ( 123 ) ; expected . add ( 456 ) ; expected . add ( null ) ; » assert That « ( this . map . » key Set « ( ) ) . » is Equal To « ( expected ) ; }
@Test { this . map . put ( 123 , " 123 " ) ; this . map . put ( 456 , null ) ; this . map . put ( null , " 789 " ) ; » Hash Map « < Integer , String > expected = new » Hash Map « < > ( ) ; expected . put ( 123 , " 123 " ) ; expected . put ( 456 , null ) ; expected . put ( null , " 789 " ) ; » assert That « ( this . map . » entry Set « ( ) ) . » is Equal To « ( expected . » entry Set « ( ) ) ; }
@Test { this . map = new » Test Weak Concurrent Cache « < > ( 1 , 10.0f , 1 ) ; this . map . put ( 1 , " 1 " ) ; this . map . put ( 2 , " 2 " ) ; this . map . put ( 3 , " 3 " ) ; » Hash Map « < Integer , String > expected = new » Hash Map « < > ( ) ; expected . put ( 1 , " 1 " ) ; expected . put ( 2 , " 2 " ) ; expected . put ( 3 , " 3 " ) ; » assert That « ( this . map . » entry Set « ( ) ) . » is Equal To « ( expected . » entry Set « ( ) ) ; }
@Test { map . » create Reference Manager « ( ) . » create Reference « ( null , 1234 , null ) ; }
@Test { » assert That « ( » Class Utils « . » is Present « ( " java . lang . String " , » class Loader « ) ) . » is True « ( ) ; » assert That « ( » Class Utils « . » is Present « ( " java . lang . » My Special String « " , » class Loader « ) ) . » is False « ( ) ; }
@Test { String » class Name « = » Class Utils « . » get Short Name « ( » get Class « ( ) ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " » Class Utils Tests « " ) ; }
@Test { String » class Name « = » Class Utils « . » get Short Name « ( Object [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " Object [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Short Name « ( Object [ ] [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " Object [ ] [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Short Name « ( byte [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " byte [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Short Name « ( byte [ ] [ ] [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " byte [ ] [ ] [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Short Name « ( » Inner Class « . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " » Class Utils Tests « . » Inner Class « " ) ; }
@Test { String » short Name « = » Class Utils « . » get Short Name As Property « ( this . » get Class « ( ) ) ; » assert That « ( » short Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " » class Utils Tests « " ) ; }
@Test { » assert That « ( » Class Utils « . » get Class File Name « ( String . class ) ) . » is Equal To « ( " String . class " ) ; » assert That « ( » Class Utils « . » get Class File Name « ( » get Class « ( ) ) ) . » is Equal To « ( " » Class Utils Tests « . class " ) ; }
@Test { » assert That « ( » Class Utils « . » get Package Name « ( String . class ) ) . » is Equal To « ( " java . lang " ) ; » assert That « ( » Class Utils « . » get Package Name « ( » get Class « ( ) ) ) . » is Equal To « ( » get Class « ( ) . » get Package « ( ) . » get Name « ( ) ) ; }
@Test { String » class Name « = » Class Utils « . » get Qualified Name « ( » get Class « ( ) ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " org . springframework . util . » Class Utils Tests « " ) ; }
@Test { String » class Name « = » Class Utils « . » get Qualified Name « ( Object [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " java . lang . Object [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Qualified Name « ( Object [ ] [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " java . lang . Object [ ] [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Qualified Name « ( byte [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " byte [ ] " ) ; }
@Test { String » class Name « = » Class Utils « . » get Qualified Name « ( byte [ ] [ ] . class ) ; » assert That « ( » class Name « ) . as ( " Class name did not match " ) . » is Equal To « ( " byte [ ] [ ] " ) ; }
@Test { » assert That « ( » Class Utils « . » has Method « ( Collection . class , " size " ) ) . » is True « ( ) ; » assert That « ( » Class Utils « . » has Method « ( Collection . class , " remove " , Object . class ) ) . » is True « ( ) ; » assert That « ( » Class Utils « . » has Method « ( Collection . class , " remove " ) ) . » is False « ( ) ; » assert That « ( » Class Utils « . » has Method « ( Collection . class , " » some Other Method « " ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Class Utils « . » get Method Count For Name « ( » Overloaded Methods Class « . class , " print " ) ) . as ( " Verifying number of overloaded 'print' methods for » Overloaded Methods Class « . " ) . » is Equal To « ( 2 ) ; » assert That « ( » Class Utils « . » get Method Count For Name « ( » Sub Overloaded Methods Class « . class , " print " ) ) . as ( " Verifying number of overloaded 'print' methods for » Sub Overloaded Methods Class « . " ) . » is Equal To « ( 4 ) ; }
@Test { » assert That « ( » Class Utils « . » has At Least One Method With Name « ( » Test Object « . class , " foobar " ) ) . » is False « ( ) ; » assert That « ( » Class Utils « . » has At Least One Method With Name « ( » Test Object « . class , " » hash Code « " ) ) . » is True « ( ) ; » assert That « ( » Class Utils « . » has At Least One Method With Name « ( » Test Object « . class , " » set Age « " ) ) . » is True « ( ) ; }
@Test { Method method = » Class Utils « . » get Static Method « ( » Inner Class « . class , " » static Method « " ) ; method . invoke ( null , ( Object [ ] ) null ) ; » assert That « ( » Inner Class « . » no Arg Called « ) . as ( " no argument method was not invoked . " ) . » is True « ( ) ; }
@Test { Method method = » Class Utils « . » get Static Method « ( » Inner Class « . class , " » arg Static Method « " , String . class ) ; method . invoke ( null , " test " ) ; » assert That « ( » Inner Class « . » arg Called « ) . as ( " argument method was not invoked . " ) . » is True « ( ) ; }
@Test { Method method = » Class Utils « . » get Static Method « ( » Inner Class « . class , " » static Method « " , String . class ) ; method . invoke ( null , " test " ) ; » assert That « ( » Inner Class « . » overloaded Called « ) . as ( " argument method was not invoked . " ) . » is True « ( ) ; }
@Test { String result = » Class Utils « . » class Package As Resource Path « ( Proxy . class ) ; » assert That « ( result ) . » is Equal To « ( " java / lang / reflect " ) ; }
@Test { » assert That « ( » is Empty « ( null ) ) . » is True « ( ) ; }
@Test { » assert That « ( » is Empty « ( new char [ 0 ] ) ) . » is True « ( ) ; » assert That « ( » is Empty « ( new Object [ 0 ] ) ) . » is True « ( ) ; » assert That « ( » is Empty « ( new Integer [ 0 ] ) ) . » is True « ( ) ; » assert That « ( » is Empty « ( new int [ ] { 42 } ) ) . » is False « ( ) ; » assert That « ( » is Empty « ( new Integer [ ] { 42 } ) ) . » is False « ( ) ; }
@Test { » assert That « ( » is Empty « ( Collections . » empty List « ( ) ) ) . » is True « ( ) ; » assert That « ( » is Empty « ( Collections . » empty Set « ( ) ) ) . » is True « ( ) ; Set < String > set = new » Hash Set « < > ( ) ; set . add ( " foo " ) ; » assert That « ( » is Empty « ( set ) ) . » is False « ( ) ; » assert That « ( » is Empty « ( Arrays . » as List « ( " foo " ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( » is Empty « ( Collections . » empty Map « ( ) ) ) . » is True « ( ) ; » Hash Map « < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " foo " , 42L ) ; » assert That « ( » is Empty « ( map ) ) . » is False « ( ) ; }
@Test { » assert That « ( » is Empty « ( new » String Builder « ( ) ) ) . » is True « ( ) ; » assert That « ( » is Empty « ( " " ) ) . » is True « ( ) ; » assert That « ( » is Empty « ( new » String Builder « ( " foo " ) ) ) . » is False « ( ) ; » assert That « ( » is Empty « ( " " ) ) . » is False « ( ) ; » assert That « ( » is Empty « ( " \t " ) ) . » is False « ( ) ; » assert That « ( » is Empty « ( " foo " ) ) . » is False « ( ) ; }
@Test { » assert That « ( » is Empty « ( 42L ) ) . » is False « ( ) ; » assert That « ( » is Empty « ( new Object ( ) ) ) . » is False « ( ) ; }
@Test { int [ ] a = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; Integer [ ] wrapper = ( Integer [ ] ) » Object Utils « . » to Object Array « ( a ) ; » assert That « ( wrapper . length == 5 ) . » is True « ( ) ; for ( int i = 0 ; i < wrapper . length ; i ++ ) { » assert That « ( wrapper [ i ] . » int Value « ( ) ) . » is Equal To « ( a [ i ] ) ; } }
@Test { Object [ ] objects = » Object Utils « . » to Object Array « ( null ) ; » assert That « ( objects ) . » is Not Null « ( ) ; » assert That « ( objects . length ) . » is Equal To « ( 0 ) ; }
@Test { Object [ ] objects = » Object Utils « . » to Object Array « ( new byte [ ] { } ) ; » assert That « ( objects ) . » is Not Null « ( ) ; » assert That « ( objects . length ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Object Utils « . » to Object Array « ( " Not an [ ] " ) ) ; }
@Test { String [ ] source = new String [ ] { " Bingo " } ; » assert That « ( » Object Utils « . » to Object Array « ( source ) ) . » is Equal To « ( source ) ; }
@Test { String [ ] array = new String [ ] { " foo " , " bar " } ; String » new Element « = " baz " ; Object [ ] » new Array « = » Object Utils « . » add Object To Array « ( array , » new Element « ) ; » assert That « ( » new Array « . length ) . » is Equal To « ( 3 ) ; » assert That « ( » new Array « [ 2 ] ) . » is Equal To « ( » new Element « ) ; }
@Test { String [ ] array = new String [ 0 ] ; String » new Element « = " foo " ; String [ ] » new Array « = » Object Utils « . » add Object To Array « ( array , » new Element « ) ; » assert That « ( » new Array « . length ) . » is Equal To « ( 1 ) ; » assert That « ( » new Array « [ 0 ] ) . » is Equal To « ( » new Element « ) ; }
@Test { String » existing Element « = " foo " ; String [ ] array = new String [ ] { » existing Element « } ; String » new Element « = " bar " ; String [ ] » new Array « = » Object Utils « . » add Object To Array « ( array , » new Element « ) ; » assert That « ( » new Array « . length ) . » is Equal To « ( 2 ) ; » assert That « ( » new Array « [ 0 ] ) . » is Equal To « ( » existing Element « ) ; » assert That « ( » new Array « [ 1 ] ) . » is Equal To « ( » new Element « ) ; }
@Test { String [ ] array = new String [ ] { null } ; String » new Element « = " bar " ; String [ ] » new Array « = » Object Utils « . » add Object To Array « ( array , » new Element « ) ; » assert That « ( » new Array « . length ) . » is Equal To « ( 2 ) ; » assert That « ( » new Array « [ 0 ] ) . » is Equal To « ( null ) ; » assert That « ( » new Array « [ 1 ] ) . » is Equal To « ( » new Element « ) ; }
@Test { String » new Element « = " foo " ; String [ ] » new Array « = » Object Utils « . » add Object To Array « ( null , » new Element « ) ; » assert That « ( » new Array « . length ) . » is Equal To « ( 1 ) ; » assert That « ( » new Array « [ 0 ] ) . » is Equal To « ( » new Element « ) ; }
@Test { Object [ ] » new Array « = » Object Utils « . » add Object To Array « ( null , null ) ; » assert That « ( » new Array « . length ) . » is Equal To « ( 1 ) ; » assert That « ( » new Array « [ 0 ] ) . » is Equal To « ( null ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Equals « ( new String [ ] { " a " , " b " , " c " } , new String [ ] { " a " , " b " , " c " } ) ) . » is True « ( ) ; » assert That « ( » Object Utils « . » null Safe Equals « ( new int [ ] { 1 , 2 , 3 } , new int [ ] { 1 , 2 , 3 } ) ) . » is True « ( ) ; }
@Test { int expected = Boolean . FALSE . » hash Code « ( ) ; » assert That « ( » Object Utils « . » hash Code « ( false ) ) . » is Equal To « ( expected ) ; }
@Test { int expected = Boolean . TRUE . » hash Code « ( ) ; » assert That « ( » Object Utils « . » hash Code « ( true ) ) . » is Equal To « ( expected ) ; }
@Test { double dbl = 9830.43 ; int expected = ( new Double ( dbl ) ) . » hash Code « ( ) ; » assert That « ( » Object Utils « . » hash Code « ( dbl ) ) . » is Equal To « ( expected ) ; }
@Test { float flt = 34.8f ; int expected = ( new Float ( flt ) ) . » hash Code « ( ) ; » assert That « ( » Object Utils « . » hash Code « ( flt ) ) . » is Equal To « ( expected ) ; }
@Test { long lng = 883L ; int expected = ( new Long ( lng ) ) . » hash Code « ( ) ; » assert That « ( » Object Utils « . » hash Code « ( lng ) ) . » is Equal To « ( expected ) ; }
@Test { Object obj = new Object ( ) ; String expected = obj . » get Class « ( ) . » get Name « ( ) + " @ " + » Object Utils « . » get Identity Hex String « ( obj ) ; String actual = » Object Utils « . » identity To String « ( obj ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » identity To String « ( null ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Array « ( boolean [ ] . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Array « ( Object [ ] . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Array « ( String . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( boolean . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Boolean . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( byte . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Byte . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Character . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( char . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( double . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Double . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( float . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Float . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( int . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Integer . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( long . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Long . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Object . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( short . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Class Utils « . » is Primitive Or Wrapper « ( Short . class ) ) . » is True « ( ) ; }
@Test { int expected = 31 * 7 + Boolean . TRUE . » hash Code « ( ) ; expected = 31 * expected + Boolean . FALSE . » hash Code « ( ) ; boolean [ ] array = { true , false } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( boolean [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { int expected = 31 * 7 + 8 ; expected = 31 * expected + 10 ; byte [ ] array = { 8 , 10 } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( byte [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { int expected = 31 * 7 + ' a ' ; expected = 31 * expected + ' E ' ; char [ ] array = { ' a ' , ' E ' } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( char [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { long bits = Double . » double To Long Bits « ( 8449.65 ) ; int expected = 31 * 7 + ( int ) ( bits ^ ( bits > > > 32 ) ) ; bits = Double . » double To Long Bits « ( 9944.923 ) ; expected = 31 * expected + ( int ) ( bits ^ ( bits > > > 32 ) ) ; double [ ] array = { 8449.65 , 9944.923 } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( double [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { int expected = 31 * 7 + Float . » float To Int Bits « ( 9.6f ) ; expected = 31 * expected + Float . » float To Int Bits « ( 7.4f ) ; float [ ] array = { 9.6f , 7.4f } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( float [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { int expected = 31 * 7 + 884 ; expected = 31 * expected + 340 ; int [ ] array = { 884 , 340 } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( int [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { long lng = 7993L ; int expected = 31 * 7 + ( int ) ( lng ^ ( lng > > > 32 ) ) ; lng = 84320L ; expected = 31 * expected + ( int ) ( lng ^ ( lng > > > 32 ) ) ; long [ ] array = { 7993L , 84320L } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( long [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { String str = " Luke " ; » assert That « ( » Object Utils « . » null Safe Hash Code « ( str ) ) . » is Equal To « ( str . » hash Code « ( ) ) ; }
@Test { int expected = 31 * 7 + " Leia " . » hash Code « ( ) ; expected = 31 * expected + " Han " . » hash Code « ( ) ; Object [ ] array = { " Leia " , " Han " } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( Object [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { Object array = new boolean [ ] { true , false } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( boolean [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new byte [ ] { 6 , 39 } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( byte [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new char [ ] { ' l ' , ' M ' } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( char [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new double [ ] { 68930.993 , 9022.009 } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( double [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new float [ ] { 9.9f , 9.54f } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( float [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new int [ ] { 89 , 32 } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( int [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new long [ ] { 4389 , 320 } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( long [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new Object [ ] { " Luke " , " Anakin " } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( Object [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { Object array = new short [ ] { 5 , 3 } ; int expected = » Object Utils « . » null Safe Hash Code « ( ( short [ ] ) array ) ; » assert Equal Hash Codes « ( expected , array ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( Object ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { int expected = 31 * 7 + 70 ; expected = 31 * expected + 8 ; short [ ] array = { 70 , 8 } ; int actual = » Object Utils « . » null Safe Hash Code « ( array ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe Hash Code « ( ( short [ ] ) null ) ) . » is Equal To « ( 0 ) ; }
@Test { boolean [ ] array = { true , false } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { true , false } " ) ; }
@Test { boolean [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( boolean [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { byte [ ] array = { 5 , 8 } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 5 , 8 } " ) ; }
@Test { byte [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( byte [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { char [ ] array = { ' A ' , ' B ' } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 'A' , 'B' } " ) ; }
@Test { char [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( char [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { double [ ] array = { 8594.93 , 8594023.95 } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 8594.93 , 8594023.95 } " ) ; }
@Test { double [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( double [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { float [ ] array = { 8.6f , 43.8f } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 8.6 , 43.8 } " ) ; }
@Test { float [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( float [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { int [ ] array = { 9 , 64 } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 9 , 64 } " ) ; }
@Test { int [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( int [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { long [ ] array = { 434L , 23423L } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 434 , 23423 } " ) ; }
@Test { long [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( long [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( " I shoh love tha taste of mangoes " ) ) . » is Equal To « ( " I shoh love tha taste of mangoes " ) ; }
@Test { Object [ ] array = { " Han " , Long . » value Of « ( 43 ) } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { Han , 43 } " ) ; }
@Test { Object [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( Object [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { short [ ] array = { 7 , 9 } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { 7 , 9 } " ) ; }
@Test { short [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( short [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { String [ ] array = { " Luke " , " Anakin " } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { Luke , Anakin } " ) ; }
@Test { String [ ] array = { } ; » assert That « ( » Object Utils « . » null Safe To String « ( array ) ) . » is Equal To « ( " { } " ) ; }
@Test { » assert That « ( » Object Utils « . » null Safe To String « ( ( String [ ] ) null ) ) . » is Equal To « ( " null " ) ; }
@Test { String blank = " " ; » assert That « ( » String Utils « . » has Text « ( blank ) ) . » is Equal To « ( false ) ; }
@Test { » assert That « ( » String Utils « . » has Text « ( null ) ) . » is Equal To « ( false ) ; » assert That « ( » String Utils « . » has Text « ( " " ) ) . » is Equal To « ( false ) ; }
@Test { » assert That « ( » String Utils « . » has Text « ( " t " ) ) . » is Equal To « ( true ) ; }
@Test { » assert That « ( » String Utils « . quote ( " » my String « " ) ) . » is Equal To « ( " 'myString' " ) ; » assert That « ( » String Utils « . quote ( " " ) ) . » is Equal To « ( " '' " ) ; » assert That « ( » String Utils « . quote ( null ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » String Utils « . » quote If String « ( " » my String « " ) ) . » is Equal To « ( " 'myString' " ) ; » assert That « ( » String Utils « . » quote If String « ( " " ) ) . » is Equal To « ( " '' " ) ; » assert That « ( » String Utils « . » quote If String « ( 5 ) ) . » is Equal To « ( Integer . » value Of « ( 5 ) ) ; » assert That « ( » String Utils « . » quote If String « ( null ) ) . » is Null « ( ) ; }
@Test { String qualified = " i . am . not . unqualified " ; » assert That « ( » String Utils « . unqualify ( qualified ) ) . » is Equal To « ( " unqualified " ) ; }
@Test { String capitalized = " i am not capitalized " ; » assert That « ( » String Utils « . capitalize ( capitalized ) ) . » is Equal To « ( " I am not capitalized " ) ; }
@Test { String capitalized = " I am capitalized " ; » assert That « ( » String Utils « . uncapitalize ( capitalized ) ) . » is Equal To « ( " i am capitalized " ) ; }
@Test { String [ ] input = new String [ ] { " » my String 2 « " , " » my String 1 « " , " » my String 2 « " } ; input = » String Utils « . » remove Duplicate Strings « ( input ) ; » assert That « ( input [ 0 ] ) . » is Equal To « ( " » my String 2 « " ) ; » assert That « ( input [ 1 ] ) . » is Equal To « ( " » my String 1 « " ) ; }
@Test { String [ ] input = new String [ ] { " » key 1 « = » value 1 « " , " » key 2 « = \" » value 2 « \" " } ; Properties result = » String Utils « . » split Array Elements Into Properties « ( input , " = " ) ; » assert That « ( result . » get Property « ( " » key 1 « " ) ) . » is Equal To « ( " » value 1 « " ) ; » assert That « ( result . » get Property « ( " » key 2 « " ) ) . » is Equal To « ( " \" » value 2 « \" " ) ; }
@Test { String [ ] input = new String [ ] { " » key 1 « = » value 1 « " , " » key 2 « = \" » value 2 « \" " } ; Properties result = » String Utils « . » split Array Elements Into Properties « ( input , " = " , " \" " ) ; » assert That « ( result . » get Property « ( " » key 1 « " ) ) . » is Equal To « ( " » value 1 « " ) ; » assert That « ( result . » get Property « ( " » key 2 « " ) ) . » is Equal To « ( " » value 2 « " ) ; }
@Test { String [ ] sa = » String Utils « . » tokenize To String Array « ( " a , b , , c " , " , " ) ; » assert That « ( sa . length ) . » is Equal To « ( 3 ) ; » assert That « ( sa [ 0 ] . equals ( " a " ) && sa [ 1 ] . equals ( " b " ) && sa [ 2 ] . equals ( " c " ) ) . as ( " components are correct " ) . » is True « ( ) ; }
@Test { String [ ] sa = » String Utils « . » tokenize To String Array « ( " a , b , , c " , " , " , true , false ) ; » assert That « ( sa . length ) . » is Equal To « ( 4 ) ; » assert That « ( sa [ 0 ] . equals ( " a " ) && sa [ 1 ] . equals ( " b " ) && sa [ 2 ] . equals ( " " ) && sa [ 3 ] . equals ( " c " ) ) . as ( " components are correct " ) . » is True « ( ) ; }
@Test { String [ ] sa = » String Utils « . » tokenize To String Array « ( " a , b , c " , " , " , false , true ) ; » assert That « ( sa . length ) . » is Equal To « ( 3 ) ; » assert That « ( sa [ 0 ] . equals ( " a " ) && sa [ 1 ] . equals ( " b " ) && sa [ 2 ] . equals ( " c " ) ) . as ( " components are correct " ) . » is True « ( ) ; }
@Test { String [ ] sa = » String Utils « . » comma Delimited List To String Array « ( null ) ; » assert That « ( sa != null ) . as ( " String array is » n ' t « null with null input " ) . » is True « ( ) ; » assert That « ( sa . length == 0 ) . as ( " String array length == 0 with null input " ) . » is True « ( ) ; }
@Test { String [ ] sa = » String Utils « . » comma Delimited List To String Array « ( " " ) ; » assert That « ( sa != null ) . as ( " String array is » n ' t « null with null input " ) . » is True « ( ) ; » assert That « ( sa . length == 0 ) . as ( " String array length == 0 with null input " ) . » is True « ( ) ; }
@Test { String [ ] sa = » String Utils « . » delimited List To String Array « ( " a , b " , " , " ) ; » assert That « ( sa . length ) . » is Equal To « ( 2 ) ; » assert That « ( sa [ 0 ] ) . » is Equal To « ( " a " ) ; » assert That « ( sa [ 1 ] ) . » is Equal To « ( " b " ) ; }
@Test { String [ ] sa = » String Utils « . » delimited List To String Array « ( " a ; b " , " ; " ) ; » assert That « ( sa . length ) . » is Equal To « ( 2 ) ; » assert That « ( sa [ 0 ] ) . » is Equal To « ( " a " ) ; » assert That « ( sa [ 1 ] ) . » is Equal To « ( " b " ) ; }
@Test { String [ ] sa = » String Utils « . » delimited List To String Array « ( " a , b " , " " ) ; » assert That « ( sa . length ) . » is Equal To « ( 3 ) ; » assert That « ( sa [ 0 ] ) . » is Equal To « ( " a " ) ; » assert That « ( sa [ 1 ] ) . » is Equal To « ( " , " ) ; » assert That « ( sa [ 2 ] ) . » is Equal To « ( " b " ) ; }
@Test { String [ ] sa = » String Utils « . » delimited List To String Array « ( " a , b " , null ) ; » assert That « ( sa . length ) . » is Equal To « ( 1 ) ; » assert That « ( sa [ 0 ] ) . » is Equal To « ( " a , b " ) ; }
@Test { String s = " woeirqupoiewuropqiewuorpqiwueopriquwopeiurqopwieur " ; String [ ] sa = » String Utils « . » comma Delimited List To String Array « ( s ) ; » assert That « ( sa . length == 1 ) . as ( " Found one String with no delimiters " ) . » is True « ( ) ; » assert That « ( sa [ 0 ] . equals ( s ) ) . as ( " Single array entry matches input String with no delimiters " ) . » is True « ( ) ; }
@Test { String [ ] sa = new String [ ] { " » xcvwert 4456346 « & * . " , " /// " , " . ! " , " . " , " ; " } ; » do Test Comma Delimited List To String Array Legal Match « ( sa ) ; }
@Test { Locale » expected Locale « = Locale . UK ; Locale locale = » String Utils « . » parse Locale String « ( » expected Locale « . » to String « ( ) ) ; » assert That « ( locale ) . as ( " When given a bona - fide Locale string , must not return null . " ) . » is Not Null « ( ) ; » assert That « ( locale ) . » is Equal To « ( » expected Locale « ) ; }
@Test { Locale locale = » String Utils « . » parse Locale String « ( " » _ banjo _ on _ my _ knee « " ) ; » assert That « ( locale ) . as ( " When given a malformed Locale string , must not return null . " ) . » is Not Null « ( ) ; }
@Test { Locale locale = » String Utils « . » parse Locale String « ( " " ) ; » assert That « ( locale ) . as ( " When given an empty Locale string , must return null . " ) . » is Null « ( ) ; }
@Test { String variant = " proper - northern " ; String » locale String « = " » en _ GB _ « " + variant ; Locale locale = » String Utils « . » parse Locale String « ( » locale String « ) ; » assert That « ( locale . » get Variant « ( ) ) . as ( " Multi - valued variant portion of the Locale not extracted correctly . " ) . » is Equal To « ( variant ) ; }
@Test { String variant = " » proper _ northern « " ; String » locale String « = " » en _ GB _ « " + variant ; Locale locale = » String Utils « . » parse Locale String « ( » locale String « ) ; » assert That « ( locale . » get Variant « ( ) ) . as ( " Multi - valued variant portion of the Locale not extracted correctly . " ) . » is Equal To « ( variant ) ; }
@Test { String variant = " proper northern " ; String » locale String « = " en GB " + variant ; Locale locale = » String Utils « . » parse Locale String « ( » locale String « ) ; » assert That « ( locale . » get Variant « ( ) ) . as ( " Multi - valued variant portion of the Locale not extracted correctly . " ) . » is Equal To « ( variant ) ; }
@Test { String variant = " proper northern " ; String » locale String « = " » en _ GB _ « " + variant ; Locale locale = » String Utils « . » parse Locale String « ( » locale String « ) ; » assert That « ( locale . » get Variant « ( ) ) . as ( " Multi - valued variant portion of the Locale not extracted correctly . " ) . » is Equal To « ( variant ) ; }
@Test { String variant = " » proper _ northern « " ; String » locale String « = " » en _ GB _____ « " + variant ; Locale locale = » String Utils « . » parse Locale String « ( » locale String « ) ; » assert That « ( locale . » get Variant « ( ) ) . as ( " Multi - valued variant portion of the Locale not extracted correctly . " ) . » is Equal To « ( variant ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » String Utils « . » parse Locale String « ( " % » 0 D « % » 0 A Content - length : 30 « % » 0 D « % » 0 A « % » 0 D « % » 0 A « % » 3 Cscript « % » 3 Ealert « % 28123 % 29 % » 3 C / script « % » 3 E « " ) ) ; }
@Test { » assert That « ( » String Utils « . » parse Locale String « ( " » tr _ tr « " ) . » to String « ( ) ) . » is Equal To « ( " » tr _ TR « " ) ; » assert That « ( » String Utils « . » parse Locale String « ( " » bg _ bg _ vnt « " ) . » to String « ( ) ) . » is Equal To « ( " » bg _ BG _ vnt « " ) ; }
@Test { String variant = " » G Btest « " ; String » locale String « = " » en _ GB _ « " + variant ; Locale locale = » String Utils « . » parse Locale String « ( » locale String « ) ; » assert That « ( locale . » get Variant « ( ) ) . as ( " Variant containing country code not extracted correctly " ) . » is Equal To « ( variant ) ; }
@Test { » assert That « ( » String Utils « . » parse Locale String « ( " » sr __ « # LATN " ) . » to String « ( ) ) . » is Equal To « ( " » sr __ « # LATN " ) ; }
@Test { for ( Locale locale : Locale . » get Available Locales « ( ) ) { Locale » parsed Locale « = » String Utils « . » parse Locale String « ( locale . » to String « ( ) ) ; if ( » parsed Locale « == null ) { » assert That « ( locale . » get Language « ( ) ) . » is Equal To « ( " " ) ; } else { » assert That « ( locale . » to String « ( ) ) . » is Equal To « ( » parsed Locale « . » to String « ( ) ) ; } } }
@Test { for ( Locale locale : Locale . » get Available Locales « ( ) ) { Locale » parsed Locale « = » String Utils « . » parse Locale « ( locale . » to Language Tag « ( ) ) ; if ( » parsed Locale « == null ) { » assert That « ( locale . » get Language « ( ) ) . » is Equal To « ( " " ) ; } else { » assert That « ( locale . » to Language Tag « ( ) ) . » is Equal To « ( » parsed Locale « . » to Language Tag « ( ) ) ; } } }
@Test { » assert That « ( » String Utils « . » parse Locale String « ( " invalid " ) ) . » is Equal To « ( new Locale ( " invalid " ) ) ; » assert That « ( » String Utils « . » parse Locale String « ( " invalidvalue " ) ) . » is Equal To « ( new Locale ( " invalidvalue " ) ) ; » assert That « ( » String Utils « . » parse Locale String « ( " » invalidvalue _ foo « " ) ) . » is Equal To « ( new Locale ( " invalidvalue " , " foo " ) ) ; » assert That « ( » String Utils « . » parse Locale String « ( " " ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » String Utils « . » parse Locale « ( " invalid " ) ) . » is Equal To « ( new Locale ( " invalid " ) ) ; » assert That « ( » String Utils « . » parse Locale « ( " invalidvalue " ) ) . » is Equal To « ( new Locale ( " invalidvalue " ) ) ; » assert That « ( » String Utils « . » parse Locale « ( " » invalidvalue _ foo « " ) ) . » is Equal To « ( new Locale ( " invalidvalue " , " foo " ) ) ; » assert That « ( » String Utils « . » parse Locale « ( " " ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » String Utils « . split ( " Hello , world " , " " ) ) . » is Null « ( ) ; » assert That « ( » String Utils « . split ( " " , " , " ) ) . » is Null « ( ) ; » assert That « ( » String Utils « . split ( null , " , " ) ) . » is Null « ( ) ; » assert That « ( » String Utils « . split ( " Hello , world " , null ) ) . » is Null « ( ) ; » assert That « ( » String Utils « . split ( null , null ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mime Type « ( " text " , " / " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type « . » value Of « ( " audio " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type « . » value Of « ( " audio / " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type « . » value Of « ( " audio ( / basic " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type « . » value Of « ( " audio / basic ) " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type « . » value Of « ( " text / html ; charset = foo - bar " ) ) ; }
@Test { » Conversion Service « » conversion Service « = new » Default Conversion Service « ( ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , » Mime Type « . class ) ) . » is True « ( ) ; » Mime Type « » mime Type « = » Mime Type « . » value Of « ( " application / xml " ) ; » assert That « ( » conversion Service « . convert ( " application / xml " , » Mime Type « . class ) ) . » is Equal To « ( » mime Type « ) ; }
@Test { » Mime Type « » mime Type « = new » Mime Type « ( " text " , " plain " ) ; String result = » mime Type « . » to String « ( ) ; » assert That « ( result ) . as ( " Invalid » to String « ( ) returned " ) . » is Equal To « ( " text / plain " ) ; }
@Test { String s = " » audio / « * " ; » Mime Type « » mime Type « = » Mime Type Utils « . » parse Mime Type « ( s ) ; » assert That « ( » mime Type « . » get Type « ( ) ) . as ( " Invalid type " ) . » is Equal To « ( " audio " ) ; » assert That « ( » mime Type « . » get Subtype « ( ) ) . as ( " Invalid subtype " ) . » is Equal To « ( " * " ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " audio " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " audio / " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " * / json " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " audio ( / basic " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " audio / basic ) " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " ; a = b " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; » = value « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; » attr = « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; attr < » = value « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; » attr = v « > alue " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " text / html ; charset = foo - bar " ) ) ; }
@Test { » Mime Type « » mime Type « = » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; » attr = « \" v > alue \" " ) ; » assert That « ( » mime Type « . » get Parameter « ( " attr " ) ) . » is Equal To « ( " \" v > alue \" " ) ; }
@Test { » Mime Type « » mime Type « = » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; » attr = « ' v > alue ' " ) ; » assert That « ( » mime Type « . » get Parameter « ( " attr " ) ) . » is Equal To « ( " 'v>alue' " ) ; }
@Test { » Mime Type « » mime Type « = » Mime Type Utils « . » parse Mime Type « ( " multipart / x - mixed - replace ; boundary = -- myboundary " ) ; » assert That « ( » mime Type « . » get Parameter « ( " boundary " ) ) . » is Equal To « ( " -- myboundary " ) ; }
@Test { » Mime Type « » mime Type « = » Mime Type Utils « . » parse Mime Type « ( " text / plain ; foo = \" bar \" " ) ; » assert That « ( » mime Type « . » get Parameter « ( " foo " ) ) . » is Equal To « ( " \" bar \" " ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( " » audio / « * ; » attr = « \" " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » Mime Type Utils « . » parse Mime Type « ( null ) ) ; }
@Test { List < » Mime Type « > » mime Types « = » Mime Type Utils « . » parse Mime Types « ( " text / plain , text / html , " ) ; » assert That « ( » mime Types « ) . as ( " No mime types returned " ) . » is Not Null « ( ) ; » assert That « ( » mime Types « . size ( ) ) . as ( " Incorrect number of mime types " ) . » is Equal To « ( 2 ) ; }
@Test { » test With Quoted Parameters « ( " foo / bar ; param = \" , \" " ) ; » test With Quoted Parameters « ( " foo / bar ; param = \" s , a , \" " ) ; » test With Quoted Parameters « ( " foo / bar ; param = \" s , \" " , " text / x - c " ) ; » test With Quoted Parameters « ( " foo / bar ; param = \" a \\\" b , c \" " ) ; » test With Quoted Parameters « ( " foo / bar ; param = \" \\\\\" " ) ; » test With Quoted Parameters « ( " » foo / bar « ; » param = « \" \\ , \\\" " ) ; }
@Test { Assert . state ( true , " enigma " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> Assert . state ( false , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . state ( true , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> Assert . state ( false , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> Assert . state ( false , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » is True « ( true , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is True « ( false , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . » is True « ( true , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is True « ( false , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is True « ( false , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » is Null « ( null , " Bla " ) ; }
@Test { Assert . » is Null « ( null , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Null « ( " foo " , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Null « ( " foo " , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » not Null « ( " foo " , " enigma " ) ; }
@Test { Assert . » not Null « ( " foo " , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Null « ( null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Null « ( null , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » has Length « ( " I Heart ... " , " enigma " ) ; }
@Test { Assert . » has Length « ( " \t " , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Length « ( " " , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Length « ( null , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . » has Length « ( " foo " , ( ) -> " enigma " ) ; }
@Test { Assert . » has Length « ( " \t " , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Length « ( " " , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Length « ( null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Length « ( null , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » has Text « ( " foo " , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( " \t " , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( " " , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( null , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . » has Text « ( " foo " , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( " \t " , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( " " , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » has Text « ( null , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » does Not Contain « ( null , " rod " , " enigma " ) ; }
@Test { Assert . » does Not Contain « ( " A cool chick » ' s « name is Brod . " , null , " enigma " ) ; }
@Test { Assert . » does Not Contain « ( " A cool chick » ' s « name is Brod . " , " " , " enigma " ) ; }
@Test { Assert . » does Not Contain « ( null , null , " enigma " ) ; }
@Test { Assert . » does Not Contain « ( " foo " , " bar " , ( ) -> " enigma " ) ; }
@Test { Assert . » does Not Contain « ( null , " bar " , ( ) -> " enigma " ) ; }
@Test { Assert . » does Not Contain « ( " foo " , null , ( ) -> " enigma " ) ; }
@Test { Assert . » does Not Contain « ( null , null , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » does Not Contain « ( " 1234 " , " 23 " , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » does Not Contain « ( " 1234 " , " 23 " , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » not Empty « ( new String [ ] { " 1234 " } , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( new String [ ] { } , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( ( Object [ ] ) null , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . » not Empty « ( new String [ ] { " 1234 " } , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( new String [ ] { } , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( ( Object [ ] ) null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( new String [ ] { } , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » no Null Elements « ( new String [ ] { " 1234 " } , " enigma " ) ; }
@Test { Assert . » no Null Elements « ( new String [ ] { } , " enigma " ) ; }
@Test { Assert . » no Null Elements « ( new String [ ] { " 1234 " } , ( ) -> " enigma " ) ; }
@Test { Assert . » no Null Elements « ( new String [ ] { } , ( ) -> " enigma " ) ; }
@Test { Assert . » no Null Elements « ( ( Object [ ] ) null , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » no Null Elements « ( new String [ ] { " foo " , null , " bar " } , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » no Null Elements « ( new String [ ] { " foo " , null , " bar " } , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » not Empty « ( » singleton List « ( " foo " ) , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( » empty List « ( ) , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( ( Collection < ? > ) null , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . » not Empty « ( » singleton List « ( " foo " ) , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( » empty List « ( ) , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( ( Collection < ? > ) null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( » empty List « ( ) , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » not Empty « ( » singleton Map « ( " foo " , " bar " ) , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( ( Map < ? , ? > ) null , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( » empty Map « ( ) , " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { Assert . » not Empty « ( » singleton Map « ( " foo " , " bar " ) , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( » empty Map « ( ) , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( ( Map < ? , ? > ) null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » not Empty « ( » empty Map « ( ) , ( Supplier < String > ) null ) ) . » with Message « ( null ) ; }
@Test { Assert . » is Instance Of « ( String . class , " foo " , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( null , " foo " , " enigma " ) ) . » with Message Containing « ( " Type to check against must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , null , " enigma " ) ) . » with Message Containing « ( " enigma : null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , 42L , ( String ) null ) ) . » with Message Containing « ( " Object of class [ java . lang . Long ] must be an instance of class java . lang . String " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , 42L , " Custom message " ) ) . » with Message Containing « ( " Custom message : java . lang . Long " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , 42L , " Custom message : " ) ) . » with Message Containing « ( " Custom message : Object of class [ java . lang . Long ] must be an instance of class java . lang . String " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , 42L , " Custom message for " ) ) . » with Message Containing « ( " Custom message for java . lang . Long " ) ; }
@Test { Assert . » is Instance Of « ( String . class , " foo " , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( null , " foo " , ( ) -> " enigma " ) ) . » with Message Containing « ( " Type to check against must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma : null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , 42L , ( Supplier < String > ) null ) ) . » with Message Containing « ( " Object of class [ java . lang . Long ] must be an instance of class java . lang . String " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Instance Of « ( String . class , 42L , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma : java . lang . Long " ) ; }
@Test { Assert . » is Assignable « ( Number . class , Integer . class , " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( null , Integer . class , " enigma " ) ) . » with Message Containing « ( " Super type to check against must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( Integer . class , null , " enigma " ) ) . » with Message Containing « ( " enigma : null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( String . class , Integer . class , ( String ) null ) ) . » with Message Containing « ( " class java . lang . Integer is not assignable to class java . lang . String " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( String . class , Integer . class , " Custom message " ) ) . » with Message Containing « ( " Custom message : class java . lang . Integer " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( String . class , Integer . class , " Custom message : " ) ) . » with Message Containing « ( " Custom message : class java . lang . Integer is not assignable to class java . lang . String " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( String . class , Integer . class , " Custom message for " ) ) . » with Message Containing « ( " Custom message for class java . lang . Integer " ) ; }
@Test { Assert . » is Assignable « ( Number . class , Integer . class , ( ) -> " enigma " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( null , Integer . class , ( ) -> " enigma " ) ) . » with Message Containing « ( " Super type to check against must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( Integer . class , null , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma : null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( String . class , Integer . class , ( Supplier < String > ) null ) ) . » with Message Containing « ( " class java . lang . Integer is not assignable to class java . lang . String " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> Assert . » is Assignable « ( String . class , Integer . class , ( ) -> " enigma " ) ) . » with Message Containing « ( " enigma : class java . lang . Integer " ) ; }
@Test { new » Socket Utils « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Socket Utils « . » find Available Tcp Port « ( 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Socket Utils « . » find Available Tcp Port « ( - 500 ) ) ; }
@Test { int port = » Socket Utils « . » find Available Tcp Port « ( ) ; » assert Port In Range « ( port , » PORT _ RANGE _ MIN « , » PORT _ RANGE _ MAX « ) ; }
@Test { int » min Max Port « = » Socket Utils « . » find Available Tcp Port « ( ) ; int port = » Socket Utils « . » find Available Tcp Port « ( » min Max Port « , » min Max Port « ) ; » assert That « ( port ) . » is Equal To « ( » min Max Port « ) ; }
@Test { int port = » Socket Utils « . » find Available Tcp Port « ( ) ; » Server Socket « socket = » Server Socket Factory « . » get Default « ( ) . » create Server Socket « ( port , 1 , » Inet Address « . » get By Name « ( " localhost " ) ) ; try { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Socket Utils « . » find Available Tcp Port « ( port , port ) ) . » with Message Starting With « ( " Could not find an available TCP port " ) . » with Message Ending With « ( " after 1 attempts " ) ; } finally { socket . close ( ) ; } }
@Test { int port = » Socket Utils « . » find Available Tcp Port « ( 50000 ) ; » assert Port In Range « ( port , 50000 , » PORT _ RANGE _ MAX « ) ; }
@Test { int » min Port « = 20000 ; int » max Port « = » min Port « + 1000 ; int port = » Socket Utils « . » find Available Tcp Port « ( » min Port « , » max Port « ) ; » assert Port In Range « ( port , » min Port « , » max Port « ) ; }
@Test { » find Available Tcp Ports « ( 4 ) ; }
@Test { » find Available Tcp Ports « ( 50 ) ; }
@Test { » find Available Tcp Ports « ( 4 , 30000 , 35000 ) ; }
@Test { » find Available Tcp Ports « ( 50 , 40000 , 45000 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » find Available Tcp Ports « ( 50 , 45000 , 45010 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Socket Utils « . » find Available Udp Port « ( 0 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Socket Utils « . » find Available Udp Port « ( - 500 ) ) ; }
@Test { int port = » Socket Utils « . » find Available Udp Port « ( ) ; » assert Port In Range « ( port , » PORT _ RANGE _ MIN « , » PORT _ RANGE _ MAX « ) ; }
@Test { int port = » Socket Utils « . » find Available Udp Port « ( ) ; » Datagram Socket « socket = new » Datagram Socket « ( port , » Inet Address « . » get By Name « ( " localhost " ) ) ; try { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Socket Utils « . » find Available Udp Port « ( port , port ) ) . » with Message Starting With « ( " Could not find an available UDP port " ) . » with Message Ending With « ( " after 1 attempts " ) ; } finally { socket . close ( ) ; } }
@Test { int port = » Socket Utils « . » find Available Udp Port « ( 50000 ) ; » assert Port In Range « ( port , 50000 , » PORT _ RANGE _ MAX « ) ; }
@Test { int » min Port « = 20000 ; int » max Port « = » min Port « + 1000 ; int port = » Socket Utils « . » find Available Udp Port « ( » min Port « , » max Port « ) ; » assert Port In Range « ( port , » min Port « , » max Port « ) ; }
@Test { » find Available Udp Ports « ( 4 ) ; }
@Test { » find Available Udp Ports « ( 50 ) ; }
@Test { » find Available Udp Ports « ( 4 , 30000 , 35000 ) ; }
@Test { » find Available Udp Ports « ( 50 , 40000 , 45000 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » find Available Udp Ports « ( 50 , 45000 , 45010 ) ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( " no match " ) ; » assert That Exception Of Type « ( » No Such Method Exception « . class ) . » is Thrown By « ( » method Invoker « :: prepare ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( new Purchaser ( ) ) ; » method Invoker « . prepare ( ) ; String greeting = ( String ) » method Invoker « . invoke ( ) ; » assert That « ( greeting ) . » is Equal To « ( " purchaser : hello " ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( new Shopper ( ) ) ; » method Invoker « . prepare ( ) ; String greeting = ( String ) » method Invoker « . invoke ( ) ; » assert That « ( greeting ) . » is Equal To « ( " purchaser : may I help you ? " ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( new Salesman ( ) ) ; » method Invoker « . prepare ( ) ; String greeting = ( String ) » method Invoker « . invoke ( ) ; » assert That « ( greeting ) . » is Equal To « ( " greetable : how are sales ? " ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( new Customer ( ) ) ; » method Invoker « . prepare ( ) ; String greeting = ( String ) » method Invoker « . invoke ( ) ; » assert That « ( greeting ) . » is Equal To « ( " customer : good day " ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( new Regular ( " Kotter " ) ) ; » method Invoker « . prepare ( ) ; String greeting = ( String ) » method Invoker « . invoke ( ) ; » assert That « ( greeting ) . » is Equal To « ( " regular : welcome back Kotter " ) ; }
@Test { » Method Invoker « » method Invoker « = new » Method Invoker « ( ) ; » method Invoker « . » set Target Object « ( new Greeter ( ) ) ; » method Invoker « . » set Target Method « ( " greet " ) ; » method Invoker « . » set Arguments « ( new VIP ( " Fonzie " ) ) ; » method Invoker « . prepare ( ) ; String greeting = ( String ) » method Invoker « . invoke ( ) ; » assert That « ( greeting ) . » is Equal To « ( " regular : whassup dude ? " ) ; }
@Test { Comparator < String > c = new » Compound Comparator « < > ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> c . compare ( " foo " , " bar " ) ) ; }
@Test { Comparator < Object > comparator = new » Instance Comparator « < > ( » I 1 « . class , » C 3 « . class ) ; » assert That « ( comparator . compare ( » c 1 « , » c 1 « ) ) . » is Equal To « ( 0 ) ; » assert That « ( comparator . compare ( » c 3 « , » c 4 « ) ) . » is Equal To « ( - 1 ) ; » assert That « ( comparator . compare ( » c 3 « , null ) ) . » is Equal To « ( - 1 ) ; » assert That « ( comparator . compare ( » c 4 « , null ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Invertible Comparator « < > ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Invertible Comparator « < > ( null , true ) ) ; }
@Test { » Invertible Comparator « < Integer > » invertible Comparator « = new » Invertible Comparator « < > ( comparator ) ; » assert That « ( » invertible Comparator « . » is Ascending « ( ) ) . » is True « ( ) ; » assert That « ( » invertible Comparator « . compare ( 1 , 2 ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Invertible Comparator « < Integer > » invertible Comparator « = new » Invertible Comparator « < > ( comparator ) ; » assert That « ( » invertible Comparator « . » is Ascending « ( ) ) . » is True « ( ) ; » assert That « ( » invertible Comparator « . compare ( 1 , 2 ) ) . » is Equal To « ( - 1 ) ; » invertible Comparator « . » invert Order « ( ) ; » assert That « ( » invertible Comparator « . » is Ascending « ( ) ) . » is False « ( ) ; » assert That « ( » invertible Comparator « . compare ( 1 , 2 ) ) . » is Equal To « ( 1 ) ; }
@Test { » Invertible Comparator « < Integer > » invertible Comparator « = new » Invertible Comparator « < > ( comparator , true ) ; » assert That « ( » invertible Comparator « . compare ( 1 , 2 ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Invertible Comparator « < Integer > » invertible Comparator « = new » Invertible Comparator « < > ( comparator , false ) ; » assert That « ( » invertible Comparator « . compare ( 1 , 2 ) ) . » is Equal To « ( 1 ) ; }
@Test { Comparator < String > c = » Null Safe Comparator « . » NULLS _ LOW « ; » assert That « ( c . compare ( null , " boo " ) < 0 ) . » is True « ( ) ; }
@Test { Comparator < String > c = » Null Safe Comparator « . » NULLS _ HIGH « ; » assert That « ( c . compare ( null , " boo " ) > 0 ) . » is True « ( ) ; » assert That « ( c . compare ( null , null ) == 0 ) . » is True « ( ) ; }
@Test { Comparator < Boolean > c = new » Boolean Comparator « ( true ) ; » assert That « ( c . compare ( true , false ) ) . » is Equal To « ( - 1 ) ; » assert That « ( c . compare ( Boolean . TRUE , Boolean . TRUE ) ) . » is Equal To « ( 0 ) ; }
@Test { Comparator < Boolean > c = new » Boolean Comparator « ( false ) ; » assert That « ( c . compare ( true , false ) ) . » is Equal To « ( 1 ) ; » assert That « ( c . compare ( Boolean . TRUE , Boolean . TRUE ) ) . » is Equal To « ( 0 ) ; }
@Test { Comparator < Boolean > c = » Boolean Comparator « . » TRUE _ LOW « ; » assert That « ( c . compare ( true , false ) ) . » is Equal To « ( - 1 ) ; » assert That « ( c . compare ( Boolean . TRUE , Boolean . TRUE ) ) . » is Equal To « ( 0 ) ; }
@Test { Comparator < Boolean > c = » Boolean Comparator « . » TRUE _ HIGH « ; » assert That « ( c . compare ( true , false ) ) . » is Equal To « ( 1 ) ; » assert That « ( c . compare ( Boolean . TRUE , Boolean . TRUE ) ) . » is Equal To « ( 0 ) ; }
@Test { Comparator < String > c = new » Comparable Comparator « < > ( ) ; String » s 1 « = " abc " ; String » s 2 « = " cde " ; » assert That « ( c . compare ( » s 1 « , » s 2 « ) < 0 ) . » is True « ( ) ; }
@Test { Comparator c = new » Comparable Comparator « ( ) ; Object » o 1 « = new Object ( ) ; Object » o 2 « = new Object ( ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> c . compare ( » o 1 « , » o 2 « ) ) ; }
@Test { String expected = " one " ; » Atomic Reference « < Object > actual = new » Atomic Reference « < > ( ) ; » Listenable Future « < String > future = new » Mono To Listenable Future Adapter « < > ( Mono . just ( expected ) ) ; future . » add Callback « ( actual :: set , actual :: set ) ; » assert That « ( actual . get ( ) ) . » is Equal To « ( expected ) ; }
@Test { Throwable expected = new » Illegal State Exception « ( " oops " ) ; » Atomic Reference « < Object > actual = new » Atomic Reference « < > ( ) ; » Listenable Future « < String > future = new » Mono To Listenable Future Adapter « < > ( Mono . error ( expected ) ) ; future . » add Callback « ( actual :: set , actual :: set ) ; » assert That « ( actual . get ( ) ) . » is Equal To « ( expected ) ; }
@Test { Mono < Long > mono = Mono . delay ( Duration . » of Seconds « ( 60 ) ) ; Future < Long > future = new » Mono To Listenable Future Adapter « < > ( mono ) ; » assert That « ( future . cancel ( true ) ) . » is True « ( ) ; » assert That « ( future . » is Cancelled « ( ) ) . » is True « ( ) ; }
@Test { Future < Void > future = new » Mono To Listenable Future Adapter « < > ( Mono . empty ( ) ) ; » assert That « ( future . cancel ( true ) ) . as ( " Should return false if task already completed " ) . » is False « ( ) ; » assert That « ( future . » is Cancelled « ( ) ) . » is False « ( ) ; }
@Test { given ( adaptee . cancel ( true ) ) . » will Return « ( true ) ; boolean result = adapter . cancel ( true ) ; » assert That « ( result ) . » is True « ( ) ; }
@Test { given ( adaptee . » is Cancelled « ( ) ) . » will Return « ( true ) ; boolean result = adapter . » is Cancelled « ( ) ; » assert That « ( result ) . » is True « ( ) ; }
@Test { given ( adaptee . » is Done « ( ) ) . » will Return « ( true ) ; boolean result = adapter . » is Done « ( ) ; » assert That « ( result ) . » is True « ( ) ; }
@Test { given ( adaptee . get ( ) ) . » will Return « ( 42 ) ; String result = adapter . get ( ) ; » assert That « ( result ) . » is Equal To « ( " 42 " ) ; }
@Test { given ( adaptee . get ( 1 , » Time Unit « . SECONDS ) ) . » will Return « ( 42 ) ; String result = adapter . get ( 1 , » Time Unit « . SECONDS ) ; » assert That « ( result ) . » is Equal To « ( " 42 " ) ; }
@Test { » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is False « ( ) ; }
@Test { String string = " hello " ; » assert That « ( » settable Listenable Future « . set ( string ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . get ( ) ) . » is Equal To « ( string ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { String string = " hello " ; » assert That « ( » settable Listenable Future « . set ( string ) ) . » is True « ( ) ; Future < String > completable = » settable Listenable Future « . completable ( ) ; » assert That « ( completable . get ( ) ) . » is Equal To « ( string ) ; » assert That « ( completable . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( completable . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » settable Listenable Future « . set ( " hello " ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { Throwable exception = new » Runtime Exception « ( ) ; » assert That « ( » settable Listenable Future « . » set Exception « ( exception ) ) . » is True « ( ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( » settable Listenable Future « :: get ) . » with Cause « ( exception ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { Throwable exception = new » Runtime Exception « ( ) ; » assert That « ( » settable Listenable Future « . » set Exception « ( exception ) ) . » is True « ( ) ; Future < String > completable = » settable Listenable Future « . completable ( ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( completable :: get ) . » with Cause « ( exception ) ; » assert That « ( completable . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( completable . » is Done « ( ) ) . » is True « ( ) ; }
@Test { Throwable exception = new » Out Of Memory Error « ( ) ; » assert That « ( » settable Listenable Future « . » set Exception « ( exception ) ) . » is True « ( ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( » settable Listenable Future « :: get ) . » with Cause « ( exception ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { Throwable exception = new » Out Of Memory Error « ( ) ; » assert That « ( » settable Listenable Future « . » set Exception « ( exception ) ) . » is True « ( ) ; Future < String > completable = » settable Listenable Future « . completable ( ) ; » assert That Exception Of Type « ( » Execution Exception « . class ) . » is Thrown By « ( completable :: get ) . » with Cause « ( exception ) ; » assert That « ( completable . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( completable . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » settable Listenable Future « . set ( null ) ; » assert That « ( ( Object ) » settable Listenable Future « . get ( ) ) . » is Null « ( ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » Timeout Exception « . class ) . » is Thrown By « ( ( ) -> » settable Listenable Future « . get ( 1L , » Time Unit « . MILLISECONDS ) ) ; }
@Test { » assert That « ( » settable Listenable Future « . cancel ( true ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . set ( " hello " ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » settable Listenable Future « . cancel ( true ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » Interruptible Settable Listenable Future « » interruptible Future « = new » Interruptible Settable Listenable Future « ( ) ; » assert That « ( » interruptible Future « . cancel ( true ) ) . » is True « ( ) ; » assert That « ( » interruptible Future « . » called Interrupt Task « ( ) ) . » is True « ( ) ; » assert That « ( » interruptible Future « . » is Cancelled « ( ) ) . » is True « ( ) ; » assert That « ( » interruptible Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » Interruptible Settable Listenable Future « » interruptible Future « = new » Interruptible Settable Listenable Future « ( ) ; » assert That « ( » interruptible Future « . cancel ( false ) ) . » is True « ( ) ; » assert That « ( » interruptible Future « . » called Interrupt Task « ( ) ) . » is False « ( ) ; » assert That « ( » interruptible Future « . » is Cancelled « ( ) ) . » is True « ( ) ; » assert That « ( » interruptible Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » settable Listenable Future « . set ( " hello " ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . cancel ( true ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » settable Listenable Future « . cancel ( true ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . » set Exception « ( new » Runtime Exception « ( ) ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » settable Listenable Future « . » set Exception « ( new » Runtime Exception « ( ) ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . cancel ( true ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is False « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » settable Listenable Future « . cancel ( true ) ; » assert That Exception Of Type « ( » Cancellation Exception « . class ) . » is Thrown By « ( ( ) -> » settable Listenable Future « . get ( ) ) ; » assert That « ( » settable Listenable Future « . » is Cancelled « ( ) ) . » is True « ( ) ; » assert That « ( » settable Listenable Future « . » is Done « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Data Size « . » of Bytes « ( 1024 ) . » to Bytes « ( ) ) . » is Equal To « ( 1024 ) ; }
@Test { » assert That « ( » Data Size « . » of Bytes « ( 1024 ) . » to Kilobytes « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » Data Size « . » of Kilobytes « ( 1024 ) . » to Kilobytes « ( ) ) . » is Equal To « ( 1024 ) ; }
@Test { » assert That « ( » Data Size « . » of Kilobytes « ( 1024 ) . » to Megabytes « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » Data Size « . » of Megabytes « ( 1024 ) . » to Megabytes « ( ) ) . » is Equal To « ( 1024 ) ; }
@Test { » assert That « ( » Data Size « . » of Megabytes « ( 2048 ) . » to Gigabytes « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » assert That « ( » Data Size « . » of Gigabytes « ( 4096 ) . » to Gigabytes « ( ) ) . » is Equal To « ( 4096 ) ; }
@Test { » assert That « ( » Data Size « . » of Gigabytes « ( 4096 ) . » to Terabytes « ( ) ) . » is Equal To « ( 4 ) ; }
@Test { » assert That « ( » Data Size « . » of Terabytes « ( 1 ) . » to Gigabytes « ( ) ) . » is Equal To « ( 1024 ) ; }
@Test { » assert That « ( » Data Size « . of ( 10 , » Data Unit « . BYTES ) ) . » is Equal To « ( » Data Size « . » of Bytes « ( 10 ) ) ; }
@Test { » assert That « ( » Data Size « . of ( 20 , » Data Unit « . KILOBYTES ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( 20 ) ) ; }
@Test { » assert That « ( » Data Size « . of ( 30 , » Data Unit « . MEGABYTES ) ) . » is Equal To « ( » Data Size « . » of Megabytes « ( 30 ) ) ; }
@Test { » assert That « ( » Data Size « . of ( 40 , » Data Unit « . GIGABYTES ) ) . » is Equal To « ( » Data Size « . » of Gigabytes « ( 40 ) ) ; }
@Test { » assert That « ( » Data Size « . of ( 50 , » Data Unit « . TERABYTES ) ) . » is Equal To « ( » Data Size « . » of Terabytes « ( 50 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1024 " ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1 " ) ) . » is Equal To « ( » Data Size « . » of Bytes « ( - 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1024 " , null ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1024 " , null ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( - 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1 " , » Data Unit « . KILOBYTES ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1 " , » Data Unit « . KILOBYTES ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( - 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1024 B " ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1024 B " ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( - 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " + 1024 B " ) ) . » is Equal To « ( » Data Size « . » of Kilobytes « ( 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1 KB " ) ) . » is Equal To « ( » Data Size « . » of Bytes « ( 1024 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1 KB " ) ) . » is Equal To « ( » Data Size « . » of Bytes « ( - 1024 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 4 MB " ) ) . » is Equal To « ( » Data Size « . » of Megabytes « ( 4 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 4 MB " ) ) . » is Equal To « ( » Data Size « . » of Megabytes « ( - 4 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1 GB " ) ) . » is Equal To « ( » Data Size « . » of Megabytes « ( 1024 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1 GB " ) ) . » is Equal To « ( » Data Size « . » of Megabytes « ( - 1024 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " 1 TB " ) ) . » is Equal To « ( » Data Size « . » of Terabytes « ( 1 ) ) ; }
@Test { » assert That « ( » Data Size « . parse ( " - 1 TB " ) ) . » is Equal To « ( » Data Size « . » of Terabytes « ( - 1 ) ) ; }
@Test { » assert That « ( » Data Size « . » of Bytes « ( 50 ) . » is Negative « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Data Size « . » of Bytes « ( 0 ) . » is Negative « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Data Size « . » of Bytes « ( - 1 ) . » is Negative « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Data Size « . » of Kilobytes « ( 1 ) . » to String « ( ) ) . » is Equal To « ( " 1024 B " ) ; }
@Test { » assert That « ( » Data Size « . » of Kilobytes « ( - 1 ) . » to String « ( ) ) . » is Equal To « ( " - 1024 B " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Data Size « . parse ( " 3 WB " ) ) . » with Message « ( " '3WB' is not a valid data size " ) ; }
@Test { handler = new » Dom Content Handler « ( result ) ; expected = » document Builder « . parse ( new » Input Source « ( new » String Reader « ( » XML _ 1 « ) ) ) ; » xml Reader « . » set Content Handler « ( handler ) ; » xml Reader « . parse ( new » Input Source « ( new » String Reader « ( » XML _ 1 « ) ) ) ; » assert That « ( » Xml Content « . of ( result ) ) . as ( " Invalid result " ) . » is Similar To « ( expected ) ; }
@Test { String xml = " < foo > < bar > baz < / bar > < / foo > " ; List < » XML Event « > events = » read Events « ( xml ) ; » List Based XML Event Reader « reader = new » List Based XML Event Reader « ( events ) ; » String Writer « » result Writer « = new » String Writer « ( ) ; » XML Event Writer « writer = this . » output Factory « . » create XML Event Writer « ( » result Writer « ) ; writer . add ( reader ) ; » assert That « ( » Xml Content « . from ( » result Writer « ) ) . » is Similar To « ( xml ) ; }
@Test { String xml = " < foo > < bar > baz < / bar > < / foo > " ; List < » XML Event « > events = » read Events « ( xml ) ; » List Based XML Event Reader « reader = new » List Based XML Event Reader « ( events ) ; » assert That « ( reader . » next Event « ( ) . » get Event Type « ( ) ) . » is Equal To « ( » START _ DOCUMENT « ) ; » assert That Exception Of Type « ( » XML Stream Exception « . class ) . » is Thrown By « ( reader :: » get Element Text « ) . » with Message Starting With « ( " Not at » START _ ELEMENT « " ) ; }
@Test { Transformer transformer = new » Stub Transformer « ( ) ; » Transformer Utils « . » disable Indenting « ( transformer ) ; String indent = transformer . » get Output Property « ( » Output Keys « . INDENT ) ; » assert That « ( indent ) . » is Not Null « ( ) ; » assert That « ( indent ) . » is Equal To « ( " no " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Transformer Utils « . » enable Indenting « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Transformer Utils « . » disable Indenting « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Transformer Utils « . » enable Indenting « ( new » Stub Transformer « ( ) , - 21938 ) ) ; }
@Test { » Transformer Utils « . » enable Indenting « ( new » Stub Transformer « ( ) , 0 ) ; }
@Test { while ( » stream Reader « . » has Next « ( ) ) { » stream Reader « . next ( ) ; } }
@Test { » assert That « ( » Stax Utils « . » is Stax Source « ( new » DOM Source « ( ) ) ) . as ( " A » St AX « Source " ) . » is False « ( ) ; » assert That « ( » Stax Utils « . » is Stax Source « ( new » SAX Source « ( ) ) ) . as ( " A » St AX « Source " ) . » is False « ( ) ; » assert That « ( » Stax Utils « . » is Stax Source « ( new » Stream Source « ( ) ) ) . as ( " A » St AX « Source " ) . » is False « ( ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; String expected = " < element / > " ; » XML Stream Reader « » stream Reader « = » input Factory « . » create XML Stream Reader « ( new » String Reader « ( expected ) ) ; Source source = » Stax Utils « . » create Custom Stax Source « ( » stream Reader « ) ; » assert That « ( » Stax Utils « . » is Stax Source « ( source ) ) . as ( " Not a » St AX « Source " ) . » is True « ( ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; String expected = " < element / > " ; » XML Stream Reader « » stream Reader « = » input Factory « . » create XML Stream Reader « ( new » String Reader « ( expected ) ) ; » St AX Source « source = new » St AX Source « ( » stream Reader « ) ; » assert That « ( » Stax Utils « . » is Stax Source « ( source ) ) . as ( " Not a » St AX « Source " ) . » is True « ( ) ; }
@Test { » assert That « ( » Stax Utils « . » is Stax Result « ( new » DOM Result « ( ) ) ) . as ( " A » St AX « Result " ) . » is False « ( ) ; » assert That « ( » Stax Utils « . » is Stax Result « ( new » SAX Result « ( ) ) ) . as ( " A » St AX « Result " ) . » is False « ( ) ; » assert That « ( » Stax Utils « . » is Stax Result « ( new » Stream Result « ( ) ) ) . as ( " A » St AX « Result " ) . » is False « ( ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » XML Stream Writer « » stream Writer « = » output Factory « . » create XML Stream Writer « ( new » String Writer « ( ) ) ; Result result = » Stax Utils « . » create Custom Stax Result « ( » stream Writer « ) ; » assert That « ( » Stax Utils « . » is Stax Result « ( result ) ) . as ( " Not a » St AX « Result " ) . » is True « ( ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » XML Stream Writer « » stream Writer « = » output Factory « . » create XML Stream Writer « ( new » String Writer « ( ) ) ; » St AX Result « result = new » St AX Result « ( » stream Writer « ) ; » assert That « ( » Stax Utils « . » is Stax Result « ( result ) ) . as ( " Not a » St AX « Result " ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> context . » get Namespace URI « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> context . » get Prefix « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> context . » get Prefixes « ( null ) ) ; }
@Test { context . » bind Namespace Uri « ( prefix , » namespace Uri « ) ; Iterator < String > iterator = context . » get Prefixes « ( » namespace Uri « ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( iterator :: remove ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> context . » bind Namespace Uri « ( " prefix " , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> context . » bind Namespace Uri « ( null , » namespace Uri « ) ) ; }
@Test { context . » bind Namespace Uri « ( prefix , » namespace Uri « ) ; » assert That « ( context . » get Namespace URI « ( prefix ) ) . as ( " The Namespace URI was bound to the prefix " ) . » is Equal To « ( » namespace Uri « ) ; » assert That « ( » get Item Set « ( context . » get Prefixes « ( » namespace Uri « ) ) ) . as ( " The prefix was bound to the namespace URI " ) . contains ( prefix ) ; }
@Test { context . » bind Namespace Uri « ( " » prefix 1 « " , » namespace Uri « ) ; context . » bind Namespace Uri « ( " » prefix 2 « " , » namespace Uri « ) ; context . » bind Namespace Uri « ( " » prefix 3 « " , » additional Namespace Uri « ) ; » assert That « ( » get Item Set « ( context . » get Bound Prefixes « ( ) ) ) . as ( " Returns all bound prefixes " ) . » contains Exactly In Any Order « ( " » prefix 1 « " , " » prefix 2 « " , " » prefix 3 « " ) ; }
@Test { » evaluate Array Building Expression « ( " new int [ ] { 1 , 2 , 3 } " , " [ 1 , 2 , 3 ] " ) ; » evaluate Array Building Expression « ( " new int [ ] { } " , " [ ] " ) ; evaluate ( " new int [ ] { } . length " , " 0 " , Integer . class ) ; }
@Test { evaluate ( " new String [ ] { 1 , 2 , 3 } [ 0 ] " , " 1 " , String . class ) ; evaluate ( " new int [ ] { '123' } [ 0 ] " , 123 , Integer . class ) ; }
@Test { » evaluate And Check Error « ( " new char [ 7 ] { 'a' , 'c' , 'd' , 'e' } " , » Spel Message « . » INITIALIZER _ LENGTH _ INCORRECT « ) ; » evaluate And Check Error « ( " new char [ 3 ] { 'a' , 'c' , 'd' , 'e' } " , » Spel Message « . » INITIALIZER _ LENGTH _ INCORRECT « ) ; » evaluate And Check Error « ( " new char [ 2 ] { 'hello' , 'world' } " , » Spel Message « . » TYPE _ CONVERSION _ ERROR « ) ; » evaluate And Check Error « ( " new String ( 'a' , 'c' , 'd' ) " , » Spel Message « . » CONSTRUCTOR _ INVOCATION _ PROBLEM « ) ; }
@Test { evaluate ( " new String [ ] { 'a' , 'b' , 'c' , 'd' } [ 1 ] " , " b " , String . class ) ; » evaluate And Check Error « ( " new String [ ] { 'a' , 'b' , 'c' , 'd' } . size ( ) " , » Spel Message « . » METHOD _ NOT _ FOUND « , 30 , " size ( ) " , " java . lang . String [ ] " ) ; evaluate ( " new String [ ] { 'a' , 'b' , 'c' , 'd' } . length " , 4 , Integer . class ) ; }
@Test { evaluate ( " new String [ 3 ] " , " java . lang . String [ 3 ] { null , null , null } " , String [ ] . class ) ; }
@Test { » evaluate And Check Error « ( " new String [ ] " , » Spel Message « . » MISSING _ ARRAY _ DIMENSION « ) ; }
@Test { » Evaluation Context « context = » Test Scenario Creator « . » get Test Evaluation Context « ( ) ; » Expression State « state = new » Expression State « ( context ) ; » assert That « ( state . » get Evaluation Context « ( ) ) . » is Equal To « ( context ) ; }
@Test { » Expression State « state = » get State « ( ) ; Object value = state . » lookup Local Variable « ( " foo " ) ; » assert That « ( value ) . » is Null « ( ) ; state . » set Local Variable « ( " foo " , 34 ) ; value = state . » lookup Local Variable « ( " foo " ) ; » assert That « ( value ) . » is Equal To « ( 34 ) ; state . » set Local Variable « ( " foo " , null ) ; value = state . » lookup Local Variable « ( " foo " ) ; » assert That « ( value ) . » is Equal To « ( null ) ; }
@Test { » Evaluation Context « ctx = » get Context « ( ) ; » Expression State « state = new » Expression State « ( ctx , new » Typed Value « ( " i am a string " ) ) ; » Typed Value « » state Root « = state . » get Root Context Object « ( ) ; » assert That « ( » state Root « . » get Type Descriptor « ( ) . » get Type « ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( » state Root « . » get Value « ( ) ) . » is Equal To « ( " i am a string " ) ; }
@Test { » Expression State « state = » get State « ( ) ; » assert That « ( state . » get Type Comparator « ( ) ) . » is Equal To « ( state . » get Evaluation Context « ( ) . » get Type Comparator « ( ) ) ; }
@Test { » Expression State « state = » get State « ( ) ; String s = ( String ) state . » convert Value « ( 34 , » Type Descriptor « . » value Of « ( String . class ) ) ; » assert That « ( s ) . » is Equal To « ( " 34 " ) ; s = ( String ) state . » convert Value « ( new » Typed Value « ( 34 ) , » Type Descriptor « . » value Of « ( String . class ) ) ; » assert That « ( s ) . » is Equal To « ( " 34 " ) ; }
@Test { » Expression State « state = » get State « ( ) ; » assert That « ( state . » get Property Accessors « ( ) ) . » is Equal To « ( state . » get Evaluation Context « ( ) . » get Property Accessors « ( ) ) ; }
@Test { » list Of Scalar Not Generic « = new » Array List « ( ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " » list Of Scalar Not Generic « " ) ; » assert That « ( expression . » get Value Type Descriptor « ( this ) . » to String « ( ) ) . » is Equal To « ( " java . util . » Array List « < ? > " ) ; » assert That « ( expression . » get Value « ( this , String . class ) ) . » is Equal To « ( " " ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " » list Not Generic « " ) ; » assert That « ( expression . » get Value Type Descriptor « ( this ) . » to String « ( ) ) . » is Equal To « ( " @ org . springframework . expression . spel . » Indexing Tests $ Field Annotation « java . util . List < ? > " ) ; }
@Test { » list Of Scalar Not Generic « = new » Array List « ( 1 ) ; » list Of Scalar Not Generic « . add ( " 5 " ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " » list Of Scalar Not Generic « [ 0 ] " ) ; » assert That « ( expression . » get Value « ( this , Integer . class ) ) . » is Equal To « ( new Integer ( 5 ) ) ; }
@Test { » list Of Maps Not Generic « = new » Array List « ( ) ; Map map = new » Hash Map « ( ) ; map . put ( " fruit " , " apple " ) ; » list Of Maps Not Generic « . add ( map ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " » list Of Maps Not Generic « [ 0 ] [ 'fruit' ] " ) ; » assert That « ( expression . » get Value « ( this , String . class ) ) . » is Equal To « ( " apple " ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » integers .^ « [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » List Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 0 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » integers . « $ [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » List Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 4 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » integers .^ « [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » Set Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 0 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » integers . « $ [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » Set Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 4 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » integers .^ « [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » Array Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 0 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » integers . « $ [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » Array Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 4 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » ints .^ « [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » Array Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 0 ) ; }
@Test { Expression expression = new » Spel Expression Parser « ( ) . » parse Raw « ( " » ints . « $ [ # this < 5 ] " ) ; » Evaluation Context « context = new » Standard Evaluation Context « ( new » Array Test Bean « ( ) ) ; Object value = expression . » get Value « ( context ) ; boolean condition = value instanceof Integer ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( value ) . » is Equal To « ( 4 ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression » spel Expression « = parser . » parse Expression « ( " # » a Map . contains Key « ( » ' one « ' ) " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( » spel Expression « :: » get Value « ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression » spel Expression « = parser . » parse Expression « ( " # » a Map « [ » ' one « ' ] eq 1 " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( » spel Expression « :: » get Value « ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression » spel Expression « = parser . » parse Expression « ( " # » a List . contains « ( » ' one « ' ) " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( » spel Expression « :: » get Value « ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression » spel Expression « = parser . » parse Expression « ( " # » a List « [ 0 ] eq » ' one « ' " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( » spel Expression « :: » get Value « ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression » spel Expression « = parser . » parse Expression « ( " # » an Array « [ 0 ] eq 1 " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( » spel Expression « :: » get Value « ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression » spel Expression « = parser . » parse Expression « ( " # » an Array « [ 0 ] eq 1 " ) ; » Standard Evaluation Context « ctx = new » Standard Evaluation Context « ( ) ; ctx . » set Variables « ( new » Hash Map « < String , Object > ( ) { { put ( " » an Array « " , new int [ ] { 1 , 2 , 3 } ) ; } } ) ; boolean result = » spel Expression « . » get Value « ( ctx , Boolean . class ) ; » assert That « ( result ) . » is True « ( ) ; }
@Test { evaluate ( " # answer " , " 42 " , Integer . class , » SHOULD _ BE _ WRITABLE « ) ; evaluate ( " # answer / 2 " , 21 , Integer . class , » SHOULD _ NOT _ BE _ WRITABLE « ) ; }
@Test { evaluate ( " # » this . get Name « ( ) " , " Nikola Tesla " , String . class ) ; evaluate ( " # » root . get Name « ( ) " , " Nikola Tesla " , String . class ) ; }
@Test { evaluate ( " # » reverse Int « ( » 1 , 2 , 3 « ) " , " int [ 3 ] { 3 , 2 , 1 } " , int [ ] . class ) ; evaluate ( " # » reverse Int « ( ' » 1 ', 2 , 3 « ) " , " int [ 3 ] { 3 , 2 , 1 } " , int [ ] . class ) ; » evaluate And Check Error « ( " # » reverse Int « ( 1 ) " , » Spel Message « . » INCORRECT _ NUMBER _ OF _ ARGUMENTS _ TO _ FUNCTION « , 0 , 1 , 3 ) ; }
@Test { evaluate ( " # » reverse String « ( » ' hello « ' ) " , " olleh " , String . class ) ; evaluate ( " # » reverse String « ( 37 ) " , " 73 " , String . class ) ; }
@Test { evaluate ( " new String ( 'hello world' ) " , " hello world " , String . class ) ; }
@Test { » evaluate And Check Error « ( " new » Foo Bar « ( ) " , » Spel Message « . » CONSTRUCTOR _ INVOCATION _ PROBLEM « ) ; }
@Test { evaluate ( " new Double ( 3 ) " , 3.0d , Double . class ) ; evaluate ( " new Long ( 3 ) " , 3L , Long . class ) ; }
@Test { evaluate ( " new String ( 3.0d ) " , " 3.0 " , String . class ) ; }
@Test { try { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expr = parser . » parse Raw « ( " new String ( 'hello world' ) " ) ; Object value = expr . » get Value « ( ) ; value = expr . » get Value « ( ) ; » assert That « ( value ) . » is Equal To « ( " hello world " ) ; » assert That « ( value . » get Class « ( ) ) . » is Equal To « ( String . class ) ; } catch ( » Evaluation Exception « | » Parse Exception « ex ) { throw new » Assertion Error « ( ex . » get Message « ( ) , ex ) ; } }
@Test { evaluate ( " { 'a' : 1 , 'b' : 2 , 'c' : 3 , 'd' : 4 , 'e' : 5 } " , " { a = 1 , b = 2 , c = 3 , d = 4 , e = 5 } " , » unmodifiable Class « ) ; evaluate ( " { 'a' : 1 } " , " { a = 1 } " , » unmodifiable Class « ) ; }
@Test { evaluate ( " { 'abc' : 'def' , 'uvw' : 'xyz' } " , " { abc = def , uvw = xyz } " , » unmodifiable Class « ) ; }
@Test { evaluate ( " { : } " , " { } " , » unmodifiable Class « ) ; }
@Test { evaluate ( " { # » root . name « : true } " , " { Nikola Tesla = true } " , » Linked Hash Map « . class ) ; }
@Test { » parse And Check Error « ( " { key : 'abc' " , » Spel Message « . OOD ) ; }
@Test { evaluate ( " { a : 1 , b : 2 , c : 3 , d : 4 , e : 5 } instanceof T ( java . util . Map ) " , " true " , Boolean . class ) ; }
@Test { evaluate ( " new java . util . » Hash Map « ( ) . » put All « ( { a : 'a' , b : 'b' , c : 'c' } ) " , null , Object . class ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> evaluate ( " { a : 1 , b : 2 , c : 3 , d : 4 , e : 5 } [ a ] = 6 " , " [ a : 1 , b : 2 , c : 3 , d : 4 , e : 5 ] " , » unmodifiable Class « ) ) ; }
@Test { » Type Comparator « comparator = new » Standard Type Comparator « ( ) ; » assert That « ( comparator . compare ( null , " abc " ) < 0 ) . » is True « ( ) ; » assert That « ( comparator . compare ( null , null ) == 0 ) . » is True « ( ) ; » assert That « ( comparator . compare ( " abc " , null ) > 0 ) . » is True « ( ) ; }
@Test { » Type Comparator « comparator = new » Standard Type Comparator « ( ) ; » assert That « ( comparator . compare ( " a " , " a " ) == 0 ) . » is True « ( ) ; » assert That « ( comparator . compare ( " a " , " b " ) < 0 ) . » is True « ( ) ; » assert That « ( comparator . compare ( " b " , " a " ) > 0 ) . » is True « ( ) ; }
@Test { evaluate ( " { 1 , 2 , 3 , 4 , 5 } " , " [ 1 , 2 , 3 , 4 , 5 ] " , » unmodifiable Class « ) ; }
@Test { evaluate ( " { 'abc' , 'xyz' } " , " [ abc , xyz ] " , » unmodifiable Class « ) ; }
@Test { evaluate ( " { } " , " [ ] " , » unmodifiable Class « ) ; }
@Test { evaluate ( " { 'abc' == 'xyz' } " , " [ false ] " , » Array List « . class ) ; }
@Test { evaluate ( " { { 1 , 2 , 3 } , { 4 , 5 , 6 } } " , " [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] " , » unmodifiable Class « ) ; evaluate ( " { { 1 , '2' , 3 } , { 4 , { 'a' , 'b' } , 5 , 6 } } " , " [ [ 1 , 2 , 3 ] , [ 4 , [ a , b ] , 5 , 6 ] ] " , » unmodifiable Class « ) ; }
@Test { » parse And Check Error « ( " { 'abc' " , » Spel Message « . OOD ) ; }
@Test { evaluate ( " { 1 , 2 , 3 , 4 , 5 } instanceof T ( java . util . List ) " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 3 between { 1 , 5 } " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 8 between { 1 , 5 } " , " false " , Boolean . class ) ; }
@Test { evaluate ( " new java . util . » Hash Set « ( ) . » add All « ( { 'a' , 'b' , 'c' } ) " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 32 between { 32 , 42 } " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 'efg' between { 'abc' , 'xyz' } " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 42 between { 32 , 42 } " , " true " , Boolean . class ) ; }
@Test { » evaluate And Check Error « ( " 'abc' between { 5 , 7 } " , » Spel Message « . » NOT _ COMPARABLE « , 6 ) ; }
@Test { » check Constant List « ( " { 1 , 2 , 3 , 4 , 5 } " , true ) ; » check Constant List « ( " { 'abc' } " , true ) ; » check Constant List « ( " { } " , true ) ; » check Constant List « ( " { # » a , 2 , 3 « } " , false ) ; » check Constant List « ( " { 1 , 2 , Integer . » value Of « ( 4 ) } " , false ) ; » check Constant List « ( " { » 1 , 2 « , { # a } } " , false ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> evaluate ( " { 1 , 2 , 3 , 4 , 5 } [ 0 ] = 6 " , " [ 1 , 2 , 3 , 4 , 5 ] " , » unmodifiable Class « ) ) ; }
@Test { » parse And Check Error « ( " 0xCAFEBABE " , » Spel Message « . » NOT _ AN _ INTEGER « ) ; evaluate ( " 0xCAFEBABEL " , 0xCAFEBABEL , Long . class ) ; » parse And Check Error « ( " 0xCAFEBABECAFEBABEL " , » Spel Message « . » NOT _ A _ LONG « ) ; }
@Test { » parse And Check Error « ( " 0xB0B G " , » Spel Message « . » MORE _ INPUT « , 5 , " G " ) ; }
@Test { » parse And Check Error « ( " true or " , » Spel Message « . » RIGHT _ OPERAND _ PROBLEM « , 5 ) ; }
@Test { » parse And Check Error « ( " 1 + " , » Spel Message « . » RIGHT _ OPERAND _ PROBLEM « , 2 ) ; }
@Test { » parse And Check Error « ( " null instanceof T ( 'a' ) " , » Spel Message « . » NOT _ EXPECTED _ TOKEN « , 18 , " qualified ID " , " » literal _ string « " ) ; }
@Test { evaluate ( " name " , " Nikola Tesla " , String . class ) ; }
@Test { evaluate ( " » place Of Birth « . city " , " » Smil Jan « " , String . class ) ; }
@Test { evaluate ( " » string Array Of Three Items « . length " , " 3 " , Integer . class ) ; }
@Test { » evaluate And Check Error « ( " madeup " , » Spel Message « . » PROPERTY _ OR _ FIELD _ NOT _ READABLE « , 0 ) ; » evaluate And Check Error « ( " name . foobar " , » Spel Message « . » PROPERTY _ OR _ FIELD _ NOT _ READABLE « , 5 ) ; }
@Test { Expression expression = parser . » parse Expression « ( " name " ) ; Object value = expression . » get Value « ( new » Standard Evaluation Context « ( String . class ) ) ; » assert That « ( value ) . » is Equal To « ( " java . lang . String " ) ; }
@Test { » assert That « ( parser . » parse Expression « ( " 'a' . class . name " ) . » get Value « ( ) ) . » is Equal To « ( String . class . » get Name « ( ) ) ; }
@Test { » Evaluation Context « context = » Simple Evaluation Context « . » for Read Only Data Binding « ( ) . build ( ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> parser . » parse Expression « ( " 'a' . class . name " ) . » get Value « ( context ) ) ; }
@Test { » Evaluation Context « context = » Simple Evaluation Context « . » for Read Only Data Binding « ( ) . build ( ) ; Person target = new Person ( " » p 1 « " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> parser . » parse Expression « ( " name . substring ( 1 ) " ) . » get Value « ( context , target ) ) ; }
@Test { » Evaluation Context « context = » Simple Evaluation Context « . » for Read Only Data Binding « ( ) . » with Instance Methods « ( ) . build ( ) ; Person target = new Person ( " » p 1 « " ) ; » assert That « ( parser . » parse Expression « ( " name . substring ( 1 ) " ) . » get Value « ( context , target ) ) . » is Equal To « ( " 1 " ) ; }
@Test { » Evaluation Context « context = » Simple Evaluation Context « . » for Read Only Data Binding « ( ) . build ( ) ; Expression expression = parser . » parse Expression « ( " » string Array Of Three Items « [ 3 ] " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> expression . » get Value « ( context , new Inventor ( ) ) ) . satisfies ( ex -> » assert That « ( ex . » get Message Code « ( ) ) . » is Equal To « ( » Spel Message « . » ARRAY _ INDEX _ OUT _ OF _ BOUNDS « ) ) ; }
@Test { evaluate ( " 1 between » list One Five « " , " true " , Boolean . class ) ; }
@Test { » evaluate And Check Error « ( " 1 between T ( String ) " , » Spel Message « . » BETWEEN _ RIGHT _ OPERAND _ MUST _ BE _ TWO _ ELEMENT _ LIST « , 10 ) ; }
@Test { » evaluate And Check Error « ( " 1 between » list Of Numbers Up To Ten « " , » Spel Message « . » BETWEEN _ RIGHT _ OPERAND _ MUST _ BE _ TWO _ ELEMENT _ LIST « , 10 ) ; }
@Test { evaluate ( " » list Of Numbers Up To Ten . « ! [ # this < 5 ? ' y ' : ' n ' ] " , " [ y , y , y , y , n , n , n , n , n , n ] " , » Array List « . class ) ; }
@Test { evaluate ( " » map Of Numbers Up To Ten « . ! [ key > 5 ? value : null ] " , " [ null , null , null , null , null , six , seven , eight , nine , ten ] " , » Array List « . class ) ; }
@Test { » evaluate And Check Error « ( " 'abc' . ! [ true ] " , » Spel Message « . » PROJECTION _ NOT _ SUPPORTED _ ON _ TYPE « ) ; » evaluate And Check Error « ( " null . ! [ true ] " , » Spel Message « . » PROJECTION _ NOT _ SUPPORTED _ ON _ TYPE « ) ; evaluate ( " null ? . ! [ true ] " , null , null ) ; }
@Test { » Spel Expression « expr = ( » Spel Expression « ) parser . » parse Expression « ( " 'abc' . ! [ true ] " ) ; » assert That « ( expr . » to String AST « ( ) ) . » is Equal To « ( " 'abc' . ! [ true ] " ) ; }
@Test { evaluate ( " » test Map . key Set « ( ) . ? [ # this matches '. * o . * ' ] " , " [ monday ] " , » Array List « . class ) ; evaluate ( " » test Map . key Set « ( ) . ? [ # this matches '. * r . * ' ] » . contains « ( » ' saturday « ' ) " , " true " , Boolean . class ) ; evaluate ( " » test Map . key Set « ( ) . ? [ # this matches '. * r . * ' ] » . size « ( ) " , " 3 " , Integer . class ) ; }
@Test { » evaluate And Check Error « ( " » list Of Numbers Up To Ten « . ? [ 'nonboolean' ] " , » Spel Message « . » RESULT _ OF _ SELECTION _ CRITERIA _ IS _ NOT _ BOOLEAN « ) ; }
@Test { evaluate ( " » map Of Numbers Up To Ten « . ? [ key > 5 ] . size ( ) " , " 5 " , Integer . class ) ; }
@Test { » evaluate And Check Error « ( " » map Of Numbers Up To Ten « . ? [ 'hello' ] . size ( ) " , » Spel Message « . » RESULT _ OF _ SELECTION _ CRITERIA _ IS _ NOT _ BOOLEAN « ) ; }
@Test { evaluate ( " » list Of Numbers Up To Ten .^ « [ # » is Even « ( # this ) == ' y ' ] " , " 2 " , Integer . class ) ; }
@Test { evaluate ( " » map Of Numbers Up To Ten « . ^ [ key > 5 ] . size ( ) " , " 1 " , Integer . class ) ; }
@Test { evaluate ( " » list Of Numbers Up To Ten . « $ [ # » is Even « ( # this ) == ' y ' ] " , " 10 " , Integer . class ) ; }
@Test { evaluate ( " » map Of Numbers Up To Ten « . $ [ key > 5 ] " , " { 10 = ten } " , » Hash Map « . class ) ; evaluate ( " » map Of Numbers Up To Ten « . $ [ key > 5 ] . size ( ) " , " 1 " , Integer . class ) ; }
@Test { » parse Check « ( " false " ) ; }
@Test { » parse Check « ( " 37L " , " 37 " ) ; }
@Test { » parse Check « ( " true " ) ; }
@Test { » parse Check « ( " ! true " ) ; }
@Test { » parse Check « ( " 1 " ) ; }
@Test { » parse Check « ( " 1415 " ) ; }
@Test { » parse Check « ( " 'hello' " ) ; }
@Test { » parse Check « ( " 'joe bloggs' " ) ; }
@Test { » parse Check « ( " 'Tony' 's Pizza' " , " » ' Tony « » ' s « Pizza ' " ) ; }
@Test { » parse Check « ( " 6.0221415E+23 " , " 6.0221415E23 " ) ; }
@Test { » parse Check « ( " 0x7FFFFFFF " , " 2147483647 " ) ; }
@Test { » parse Check « ( " date ( '1974/08/24' ) " ) ; }
@Test { » parse Check « ( " date ( '19740824T131030' , 'yyyyMMddTHHmmss' ) " ) ; }
@Test { » parse Check « ( " null " ) ; }
@Test { » parse Check « ( " false or false " , " ( false or false ) " ) ; }
@Test { » parse Check « ( " false or true " , " ( false or true ) " ) ; }
@Test { » parse Check « ( " true or false " , " ( true or false ) " ) ; }
@Test { » parse Check « ( " false or true and false " , " ( false or ( true and false ) ) " ) ; }
@Test { » parse Check « ( " 3 > 6 " , " ( 3 > 6 ) " ) ; }
@Test { » parse Check « ( " 3 < 6 " , " ( 3 < 6 ) " ) ; }
@Test { » parse Check « ( " 3 <= 6 " , " ( 3 <= 6 ) " ) ; }
@Test { » parse Check « ( " 3 >= 6 " , " ( 3 >= 6 ) " ) ; }
@Test { » parse Check « ( " 3 >= 3 " , " ( 3 >= 3 ) " ) ; }
@Test { » parse Check « ( " 'xyz' instanceof int " , " ( 'xyz' instanceof int ) " ) ; }
@Test { » parse Check « ( " '5.0067' matches '^-?\\d+(\\.\\d{2})?$' " , " ( '5.0067' matches '^-?\\d+(\\.\\d{2})?$' ) " ) ; }
@Test { » parse Check « ( " '5.00' matches '^-?\\d+(\\.\\d{2})?$' " , " ( '5.00' matches '^-?\\d+(\\.\\d{2})?$' ) " ) ; }
@Test { » parse Check « ( " 2 + 4 " , " ( 2 + 4 ) " ) ; }
@Test { » parse Check « ( " 'a' + 'b' " , " ( 'a' + 'b' ) " ) ; }
@Test { » parse Check « ( " 'hello' + ' ' + 'world' " , " ( ( 'hello' + ' ' ) + 'world' ) " ) ; }
@Test { » parse Check « ( " 5 - 4 " , " ( 5 - 4 ) " ) ; }
@Test { » parse Check « ( " 7 * 4 " , " ( 7 * 4 ) " ) ; }
@Test { » parse Check « ( " 8 / 4 " , " ( 8 / 4 ) " ) ; }
@Test { » parse Check « ( " 7 % 4 " , " ( 7 % 4 ) " ) ; }
@Test { » parse Check « ( " true and 5 > 3 " , " ( true and ( 5 > 3 ) ) " ) ; }
@Test { » parse Check « ( " @ foo " ) ; » parse Check « ( " @ 'foo.bar' " ) ; » parse Check « ( " @ \" foo . bar . goo \" " , " @ 'foo.bar.goo' " ) ; }
@Test { » parse Check « ( " @ » $$ foo « " ) ; }
@Test { » parse Check « ( " name " ) ; }
@Test { » parse Check « ( " placeofbirth . » Cit Y « " ) ; }
@Test { » parse Check « ( " a . b . c . d . e " ) ; }
@Test { » parse Check « ( " { 1 , 2 , 3 , 4 , 5 } " , " { 1 , 2 , 3 , 4 , 5 } " ) ; }
@Test { » parse Check « ( " { 'abc' , 'xyz' } " , " { 'abc' , 'xyz' } " ) ; }
@Test { » parse Check « ( " { 'key1' : 'Value 1' , 'today' : » Date Time « . Today } " ) ; }
@Test { » parse Check « ( " { 1 : 'January' , 2 : 'February' , 3 : 'March' } " ) ; }
@Test { » parse Check « ( " echo ( 12 ) " ) ; }
@Test { » parse Check « ( " echo ( name ) " ) ; }
@Test { » parse Check « ( " age . » double It And Add « ( 12 ) " ) ; }
@Test { » parse Check « ( " new String ( 'hello' ) " ) ; }
@Test { » parse Check « ( " # foo " ) ; }
@Test { » parse Check « ( " # fn ( » 1 , 2 , 3 « ) " ) ; }
@Test { » parse Check « ( " # fn ( » ' hello « ' ) " ) ; }
@Test { » parse Check « ( " # » var 1 =' value 1 « ' " ) ; }
@Test { » parse Check « ( " 1 > 2 ? 3 : 4 " , " ( 1 > 2 ) ? 3 : 4 " ) ; }
@Test { » parse Check « ( " T ( java . lang . String ) " ) ; }
@Test { » parse Check « ( " T ( String ) " ) ; }
@Test { » parse Check « ( " { 1 , 2 , 3 , 4 } " ) ; }
@Test { expression = parser . » parse Expression « ( " null " ) ; Object » result I « = expression . » get Value « ( new » Test Class 1 « ( ) , Object . class ) ; » assert Can Compile « ( expression ) ; Object » result C « = expression . » get Value « ( new » Test Class 1 « ( ) , Object . class ) ; » assert That « ( » result I « ) . » is Equal To « ( null ) ; » assert That « ( » result C « ) . » is Equal To « ( null ) ; » assert That « ( » result C « ) . » is Equal To « ( null ) ; }
@Test { expression = parser . » parse Expression « ( " 99L " ) ; long » result I « = expression . » get Value « ( new » Test Class 1 « ( ) , Long . TYPE ) ; » assert Can Compile « ( expression ) ; long » result C « = expression . » get Value « ( new » Test Class 1 « ( ) , Long . TYPE ) ; » assert That « ( » result I « ) . » is Equal To « ( 99L ) ; » assert That « ( » result C « ) . » is Equal To « ( 99L ) ; }
@Test { » Evaluation Context « ctx = new » Standard Evaluation Context « ( ) ; Method m = » get Class « ( ) . » get Declared Method « ( " join " , String [ ] . class ) ; ctx . » set Variable « ( " join " , m ) ; expression = parser . » parse Expression « ( " # join ( ' a ' , ' b ' , ' c ' ) " ) ; » assert That « ( expression . » get Value « ( ctx ) ) . » is Equal To « ( " abc " ) ; » assert Can Compile « ( expression ) ; » assert That « ( expression . » get Value « ( ctx ) ) . » is Equal To « ( " abc " ) ; }
@Test { Expression expression = parser . » parse Expression « ( " T ( Integer ) . » value Of « ( 42 ) " ) ; int » result I « = expression . » get Value « ( new » Test Class 1 « ( ) , Integer . TYPE ) ; » assert Can Compile « ( expression ) ; int » result C « = expression . » get Value « ( new » Test Class 1 « ( ) , Integer . TYPE ) ; » assert That « ( » result I « ) . » is Equal To « ( 42 ) ; » assert That « ( » result C « ) . » is Equal To « ( 42 ) ; }
@Test { Expression expression = parser . » parse Expression « ( " 'abcd' . substring ( 1 , 3 ) " ) ; String » result I « = expression . » get Value « ( new » Test Class 1 « ( ) , String . class ) ; » assert Can Compile « ( expression ) ; String » result C « = expression . » get Value « ( new » Test Class 1 « ( ) , String . class ) ; » assert That « ( » result I « ) . » is Equal To « ( " bc " ) ; » assert That « ( » result C « ) . » is Equal To « ( " bc " ) ; }
@Test { Expression expression = parser . » parse Expression « ( " » to String « ( ) " ) ; String » result I « = expression . » get Value « ( 42 , String . class ) ; » assert Can Compile « ( expression ) ; String » result C « = expression . » get Value « ( 42 , String . class ) ; » assert That « ( » result I « ) . » is Equal To « ( " 42 " ) ; » assert That « ( » result C « ) . » is Equal To « ( " 42 " ) ; }
@Test { expression = parser . » parse Expression « ( " » int Value « ( ) " ) ; int » result I « = expression . » get Value « ( new Integer ( 42 ) , Integer . TYPE ) ; » assert That « ( » result I « ) . » is Equal To « ( 42 ) ; » assert Can Compile « ( expression ) ; int » result C « = expression . » get Value « ( new Integer ( 42 ) , Integer . TYPE ) ; » assert That « ( » result C « ) . » is Equal To « ( 42 ) ; }
@Test { Expression expression = parser . » parse Expression « ( " » index Of « ( 'b' ) " ) ; int » result I « = expression . » get Value « ( " abc " , Integer . TYPE ) ; » assert Can Compile « ( expression ) ; int » result C « = expression . » get Value « ( " abc " , Integer . TYPE ) ; » assert That « ( » result I « ) . » is Equal To « ( 1 ) ; » assert That « ( » result C « ) . » is Equal To « ( 1 ) ; }
@Test { expression = parser . » parse Expression « ( " » char At « ( 2 ) " ) ; char » result I « = expression . » get Value « ( " abc " , Character . TYPE ) ; » assert That « ( » result I « ) . » is Equal To « ( ' c ' ) ; » assert Can Compile « ( expression ) ; char » result C « = expression . » get Value « ( " abc " , Character . TYPE ) ; » assert That « ( » result C « ) . » is Equal To « ( ' c ' ) ; }
@Test { Map < String , String > m = new » Hash Map « < > ( ) ; m . put ( " andy " , " 778 " ) ; expression = parse ( " [ 'andy' ] == null ? 1 : 2 " ) ; » assert That « ( expression . » get Value « ( m ) ) . » is Equal To « ( 2 ) ; » assert Can Compile « ( expression ) ; » assert That « ( expression . » get Value « ( m ) ) . » is Equal To « ( 2 ) ; m . remove ( " andy " ) ; » assert That « ( expression . » get Value « ( m ) ) . » is Equal To « ( 1 ) ; }
@Test { » Standard Evaluation Context « ctx = new » Standard Evaluation Context « ( ) ; ctx . » set Variable « ( " » http Servlet Request « " , » Http Servlet 3 Request Factory « . » get One « ( ) ) ; expression = parser . » parse Expression « ( " # » http Servlet Request . servlet Path « " ) ; » assert That « ( expression . » get Value « ( ctx ) ) . » is Equal To « ( " wibble " ) ; » assert Can Compile « ( expression ) ; » assert That « ( expression . » get Value « ( ctx ) ) . » is Equal To « ( " wibble " ) ; }
@Test { » Payload 2 Holder « holder = new » Payload 2 Holder « ( ) ; » Standard Evaluation Context « ctx = new » Standard Evaluation Context « ( ) ; ctx . » add Property Accessor « ( new » My Accessor « ( ) ) ; expression = parser . » parse Expression « ( " » payload 2 « . » var 1 « " ) ; Object v = expression . » get Value « ( ctx , holder ) ; » assert That « ( v ) . » is Equal To « ( " abc " ) ; » assert Can Compile « ( expression ) ; v = expression . » get Value « ( ctx , holder ) ; » assert That « ( v ) . » is Equal To « ( " abc " ) ; }
@Test { evaluate ( " true " , Boolean . TRUE , Boolean . class ) ; }
@Test { evaluate ( " false " , Boolean . FALSE , Boolean . class ) ; }
@Test { evaluate ( " false or false " , Boolean . FALSE , Boolean . class ) ; evaluate ( " false or true " , Boolean . TRUE , Boolean . class ) ; evaluate ( " true or false " , Boolean . TRUE , Boolean . class ) ; evaluate ( " true or true " , Boolean . TRUE , Boolean . class ) ; }
@Test { evaluate ( " false and false " , Boolean . FALSE , Boolean . class ) ; evaluate ( " false and true " , Boolean . FALSE , Boolean . class ) ; evaluate ( " true and false " , Boolean . FALSE , Boolean . class ) ; evaluate ( " true and true " , Boolean . TRUE , Boolean . class ) ; }
@Test { evaluate ( " ! false " , Boolean . TRUE , Boolean . class ) ; evaluate ( " ! true " , Boolean . FALSE , Boolean . class ) ; evaluate ( " not false " , Boolean . TRUE , Boolean . class ) ; evaluate ( " » No T « true " , Boolean . FALSE , Boolean . class ) ; }
@Test { evaluate ( " false and false or true " , Boolean . TRUE , Boolean . class ) ; evaluate ( " true and false or true " , Boolean . TRUE , Boolean . class ) ; evaluate ( " true and false or false " , Boolean . FALSE , Boolean . class ) ; }
@Test { evaluate ( " true and true " , Boolean . TRUE , Boolean . class , false ) ; evaluate ( " true or true " , Boolean . TRUE , Boolean . class , false ) ; evaluate ( " ! false " , Boolean . TRUE , Boolean . class , false ) ; }
@Test { » set Value « ( " » won Nobel Prize « " , true ) ; }
@Test { » set Value « ( " » place Of Birth « . city " , " Wien " ) ; }
@Test { » set Value « ( " inventions [ 0 ] " , " Just the telephone " ) ; }
@Test { » set Value Expect Error « ( " 3 = 4 " , null ) ; }
@Test { » set Value Expect Error « ( " new org . springframework . expression . spel . testresources . Inventor ( ) . inventions [ 1 ] " , » Spel Message « . » CANNOT _ INDEX _ INTO _ NULL _ VALUE « ) ; }
@Test { » set Value Expect Error « ( " » array Container « . ints [ 1 ] " , " wibble " ) ; » set Value Expect Error « ( " » array Container « . floats [ 1 ] " , " dribble " ) ; » set Value Expect Error « ( " » array Container « . booleans [ 1 ] " , " nein " ) ; » set Value Expect Error « ( " » array Container « . bytes [ 1 ] " , " » Na B « " ) ; » set Value Expect Error « ( " » array Container « . chars [ 1 ] " , " » Na C « " ) ; }
@Test { » set Value « ( " » places Lived « [ 0 ] . city " , " Wien " ) ; }
@Test { » set Value « ( " » places Lived List « [ 0 ] " , new » Place Of Birth « ( " Wien " ) ) ; }
@Test { » set Value « ( " » places Lived List « [ 0 ] " , " Wien " ) ; }
@Test { » set Value « ( " » boolean List « [ 0 ] " , " true " , Boolean . TRUE ) ; }
@Test { » set Value Expect Error « ( " » places Lived « [ 23 ] " , " Wien " ) ; » set Value Expect Error « ( " » places Lived List « [ 23 ] " , " Wien " ) ; }
@Test { » set Value « ( " » test Map « [ 'montag' ] " , " lundi " ) ; }
@Test { » set Value Expect Error « ( " 'hello' [ 3 ] " , ' p ' ) ; }
@Test { » set Value « ( " » public Boolean « " , " true " , Boolean . TRUE ) ; }
@Test { » set Value « ( " » Some Property « " , " true " , Boolean . TRUE ) ; }
@Test { » Standard Evaluation Context « » e Context « = » Test Scenario Creator « . » get Test Evaluation Context « ( ) ; Expression e = parse ( " » public Name « = 'Andy' " ) ; » assert That « ( e . » is Writable « ( » e Context « ) ) . » is False « ( ) ; » assert That « ( e . » get Value « ( » e Context « ) ) . » is Equal To « ( " Andy " ) ; }
@Test { evaluate ( " » get Place Of Birth « ( ) . » get City « ( ) " , " » Smil Jan « " , String . class ) ; }
@Test { evaluate ( " new java . lang . String ( 'hello' ) . » char At « ( 2 ) " , ' l ' , Character . class ) ; evaluate ( " new java . lang . String ( 'hello' ) . » char At « ( 2 ) . equals ( 'l' . » char At « ( 0 ) ) " , true , Boolean . class ) ; evaluate ( " 'HELLO' . » to Lower Case « ( ) " , " hello " , String . class ) ; evaluate ( " ' abcba ' . trim ( ) " , " abcba " , String . class ) ; }
@Test { » evaluate And Check Error « ( " name . madeup ( ) " , » Spel Message « . » METHOD _ NOT _ FOUND « , 5 ) ; }
@Test { evaluate ( " new Double ( 3.0d ) . » compare To « ( 8 ) " , - 1 , Integer . class ) ; evaluate ( " new Double ( 3.0d ) . » compare To « ( 3 ) " , 0 , Integer . class ) ; evaluate ( " new Double ( 3.0d ) . » compare To « ( 2 ) " , 1 , Integer . class ) ; }
@Test { evaluate ( " new String ( 'hello 2.0 to you' ) . » starts With « ( 7.0d ) " , false , Boolean . class ) ; evaluate ( " new String ( '7.0 foobar' ) . » starts With « ( 7.0d ) " , true , Boolean . class ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expr = parser . » parse Expression « ( " » throw Exception « ( # bar ) " ) ; context . » set Variable « ( " bar " , 2 ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> expr . » get Value « ( context ) ) . satisfies ( ex -> » assert That « ( ex ) . » is Not Instance Of « ( » Spel Evaluation Exception « . class ) ) ; }
@Test { evaluate ( " » a Varargs Method « ( ) " , 0 , Integer . class ) ; evaluate ( " » a Varargs Method « ( 1 , 2 , 3 ) " , 3 , Integer . class ) ; evaluate ( " » a Varargs Method « ( 1 ) " , 1 , Integer . class ) ; evaluate ( " » a Varargs Method « ( 1 , 'a' , 3.0d ) " , 3 , Integer . class ) ; }
@Test { evaluate ( " » a Varargs Method 2 « ( 5 , 'a' , 'b' , 'c' ) " , 8 , Integer . class ) ; evaluate ( " » a Varargs Method 2 « ( 2 , 'a' ) " , 3 , Integer . class ) ; evaluate ( " » a Varargs Method 2 « ( 4 ) " , 4 , Integer . class ) ; evaluate ( " » a Varargs Method 2 « ( 8 , 2 , 3 ) " , 10 , Integer . class ) ; evaluate ( " » a Varargs Method 2 « ( 9 ) " , 9 , Integer . class ) ; evaluate ( " » a Varargs Method 2 « ( 2 , 'a' , 3.0d ) " , 4 , Integer . class ) ; }
@Test { » evaluate And Check Error « ( " null . » to String « ( ) " , » Spel Message « . » METHOD _ CALL _ ON _ NULL _ OBJECT _ NOT _ ALLOWED « ) ; }
@Test { Expression expression = parser . » parse Expression « ( " » get Name « ( ) " ) ; Object value = expression . » get Value « ( new » Standard Evaluation Context « ( String . class ) ) ; » assert That « ( value ) . » is Equal To « ( " java . lang . String " ) ; }
@Test { evaluate ( " » test Map « . get ( 'monday' ) " , " montag " , String . class ) ; }
@Test { evaluate ( " » test Map « [ 'monday' ] " , " montag " , String . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « ctx = » Test Scenario Creator « . » get Test Evaluation Context « ( ) ; ctx . » add Property Accessor « ( new » Map Accessor « ( ) ) ; Expression expr = parser . » parse Expression « ( " » test Map « . monday " ) ; Object value = expr . » get Value « ( ctx , String . class ) ; » assert That « ( value ) . » is Equal To « ( " montag " ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « ctx = » Test Scenario Creator « . » get Test Evaluation Context « ( ) ; ctx . » set Variable « ( " day " , " saturday " ) ; Expression expr = parser . » parse Expression « ( " » test Map « [ # day ] " ) ; Object value = expr . » get Value « ( ctx , String . class ) ; » assert That « ( value ) . » is Equal To « ( " samstag " ) ; }
@Test { Map < String , String > map = new » Hash Map « < > ( ) ; map . put ( " key " , " value " ) ; » Expression Parser « » spel Expression Parser « = new » Spel Expression Parser « ( ) ; Expression expr = » spel Expression Parser « . » parse Expression « ( " # root [ » ' key « ' ] " ) ; » assert That « ( expr . » get Value « ( map ) ) . » is Equal To « ( " value " ) ; }
@Test { Expression expression = this . parser . » parse Expression « ( " echo ( # var ) " ) ; » assert Method Execution « ( expression , 42 , " int : 42 " ) ; » assert Method Execution « ( expression , 42 , " int : 42 " ) ; » assert Method Execution « ( expression , " Deep Thought " , " String : Deep Thought " ) ; » assert Method Execution « ( expression , 42 , " int : 42 " ) ; }
@Test { Expression expression = this . parser . » parse Expression « ( " # » var . echo « ( 42 ) " ) ; » assert Method Execution « ( expression , new » Root Object « ( ) , " int : 42 " ) ; » assert Method Execution « ( expression , new » Root Object « ( ) , " int : 42 " ) ; » assert Method Execution « ( expression , new » Base Object « ( ) , " String : 42 " ) ; » assert Method Execution « ( expression , new » Root Object « ( ) , " int : 42 " ) ; }
@Test { evaluate ( " 3 " , 3 , Integer . class ) ; }
@Test { evaluate ( " 3.5 " , 3.5d , Double . class ) ; }
@Test { evaluate ( " 'a' * 5 " , " aaaaa " , String . class ) ; }
@Test { evaluate ( " 3.0d * 5.0d " , 15.0d , Double . class ) ; }
@Test { evaluate ( " 'hello' + ' ' + 'world' " , " hello world " , String . class ) ; }
@Test { evaluate ( " 1 + 2 + 3 " , 6 , Integer . class ) ; evaluate ( " 2 * 3 * 4 " , 24 , Integer . class ) ; evaluate ( " 12 - 1 - 2 " , 9 , Integer . class ) ; }
@Test { » evaluate And Ask For Return Type « ( " 8 / 4 " , new Double ( 2.0 ) , Double . class ) ; }
@Test { » evaluate And Ask For Return Type « ( " 8 / 4 " , new Float ( 2.0 ) , Float . class ) ; }
@Test { » evaluate And Check Error « ( " 'a' * '2' " , » Spel Message « . » OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES « ) ; » evaluate And Check Error « ( " 'a' ^ '2' " , » Spel Message « . » OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES « ) ; }
@Test { evaluate ( " 3.0d + 5.0f " , 8.0d , Double . class ) ; evaluate ( " 3.0D - 5.0f " , - 2.0d , Double . class ) ; evaluate ( " 3.0f * 5.0d " , 15.0d , Double . class ) ; evaluate ( " 3.0f / 5.0D " , 0.6d , Double . class ) ; evaluate ( " 5.0D % 3f " , 2.0d , Double . class ) ; }
@Test { evaluate ( " 3.0d + 5 " , 8.0d , Double . class ) ; evaluate ( " 3.0D - 5 " , - 2.0d , Double . class ) ; evaluate ( " 3.0f * 5 " , 15.0f , Float . class ) ; evaluate ( " 6.0f / 2 " , 3.0f , Float . class ) ; evaluate ( " 6.0f / 4 " , 1.5f , Float . class ) ; evaluate ( " 5.0D % 3 " , 2.0d , Double . class ) ; evaluate ( " 5.5D % 3 " , 2.5 , Double . class ) ; }
@Test { evaluate ( " » join Three Strings « ( 'a' , null , 'c' ) " , " anullc " , String . class ) ; }
@Test { evaluate ( " » print Double « ( T ( java . math . » Big Decimal « ) . » value Of « ( 14.35 ) ) " , " 14.35 " , String . class ) ; }
@Test { evaluate ( " » print Double « ( 14.35 ) " , " 14.35 " , String . class ) ; }
@Test { evaluate ( " » print Doubles « ( » get Doubles As String List « ( ) ) " , " { 14.35 , 15.45 } " , String . class ) ; }
@Test { Map < String , String > m = new » Hash Map « < > ( ) ; m . put ( " foo " , " bar " ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( m ) ; context . » add Property Accessor « ( new » Map Accessor « ( ) ) ; Expression expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " [ 'foo' ] " ) ; » assert That « ( expr . » get Value « ( context ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new Foo ( ) ) ; Expression expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " resource . resource . server " ) ; String name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " abc " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new Goo ( ) ) ; String name = null ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " instance [ bar ] " ) ; name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " hello " ) ; name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " hello " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new Goo ( ) ) ; context . » set Variable « ( " bar " , " key " ) ; String name = null ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " instance [ # bar ] " ) ; name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " hello " ) ; name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " hello " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new Goo ( ) ) ; context . » set Variable « ( " bar " , " wibble " ) ; String name = null ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " instance [ # bar ] " ) ; name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " wobble " ) ; name = expr . » get Value « ( context , String . class ) ; » assert That « ( name ) . » is Equal To « ( " wobble " ) ; }
@Test { Goo g = Goo . instance ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( g ) ; context . » set Variable « ( " bar " , " wibble " ) ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " instance [ # bar ] » =' world « ' " ) ; expr . » get Value « ( context , String . class ) ; » assert That « ( g . wibble ) . » is Equal To « ( " world " ) ; expr . » get Value « ( context , String . class ) ; » assert That « ( g . wibble ) . » is Equal To « ( " world " ) ; }
@Test { Goo g = Goo . instance ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( g ) ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " instance [ bar ] = 'world' " ) ; expr . » get Value « ( context , String . class ) ; » assert That « ( g . value ) . » is Equal To « ( " world " ) ; expr . » get Value « ( context , String . class ) ; » assert That « ( g . value ) . » is Equal To « ( " world " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new XX ( ) ) ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " m [ '$foo' ] " ) ; context . » set Variable « ( " » file _ name « " , " » $ foo « " ) ; » assert That « ( expr . » get Value « ( context , String . class ) ) . » is Equal To « ( " wibble " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new XX ( ) ) ; Expression expr = null ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " m [ » $ foo « ] " ) ; context . » set Variable « ( " » file _ name « " , " » $ foo « " ) ; » assert That « ( expr . » get Value « ( context , String . class ) ) . » is Equal To « ( " wibble " ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Spel Expression « expression = parser . » parse Raw « ( " T ( org . springframework . expression . spel . testresources . le . div . mod . reserved . Reserver ) . CONST " ) ; Object value = expression . » get Value « ( context ) ; » assert That « ( Reserver . CONST ) . » is Equal To « ( value ) ; }
@Test { Number » expected Result « = Math . abs ( - 10.2f ) ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » SPR 9486 _ Functions Class « » test Object « = new » SPR 9486 _ Functions Class « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " abs ( - 10.2f ) " ) ; Number result = expression . » get Value « ( context , » test Object « , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Number » expected Number « = 10.21f + 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f + 10.2 " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = 10.21f + 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f + 10.2f " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = 10.21f - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f - 10.2 " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = 10.21f - 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f - 10.2f " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = 10.21f * 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f * 10.2 " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = 10.21f * 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f * 10.2f " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = - 10.21f / - 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f / - 10.2f " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Number » expected Number « = - 10.21f / - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f / - 10.2 " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Result « = - 10.21f == - 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f == - 10.2f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Result « = - 10.21f == - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f == - 10.2 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Result « = 10.215f == 10.2109f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.215f == 10.2109f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Result « = 10.215f == 10.2109 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.215f == 10.2109 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Result « = 10.215f != 10.2109f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.215f != 10.2109f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Result « = 10.215f != 10.2109 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.215f != 10.2109 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Number « = - 10.21f < - 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f < - 10.2f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Number « = - 10.21f < - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f < - 10.2 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Number « = - 10.21f <= - 10.22f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f <= - 10.22f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Number « = - 10.21f <= - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f <= - 10.2 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Number « = - 10.21f > - 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f > - 10.2f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Result « = - 10.21f > - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f > - 10.2 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Boolean » expected Number « = - 10.21f >= - 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f >= - 10.2f " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Number « ) ; }
@Test { Boolean » expected Result « = - 10.21f >= - 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " - 10.21f >= - 10.2 " ) ; Boolean result = expression . » get Value « ( context , null , Boolean . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Number » expected Result « = 10.21f % 10.2f ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f % 10.2f " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Number » expected Result « = 10.21f % 10.2 ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f % 10.2 " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Number » expected Result « = Math . pow ( 10.21f , - 10.2f ) ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f ^ - 10.2f " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { Number » expected Result « = Math . pow ( 10.21f , 10.2 ) ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Expression expression = parser . » parse Expression « ( " 10.21f ^ 10.2 " ) ; Number result = expression . » get Value « ( context , null , Number . class ) ; » assert That « ( result ) . » is Equal To « ( » expected Result « ) ; }
@Test { » Reflective Property Accessor « accessor = new » Reflective Property Accessor « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; Object target = new » Only Bridge Method « ( ) ; » Typed Value « value = accessor . read ( context , target , " property " ) ; » assert That « ( value . » get Value « ( ) ) . » is Null « ( ) ; » assert That « ( value . » get Type Descriptor « ( ) . » get Type « ( ) ) . » is Equal To « ( Integer . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « » evaluation Context « = new » Standard Evaluation Context « ( new » Boolean Holder « ( ) ) ; Class < ? > » value Type « = parser . » parse Expression « ( " » simple Property « " ) . » get Value Type « ( » evaluation Context « ) ; » assert That « ( » value Type « ) . » is Equal To « ( Boolean . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « » evaluation Context « = new » Standard Evaluation Context « ( new » Boolean Holder « ( ) ) ; Object value = parser . » parse Expression « ( " » simple Property « " ) . » get Value « ( » evaluation Context « ) ; » assert That « ( value ) . » is Instance Of « ( Boolean . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « » evaluation Context « = new » Standard Evaluation Context « ( new » Boolean Holder « ( ) ) ; Class < ? > » value Type « = parser . » parse Expression « ( " » primitive Property « " ) . » get Value Type « ( » evaluation Context « ) ; » assert That « ( » value Type « ) . » is Equal To « ( Boolean . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « » evaluation Context « = new » Standard Evaluation Context « ( new » Boolean Holder « ( ) ) ; Object value = parser . » parse Expression « ( " » primitive Property « " ) . » get Value « ( » evaluation Context « ) ; » assert That « ( value ) . » is Instance Of « ( Boolean . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; parser . » parse Expression « ( " » simple Property « " ) . » set Value « ( new » Boolean Holder « ( ) , null ) ; » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> parser . » parse Expression « ( " » primitive Property « " ) . » set Value « ( new » Boolean Holder « ( ) , null ) ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Variable « ( " » bridge Example « " , new org . springframework . expression . spel . » spr 10210 « . D ( ) ) ; Expression » parse Expression « = parser . » parse Expression « ( " # » bridge Example . bridge Method « ( ) " ) ; » parse Expression « . » get Value « ( context ) ; }
@Test { » assert That Exception Of Type « ( » Spel Parse Exception « . class ) . » is Thrown By « ( ( ) -> parser . » parse Expression « ( " $ [ ] " ) ) . » with Message Containing « ( " » EL 1071 E « : A required selection expression has not been specified " ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; » Spr 11142 « » root Object « = new » Spr 11142 « ( ) ; Expression expression = parser . » parse Expression « ( " something " ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> expression . » get Value « ( context , » root Object « ) ) . » with Message Containing « ( " 'something' cannot be found " ) ; }
@Test { » Test Class 2 « one = new » Test Class 2 « ( " abc " ) ; » Test Class 2 « two = new » Test Class 2 « ( " abc " ) ; Map < String , » Test Class 2 « > map = new » Hash Map « < > ( ) ; map . put ( " one " , one ) ; map . put ( " two " , two ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expr = parser . » parse Expression « ( " [ 'one' ] == [ 'two' ] " ) ; » assert That « ( expr . » get Value « ( map , Boolean . class ) ) . » is True « ( ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( new » Spr 11445 Class « ( ) ) ; Expression expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " echo ( parameter ( ) ) " ) ; » assert That « ( expr . » get Value « ( context ) ) . » is Equal To « ( 1 ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Bean Resolver « ( new » Spr 11445 Class « ( ) ) ; Expression expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " @ bean . echo ( @ bean . parameter ( ) ) " ) ; » assert That « ( expr . » get Value « ( context ) ) . » is Equal To « ( 1 ) ; }
@Test { Expression exp = new » Spel Expression Parser « ( ) . » parse Expression « ( " T ( java . util . Arrays ) . » as List « ( 'a' , 'b' ) " ) ; List < String > list = ( List < String > ) exp . » get Value « ( ) ; » assert That « ( list ) . » has Size « ( 2 ) ; }
@Test { » Standard Evaluation Context « sec = new » Standard Evaluation Context « ( ) ; sec . » add Property Accessor « ( new » Map Accessor « ( ) ) ; Expression exp = new » Spel Expression Parser « ( ) . » parse Expression « ( " T ( org . springframework . expression . spel . » Spel Repro Tests $ Map With Constant « ) . X " ) ; » assert That « ( exp . » get Value « ( sec ) ) . » is Equal To « ( 1 ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " # » root . get Class « ( ) » . get Name « ( ) " ) ; » assert That « ( expression . » get Value « ( new » Unnamed User « ( ) ) ) . » is Equal To « ( » Unnamed User « . class . » get Name « ( ) ) ; » assert That « ( expression . » get Value « ( new » Named User « ( ) ) ) . » is Equal To « ( » Named User « . class . » get Name « ( ) ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " T ( java . util . Arrays ) . » as List « ( '' ) " ) ; Object value = expression . » get Value « ( ) ; » assert That « ( value instanceof List ) . » is True « ( ) ; » assert That « ( ( ( List ) value ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Standard Evaluation Context « sec = new » Standard Evaluation Context « ( ) ; sec . » set Variable « ( " iterable " , Collections . » empty List « ( ) ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expression = parser . » parse Expression « ( " T ( » org . springframework . expression . spel . Spel Repro Tests . Foo Lists « ) » . new Array List « ( # iterable ) " ) ; » assert That « ( expression . » get Value « ( sec ) instanceof » Array List « ) . » is True « ( ) ; }
@Test { » Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Variable « ( " encoding " , " UTF - 8 " ) ; Expression ex = parser . » parse Expression « ( " T ( » java . nio . charset . Charset « ) » . for Name « ( # encoding ) " ) ; Object result = ex . » get Value « ( context ) ; » assert That « ( result ) . » is Equal To « ( » Standard Charsets « . » UTF _ 8 « ) ; }
@Test { » Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Variable « ( " str " , " » a \ 0 b « " ) ; Expression ex = parser . » parse Expression « ( " # str ? » . split « ( » '\ 0 « ' ) " ) ; Object result = ex . » get Value « ( context ) ; » assert That « ( » Object Utils « . » null Safe Equals « ( result , new String [ ] { " a " , " b " } ) ) . » is True « ( ) ; }
@Test { evaluate ( " 'Hello World' . concat ( '!' ) " , " Hello World ! " , String . class ) ; }
@Test { evaluate ( " new String ( 'Hello World' . bytes ) " , " Hello World " , String . class ) ; }
@Test { evaluate ( " 'Hello World' . bytes . length " , 11 , Integer . class ) ; }
@Test { » Gregorian Calendar « c = new » Gregorian Calendar « ( ) ; c . set ( 1856 , 7 , 9 ) ; Inventor tesla = new Inventor ( " Nikola Tesla " , c . » get Time « ( ) , " Serbian " ) ; » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression exp = parser . » parse Expression « ( " name " ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Root Object « ( tesla ) ; String name = ( String ) exp . » get Value « ( context ) ; » assert That « ( name ) . » is Equal To « ( " Nikola Tesla " ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Root Object « ( tesla ) ; Expression exp = parser . » parse Expression « ( " name == 'Nikola Tesla' " ) ; boolean » is Equal « = exp . » get Value « ( context , Boolean . class ) ; » assert That « ( » is Equal « ) . » is True « ( ) ; }
@Test { evaluate ( " ( T ( » java . lang . Math « ) » . random « ( ) * » 100 . 0 « ) > 0 " , true , Boolean . class ) ; }
@Test { » Evaluation Context « context = » Test Scenario Creator « . » get Test Evaluation Context « ( ) ; int year = ( Integer ) parser . » parse Expression « ( " Birthdate . Year + 1900 " ) . » get Value « ( context ) ; » assert That « ( year ) . » is Equal To « ( 1856 ) ; String city = ( String ) parser . » parse Expression « ( " » place Of Birth « . City " ) . » get Value « ( context ) ; » assert That « ( city ) . » is Equal To « ( " » Smil Jan « " ) ; }
@Test { String c = parser . » parse Expression « ( " 'abc' . substring ( 1 , 3 ) " ) . » get Value « ( String . class ) ; » assert That « ( c ) . » is Equal To « ( " bc " ) ; » Standard Evaluation Context « » society Context « = new » Standard Evaluation Context « ( ) ; » society Context « . » set Root Object « ( new IEEE ( ) ) ; boolean » is Member « = parser . » parse Expression « ( " » is Member « ( 'Mihajlo Pupin' ) " ) . » get Value « ( » society Context « , Boolean . class ) ; » assert That « ( » is Member « ) . » is True « ( ) ; }
@Test { boolean result = parser . » parse Expression « ( " 2 == 2 " ) . » get Value « ( Boolean . class ) ; » assert That « ( result ) . » is True « ( ) ; result = parser . » parse Expression « ( " 2 < - 5.0 " ) . » get Value « ( Boolean . class ) ; » assert That « ( result ) . » is False « ( ) ; result = parser . » parse Expression « ( " 'black' < 'block' " ) . » get Value « ( Boolean . class ) ; » assert That « ( result ) . » is True « ( ) ; }
@Test { boolean » false Value « = parser . » parse Expression « ( " 'xyz' instanceof T ( int ) " ) . » get Value « ( Boolean . class ) ; » assert That « ( » false Value « ) . » is False « ( ) ; boolean » true Value « = parser . » parse Expression « ( " '5.00' matches '^-?\\d+(\\.\\d{2})?$' " ) . » get Value « ( Boolean . class ) ; » assert That « ( » true Value « ) . » is True « ( ) ; » false Value « = parser . » parse Expression « ( " '5.0067' matches '^-?\\d+(\\.\\d{2})?$' " ) . » get Value « ( Boolean . class ) ; » assert That « ( » false Value « ) . » is False « ( ) ; }
@Test { Class < ? > » date Class « = parser . » parse Expression « ( " T ( java . util . Date ) " ) . » get Value « ( Class . class ) ; » assert That « ( » date Class « ) . » is Equal To « ( Date . class ) ; boolean » true Value « = parser . » parse Expression « ( " T ( java . math . » Rounding Mode « ) . CEILING < T ( java . math . » Rounding Mode « ) . FLOOR " ) . » get Value « ( Boolean . class ) ; » assert That « ( » true Value « ) . » is True « ( ) ; }
@Test { Inventor tesla = new Inventor ( " Nikola Tesla " , " Serbian " ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » set Variable « ( " » new Name « " , " Mike Tesla " ) ; context . » set Root Object « ( tesla ) ; parser . » parse Expression « ( " foo = # » new Name « " ) . » get Value « ( context ) ; » assert That « ( tesla . » get Foo « ( ) ) . » is Equal To « ( " Mike Tesla " ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; context . » register Function « ( " » reverse String « " , » String Utils « . class . » get Declared Method « ( " » reverse String « " , String . class ) ) ; String » hello World Reversed « = parser . » parse Expression « ( " # » reverse String « ( » ' hello « world ' ) " ) . » get Value « ( context , String . class ) ; » assert That « ( » hello World Reversed « ) . » is Equal To « ( " dlrow olleh " ) ; }
@Test { » Standard Evaluation Context « » society Context « = new » Standard Evaluation Context « ( ) ; » society Context « . » set Root Object « ( new IEEE ( ) ) ; List < Inventor > list = ( List < Inventor > ) parser . » parse Expression « ( " » Members 2 « . ? [ nationality == 'Serbian' ] " ) . » get Value « ( » society Context « ) ; » assert That « ( list . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( list . get ( 0 ) . » get Name « ( ) ) . » is Equal To « ( " Nikola Tesla " ) ; }
@Test { String » random Phrase « = parser . » parse Expression « ( " random number is $ { T ( java . lang . Math ) . random ( ) } " , new » Templated Parser Context « ( ) ) . » get Value « ( String . class ) ; » assert That « ( » random Phrase « . » starts With « ( " random number " ) ) . » is True « ( ) ; }
@Test { evaluate ( " false " , " false " , Boolean . class ) ; }
@Test { evaluate ( " true " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 1 " , " 1 " , Integer . class ) ; }
@Test { evaluate ( " 1415 " , " 1415 " , Integer . class ) ; }
@Test { evaluate ( " 'Hello World' " , " Hello World " , String . class ) ; }
@Test { evaluate ( " 'joe bloggs' " , " joe bloggs " , String . class ) ; }
@Test { evaluate ( " 'hello' " , " hello " , String . class ) ; }
@Test { evaluate ( " 'Tony' 's Pizza' " , " Tony » ' s « Pizza " , String . class ) ; evaluate ( " 'Tony \\r ' 's Pizza' " , " Tony \\r » ' s « Pizza " , String . class ) ; }
@Test { evaluate ( " \" Hello World \" " , " Hello World " , String . class ) ; }
@Test { evaluate ( " \" Hello ' World \" " , " Hello ' World " , String . class ) ; }
@Test { evaluate ( " 0x7FFFF " , " 524287 " , Integer . class ) ; evaluate ( " 0x7FFFFL " , 524287L , Long . class ) ; evaluate ( " 0X7FFFF " , " 524287 " , Integer . class ) ; evaluate ( " 0X7FFFFl " , 524287L , Long . class ) ; }
@Test { evaluate ( " 0xCAFEBABEL " , 3405691582L , Long . class ) ; }
@Test { evaluate ( " 0x20 * 2L " , 64L , Long . class ) ; » evaluate And Ask For Return Type « ( " 0x20 * 2L " , 64 , Integer . class ) ; » evaluate And Check Error « ( " 0x1220 * 0xffffffffL " , Integer . class , » Spel Message « . » TYPE _ CONVERSION _ ERROR « , 0 ) ; }
@Test { evaluate ( " - 1 " , - 1 , Integer . class ) ; evaluate ( " - 0xa " , - 10 , Integer . class ) ; evaluate ( " - 1L " , - 1L , Long . class ) ; evaluate ( " - 0x20l " , - 32L , Long . class ) ; }
@Test { evaluate ( " 1.25 " , 1.25d , Double . class ) ; evaluate ( " 2.99 " , 2.99d , Double . class ) ; evaluate ( " - 3.141 " , - 3.141d , Double . class ) ; evaluate ( " 1.25d " , 1.25d , Double . class ) ; evaluate ( " 2.99d " , 2.99d , Double . class ) ; evaluate ( " - 3.141d " , - 3.141d , Double . class ) ; evaluate ( " 1.25D " , 1.25d , Double . class ) ; evaluate ( " 2.99D " , 2.99d , Double . class ) ; evaluate ( " - 3.141D " , - 3.141d , Double . class ) ; }
@Test { evaluate ( " 1.25f " , 1.25f , Float . class ) ; evaluate ( " 2.5f " , 2.5f , Float . class ) ; evaluate ( " - 3.5f " , - 3.5f , Float . class ) ; evaluate ( " 1.25F " , 1.25f , Float . class ) ; evaluate ( " 2.5F " , 2.5f , Float . class ) ; evaluate ( " - 3.5F " , - 3.5f , Float . class ) ; }
@Test { evaluate ( " 6.0221415E+23 " , " 6.0221415E23 " , Double . class ) ; evaluate ( " 6.0221415e+23 " , " 6.0221415E23 " , Double . class ) ; evaluate ( " 6.0221415E+23d " , " 6.0221415E23 " , Double . class ) ; evaluate ( " 6.0221415e+23D " , " 6.0221415E23 " , Double . class ) ; evaluate ( " 6E2f " , 6E2f , Float . class ) ; }
@Test { » parse And Check Error « ( " 6.1e23 » e 22 « " , » Spel Message « . » MORE _ INPUT « , 6 , " » e 22 « " ) ; » parse And Check Error « ( " 6.1f 23e22 " , » Spel Message « . » MORE _ INPUT « , 4 , " 23e22 " ) ; }
@Test { evaluate ( " null " , null , null ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expr = parser . » parse Expression « ( " hello $ { 'world' } " , » DEFAULT _ TEMPLATE _ PARSER _ CONTEXT « ) ; Object o = expr . » get Value « ( ) ; » assert That « ( o . » to String « ( ) ) . » is Equal To « ( " hello world " ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expr = parser . » parse Expression « ( " hello $ { 'to' } you " , » DEFAULT _ TEMPLATE _ PARSER _ CONTEXT « ) ; Object o = expr . » get Value « ( ) ; » assert That « ( o . » to String « ( ) ) . » is Equal To « ( " hello to you " ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression expr = parser . » parse Expression « ( " The quick $ { 'brown' } fox jumped over the $ { 'lazy' } dog " , » DEFAULT _ TEMPLATE _ PARSER _ CONTEXT « ) ; Object o = expr . » get Value « ( ) ; » assert That « ( o . » to String « ( ) ) . » is Equal To « ( " The quick brown fox jumped over the lazy dog " ) ; }
@Test { Expression expr = parser . » parse Expression « ( " 1 + 2 + 3 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 6 ) ; }
@Test { evaluate ( " 'Andy' ? : 'Dave' " , " Andy " , String . class ) ; evaluate ( " null ? : 'Dave' " , " Dave " , String . class ) ; }
@Test { evaluate ( " null ? . null ? . null " , null , null ) ; }
@Test { evaluate ( " 3 > 6 " , " false " , Boolean . class ) ; }
@Test { evaluate ( " 3 < 6 " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 3 <= 6 " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 3 >= 6 " , " false " , Boolean . class ) ; }
@Test { evaluate ( " 3 >= 3 " , " true " , Boolean . class ) ; }
@Test { evaluate ( " 'xyz' instanceof T ( int ) " , " false " , Boolean . class ) ; }
@Test { evaluate ( " null instanceof T ( String ) " , " false " , Boolean . class ) ; }
@Test { evaluate ( " null instanceof T ( Integer ) " , " false " , Boolean . class ) ; }
@Test { » evaluate And Check Error « ( " 'A' instanceof null " , » Spel Message « . » INSTANCEOF _ OPERATOR _ NEEDS _ CLASS _ OPERAND « , 15 , " null " ) ; }
@Test { evaluate ( " '5.0067' matches '^-?\\d+(\\.\\d{2})?$' " , " false " , Boolean . class ) ; }
@Test { evaluate ( " '5.00' matches '^-?\\d+(\\.\\d{2})?$' " , " true " , Boolean . class ) ; }
@Test { » evaluate And Check Error « ( " null matches '^.*$' " , » Spel Message « . » INVALID _ FIRST _ OPERAND _ FOR _ MATCHES _ OPERATOR « , 0 , null ) ; }
@Test { » evaluate And Check Error « ( " 'abc' matches null " , » Spel Message « . » INVALID _ SECOND _ OPERAND _ FOR _ MATCHES _ OPERATOR « , 14 , null ) ; }
@Test { evaluate ( " 27 matches '^.*2.*$' " , true , Boolean . class ) ; }
@Test { evaluate ( " true and 5 > 3 " , " true " , Boolean . class ) ; }
@Test { evaluate ( " name " , " Nikola Tesla " , String . class , false ) ; » evaluate And Check Error « ( " madeup " , » Spel Message « . » PROPERTY _ OR _ FIELD _ NOT _ READABLE « , 0 , " madeup " , " org . springframework . expression . spel . testresources . Inventor " ) ; }
@Test { evaluate ( " » _ name « " , " Nikola Tesla " , String . class ) ; evaluate ( " » _ name _ « " , " Nikola Tesla " , String . class ) ; }
@Test { » assert That Exception Of Type « ( » Spel Parse Exception « . class ) . » is Thrown By « ( ( ) -> new » Spel Expression Parser « ( ) . » parse Expression « ( " » place Of Birth « . foo . " ) ) . satisfies ( ex -> { » assert That « ( ex . » get Message Code « ( ) ) . » is Equal To « ( » Spel Message « . OOD ) ; » assert That « ( ex . » get Position « ( ) ) . » is Equal To « ( 16 ) ; } ) ; }
@Test { evaluate ( " » place Of Birth « . city " , " » Smil Jan « " , String . class , true ) ; }
@Test { evaluate ( " » place Of Birth « . » double It « ( 12 ) " , " 24 " , Integer . class ) ; }
@Test { » assert That Exception Of Type « ( » Spel Parse Exception « . class ) . » is Thrown By « ( ( ) -> new » Spel Expression Parser « ( ) . » parse Raw « ( " » place Of Birth « .23 " ) ) . satisfies ( ex -> { » assert That « ( ex . » get Message Code « ( ) ) . » is Equal To « ( » Spel Message « . » UNEXPECTED _ DATA _ AFTER _ DOT « ) ; » assert That « ( ex . » get Inserts « ( ) [ 0 ] ) . » is Equal To « ( " 23 " ) ; } ) ; }
@Test { evaluate ( " echo ( 12 ) " , " 12 " , String . class ) ; }
@Test { evaluate ( " echo ( name ) " , " Nikola Tesla " , String . class ) ; }
@Test { evaluate ( " new String ( 'hello' ) " , " hello " , String . class ) ; }
@Test { evaluate ( " new java . lang . String ( 'foobar' ) " , " foobar " , String . class ) ; }
@Test { evaluate ( " - 5 " , " - 5 " , Integer . class ) ; }
@Test { evaluate ( " + 5 " , " 5 " , Integer . class ) ; }
@Test { evaluate ( " ! true " , " false " , Boolean . class ) ; }
@Test { evaluate ( " ! false " , " true " , Boolean . class ) ; }
@Test { » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( parser . » parse Expression « ( " ! null " ) :: » get Value « ) ; }
@Test { » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( parser . » parse Expression « ( " null and true " ) :: » get Value « ) ; }
@Test { » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( parser . » parse Expression « ( " true and null " ) :: » get Value « ) ; }
@Test { » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( parser . » parse Expression « ( " null or false " ) :: » get Value « ) ; }
@Test { » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( parser . » parse Expression « ( " false or null " ) :: » get Value « ) ; }
@Test { evaluate ( " # » var 1 =' value 1 « ' " , " » value 1 « " , String . class ) ; }
@Test { evaluate ( " 2 > 4 ? 1 : 2 " , 2 , Integer . class ) ; }
@Test { evaluate ( " 'abc' == 'abc' ? 1 : 2 " , 1 , Integer . class ) ; }
@Test { » evaluate And Check Error « ( " 'hello' ? 1 : 2 " , » Spel Message « . » TYPE _ CONVERSION _ ERROR « ) ; }
@Test { Expression e = parser . » parse Expression « ( " 1 > 2 ? 3 : 4 " ) ; » assert That « ( e . » is Writable « ( context ) ) . » is False « ( ) ; }
@Test { evaluate ( " 1 > 2 ? # » var = 4 « : # » var = 5 « " , 5 , Integer . class ) ; evaluate ( " 3 ? : # » var = 5 « " , 3 , Integer . class ) ; evaluate ( " null ? : # » var = 5 « " , 5 , Integer . class ) ; evaluate ( " 2 > 4 ? ( 3 > 2 ? true : false ) : ( 5 < 3 ? true : false ) " , false , Boolean . class ) ; }
@Test { » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( parser . » parse Expression « ( " null ? 0 : 1 " ) :: » get Value « ) ; }
@Test { evaluate ( " » place Of Birth « . » double It « ( inventions . length ) " , 18 , Integer . class ) ; }
@Test { evaluate ( " new org . springframework . expression . spel . testresources . » Place Of Birth « ( inventions [ 0 ] . » to String « ( ) ) . city " , " Telephone repeater " , String . class ) ; }
@Test { evaluate ( " # » reverse Int « ( » inventions . length « , » inventions . length « , » inventions . length « ) " , " int [ 3 ] { 9 , 9 , 9 } " , int [ ] . class ) ; }
@Test { evaluate ( " » place Of Birth . double It « ( # » reverse Int « ( » inventions . length , 2 , 3 « ) [ 2 ] ) " , 18 , Integer . class ) ; }
@Test { evaluate ( " 'christian' [ 8 ] " , " n " , String . class ) ; }
@Test { » evaluate And Check Error « ( " new org . springframework . expression . spel . testresources . Inventor ( ) . inventions [ 1 ] " , » Spel Message « . » CANNOT _ INDEX _ INTO _ NULL _ VALUE « ) ; }
@Test { evaluate ( " T ( » java . awt . Color « ) » . green . get RGB « ( ) ! » = 0 « " , " true " , Boolean . class ) ; }
@Test { evaluate ( " # answer " , " 42 " , Integer . class , true ) ; }
@Test { evaluate ( " # » reverse Int « ( » 1 , 2 , 3 « ) " , " int [ 3 ] { 3 , 2 , 1 } " , int [ ] . class ) ; }
@Test { evaluate ( " # » reverse String « ( » ' hello « ' ) " , " olleh " , String . class ) ; }
@Test { evaluate ( " T ( java . lang . String ) " , " class java . lang . String " , Class . class ) ; }
@Test { evaluate ( " T ( int ) " , " int " , Class . class ) ; evaluate ( " T ( byte ) " , " byte " , Class . class ) ; evaluate ( " T ( char ) " , " char " , Class . class ) ; evaluate ( " T ( boolean ) " , " boolean " , Class . class ) ; evaluate ( " T ( long ) " , " long " , Class . class ) ; evaluate ( " T ( short ) " , " short " , Class . class ) ; evaluate ( " T ( double ) " , " double " , Class . class ) ; evaluate ( " T ( float ) " , " float " , Class . class ) ; }
@Test { evaluate ( " T ( String ) " , " class java . lang . String " , Class . class ) ; }
@Test { » evaluate And Ask For Return Type « ( " » get Place Of Birth « ( ) . » get City « ( ) " , " » Smil Jan « " , String . class ) ; }
@Test { » evaluate And Ask For Return Type « ( " 3 * 4 + 5 " , 17 , Integer . class ) ; » evaluate And Ask For Return Type « ( " 3 * 4 + 5 " , 17L , Long . class ) ; » evaluate And Ask For Return Type « ( " 65 " , ' A ' , Character . class ) ; » evaluate And Ask For Return Type « ( " 3 * 4 + 5 " , ( short ) 17 , Short . class ) ; » evaluate And Ask For Return Type « ( " 3 * 4 + 5 " , " 17 " , String . class ) ; }
@Test { Class < ? > » string Class « = parser . » parse Expression « ( " T ( String ) " ) . » get Value « ( Class . class ) ; » assert That « ( » string Class « ) . » is Equal To « ( String . class ) ; }
@Test { » Expression Parser « parser = new » Spel Expression Parser « ( ) ; Expression e = parser . » parse Expression « ( " null " ) ; » assert That « ( e . » get Value « ( ) ) . » is Null « ( ) ; e = parser . » parse Expression « ( " NULL " ) ; » assert That « ( e . » get Value « ( ) ) . » is Null « ( ) ; e = parser . » parse Expression « ( " » Nu Ll « " ) ; » assert That « ( e . » get Value « ( ) ) . » is Null « ( ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; List < » Method Resolver « > » custom Resolvers « = new » Array List « < > ( ) ; » custom Resolvers « . add ( new » Custom Method Resolver « ( ) ) ; context . » set Method Resolvers « ( » custom Resolvers « ) ; » Method Filter « filter = new » Custom Method Filter « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> context . » register Method Filter « ( String . class , filter ) ) . » with Message « ( " Method filter cannot be set as the reflective method resolver is not in use " ) ; }
@Test { String message = » Format Helper « . » format Method For Message « ( " foo " , Arrays . » as List « ( » Type Descriptor « . » for Object « ( " a string " ) ) ) ; » assert That « ( message ) . » is Equal To « ( " foo ( java . lang . String ) " ) ; }
@Test { String message = » Format Helper « . » format Method For Message « ( " foo " , Arrays . » as List « ( » Type Descriptor « . » for Object « ( " a string " ) , » Type Descriptor « . » for Object « ( Integer . » value Of « ( 5 ) ) ) ) ; » assert That « ( message ) . » is Equal To « ( " foo ( java . lang . String , java . lang . Integer ) " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Op Plus « ( - 1 , - 1 ) ) ; }
@Test { » Expression State « » expression State « = new » Expression State « ( new » Standard Evaluation Context « ( ) ) ; » String Literal « str = new » String Literal « ( " word " , - 1 , - 1 , " word " ) ; » Op Plus « o = new » Op Plus « ( - 1 , - 1 , str ) ; » assert That Exception Of Type « ( » Spel Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> o . » get Value Internal « ( » expression State « ) ) ; }
@Test { » Spel Parser Configuration « config = new » Spel Parser Configuration « ( » Spel Compiler Mode « . IMMEDIATE , null ) ; » Spel Expression Parser « parser = new » Spel Expression Parser « ( config ) ; » Ordered Component « component = new » Ordered Component « ( ) ; Expression expression = parser . » parse Expression « ( " order " ) ; » Int Stream « . » range Closed « ( 1 , 5 ) . » for Each « ( i -> » assert That « ( expression . » get Value « ( component ) ) . » is Equal To « ( 42 ) ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Spel Expression « expr = parser . » parse Raw « ( " 2 + 2 " ) ; » assert That « ( expr ) . » is Not Null « ( ) ; » assert That « ( expr . » get AST « ( ) ) . » is Not Null « ( ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 4 ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Spel Expression « expr = parser . » parse Raw « ( " 37 + 41 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 78 ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Spel Expression « expr = parser . » parse Raw « ( " 2 * 3 " ) ; » assert That « ( expr ) . » is Not Null « ( ) ; » assert That « ( expr . » get AST « ( ) ) . » is Not Null « ( ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 6 ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Spel Expression « expr = parser . » parse Raw « ( " 2 * 3 + 5 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 11 ) ; }
@Test { » Spel Expression Parser « parser = new » Spel Expression Parser « ( ) ; » Spel Expression « expr = parser . » parse Raw « ( " 2 + 3 * 5 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 17 ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " 3 + 10 / 2 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 8 ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " 10 / 2 + 3 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 8 ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " ( 4 + 10 ) / 2 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 7 ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " ( 3 + 2 ) * 2 " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( 10 ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " 'howdy' " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( " howdy " ) ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " 'hello ' ' world' " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( " hello ' world " ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " 'howdy' . substring ( 0 , 2 ) " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( " ho " ) ; }
@Test { » Spel Expression « expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " \" double quote : \" \" . \" " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( " double quote : \" . " ) ; expr = new » Spel Expression Parser « ( ) . » parse Raw « ( " \" hello \" \" world \" " ) ; » assert That « ( expr . » get Value « ( ) ) . » is Equal To « ( " hello \" world " ) ; }
@Test { » assert That Exception Of Type « ( » Spel Parse Exception « . class ) . » is Thrown By « ( ( ) -> new » Spel Expression Parser « ( ) . » parse Raw « ( " \" double quote : \\\" \\\" . \" " ) ) . satisfies ( ex -> { » assert That « ( ex . » get Position « ( ) ) . » is Equal To « ( 17 ) ; » assert That « ( ex . » get Message Code « ( ) ) . » is Equal To « ( » Spel Message « . » UNEXPECTED _ ESCAPE _ CHAR « ) ; } ) ; }
@Test { » check Number « ( " 3.14 . » to String « ( ) " , " 3.14 " , String . class ) ; » check Number « ( " 3. » to String « ( ) " , " 3 " , String . class ) ; }
@Test { » Standard Type Converter « tc = new » Standard Type Converter « ( ) ; » check Match « ( new Class < ? > [ ] { String . class } , new Class < ? > [ ] { String . class } , tc , » Reflection Helper « . » Arguments Match Kind « . EXACT ) ; » check Match « ( new Class < ? > [ ] { String . class , Integer . class } , new Class < ? > [ ] { String . class , Integer . class } , tc , » Arguments Match Kind « . EXACT ) ; }
@Test { » Standard Type Converter « » type Converter « = new » Standard Type Converter « ( ) ; » check Match « ( new Class < ? > [ ] { Super . class , String . class } , new Class < ? > [ ] { Sub . class , String . class } , » type Converter « , null ) ; }
@Test { » Standard Evaluation Context « context = new » Standard Evaluation Context « ( ) ; » assert That « ( context . » get Type Comparator « ( ) ) . » is Not Null « ( ) ; » Type Comparator « tc = new » Standard Type Comparator « ( ) ; context . » set Type Comparator « ( tc ) ; » assert That « ( context . » get Type Comparator « ( ) ) . » is Equal To « ( tc ) ; » Type Locator « tl = new » Standard Type Locator « ( ) ; context . » set Type Locator « ( tl ) ; » assert That « ( context . » get Type Locator « ( ) ) . » is Equal To « ( tl ) ; }
@Test { » Operator Overloader « oo = new » Standard Operator Overloader « ( ) ; » assert That « ( oo . » overrides Operation « ( Operation . ADD , null , null ) ) . » is False « ( ) ; » assert That Exception Of Type « ( » Evaluation Exception « . class ) . » is Thrown By « ( ( ) -> oo . operate ( Operation . ADD , 2 , 3 ) ) ; }
@Test { » Standard Type Locator « tl = new » Standard Type Locator « ( ) ; List < String > prefixes = tl . » get Import Prefixes « ( ) ; » assert That « ( prefixes . size ( ) ) . » is Equal To « ( 1 ) ; tl . » register Import « ( " java . util " ) ; prefixes = tl . » get Import Prefixes « ( ) ; » assert That « ( prefixes . size ( ) ) . » is Equal To « ( 2 ) ; tl . » remove Import « ( " java . util " ) ; prefixes = tl . » get Import Prefixes « ( ) ; » assert That « ( prefixes . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Type Converter « tc = new » Standard Type Converter « ( ) ; tc . » convert Value « ( 3 , » Type Descriptor « . » for Object « ( 3 ) , » Type Descriptor « . » value Of « ( Double . class ) ) ; }
@Test { context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - config . xml " ) ; » assert Correct Setup « ( context . » get Bean « ( " » data Source « " , » Data Source « . class ) ) ; }
@Test { System . » set Property « ( " ENABLED " , " false " ) ; context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - config . xml " ) ; » assert That Exception Of Type « ( » Bad Sql Grammar Exception « . class ) . » is Thrown By « ( ( ) -> » assert Correct Setup « ( context . » get Bean « ( " » data Source « " , » Data Source « . class ) ) ) ; }
@Test { context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - fail - config . xml " ) ; » assert Correct Setup « ( context . » get Bean « ( " » data Source « " , » Data Source « . class ) ) ; }
@Test { context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - pattern - config . xml " ) ; » Data Source « » data Source « = context . » get Bean « ( " » data Source « " , » Data Source « . class ) ; » assert Correct Setup « ( » data Source « ) ; » Jdbc Template « t = new » Jdbc Template « ( » data Source « ) ; » assert That « ( t . » query For Object « ( " select name from » T _ TEST « " , String . class ) ) . » is Equal To « ( " Dave " ) ; }
@Test { context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - placeholder - config . xml " ) ; » Data Source « » data Source « = context . » get Bean « ( " » data Source « " , » Data Source « . class ) ; » assert Correct Setup « ( » data Source « ) ; }
@Test { context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - expression - config . xml " ) ; » Data Source « » data Source « = context . » get Bean « ( " » data Source « " , » Data Source « . class ) ; » assert Correct Setup « ( » data Source « ) ; }
@Test { context = new » Class Path Xml Application Context « ( " org / springframework / jdbc / config / jdbc - initialize - cache - config . xml " ) ; » assert Correct Setup « ( context . » get Bean « ( " » data Source « " , » Data Source « . class ) ) ; » Cache Data « cache = context . » get Bean « ( » Cache Data « . class ) ; » assert That « ( cache . » get Cached Data « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert Correct Setup « ( " jdbc - config . xml " , " » data Source « " , " » h 2 Data Source « " , " » derby Data Source « " ) ; }
@Test { » assert Correct Setup « ( " jdbc - config . xml " , " » derby Data Source « " ) ; }
@Test { » assert Correct Setup « ( " jdbc - config - pattern . xml " , " » data Source « " ) ; }
@Test { » assert Correct Setup For Single Data Source « ( " jdbc - config - db - name - default - and - anonymous - datasource . xml " , url -> url . » ends With « ( » DEFAULT _ DATABASE _ NAME « ) ) ; }
@Test { » assert Correct Setup For Single Data Source « ( " jdbc - config - db - name - implicit . xml " , url -> url . » ends With « ( " » data Source « " ) ) ; }
@Test { » assert Correct Setup For Single Data Source « ( " jdbc - config - db - name - explicit . xml " , url -> url . » ends With « ( " » custom Db Name « " ) ) ; }
@Test { Predicate < String > » url Predicate « = url -> url . » starts With « ( " jdbc : hsqldb : mem : " ) ; » url Predicate « . and ( url -> ! url . » ends With « ( " » data Source « " ) ) ; » url Predicate « . and ( url -> ! url . » ends With « ( " » should Be Overridden By Generated Name « " ) ) ; » assert Correct Setup For Single Data Source « ( " jdbc - config - db - name - generated . xml " , » url Predicate « ) ; }
@Test { » assert Correct Setup And Close Context « ( " jdbc - initialize - endings - config . xml " , 2 , " » data Source « " ) ; }
@Test { » assert Correct Setup And Close Context « ( " jdbc - initialize - endings - nested - config . xml " , 2 , " » data Source « " ) ; }
@Test { » Default Listable Bean Factory « factory = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( factory ) . » load Bean Definitions « ( new » Class Path Resource « ( " jdbc - config - multiple - datasources . xml " , » get Class « ( ) ) ) ; » assert Bean Property Value Of « ( " » database Name « " , " » first Data Source « " , factory ) ; » assert Bean Property Value Of « ( " » database Name « " , " » second Data Source « " , factory ) ; }
@Test { » assert Correct Setup And Close Context « ( " jdbc - initialize - custom - separator . xml " , 2 , " » data Source « " ) ; }
@Test { » assert Correct Setup And Close Context « ( " jdbc - config - custom - separator . xml " , 2 , " » data Source « " ) ; }
@Test { » assert That « ( this . template . » get Data Source « ( ) == this . » data Source « ) . as ( " datasource ok " ) . » is True « ( ) ; » assert That « ( this . template . » is Ignore Warnings « ( ) ) . as ( " ignores warnings by default " ) . » is True « ( ) ; this . template . » set Ignore Warnings « ( false ) ; boolean condition = ! this . template . » is Ignore Warnings « ( ) ; » assert That « ( condition ) . as ( " can set NOT to ignore warnings " ) . » is True « ( ) ; }
@Test { » do Test Strings « ( null , null , null , null , ( template , sql , rch ) -> template . query ( sql , rch ) ) ; }
@Test { » do Test Strings « ( 10 , 20 , 30 , null , ( template , sql , rch ) -> template . query ( sql , rch ) ) ; }
@Test { » do Test Strings « ( null , null , null , null , ( template , sql , rch ) -> template . query ( sql , ( » Prepared Statement Setter « ) null , rch ) ) ; }
@Test { final Integer argument = 99 ; » do Test Strings « ( null , null , null , argument , ( template , sql , rch ) -> template . query ( sql , ps -> ps . » set Object « ( 1 , argument ) , rch ) ) ; }
@Test { » do Test Strings « ( null , null , null , null , ( template , sql , rch ) -> template . query ( sql , ( Object [ ] ) null , rch ) ) ; }
@Test { final Integer argument = 99 ; » do Test Strings « ( null , null , null , argument , ( template , sql , rch ) -> template . query ( sql , new Object [ ] { argument } , rch ) ) ; }
@Test { String result = this . template . execute ( new » Connection Callback « < String > ( ) { @ Override public String » do In Connection « ( Connection con ) { » assert That « ( con instanceof » Connection Proxy « ) . » is True « ( ) ; » assert That « ( ( ( » Connection Proxy « ) con ) . » get Target Connection « ( ) ) . » is Same As « ( » Jdbc Template Tests « . this . connection ) ; return " test " ; } } ) ; » assert That « ( result ) . » is Equal To « ( " test " ) ; }
@Test { String sql = " SELECT ID , FORENAME FROM CUSTMR WHERE ID < 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( false ) ; given ( this . connection . » create Statement « ( ) ) . » will Return « ( this . » prepared Statement « ) ; » Row Count Callback Handler « rcch = new » Row Count Callback Handler « ( ) ; this . template . query ( sql , rcch ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . » prepared Statement « ) . close ( ) ; verify ( this . connection ) . close ( ) ; }
@Test { final String sql = " UPDATE NOSUCHTABLE SET » DATE _ DISPATCHED « = SYSDATE WHERE ID = ? " ; » Jdbc Template « template = new » Jdbc Template « ( this . » data Source « , false ) ; int [ ] » actual Rows Affected « = template . » batch Update « ( sql , Collections . » empty List « ( ) ) ; » assert That « ( » actual Rows Affected « . length == 0 ) . as ( " executed 0 updates " ) . » is True « ( ) ; }
@Test { » do Test Could Not Get Connection In Operation With Exception Translator Initialized « ( true ) ; }
@Test { » do Test Could Not Get Connection In Operation With Exception Translator Initialized « ( false ) ; }
@Test { » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . VARCHAR , null , null ) ; verify ( » prepared Statement « ) . » set Null « ( 1 , Types . VARCHAR ) ; }
@Test { » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . VARCHAR , " mytype " , null ) ; verify ( » prepared Statement « ) . » set Null « ( 1 , Types . VARCHAR , " mytype " ) ; }
@Test { » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . VARCHAR , null , " test " ) ; verify ( » prepared Statement « ) . » set String « ( 1 , " test " ) ; }
@Test { » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . CHAR , null , " test " ) ; verify ( » prepared Statement « ) . » set Object « ( 1 , " test " , Types . CHAR ) ; }
@Test { » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , » Sql Type Value « . » TYPE _ UNKNOWN « , null , " test " ) ; verify ( » prepared Statement « ) . » set String « ( 1 , " test " ) ; }
@Test { java . sql . Date date = new java . sql . Date ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . DATE , null , date ) ; verify ( » prepared Statement « ) . » set Date « ( 1 , date ) ; }
@Test { java . util . Date date = new java . util . Date ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . DATE , null , date ) ; verify ( » prepared Statement « ) . » set Date « ( 1 , new java . sql . Date ( 1000 ) ) ; }
@Test { java . util . Calendar cal = new » Gregorian Calendar « ( ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . DATE , null , cal ) ; verify ( » prepared Statement « ) . » set Date « ( 1 , new java . sql . Date ( cal . » get Time « ( ) . » get Time « ( ) ) , cal ) ; }
@Test { java . sql . Time time = new java . sql . Time ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . TIME , null , time ) ; verify ( » prepared Statement « ) . » set Time « ( 1 , time ) ; }
@Test { java . util . Date date = new java . util . Date ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . TIME , null , date ) ; verify ( » prepared Statement « ) . » set Time « ( 1 , new java . sql . Time ( 1000 ) ) ; }
@Test { java . util . Calendar cal = new » Gregorian Calendar « ( ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . TIME , null , cal ) ; verify ( » prepared Statement « ) . » set Time « ( 1 , new java . sql . Time ( cal . » get Time « ( ) . » get Time « ( ) ) , cal ) ; }
@Test { java . sql . Timestamp timestamp = new java . sql . Timestamp ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . TIMESTAMP , null , timestamp ) ; verify ( » prepared Statement « ) . » set Timestamp « ( 1 , timestamp ) ; }
@Test { java . util . Date date = new java . util . Date ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . TIMESTAMP , null , date ) ; verify ( » prepared Statement « ) . » set Timestamp « ( 1 , new java . sql . Timestamp ( 1000 ) ) ; }
@Test { java . util . Calendar cal = new » Gregorian Calendar « ( ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . TIMESTAMP , null , cal ) ; verify ( » prepared Statement « ) . » set Timestamp « ( 1 , new java . sql . Timestamp ( cal . » get Time « ( ) . » get Time « ( ) ) , cal ) ; }
@Test { java . util . Date date = new java . util . Date ( 1000 ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , » Sql Type Value « . » TYPE _ UNKNOWN « , null , date ) ; verify ( » prepared Statement « ) . » set Timestamp « ( 1 , new java . sql . Timestamp ( 1000 ) ) ; }
@Test { java . util . Calendar cal = new » Gregorian Calendar « ( ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , » Sql Type Value « . » TYPE _ UNKNOWN « , null , cal ) ; verify ( » prepared Statement « ) . » set Timestamp « ( 1 , new java . sql . Timestamp ( cal . » get Time « ( ) . » get Time « ( ) ) , cal ) ; }
@Test { Connection con = mock ( Connection . class ) ; » Database Meta Data « dbmd = mock ( » Database Meta Data « . class ) ; given ( » prepared Statement « . » get Connection « ( ) ) . » will Return « ( con ) ; given ( dbmd . » get Database Product Name « ( ) ) . » will Return « ( " Oracle " ) ; given ( con . » get Meta Data « ( ) ) . » will Return « ( dbmd ) ; » Statement Creator Utils « . » set Parameter Value « ( » prepared Statement « , 1 , Types . OTHER , null , " test " ) ; verify ( » prepared Statement « ) . » set String « ( 1 , " test " ) ; }
@Test { » Bean Property Row Mapper « mapper = new » Bean Property Row Mapper « ( Person . class ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> mapper . » set Mapped Class « ( Long . class ) ) ; }
@Test { » Bean Property Row Mapper « < Person > mapper = new » Bean Property Row Mapper « < > ( Person . class ) ; mapper . » set Mapped Class « ( Person . class ) ; }
@Test { Mock mock = new Mock ( ) ; List < Person > result = mock . » get Jdbc Template « ( ) . query ( " select name , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( Person . class ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » verify Person « ( result . get ( 0 ) ) ; mock . » verify Closed « ( ) ; }
@Test { Mock mock = new Mock ( ) ; List < » Concrete Person « > result = mock . » get Jdbc Template « ( ) . query ( " select name , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( » Concrete Person « . class ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » verify Person « ( result . get ( 0 ) ) ; mock . » verify Closed « ( ) ; }
@Test { Mock mock = new Mock ( ) ; List < » Concrete Person « > result = mock . » get Jdbc Template « ( ) . query ( " select name , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( » Concrete Person « . class , true ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » verify Person « ( result . get ( 0 ) ) ; mock . » verify Closed « ( ) ; }
@Test { Mock mock = new Mock ( ) ; List < » Extended Person « > result = mock . » get Jdbc Template « ( ) . query ( " select name , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( » Extended Person « . class ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » Extended Person « bean = result . get ( 0 ) ; » verify Person « ( bean ) ; mock . » verify Closed « ( ) ; }
@Test { Mock mock = new Mock ( ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> mock . » get Jdbc Template « ( ) . query ( " select name , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( » Extended Person « . class , true ) ) ) ; }
@Test { » Bean Property Row Mapper « < Person > mapper = new » Bean Property Row Mapper « < > ( Person . class ) ; Mock mock = new Mock ( » Mock Type « . TWO ) ; » assert That Exception Of Type « ( » Type Mismatch Exception « . class ) . » is Thrown By « ( ( ) -> mock . » get Jdbc Template « ( ) . query ( " select name , null as age , » birth _ date « , balance from people " , mapper ) ) ; }
@Test { Mock mock = new Mock ( » Mock Type « . THREE ) ; List < » Space Person « > result = mock . » get Jdbc Template « ( ) . query ( " select » last _ name « as \" Last Name \" , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( » Space Person « . class ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » verify Person « ( result . get ( 0 ) ) ; mock . » verify Closed « ( ) ; }
@Test { Mock mock = new Mock ( » Mock Type « . THREE ) ; List < » Date Person « > result = mock . » get Jdbc Template « ( ) . query ( " select » last _ name « as \" Last Name \" , age , » birth _ date « , balance from people " , new » Bean Property Row Mapper « < > ( » Date Person « . class ) ) ; » assert That « ( result . size ( ) ) . » is Equal To « ( 1 ) ; » verify Person « ( result . get ( 0 ) ) ; mock . » verify Closed « ( ) ; }
@Test { result = template . query ( " some SQL " , » test Row Mapper « ) ; verify ( statement ) . close ( ) ; }
@Test { result = template . query ( con -> » prepared Statement « , » test Row Mapper « ) ; verify ( » prepared Statement « ) . close ( ) ; }
@Test { result = template . query ( " some SQL " , ps -> ps . » set String « ( 1 , " test " ) , » test Row Mapper « ) ; verify ( » prepared Statement « ) . » set String « ( 1 , " test " ) ; verify ( » prepared Statement « ) . close ( ) ; }
@Test { result = template . query ( " some SQL " , new Object [ ] { " » test 1 « " , " » test 2 « " } , » test Row Mapper « ) ; » prepared Statement « . » set String « ( 1 , " » test 1 « " ) ; » prepared Statement « . » set String « ( 2 , " » test 2 « " ) ; » prepared Statement « . close ( ) ; }
@Test { result = template . query ( " some SQL " , new Object [ ] { " » test 1 « " , " » test 2 « " } , new int [ ] { Types . VARCHAR , Types . VARCHAR } , » test Row Mapper « ) ; verify ( » prepared Statement « ) . » set String « ( 1 , " » test 1 « " ) ; verify ( » prepared Statement « ) . » set String « ( 2 , " » test 2 « " ) ; verify ( » prepared Statement « ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID < 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( false ) ; List < Map < String , Object > > li = this . template . » query For List « ( sql ) ; » assert That « ( li . size ( ) ) . as ( " All rows returned " ) . » is Equal To « ( 0 ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get String « ( 1 ) ) . » will Return « ( " myvalue " ) ; » assert That « ( this . template . » query For Object « ( sql , String . class ) ) . » is Equal To « ( " myvalue " ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Big Decimal « ( 1 ) ) . » will Return « ( new » Big Decimal « ( " 22.5 " ) ) ; » assert That « ( this . template . » query For Object « ( sql , » Big Decimal « . class ) ) . » is Equal To « ( new » Big Decimal « ( " 22.5 " ) ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Int « ( 1 ) ) . » will Return « ( 22 ) ; » assert That « ( this . template . » query For Object « ( sql , Integer . class ) ) . » is Equal To « ( Integer . » value Of « ( 22 ) ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Int « ( 1 ) ) . » will Return « ( 0 ) ; given ( this . » result Set « . » was Null « ( ) ) . » will Return « ( true ) ; » assert That « ( this . template . » query For Object « ( sql , Integer . class ) ) . » is Null « ( ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Int « ( 1 ) ) . » will Return « ( 22 ) ; int i = this . template . » query For Object « ( sql , Integer . class ) . » int Value « ( ) ; » assert That « ( i ) . as ( " Return of an int " ) . » is Equal To « ( 22 ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Int « ( 1 ) ) . » will Return « ( 22 ) ; int i = this . template . » query For Object « ( sql , int . class ) ; » assert That « ( i ) . as ( " Return of an int " ) . » is Equal To « ( 22 ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Long « ( 1 ) ) . » will Return « ( 87L ) ; long l = this . template . » query For Object « ( sql , Long . class ) . » long Value « ( ) ; » assert That « ( l ) . as ( " Return of a long " ) . » is Equal To « ( 87 ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID = 3 " ; given ( this . » result Set « . next ( ) ) . » will Return « ( true , false ) ; given ( this . » result Set « . » get Long « ( 1 ) ) . » will Return « ( 87L ) ; long l = this . template . » query For Object « ( sql , long . class ) ; » assert That « ( l ) . as ( " Return of a long " ) . » is Equal To « ( 87 ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . statement ) . close ( ) ; }
@Test { » do Test Query For List With Args « ( " SELECT AGE FROM CUSTMR WHERE ID < ? " ) ; }
@Test { » do Test Query For List With Args « ( " SELECT AGE FROM PREFIX : CUSTMR WHERE ID < ? " ) ; }
@Test { String sql = " SELECT AGE FROM CUSTMR WHERE ID < ? " ; given ( this . » result Set « . next ( ) ) . » will Return « ( false ) ; List < Map < String , Object > > li = this . template . » query For List « ( sql , new Object [ ] { 3 } ) ; » assert That « ( li . size ( ) ) . as ( " All rows returned " ) . » is Equal To « ( 0 ) ; verify ( this . » prepared Statement « ) . » set Object « ( 1 , 3 ) ; verify ( this . » result Set « ) . close ( ) ; verify ( this . » prepared Statement « ) . close ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Bean Property Sql Parameter Source « ( null ) ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » Test Bean « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> source . » get Value « ( " » this Property Does Not Exist « " ) ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » Test Bean « ( ) ) ; » assert That « ( source . » has Value « ( " » this Property Does Not Exist « " ) ) . » is False « ( ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » No Readable Properties « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> source . » get Value « ( " » no Op « " ) ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » No Readable Properties « ( ) ) ; » assert That « ( source . » has Value « ( " » no Op « " ) ) . » is False « ( ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » Test Bean « ( " tb " , 99 ) ) ; » assert That « ( source . » to String « ( ) ) . » starts With « ( " » Bean Property Sql Parameter Source « { " ) . contains ( " name = tb ( type : VARCHAR ) " ) . contains ( " age = 99 ( type : INTEGER ) " ) . » ends With « ( " } " ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » Test Bean « ( " tb " , 99 ) ) ; source . » register Sql Type « ( " name " , Integer . » MAX _ VALUE « ) ; » assert That « ( source . » to String « ( ) ) . » starts With « ( " » Bean Property Sql Parameter Source « { " ) . contains ( " name = tb ( type : " + Integer . » MAX _ VALUE « + " ) " ) . contains ( " age = 99 ( type : INTEGER ) " ) . » ends With « ( " } " ) ; }
@Test { » Bean Property Sql Parameter Source « source = new » Bean Property Sql Parameter Source « ( new » Test Bean « ( " tb " , 99 ) ) ; » assert That « ( source . » to String « ( ) ) . » starts With « ( " » Bean Property Sql Parameter Source « { " ) . contains ( " » bean Factory « = null " ) . » does Not Contain « ( " » bean Factory « = null ( type : " ) . » ends With « ( " } " ) ; }
@Test { new » Map Sql Parameter Source « ( null ) ; }
@Test { » Map Sql Parameter Source « source = new » Map Sql Parameter Source « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> source . » get Value « ( " pechorin was right ! " ) ) ; }
@Test { » Map Sql Parameter Source « source = new » Map Sql Parameter Source « ( " FOO " , new » Sql Parameter Value « ( Types . NUMERIC , " Foo " ) ) ; » assert That « ( source . » to String « ( ) ) . » is Equal To « ( " » Map Sql Parameter Source « { FOO = Foo ( type : NUMERIC ) } " ) ; }
@Test { » Map Sql Parameter Source « source = new » Map Sql Parameter Source « ( " FOO " , new » Sql Parameter Value « ( Integer . » MAX _ VALUE « , " Foo " ) ) ; » assert That « ( source . » to String « ( ) ) . » is Equal To « ( ( " » Map Sql Parameter Source « { FOO = Foo ( type : " + Integer . » MAX _ VALUE « + " ) } " ) ) ; }
@Test { » Map Sql Parameter Source « source = new » Map Sql Parameter Source « ( " FOO " , new » Sql Parameter Value « ( » Jdbc Utils « . » TYPE _ UNKNOWN « , " Foo " ) ) ; » assert That « ( source . » to String « ( ) ) . » is Equal To « ( " » Map Sql Parameter Source « { FOO = Foo } " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Named Parameter Jdbc Template « ( ( » Data Source « ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Named Parameter Jdbc Template « ( ( » Jdbc Operations « ) null ) ) ; }
@Test { » assert That « ( » named Parameter Template « . » get Jdbc Template « ( ) . » get Data Source « ( ) ) . » is Same As « ( » data Source « ) ; }
@Test { @ » Suppress Warnings « ( " unchecked " ) final Map < String , Integer > [ ] ids = new Map [ 0 ] ; » named Parameter Template « = new » Named Parameter Jdbc Template « ( new » Jdbc Template « ( » data Source « , false ) ) ; int [ ] » actual Rows Affected « = » named Parameter Template « . » batch Update « ( " UPDATE NOSUCHTABLE SET » DATE _ DISPATCHED « = SYSDATE WHERE ID = : id " , ids ) ; » assert That « ( » actual Rows Affected « . length == 0 ) . as ( " executed 0 updates " ) . » is True « ( ) ; }
@Test { String sql = " select count ( 0 ) from foo where id = : id " ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> » Named Parameter Utils « . » build Value Array « ( sql , Collections . < String , Object > » empty Map « ( ) ) ) ; }
@Test { String » expected Sql « = " select 'first name' from artists where id = ? and quote = 'exsqueeze me?' " ; String sql = " select 'first name' from artists where id = : id and quote = 'exsqueeze me?' " ; String » new Sql « = » Named Parameter Utils « . » substitute Named Parameters « ( sql , new » Map Sql Parameter Source « ( ) ) ; » assert That « ( » new Sql « ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String » expected Sql « = " select 'first name' from artists where id = ? and quote = 'exsqueeze me?' " ; String sql = " select 'first name' from artists where id = : id and quote = 'exsqueeze me?' " ; » Parsed Sql « » parsed Sql « = » Named Parameter Utils « . » parse Sql Statement « ( sql ) ; » assert That « ( » Named Parameter Utils « . » substitute Named Parameters « ( » parsed Sql « , null ) ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String » expected Sql « = " select 'first name' from artists where id = ? and » birth _ date « = ? :: timestamp " ; String sql = " select 'first name' from artists where id = : id and » birth _ date « = : » birth Date « :: timestamp " ; » Parsed Sql « » parsed Sql « = » Named Parameter Utils « . » parse Sql Statement « ( sql ) ; » assert That « ( » Named Parameter Utils « . » substitute Named Parameters « ( » parsed Sql « , null ) ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String » expected Sql « = " select '[ \" 3 \" , \" 11 \" ]' :: jsonb ? | '{1,3,11,12,17}' :: text [ ] " ; String sql = " select '[ \" 3 \" , \" 11 \" ]' :: jsonb ? | '{1,3,11,12,17}' :: text [ ] " ; » Parsed Sql « » parsed Sql « = » Named Parameter Utils « . » parse Sql Statement « ( sql ) ; » assert That « ( » parsed Sql « . » get Total Parameter Count « ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( » Named Parameter Utils « . » substitute Named Parameters « ( » parsed Sql « , null ) ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String » expected Sql « = " xxx & yyyy " ; » Parsed Sql « » parsed Sql « = » Named Parameter Utils « . » parse Sql Statement « ( » expected Sql « ) ; » assert That « ( » Named Parameter Utils « . » substitute Named Parameters « ( » parsed Sql « , null ) ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String » expected Sql « = " xxx & yyyy " ; String » new Sql « = » Named Parameter Utils « . » substitute Named Parameters « ( » expected Sql « , new » Map Sql Parameter Source « ( ) ) ; » assert That « ( » new Sql « ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String » expected Sql « = " x : = 1 " ; String » new Sql « = » Named Parameter Utils « . » substitute Named Parameters « ( » expected Sql « , new » Map Sql Parameter Source « ( ) ) ; » assert That « ( » new Sql « ) . » is Equal To « ( » expected Sql « ) ; }
@Test { String sql = " SELECT ':foo' ':doo' , : xxx FROM DUAL " ; » Parsed Sql « psql = » Named Parameter Utils « . » parse Sql Statement « ( sql ) ; » assert That « ( psql . » get Total Parameter Count « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( psql . » get Parameter Names « ( ) . get ( 0 ) ) . » is Equal To « ( " xxx " ) ; }
@Test { String sql = " SELECT ':foo' , : xxx FROM DUAL " ; » Parsed Sql « psql = » Named Parameter Utils « . » parse Sql Statement « ( sql ) ; » assert That « ( psql . » get Total Parameter Count « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( psql . » get Parameter Names « ( ) . get ( 0 ) ) . » is Equal To « ( " xxx " ) ; }
@Test { String » sql 2 « = " SELECT ':foo' , : xxx FROM DUAL " ; » Parsed Sql « » psql 2 « = » Named Parameter Utils « . » parse Sql Statement « ( » sql 2 « ) ; » assert That « ( » psql 2 « . » get Total Parameter Count « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » psql 2 « . » get Parameter Names « ( ) . get ( 0 ) ) . » is Equal To « ( " xxx " ) ; }
@Test { final String » MY _ PROC « = " » my _ proc « " ; » Simple Jdbc Call « sproc = new » Simple Jdbc Call « ( » data Source « ) . » with Procedure Name « ( » MY _ PROC « ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> sproc . » add Declared Parameter « ( new » Sql Parameter « ( 1 ) ) ) ; }
@Test { » initialize Add Invoice With Meta Data « ( false ) ; » Simple Jdbc Call « adder = new » Simple Jdbc Call « ( » data Source « ) . » with Procedure Name « ( " » add _ invoice « " ) ; Number » new Id « = adder . » execute Object « ( Number . class , 1103 , 3 ) ; » assert That « ( » new Id « . » int Value « ( ) ) . » is Equal To « ( 4 ) ; » verify Add Invoice With Meta Data « ( false ) ; verify ( connection , » at Least Once « ( ) ) . close ( ) ; }
@Test { » initialize Add Invoice With Meta Data « ( true ) ; » Simple Jdbc Call « adder = new » Simple Jdbc Call « ( » data Source « ) . » with Function Name « ( " » add _ invoice « " ) ; Number » new Id « = adder . » execute Function « ( Number . class , 1103 , 3 ) ; » assert That « ( » new Id « . » int Value « ( ) ) . » is Equal To « ( 4 ) ; » verify Add Invoice With Meta Data « ( true ) ; verify ( connection , » at Least Once « ( ) ) . close ( ) ; }
@Test { » initialize Add Invoice With Meta Data « ( true ) ; » Simple Jdbc Call « adder = new » Simple Jdbc Call « ( » data Source « ) . » with Function Name « ( " » add _ invoice « " ) ; adder . compile ( ) ; » verify Statement « ( adder , " { ? = call » ADD _ INVOICE « ( ? , ? ) } " ) ; }
@Test { » initialize Add Invoice With Meta Data « ( true ) ; » Simple Jdbc Call « adder = new » Simple Jdbc Call « ( » data Source « ) . » with Named Binding « ( ) . » with Function Name « ( " » add _ invoice « " ) ; adder . compile ( ) ; » verify Statement « ( adder , " { ? = call » ADD _ INVOICE « ( AMOUNT = > ? , CUSTID = > ? ) } " ) ; }
@Test { » initialize Add Invoice With Meta Data « ( false ) ; » Simple Jdbc Call « adder = new » Simple Jdbc Call « ( » data Source « ) . » with Named Binding « ( ) . » with Procedure Name « ( " » add _ invoice « " ) ; adder . compile ( ) ; » verify Statement « ( adder , " { call » ADD _ INVOICE « ( AMOUNT = > ? , CUSTID = > ? , NEWID = > ? ) } " ) ; }
@Test { » Result Set « rset = mock ( » Result Set « . class ) ; » Abstract Lob Streaming Result Set Extractor « < Void > » lob Rse « = » get Result Set Extractor « ( false ) ; » assert That Exception Of Type « ( » Incorrect Result Size Data Access Exception « . class ) . » is Thrown By « ( ( ) -> » lob Rse « . » extract Data « ( rset ) ) ; verify ( rset ) . next ( ) ; }
@Test { » Result Set « rset = mock ( » Result Set « . class ) ; given ( rset . next ( ) ) . » will Return « ( true , false ) ; » Abstract Lob Streaming Result Set Extractor « < Void > » lob Rse « = » get Result Set Extractor « ( false ) ; » lob Rse « . » extract Data « ( rset ) ; verify ( rset ) . » clear Warnings « ( ) ; }
@Test { » Result Set « rset = mock ( » Result Set « . class ) ; given ( rset . next ( ) ) . » will Return « ( true , true , false ) ; » Abstract Lob Streaming Result Set Extractor « < Void > » lob Rse « = » get Result Set Extractor « ( false ) ; » assert That Exception Of Type « ( » Incorrect Result Size Data Access Exception « . class ) . » is Thrown By « ( ( ) -> » lob Rse « . » extract Data « ( rset ) ) ; verify ( rset ) . » clear Warnings « ( ) ; }
@Test { » Result Set « rset = mock ( » Result Set « . class ) ; given ( rset . next ( ) ) . » will Return « ( true ) ; » Abstract Lob Streaming Result Set Extractor « < Void > » lob Rse « = » get Result Set Extractor « ( true ) ; » assert That Exception Of Type « ( » Lob Retrieval Failure Exception « . class ) . » is Thrown By « ( ( ) -> » lob Rse « . » extract Data « ( rset ) ) ; }
@Test { byte [ ] » test Bytes « = " Bla " . » get Bytes « ( ) ; » Sql Lob Value « lob = new » Sql Lob Value « ( » test Bytes « , handler ) ; lob . » set Type Value « ( » prepared Statement « , 1 , Types . BLOB , " test " ) ; verify ( creator ) . » set Blob As Bytes « ( » prepared Statement « , 1 , » test Bytes « ) ; }
@Test { String » test String « = " Bla " ; » Sql Lob Value « lob = new » Sql Lob Value « ( » test String « , handler ) ; lob . » set Type Value « ( » prepared Statement « , 1 , Types . BLOB , " test " ) ; verify ( creator ) . » set Blob As Bytes « ( » prepared Statement « , 1 , » test String « . » get Bytes « ( ) ) ; }
@Test { » Sql Lob Value « lob = new » Sql Lob Value « ( new » Input Stream Reader « ( new » Byte Array Input Stream « ( " Bla " . » get Bytes « ( ) ) ) , 12 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lob . » set Type Value « ( » prepared Statement « , 1 , Types . BLOB , " test " ) ) ; }
@Test { String » test Content « = " Bla " ; » Sql Lob Value « lob = new » Sql Lob Value « ( » test Content « , handler ) ; lob . » set Type Value « ( » prepared Statement « , 1 , Types . CLOB , " test " ) ; verify ( creator ) . » set Clob As String « ( » prepared Statement « , 1 , » test Content « ) ; }
@Test { byte [ ] » test Content « = " Bla " . » get Bytes « ( ) ; » Byte Array Input Stream « bais = new » Byte Array Input Stream « ( » test Content « ) ; » Input Stream Reader « reader = new » Input Stream Reader « ( bais ) ; » Sql Lob Value « lob = new » Sql Lob Value « ( reader , 3 , handler ) ; lob . » set Type Value « ( » prepared Statement « , 1 , Types . CLOB , " test " ) ; verify ( creator ) . » set Clob As Character Stream « ( eq ( » prepared Statement « ) , eq ( 1 ) , eq ( reader ) , eq ( 3 ) ) ; }
@Test { » Sql Lob Value « lob = new » Sql Lob Value « ( " bla " . » get Bytes « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lob . » set Type Value « ( » prepared Statement « , 1 , Types . CLOB , " test " ) ) ; }
@Test { » Sql Lob Value « lob = new » Sql Lob Value « ( " Bla " , handler ) ; lob . » set Type Value « ( » prepared Statement « , 1 , Types . CLOB , " test " ) ; lob . cleanup ( ) ; verify ( creator ) . » set Clob As String « ( » prepared Statement « , 1 , " Bla " ) ; verify ( creator ) . close ( ) ; }
@Test { » Sql Lob Value « lob = new » Sql Lob Value « ( " Bla " , handler ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> lob . » set Type Value « ( » prepared Statement « , 1 , Types . SMALLINT , " test " ) ) ; }
@Test { String » bogus Class Name « = " foobar " ; » Driver Manager Data Source « ds = new » Driver Manager Data Source « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> ds . » set Driver Class Name « ( » bogus Class Name « ) ) . » with Cause Instance Of « ( » Class Not Found Exception « . class ) ; }
@Test { » Data Source « » data Source « = mock ( » Data Source « . class ) ; Connection connection = mock ( Connection . class ) ; given ( » data Source « . » get Connection « ( " user " , " pw " ) ) . » will Return « ( connection ) ; » User Credentials Data Source Adapter « adapter = new » User Credentials Data Source Adapter « ( ) ; adapter . » set Target Data Source « ( » data Source « ) ; adapter . » set Username « ( " user " ) ; adapter . » set Password « ( " pw " ) ; » assert That « ( adapter . » get Connection « ( ) ) . » is Equal To « ( connection ) ; }
@Test { » Data Source « » data Source « = mock ( » Data Source « . class ) ; Connection connection = mock ( Connection . class ) ; given ( » data Source « . » get Connection « ( ) ) . » will Return « ( connection ) ; » User Credentials Data Source Adapter « adapter = new » User Credentials Data Source Adapter « ( ) ; adapter . » set Target Data Source « ( » data Source « ) ; » assert That « ( adapter . » get Connection « ( ) ) . » is Equal To « ( connection ) ; }
@Test { » do Test Jta Transaction « ( false ) ; }
@Test { » do Test Jta Transaction « ( true ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( false , false , false , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( false , false , true , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( false , true , false , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( false , true , true , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( false , false , true , true ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( true , false , false , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( true , false , true , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( true , true , false , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( true , true , true , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New « ( true , false , true , true ) ; }
@Test { » do Test Jta Transaction Commit With New Transaction Within Empty Transaction « ( false , false ) ; }
@Test { » do Test Jta Transaction Commit With New Transaction Within Empty Transaction « ( false , true ) ; }
@Test { » do Test Jta Transaction Commit With New Transaction Within Empty Transaction « ( true , false ) ; }
@Test { » do Test Jta Transaction Commit With New Transaction Within Empty Transaction « ( true , true ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( true , false , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( true , true , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( true , false , true ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( true , true , true ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( false , false , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( false , true , false ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( false , true , true ) ; }
@Test { » do Test Jta Transaction With Propagation Requires New And Begin Exception « ( false , false , true ) ; }
@Test { » do Test Jta Transaction With Isolation Level Data Source Router « ( false ) ; }
@Test { » do Test Jta Transaction With Isolation Level Data Source Router « ( true ) ; }
@Test { Connection connection = mock ( Connection . class ) ; given ( delegate . » get Connection « ( ) ) . » will Return « ( connection ) ; » assert That « ( » data Source « . » get Connection « ( ) ) . » is Equal To « ( connection ) ; }
@Test { Connection connection = mock ( Connection . class ) ; String username = " username " ; String password = " password " ; given ( delegate . » get Connection « ( username , password ) ) . » will Return « ( connection ) ; » assert That « ( » data Source « . » get Connection « ( username , password ) ) . » is Equal To « ( connection ) ; }
@Test { » Print Writer « writer = new » Print Writer « ( new » Byte Array Output Stream « ( ) ) ; given ( delegate . » get Log Writer « ( ) ) . » will Return « ( writer ) ; » assert That « ( » data Source « . » get Log Writer « ( ) ) . » is Equal To « ( writer ) ; }
@Test { » Print Writer « writer = new » Print Writer « ( new » Byte Array Output Stream « ( ) ) ; » data Source « . » set Log Writer « ( writer ) ; verify ( delegate ) . » set Log Writer « ( writer ) ; }
@Test { int timeout = 123 ; given ( delegate . » get Login Timeout « ( ) ) . » will Return « ( timeout ) ; » assert That « ( » data Source « . » get Login Timeout « ( ) ) . » is Equal To « ( timeout ) ; }
@Test { int timeout = 123 ; » data Source « . » set Login Timeout « ( timeout ) ; verify ( delegate ) . » set Login Timeout « ( timeout ) ; }
@Test { » Example Wrapper « wrapper = mock ( » Example Wrapper « . class ) ; given ( delegate . unwrap ( » Example Wrapper « . class ) ) . » will Return « ( wrapper ) ; » assert That « ( » data Source « . unwrap ( » Example Wrapper « . class ) ) . » is Equal To « ( wrapper ) ; }
@Test { » data Source « = new » Delegating Data Source With Wrapper « ( ) ; » assert That « ( » data Source « . unwrap ( » Example Wrapper « . class ) ) . » is Same As « ( » data Source « ) ; }
@Test { given ( delegate . » is Wrapper For « ( » Example Wrapper « . class ) ) . » will Return « ( true ) ; » assert That « ( » data Source « . » is Wrapper For « ( » Example Wrapper « . class ) ) . » is True « ( ) ; }
@Test { » data Source « = new » Delegating Data Source With Wrapper « ( ) ; » assert That « ( » data Source « . » is Wrapper For « ( » Example Wrapper « . class ) ) . » is True « ( ) ; }
@Test { » do Test Transaction Commit Restoring Auto Commit « ( true , false , false ) ; }
@Test { » do Test Transaction Commit Restoring Auto Commit « ( false , false , false ) ; }
@Test { » do Test Transaction Commit Restoring Auto Commit « ( true , true , false ) ; }
@Test { » do Test Transaction Commit Restoring Auto Commit « ( false , true , false ) ; }
@Test { » do Test Transaction Commit Restoring Auto Commit « ( true , true , true ) ; }
@Test { » do Test Transaction Commit Restoring Auto Commit « ( false , true , true ) ; }
@Test { » do Test Transaction Rollback Restoring Auto Commit « ( true , false , false ) ; }
@Test { » do Test Transaction Rollback Restoring Auto Commit « ( false , false , false ) ; }
@Test { » do Test Transaction Rollback Restoring Auto Commit « ( true , true , false ) ; }
@Test { » do Test Transaction Rollback Restoring Auto Commit « ( false , true , false ) ; }
@Test { » do Test Transaction Rollback Restoring Auto Commit « ( true , true , true ) ; }
@Test { » do Test Transaction Rollback Restoring Auto Commit « ( false , true , true ) ; }
@Test { » do Test Participating Transaction With Rollback Only « ( false ) ; }
@Test { » do Test Participating Transaction With Rollback Only « ( true ) ; }
@Test { » do Test Transaction With Timeout « ( 10 ) ; }
@Test { » do Test Transaction With Timeout « ( 1 ) ; }
@Test { » do Test Existing Transaction With Propagation Nested « ( 1 ) ; }
@Test { » do Test Existing Transaction With Propagation Nested « ( 2 ) ; }
@Test { » Stub Database Populator « populator = new » Stub Database Populator « ( ) ; factory . » set Database Populator « ( populator ) ; » Embedded Database « db = factory . » get Database « ( ) ; » assert That « ( populator . » populate Called « ) . » is True « ( ) ; db . shutdown ( ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = new » Embedded Database Builder « ( ) . » add Default Scripts « ( ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » assert That Exception Of Type « ( » Cannot Read Script Exception « . class ) . » is Thrown By « ( new » Embedded Database Builder « ( ) . » add Script « ( " bogus . sql " ) :: build ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » add Script « ( " db - schema . sql " ) . » add Script « ( " db - test - data . sql " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » add Scripts « ( " db - schema . sql " , " db - test - data . sql " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » add Scripts « ( " db - schema - comments . sql " , " db - test - data . sql " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » add Scripts « ( " db - schema - custom - comments . sql " , " db - test - data . sql " ) . » set Comment Prefix « ( " ~ " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » add Scripts « ( " db - schema - block - comments . sql " , " db - test - data . sql " ) . » set Block Comment Start Delimiter « ( " { * " ) . » set Block Comment End Delimiter « ( " * } " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » set Type « ( » H 2 « ) . » add Scripts « ( " db - schema . sql " , " db - test - data . sql " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » do Twice « ( new Runnable ( ) { @ Override public void run ( ) { » Embedded Database « db = builder . » set Type « ( DERBY ) . » ignore Failed Drops « ( true ) . » add Scripts « ( " db - schema - derby - with - drop . sql " , " db - test - data . sql " ) . build ( ) ; » assert Database Created And Shutdown « ( db ) ; } } ) ; }
@Test { » Embedded Database « » db 1 « = new » Embedded Database Builder « ( new » Class Relative Resource Loader « ( » get Class « ( ) ) ) . » add Scripts « ( " db - schema - without - dropping . sql " ) . build ( ) ; try { » assert That Exception Of Type « ( » Script Statement Failed Exception « . class ) . » is Thrown By « ( ( ) -> new » Embedded Database Builder « ( new » Class Relative Resource Loader « ( » get Class « ( ) ) ) . » add Scripts « ( " db - schema - without - dropping . sql " ) . build ( ) ) ; } finally { » db 1 « . shutdown ( ) ; } }
@Test { » database Populator « . » add Script « ( resource ( " db - schema - failed - drop - comments . sql " ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data . sql " ) ) ; » database Populator « . » set Ignore Failed Drops « ( true ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert Test Database Created « ( ) ; }
@Test { » database Populator « . » add Script « ( » default Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - escaped - literal . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert Test Database Created « ( " 'Keith' " ) ; }
@Test { » database Populator « . » add Script « ( » default Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - mysql - escaped - literal . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert Test Database Created « ( " \\ $ » Keith \\ « $ " ) ; }
@Test { » database Populator « . » add Script « ( » default Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - multiple . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert That « ( » jdbc Template « . » query For Object « ( » COUNT _ KEITH _ SQL « , Integer . class ) ) . » is Equal To « ( 1 ) ; » assert That « ( » jdbc Template « . » query For Object « ( » COUNT _ DAVE _ SQL « , Integer . class ) ) . » is Equal To « ( 1 ) ; }
@Test { » database Populator « . » add Script « ( » default Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - newline . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert That « ( » jdbc Template « . » query For Object « ( » COUNT _ KEITH _ SQL « , Integer . class ) ) . » is Equal To « ( 1 ) ; » assert That « ( » jdbc Template « . » query For Object « ( » COUNT _ DAVE _ SQL « , Integer . class ) ) . » is Equal To « ( 1 ) ; }
@Test { » database Populator « . » add Script « ( » users Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " users - data . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert Users Database Created « ( " Brannen " ) ; }
@Test { » database Populator « . » add Script « ( » users Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " users - data - with - comments . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert Users Database Created « ( " Brannen " , " Hoeller " ) ; }
@Test { » database Populator « . » set Separator « ( » Script Utils « . » EOF _ STATEMENT _ SEPARATOR « ) ; » database Populator « . » add Script « ( resource ( " drop - users - schema . sql " ) ) ; » database Populator « . » add Script « ( resource ( " users - schema - without - separator . sql " ) ) ; » database Populator « . » add Script « ( resource ( " users - data - without - separator . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert Users Database Created « ( " Brannen " ) ; }
@Test { final » Resource Database Populator « populator = new » Resource Database Populator « ( » users Schema « ( ) , resource ( " users - data - with - comments . sql " ) ) ; » Database Populator Utils « . execute ( populator , db ) ; » assert Users Database Created « ( " Brannen " , " Hoeller " ) ; }
@Test { » database Populator « . » add Script « ( » default Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - select . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; » assert That « ( » jdbc Template « . » query For Object « ( » COUNT _ KEITH _ SQL « , Integer . class ) ) . » is Equal To « ( 1 ) ; » assert That « ( » jdbc Template « . » query For Object « ( » COUNT _ DAVE _ SQL « , Integer . class ) ) . » is Equal To « ( 1 ) ; }
@Test { » Transaction Synchronization Manager « . » init Synchronization « ( ) ; Connection connection = » Data Source Utils « . » get Connection « ( db ) ; » Database Populator « populator = mock ( » Database Populator « . class ) ; » Database Populator Utils « . execute ( populator , db ) ; verify ( populator ) . populate ( connection ) ; }
@Test { » database Populator « . » add Script « ( » default Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - huge . sql " ) ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; }
@Test { » Composite Database Populator « populator = new » Composite Database Populator « ( ) ; populator . » add Populators « ( » mocked Database Populator 1 « , » mocked Database Populator 2 « ) ; populator . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 1 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 2 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; }
@Test { » Composite Database Populator « populator = new » Composite Database Populator « ( ) ; populator . » set Populators « ( » mocked Database Populator 1 « , » mocked Database Populator 2 « ) ; populator . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 1 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 2 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; }
@Test { » Composite Database Populator « populator = new » Composite Database Populator « ( ) ; populator . » set Populators « ( » mocked Database Populator 1 « ) ; populator . » set Populators « ( » mocked Database Populator 2 « ) ; populator . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 1 « , times ( 0 ) ) . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 2 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; }
@Test { » Composite Database Populator « populator = new » Composite Database Populator « ( » mocked Database Populator 1 « , » mocked Database Populator 2 « ) ; populator . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 1 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 2 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; }
@Test { Set < » Database Populator « > populators = new » Linked Hash Set « < > ( ) ; populators . add ( » mocked Database Populator 1 « ) ; populators . add ( » mocked Database Populator 2 « ) ; » Composite Database Populator « populator = new » Composite Database Populator « ( populators ) ; populator . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 1 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; verify ( » mocked Database Populator 2 « , times ( 1 ) ) . populate ( » mocked Connection « ) ; }
@Test { » database Populator « . » add Script « ( » users Schema « ( ) ) ; » database Populator « . » add Script « ( resource ( " db - test - data - » h 2 « - alias . sql " ) ) ; » database Populator « . » set Separator « ( " \n \n " ) ; » Database Populator Utils « . execute ( » database Populator « , db ) ; String sql = " select REVERSE ( » first _ name « ) from users where » last _ name « = 'Brannen' " ; » assert That « ( » jdbc Template « . » query For Object « ( sql , String . class ) ) . » is Equal To « ( " » ma S « " ) ; }
@Test { » execute Sql Script « ( db . » get Connection « ( ) , resource ( " test - data - with - multi - line - comments . sql " ) ) ; » assert Users Database Created « ( " Hoeller " , " Brannen " ) ; }
@Test { » execute Sql Script « ( db . » get Connection « ( ) , resource ( " users - data - with - single - quotes - nested - in - double - quotes . sql " ) ) ; » assert Users Database Created « ( " Hoeller " , " Brannen " ) ; }
@Test { String » statement 1 « = " do something " ; String » statement 2 « = " do something else " ; char delim = ' \n ' ; String script = » statement 1 « + delim + » statement 2 « + delim ; List < String > statements = new » Array List « < > ( ) ; » split Sql Script « ( script , » DEFAULT _ STATEMENT _ SEPARATOR « , statements ) ; » assert That « ( statements ) . as ( " stripped but not split statements " ) . » contains Exactly « ( script . replace ( ' \n ' , ' ' ) ) ; }
@Test { String » statement 1 « = " select '1' as \" Dogbert 's owner' s \" from dual " ; String » statement 2 « = " select ' 2 ' as \" Dilbert » ' s « \" from dual " ; char delim = ' ; ' ; String script = » statement 1 « + delim + » statement 2 « + delim ; List < String > statements = new » Array List « < > ( ) ; » split Sql Script « ( script , ' ; ' , statements ) ; » assert That « ( statements ) . » contains Exactly « ( » statement 1 « , » statement 2 « ) ; }
@Test { String script = » read Script « ( " db - test - data - multi - newline . sql " ) ; List < String > statements = new » Array List « < > ( ) ; » split Sql Script « ( script , " \n \n " , statements ) ; String » statement 1 « = " insert into » T _ TEST « ( NAME ) values ( 'Keith' ) " ; String » statement 2 « = " insert into » T _ TEST « ( NAME ) values ( 'Dave' ) " ; » assert That « ( statements ) . » contains Exactly « ( » statement 1 « , » statement 2 « ) ; }
@Test { String script = » read Script « ( " test - data - with - comments . sql " ) ; » split Script Containing Comments « ( script , » DEFAULT _ COMMENT _ PREFIXES « ) ; }
@Test { String script = » read Script « ( " test - data - with - comments . sql " ) . » replace All « ( " \n " , " \r \n " ) ; » split Script Containing Comments « ( script , » DEFAULT _ COMMENT _ PREFIXES « ) ; }
@Test { String script = » read Script « ( " test - data - with - multi - prefix - comments . sql " ) ; » split Script Containing Comments « ( script , " -- " , " # " , " ^ " ) ; }
@Test { String script = » read Script « ( " test - data - with - multi - line - comments . sql " ) ; List < String > statements = new » Array List « < > ( ) ; » split Sql Script « ( script , ' ; ' , statements ) ; String » statement 1 « = " INSERT INTO users ( » first _ name « , » last _ name « ) VALUES ( 'Juergen' , 'Hoeller' ) " ; String » statement 2 « = " INSERT INTO users ( » first _ name « , » last _ name « ) VALUES ( 'Sam' , 'Brannen' ) " ; » assert That « ( statements ) . » contains Exactly « ( » statement 1 « , » statement 2 « ) ; }
@Test { String script = » read Script « ( " test - data - with - multi - line - nested - comments . sql " ) ; List < String > statements = new » Array List « < > ( ) ; » split Sql Script « ( script , ' ; ' , statements ) ; String » statement 1 « = " INSERT INTO users ( » first _ name « , » last _ name « ) VALUES ( 'Juergen' , 'Hoeller' ) " ; String » statement 2 « = " INSERT INTO users ( » first _ name « , » last _ name « ) VALUES ( 'Sam' , 'Brannen' ) " ; » assert That « ( statements ) . » contains Exactly « ( » statement 1 « , » statement 2 « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Resource Database Populator « ( ( Resource ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Resource Database Populator « ( ( Resource [ ] ) null ) ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( » script 1 « ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( » script 1 « , » script 2 « ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( » script 1 « , » script 2 « ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 2 ) ; » database Populator « . » add Script « ( » script 3 « ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 3 ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » database Populator « . » add Scripts « ( ( Resource ) null ) ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » database Populator « . » add Scripts « ( ( Resource [ ] ) null ) ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » database Populator « . » set Scripts « ( ( Resource ) null ) ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » database Populator « . » set Scripts « ( ( Resource [ ] ) null ) ) ; }
@Test { » Resource Database Populator « » database Populator « = new » Resource Database Populator « ( ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 0 ) ; » database Populator « . » set Scripts « ( » script 1 « , » script 2 « ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 2 ) ; » database Populator « . » add Script « ( » script 3 « ) ; » assert That « ( » database Populator « . scripts . size ( ) ) . » is Equal To « ( 3 ) ; }
@Test { » Bean Factory Data Source Lookup « lookup = new » Bean Factory Data Source Lookup « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> lookup . » get Data Source « ( » DATASOURCE _ BEAN _ NAME « ) ) ; }
@Test { » Jndi Data Source Lookup « lookup = new » Jndi Data Source Lookup « ( ) { @ Override protected < T > T lookup ( String » jndi Name « , Class < T > » required Type « ) throws » Naming Exception « { » assert That « ( » jndi Name « ) . » is Equal To « ( » DATA _ SOURCE _ NAME « ) ; throw new » Naming Exception « ( ) ; } } ; » assert That Exception Of Type « ( » Data Source Lookup Failure Exception « . class ) . » is Thrown By « ( ( ) -> lookup . » get Data Source « ( » DATA _ SOURCE _ NAME « ) ) ; }
@Test { » Map Data Source Lookup « lookup = new » Map Data Source Lookup « ( ) ; Map » data Sources « = lookup . » get Data Sources « ( ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> » data Sources « . put ( " " , " " ) ) ; }
@Test { Map » data Sources « = new » Hash Map « ( ) ; » data Sources « . put ( » DATA _ SOURCE _ NAME « , new Object ( ) ) ; » Map Data Source Lookup « lookup = new » Map Data Source Lookup « ( » data Sources « ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> lookup . » get Data Source « ( » DATA _ SOURCE _ NAME « ) ) ; }
@Test { » Map Data Source Lookup « lookup = new » Map Data Source Lookup « ( ) ; » assert That Exception Of Type « ( » Data Source Lookup Failure Exception « . class ) . » is Thrown By « ( ( ) -> lookup . » get Data Source « ( » DATA _ SOURCE _ NAME « ) ) ; }
@Test { » do Test Batch Update « ( false ) ; }
@Test { » do Test Batch Update « ( true ) ; }
@Test { » Sql Query « < ? > query = ( » Sql Query « < ? > ) » bean Factory « . » get Bean « ( " » query With Placeholders « " ) ; » do Test Customer Query « ( query , false ) ; }
@Test { » Sql Query « < ? > query = ( » Sql Query « < ? > ) » bean Factory « . » get Bean « ( " » query With Named Parameters « " ) ; » do Test Customer Query « ( query , true ) ; }
@Test { » Sql Query « < ? > query = ( » Sql Query « < ? > ) » bean Factory « . » get Bean « ( " » query With Row Mapper Bean « " ) ; » do Test Customer Query « ( query , true ) ; }
@Test { given ( » result Set « . next ( ) ) . » will Return « ( false ) ; » String Query « query = new » String Query « ( » data Source « , » SELECT _ FORENAME _ EMPTY « ) ; String [ ] results = query . run ( ) ; » assert That « ( results ) . » is Equal To « ( new String [ 0 ] ) ; verify ( connection ) . » prepare Statement « ( » SELECT _ FORENAME _ EMPTY « ) ; verify ( » result Set « ) . close ( ) ; verify ( » prepared Statement « ) . close ( ) ; verify ( connection ) . close ( ) ; }
@Test { » do Test Named Parameter Customer Query « ( false ) ; }
@Test { » do Test Named Parameter Customer Query « ( true ) ; }
@Test { » SQL Exception « » sql Exception « = new » SQL Exception « ( " Syntax error or access violation exception " , " 42000 " ) ; given ( » callable Statement « . execute ( ) ) . » will Throw « ( » sql Exception « ) ; given ( connection . » prepare Call « ( " { call " + » No Such Stored Procedure « . SQL + " ( ) } " ) ) . » will Return « ( » callable Statement « ) ; » No Such Stored Procedure « sproc = new » No Such Stored Procedure « ( » data Source « ) ; » assert That Exception Of Type « ( » Bad Sql Grammar Exception « . class ) . » is Thrown By « ( sproc :: execute ) ; }
@Test { given ( » callable Statement « . execute ( ) ) . » will Return « ( false ) ; given ( » callable Statement « . » get Update Count « ( ) ) . » will Return « ( - 1 ) ; given ( connection . » prepare Call « ( " { call " + » Null Arg « . SQL + " ( ? ) } " ) ) . » will Return « ( » callable Statement « ) ; » Null Arg « na = new » Null Arg « ( » data Source « ) ; na . execute ( ( String ) null ) ; » callable Statement « . » set Null « ( 1 , Types . VARCHAR ) ; }
@Test { this . » verify Closed After « = false ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> new » Unnamed Parameter Stored Procedure « ( » data Source « ) ) ; }
@Test { this . » verify Closed After « = false ; » Missing Parameter Stored Procedure « mp = new » Missing Parameter Stored Procedure « ( » data Source « ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( mp :: execute ) ; }
@Test { » SQL Exception « » sql Exception « = new » SQL Exception « ( " Syntax error or access violation exception " , " 42000 " ) ; given ( » callable Statement « . execute ( ) ) . » will Throw « ( » sql Exception « ) ; given ( connection . » prepare Call « ( " { call " + » Stored Procedure Exception Translator « . SQL + " ( ) } " ) ) . » will Return « ( » callable Statement « ) ; » Stored Procedure Exception Translator « sproc = new » Stored Procedure Exception Translator « ( » data Source « ) ; » assert That Exception Of Type « ( » Custom Data Exception « . class ) . » is Thrown By « ( sproc :: execute ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 1 ) ; given ( connection . » prepare Statement « ( UPDATE ) ) . » will Return « ( » prepared Statement « ) ; Updater pc = new Updater ( ) ; int » rows Affected « = pc . run ( ) ; » assert That « ( » rows Affected « ) . » is Equal To « ( 1 ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 1 ) ; given ( connection . » prepare Statement « ( » UPDATE _ INT « ) ) . » will Return « ( » prepared Statement « ) ; » Int Updater « pc = new » Int Updater « ( ) ; int » rows Affected « = pc . run ( 1 ) ; » assert That « ( » rows Affected « ) . » is Equal To « ( 1 ) ; verify ( » prepared Statement « ) . » set Object « ( 1 , 1 , Types . NUMERIC ) ; }
@Test { » do Test Named Parameter Update « ( false ) ; }
@Test { » do Test Named Parameter Update « ( true ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 1 ) ; given ( connection . » prepare Statement « ( » UPDATE _ STRING « ) ) . » will Return « ( » prepared Statement « ) ; » String Updater « pc = new » String Updater « ( ) ; int » rows Affected « = pc . run ( " rod " ) ; » assert That « ( » rows Affected « ) . » is Equal To « ( 1 ) ; verify ( » prepared Statement « ) . » set String « ( 1 , " rod " ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 3 ) ; given ( connection . » prepare Statement « ( UPDATE ) ) . » will Return « ( » prepared Statement « ) ; » Max Rows Updater « pc = new » Max Rows Updater « ( ) ; int » rows Affected « = pc . run ( ) ; » assert That « ( » rows Affected « ) . » is Equal To « ( 3 ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 5 ) ; given ( connection . » prepare Statement « ( UPDATE ) ) . » will Return « ( » prepared Statement « ) ; » Max Rows Updater « pc = new » Max Rows Updater « ( ) ; int » rows Affected « = pc . run ( ) ; » assert That « ( » rows Affected « ) . » is Equal To « ( 5 ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 8 ) ; given ( connection . » prepare Statement « ( UPDATE ) ) . » will Return « ( » prepared Statement « ) ; » Max Rows Updater « pc = new » Max Rows Updater « ( ) ; » assert That Exception Of Type « ( » Jdbc Update Affected Incorrect Number Of Rows Exception « . class ) . » is Thrown By « ( pc :: run ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 3 ) ; given ( connection . » prepare Statement « ( UPDATE ) ) . » will Return « ( » prepared Statement « ) ; » Required Rows Updater « pc = new » Required Rows Updater « ( ) ; int » rows Affected « = pc . run ( ) ; » assert That « ( » rows Affected « ) . » is Equal To « ( 3 ) ; }
@Test { given ( » prepared Statement « . » execute Update « ( ) ) . » will Return « ( 2 ) ; given ( connection . » prepare Statement « ( UPDATE ) ) . » will Return « ( » prepared Statement « ) ; » Required Rows Updater « pc = new » Required Rows Updater « ( ) ; » assert That Exception Of Type « ( » Jdbc Update Affected Incorrect Number Of Rows Exception « . class ) . » is Thrown By « ( pc :: run ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( operation :: compile ) ; }
@Test { operation . » set Data Source « ( new » Driver Manager Data Source « ( ) ) ; operation . » set Sql « ( " select * from mytable " ) ; operation . compile ( ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . » set Types « ( new int [ ] { Types . INTEGER } ) ) ; }
@Test { operation . » set Data Source « ( new » Driver Manager Data Source « ( ) ) ; operation . » set Sql « ( " select * from mytable " ) ; operation . compile ( ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . » declare Parameter « ( new » Sql Parameter « ( Types . INTEGER ) ) ) ; }
@Test { operation . » set Sql « ( " select * from mytable " ) ; operation . » set Types « ( new int [ ] { Types . INTEGER } ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . » validate Parameters « ( ( Object [ ] ) null ) ) ; }
@Test { operation . » set Sql « ( " select * from mytable " ) ; operation . » set Types « ( new int [ ] { Types . INTEGER } ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . » validate Named Parameters « ( ( Map < String , String > ) null ) ) ; }
@Test { operation . » set Sql « ( " foo " ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . compile ( ) ) . » with Message Containing « ( " » ata Source « " ) ; }
@Test { operation . » set Sql « ( " select * from mytable " ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . » validate Parameters « ( new Object [ ] { 1 , 2 } ) ) ; }
@Test { operation . » set Sql « ( " select * from mytable " ) ; Map < String , String > params = new » Hash Map « < > ( ) ; params . put ( " » col 1 « " , " value " ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( ( ) -> operation . » validate Named Parameters « ( params ) ) ; }
@Test { operation . » set Data Source « ( new » Driver Manager Data Source « ( ) ) ; operation . » set Sql « ( " select * from mytable " ) ; operation . » set Types « ( null ) ; operation . compile ( ) ; operation . compile ( ) ; }
@Test { » Sql Operation « operation = new » Sql Operation « ( ) { } ; operation . » set Sql « ( " select * from mytable " ) ; » assert That Exception Of Type « ( » Invalid Data Access Api Usage Exception « . class ) . » is Thrown By « ( operation :: compile ) ; }
@Test { operation . » set Data Source « ( new » Driver Manager Data Source « ( ) ) ; operation . » set Sql « ( " » DUMMY _ PROC « " ) ; operation . » declare Parameter « ( new » Sql Out Parameter « ( " » DUMMY _ OUT _ PARAM « " , Types . VARCHAR ) ) ; operation . » declare Parameter « ( new » Sql In Out Parameter « ( " » DUMMY _ IN _ OUT _ PARAM « " , Types . VARCHAR ) ) ; operation . » validate Parameters « ( new Object [ ] { " » DUMMY _ VALUE 1 « " , " » DUMMY _ VALUE 2 « " } ) ; }
@Test { » assert That « ( » Jdbc Utils « . » resolve Type Name « ( Types . VARCHAR ) ) . » is Equal To « ( " VARCHAR " ) ; » assert That « ( » Jdbc Utils « . » resolve Type Name « ( Types . NUMERIC ) ) . » is Equal To « ( " NUMERIC " ) ; » assert That « ( » Jdbc Utils « . » resolve Type Name « ( Types . INTEGER ) ) . » is Equal To « ( " INTEGER " ) ; » assert That « ( » Jdbc Utils « . » resolve Type Name « ( » Jdbc Utils « . » TYPE _ UNKNOWN « ) ) . » is Null « ( ) ; }
@Test { kh . » get Key List « ( ) . » add All « ( » singleton List « ( » singleton Map « ( " key " , 1 ) ) ) ; » assert That « ( kh . » get Key « ( ) . » int Value « ( ) ) . as ( " single key should be returned " ) . » is Equal To « ( 1 ) ; }
@Test { kh . » get Key List « ( ) . » add All « ( » singleton List « ( » singleton Map « ( " key " , " 1 " ) ) ) ; » assert That Exception Of Type « ( » Data Retrieval Failure Exception « . class ) . » is Thrown By « ( ( ) -> kh . » get Key « ( ) . » int Value « ( ) ) . » with Message Starting With « ( " The generated key is not of a supported numeric type . " ) ; }
@Test { kh . » get Key List « ( ) . » add All « ( » singleton List « ( » empty Map « ( ) ) ) ; » assert That Exception Of Type « ( » Data Retrieval Failure Exception « . class ) . » is Thrown By « ( ( ) -> kh . » get Key « ( ) ) . » with Message Starting With « ( " Unable to retrieve the generated key . " ) ; }
@Test { » SQL Exception Translator « sext = new » SQL Error Code SQL Exception Translator « ( » ERROR _ CODES « ) ; » SQL Exception « » data Access Ex « = new » SQL Exception « ( " " , " " , 5 ) ; » Data Truncation « » data Truncation « = new » Data Truncation « ( 1 , true , true , 1 , 1 , » data Access Ex « ) ; » Data Access Resource Failure Exception « daex = ( » Data Access Resource Failure Exception « ) sext . translate ( " task " , " SQL " , » data Truncation « ) ; » assert That « ( daex . » get Cause « ( ) ) . » is Equal To « ( » data Truncation « ) ; }
@Test { » SQL Error Codes « sec = » SQL Error Codes Factory « . » get Instance « ( ) . » get Error Codes « ( " xx " ) ; » assert That « ( sec . » get Bad Sql Grammar Codes « ( ) . length == 0 ) . » is True « ( ) ; » assert That « ( sec . » get Data Integrity Violation Codes « ( ) . length == 0 ) . » is True « ( ) ; }
@Test { » SQL Error Codes « sec = » SQL Error Codes Factory « . » get Instance « ( ) . » get Error Codes « ( " Oracle " ) ; » assert Is Oracle « ( sec ) ; }
@Test { Connection connection = mock ( Connection . class ) ; » Data Source « » data Source « = mock ( » Data Source « . class ) ; given ( » data Source « . » get Connection « ( ) ) . » will Return « ( connection ) ; » SQL Error Codes « sec = » SQL Error Codes Factory « . » get Instance « ( ) . » get Error Codes « ( » data Source « ) ; » assert Is Empty « ( sec ) ; verify ( connection ) . close ( ) ; }
@Test { » SQL Exception « » expected SQL Exception « = new » SQL Exception « ( ) ; » Data Source « » data Source « = mock ( » Data Source « . class ) ; given ( » data Source « . » get Connection « ( ) ) . » will Throw « ( » expected SQL Exception « ) ; » SQL Error Codes « sec = » SQL Error Codes Factory « . » get Instance « ( ) . » get Error Codes « ( » data Source « ) ; » assert Is Empty « ( sec ) ; }
@Test { » SQL Error Codes « sec = » get Error Codes From Data Source « ( " MS - SQL " , null ) ; » assert Is SQL Server « ( sec ) ; }
@Test { » SQL Error Codes « sec = » get Error Codes From Data Source « ( " Oracle " , null ) ; » assert Is Oracle « ( sec ) ; }
@Test { » SQL Error Codes « sec = » get Error Codes From Data Source « ( " HSQL Database Engine " , null ) ; » assert Is Hsql « ( sec ) ; }
@Test { » SQL Error Codes « sec = » get Error Codes From Data Source « ( " » DB 2 « " , null ) ; » assert Is DB 2 « ( sec ) ; sec = » get Error Codes From Data Source « ( " » DB 2 « / " , null ) ; » assert Is DB 2 « ( sec ) ; sec = » get Error Codes From Data Source « ( " DB - 2 " , null ) ; » assert Is Empty « ( sec ) ; }
@Test { » SQL Error Codes « sec = » get Error Codes From Data Source « ( " SAP DB " , null ) ; » assert Is Hana « ( sec ) ; }
@Test { » SQL Exception « » bad Sql Grammar Exception Ex « = » SQL Exception Subclass Factory « . » new SQL Data Exception « ( " " , " " , 1 ) ; » Data Access Exception « dae = sext . translate ( " task " , " SQL " , » bad Sql Grammar Exception Ex « ) ; » assert That « ( dae . » get Cause « ( ) ) . » is Equal To « ( » bad Sql Grammar Exception Ex « ) ; » assert That « ( dae ) . » is Instance Of « ( » Bad Sql Grammar Exception « . class ) ; }
@Test { » SQL Exception « » data Access Resource Ex « = » SQL Exception Subclass Factory « . » new SQL Data Exception « ( " " , " " , 2 ) ; » Data Access Exception « dae = sext . translate ( " task " , " SQL " , » data Access Resource Ex « ) ; » assert That « ( dae . » get Cause « ( ) ) . » is Equal To « ( » data Access Resource Ex « ) ; » assert That « ( dae ) . » is Instance Of « ( » Transient Data Access Resource Exception « . class ) ; }
@Test { » SQL Exception « sex = new » SQL Exception « ( " Message " , " 42001 " , 1 ) ; try { throw this . trans . translate ( " task " , sql , sex ) ; } catch ( » Bad Sql Grammar Exception « ex ) { » assert That « ( sql . equals ( ex . » get Sql « ( ) ) ) . as ( " SQL is correct " ) . » is True « ( ) ; » assert That « ( sex . equals ( ex . » get SQL Exception « ( ) ) ) . as ( " Exception matches " ) . » is True « ( ) ; } }
@Test { » SQL Exception « sex = new » SQL Exception « ( " Message " , " NO SUCH CODE " , 1 ) ; try { throw this . trans . translate ( " task " , sql , sex ) ; } catch ( » Uncategorized SQL Exception « ex ) { » assert That « ( sql . equals ( ex . » get Sql « ( ) ) ) . as ( " SQL is correct " ) . » is True « ( ) ; » assert That « ( sex . equals ( ex . » get SQL Exception « ( ) ) ) . as ( " Exception matches " ) . » is True « ( ) ; } }
@Test { » SQL Exception « sex = new » SQL Exception « ( " Message " , null , 1 ) ; » test Malformed Sql State Code « ( sex ) ; sex = new » SQL Exception « ( " Message " , " " , 1 ) ; » test Malformed Sql State Code « ( sex ) ; sex = new » SQL Exception « ( " Message " , " I " , 1 ) ; » test Malformed Sql State Code « ( sex ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » SQL State SQL Exception Translator « ( ) . translate ( " " , " " , null ) ) ; }
@Test { » do Test « ( " 07 " , » Bad Sql Grammar Exception « . class ) ; }
@Test { » do Test « ( " 23 " , » Data Integrity Violation Exception « . class ) ; }
@Test { » do Test « ( " 53 " , » Data Access Resource Failure Exception « . class ) ; }
@Test { » do Test « ( " » S 1 « " , » Transient Data Access Resource Exception « . class ) ; }
@Test { » do Test « ( " 40 " , » Concurrency Failure Exception « . class ) ; }
@Test { » do Test « ( " 00000000 " , » Uncategorized SQL Exception « . class ) ; }
@Test { » lob Handler « . » get Blob As Bytes « ( rs , 1 ) ; verify ( rs ) . » get Bytes « ( 1 ) ; }
@Test { » lob Handler « . » get Blob As Binary Stream « ( rs , 1 ) ; verify ( rs ) . » get Binary Stream « ( 1 ) ; }
@Test { » lob Handler « . » get Clob As String « ( rs , 1 ) ; verify ( rs ) . » get String « ( 1 ) ; }
@Test { » lob Handler « . » get Clob As Ascii Stream « ( rs , 1 ) ; verify ( rs ) . » get Ascii Stream « ( 1 ) ; }
@Test { » lob Handler « . » get Clob As Character Stream « ( rs , 1 ) ; verify ( rs ) . » get Character Stream « ( 1 ) ; }
@Test { byte [ ] content = " » test Content « " . » get Bytes « ( ) ; » lob Creator « . » set Blob As Bytes « ( ps , 1 , content ) ; verify ( ps ) . » set Bytes « ( 1 , content ) ; }
@Test { » Input Stream « bis = new » Byte Array Input Stream « ( " » test Content « " . » get Bytes « ( ) ) ; » lob Creator « . » set Blob As Binary Stream « ( ps , 1 , bis , 11 ) ; verify ( ps ) . » set Binary Stream « ( 1 , bis , 11 ) ; }
@Test { » Input Stream « bis = new » Byte Array Input Stream « ( " » test Content « " . » get Bytes « ( ) ) ; » lob Creator « . » set Blob As Binary Stream « ( ps , 1 , bis , - 1 ) ; verify ( ps ) . » set Binary Stream « ( 1 , bis ) ; }
@Test { String content = " » test Content « " ; » lob Creator « . » set Clob As String « ( ps , 1 , content ) ; verify ( ps ) . » set String « ( 1 , content ) ; }
@Test { » Input Stream « bis = new » Byte Array Input Stream « ( " » test Content « " . » get Bytes « ( ) ) ; » lob Creator « . » set Clob As Ascii Stream « ( ps , 1 , bis , 11 ) ; verify ( ps ) . » set Ascii Stream « ( 1 , bis , 11 ) ; }
@Test { » Input Stream « bis = new » Byte Array Input Stream « ( " » test Content « " . » get Bytes « ( ) ) ; » lob Creator « . » set Clob As Ascii Stream « ( ps , 1 , bis , - 1 ) ; verify ( ps ) . » set Ascii Stream « ( 1 , bis ) ; }
@Test { Reader str = new » String Reader « ( " » test Content « " ) ; » lob Creator « . » set Clob As Character Stream « ( ps , 1 , str , 11 ) ; verify ( ps ) . » set Character Stream « ( 1 , str , 11 ) ; }
@Test { Reader str = new » String Reader « ( " » test Content « " ) ; » lob Creator « . » set Clob As Character Stream « ( ps , 1 , str , - 1 ) ; verify ( ps ) . » set Character Stream « ( 1 , str ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Big Decimal « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Big Decimal « " , int . class ) ; » do Test « ( rset , rowset , 1 , » Big Decimal « . ONE ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Big Decimal « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Big Decimal « " , String . class ) ; » do Test « ( rset , rowset , " test " , » Big Decimal « . ONE ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get String « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get String « " , int . class ) ; » do Test « ( rset , rowset , 1 , " test " ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get String « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get String « " , String . class ) ; » do Test « ( rset , rowset , " test " , " test " ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Timestamp « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Timestamp « " , int . class ) ; » do Test « ( rset , rowset , 1 , new Timestamp ( 1234L ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Timestamp « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Timestamp « " , String . class ) ; » do Test « ( rset , rowset , " test " , new Timestamp ( 1234L ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Date « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Date « " , int . class ) ; » do Test « ( rset , rowset , 1 , new Date ( 1234L ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Date « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Date « " , String . class ) ; » do Test « ( rset , rowset , " test " , new Date ( 1234L ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Time « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Time « " , int . class ) ; » do Test « ( rset , rowset , 1 , new Time ( 1234L ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Time « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Time « " , String . class ) ; » do Test « ( rset , rowset , " test " , new Time ( 1234L ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Object « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Object « " , int . class ) ; » do Test « ( rset , rowset , 1 , new Object ( ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Object « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Object « " , String . class ) ; » do Test « ( rset , rowset , " test " , new Object ( ) ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Int « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Int « " , int . class ) ; » do Test « ( rset , rowset , 1 , 1 ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Int « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Int « " , String . class ) ; » do Test « ( rset , rowset , " test " , 1 ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Float « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Float « " , int . class ) ; » do Test « ( rset , rowset , 1 , 1.0f ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Float « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Float « " , String . class ) ; » do Test « ( rset , rowset , " test " , 1.0f ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Double « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Double « " , int . class ) ; » do Test « ( rset , rowset , 1 , 1.0d ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Double « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Double « " , String . class ) ; » do Test « ( rset , rowset , " test " , 1.0d ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Long « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Long « " , int . class ) ; » do Test « ( rset , rowset , 1 , 1L ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Long « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Long « " , String . class ) ; » do Test « ( rset , rowset , " test " , 1L ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Boolean « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Boolean « " , int . class ) ; » do Test « ( rset , rowset , 1 , true ) ; }
@Test { Method rset = » Result Set « . class . » get Declared Method « ( " » get Boolean « " , int . class ) ; Method rowset = » Result Set Wrapping Sql Row Set « . class . » get Declared Method « ( " » get Boolean « " , String . class ) ; » do Test « ( rset , rowset , " test " , true ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Sample Config « . class , » Sample Bean « . class ) ; » test Sample Configuration « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Full Config « . class , » Full Bean « . class ) ; » test Full Configuration « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Full Configurable Config « . class , » Full Configurable Bean « . class ) ; » test Full Configuration « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Custom Config « . class , » Custom Bean « . class ) ; » test Custom Configuration « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Custom Container Factory Config « . class , » Default Bean « . class ) ; » test Explicit Container Factory Configuration « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Default Container Factory Config « . class , » Default Bean « . class ) ; » test Default Container Factory Configuration « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Default Container Factory Config « . class , » Default Bean « . class ) ; » Jms Listener Container Test Factory « factory = context . » get Bean « ( » Jms Listener Container Test Factory « . class ) ; » Message Listener Test Container « container = factory . » get Listener Containers « ( ) . get ( 0 ) ; » assert That « ( container . » is Auto Startup « ( ) ) . » is True « ( ) ; » assert That « ( container . » is Started « ( ) ) . » is True « ( ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Handler Method Factory Config « . class , » Validation Bean « . class ) ; » assert That Exception Of Type « ( » Listener Execution Failed Exception « . class ) . » is Thrown By « ( ( ) -> » test Jms Handler Method Factory Configuration « ( context ) ) . » with Cause Instance Of « ( » Method Argument Not Valid Exception « . class ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Default Container Factory Config « . class , » Jms Listener Repeatable Bean « . class ) ; » test Jms Listener Repeatable « ( context ) ; }
@Test { » Configurable Application Context « context = new » Annotation Config Application Context « ( » Enable Jms Default Container Factory Config « . class , » Jms Listeners Bean « . class ) ; » test Jms Listener Repeatable « ( context ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Enable Jms Sample Config « . class , » Custom Bean « . class ) ) . » with Message Containing « ( " » custom Factory « " ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( Config . class , » Proxy Config « . class , » Invalid Proxy Test Bean « . class ) ) . » with Cause Instance Of « ( » Illegal State Exception « . class ) . » with Message Containing « ( " » handle It 2 « " ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - sample - config . xml " , » get Class « ( ) ) ; » test Sample Configuration « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - full - config . xml " , » get Class « ( ) ) ; » test Full Configuration « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - full - configurable - config . xml " , » get Class « ( ) ) ; » test Full Configuration « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - custom - registry . xml " , » get Class « ( ) ) ; » test Custom Configuration « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - custom - container - factory . xml " , » get Class « ( ) ) ; » test Explicit Container Factory Configuration « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - default - container - factory . xml " , » get Class « ( ) ) ; » test Default Container Factory Configuration « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - custom - handler - method - factory . xml " , » get Class « ( ) ) ; » assert That Exception Of Type « ( » Listener Execution Failed Exception « . class ) . » is Thrown By « ( ( ) -> » test Jms Handler Method Factory Configuration « ( context ) ) . » with Cause Instance Of « ( » Method Argument Not Valid Exception « . class ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - jms - listener - repeatable . xml " , » get Class « ( ) ) ; » test Jms Listener Repeatable « ( context ) ; }
@Test { » Application Context « context = new » Class Path Xml Application Context « ( " annotation - driven - jms - listeners . xml " , » get Class « ( ) ) ; » test Jms Listener Repeatable « ( context ) ; }
@Test { » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; » Message Listener « » message Listener « = new » Message Listener Adapter « ( ) ; endpoint . » set Message Listener « ( » message Listener « ) ; » assert That « ( endpoint . » create Message Listener « ( container ) ) . » is Same As « ( » message Listener « ) ; }
@Test { this . » container Factory « . » set Message Converter « ( new » Upper Case Message Converter « ( ) ) ; » test Message Converter Is Used « ( ) ; }
@Test { » Messaging Message Converter « converter = new » Messaging Message Converter « ( ) ; converter . » set Payload Converter « ( new » Upper Case Message Converter « ( ) ) ; this . » container Factory « . » set Message Converter « ( converter ) ; » test Message Converter Is Used « ( ) ; }
@Test { » Default Jca Listener Container Factory « factory = new » Default Jca Listener Container Factory « ( ) ; factory . » set Destination Resolver « ( this . » destination Resolver « ) ; factory . » set Activation Spec Factory « ( new » Stub Jms Activation Spec Factory « ( ) ) ; » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; endpoint . » set Message Listener « ( new » Message Listener Adapter « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> factory . » create Listener Container « ( endpoint ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . registrar . » register Endpoint « ( null , this . » container Factory « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . registrar . » register Endpoint « ( new » Simple Jms Listener Endpoint « ( ) , this . » container Factory « ) ) ; }
@Test { » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; endpoint . » set Id « ( " " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . registrar . » register Endpoint « ( endpoint , this . » container Factory « ) ) ; }
@Test { » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; endpoint . » set Id « ( " some id " ) ; this . registrar . » register Endpoint « ( endpoint , null ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . registrar . » after Properties Set « ( ) ) . » with Message Containing « ( endpoint . » to String « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> registry . » register Listener Container « ( null , » container Factory « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> registry . » register Listener Container « ( new » Simple Jms Listener Endpoint « ( ) , » container Factory « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> registry . » register Listener Container « ( » create Endpoint « ( " foo " , " » my Destination « " ) , null ) ) ; }
@Test { registry . » register Listener Container « ( » create Endpoint « ( " test " , " queue " ) , » container Factory « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> registry . » register Listener Container « ( » create Endpoint « ( " test " , " queue " ) , » container Factory « ) ) ; }
@Test { Iterator < » Component Definition « > iterator = context . » get Registered Components « ( ) ; while ( iterator . » has Next « ( ) ) { » Component Definition « » comp Def « = iterator . next ( ) ; » assert That « ( » comp Def « . » get Source « ( ) ) . as ( " » Composite Component Definition « ' " + » comp Def « . » get Name « ( ) + " ' has no source attachment " ) . » is Not Null « ( ) ; » validate Component Definition « ( » comp Def « ) ; } }
@Test { » Simple Message Listener Container « container = new » Simple Message Listener Container « ( ) ; » Message Listener « » message Listener « = new » Message Listener Adapter « ( ) ; » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; endpoint . » set Concurrency « ( " 5 - 10 " ) ; endpoint . » set Message Listener « ( » message Listener « ) ; endpoint . » setup Listener Container « ( container ) ; » assert That « ( new » Direct Field Accessor « ( container ) . » get Property Value « ( " » concurrent Consumers « " ) ) . » is Equal To « ( 10 ) ; }
@Test { » Default Message Listener Container « container = new » Default Message Listener Container « ( ) ; » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> endpoint . » setup Listener Container « ( container ) ) ; }
@Test { » Message Listener Container « container = mock ( » Message Listener Container « . class ) ; » Simple Jms Listener Endpoint « endpoint = new » Simple Jms Listener Endpoint « ( ) ; endpoint . » set Message Listener « ( new » Message Listener Adapter « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> endpoint . » setup Listener Container « ( container ) ) ; }
@Test { » Method Jms Listener Endpoint « endpoint = new » Method Jms Listener Endpoint « ( ) ; endpoint . » set Bean « ( this ) ; endpoint . » set Method « ( » get Test Method « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> endpoint . » create Message Listener « ( this . container ) ) ; }
@Test { » Method Jms Listener Endpoint « endpoint = new » Method Jms Listener Endpoint « ( ) ; endpoint . » set Bean « ( this ) ; endpoint . » set Method « ( » get Test Method « ( ) ) ; endpoint . » set Message Handler Method Factory « ( this . factory ) ; » assert That « ( endpoint . » create Message Listener « ( this . container ) ) . » is Not Null « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( javax . jms . Message . class , Session . class ) ; Session session = mock ( Session . class ) ; listener . » on Message « ( » create Simple Jms Text Message « ( " test " ) , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( Message . class ) ; Session session = mock ( Session . class ) ; listener . » on Message « ( » create Simple Jms Text Message « ( " test " ) , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( String . class , int . class ) ; Session session = mock ( Session . class ) ; » Stub Text Message « message = » create Simple Jms Text Message « ( " my payload " ) ; message . » set Int Property « ( " » my Counter « " , 55 ) ; listener . » on Message « ( message , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( String . class , int . class ) ; Session session = mock ( Session . class ) ; » Stub Text Message « message = » create Simple Jms Text Message « ( " my payload " ) ; message . » set Int Property « ( " » my Counter « " , 24 ) ; listener . » on Message « ( message , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( String . class , Map . class ) ; Session session = mock ( Session . class ) ; » Stub Text Message « message = » create Simple Jms Text Message « ( " my payload " ) ; message . » set Int Property « ( " » custom Int « " , 1234 ) ; message . » set JMS Message ID « ( " abcd - 1234 " ) ; listener . » on Message « ( message , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( » Message Headers « . class ) ; Session session = mock ( Session . class ) ; » Stub Text Message « message = » create Simple Jms Text Message « ( " my payload " ) ; message . » set Long Property « ( " » custom Long « " , 4567L ) ; message . » set JMS Type « ( " » my Message Type « " ) ; listener . » on Message « ( message , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( » Jms Message Header Accessor « . class ) ; Session session = mock ( Session . class ) ; » Stub Text Message « message = » create Simple Jms Text Message « ( " my payload " ) ; message . » set Boolean Property « ( " » custom Boolean « " , true ) ; message . » set JMS Priority « ( 9 ) ; listener . » on Message « ( message , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( » My Bean « . class ) ; » My Bean « » my Bean « = new » My Bean « ( ) ; » my Bean « . name = " » my Bean « name " ; Session session = mock ( Session . class ) ; » Object Message « message = mock ( » Object Message « . class ) ; given ( message . » get Object « ( ) ) . » will Return « ( » my Bean « ) ; listener . » on Message « ( message , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( Integer . class ) ; Session session = mock ( Session . class ) ; listener . » on Message « ( » create Simple Jms Text Message « ( " 33 " ) , session ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { String » method Name « = " » process And Reply With Send To « " ; » Simple Message Listener Container « container = new » Simple Message Listener Container « ( ) ; » Messaging Message Listener Adapter « listener = » create Instance « ( this . factory , » get Listener Method « ( » method Name « , String . class ) , container ) ; » process And Reply With Send To « ( listener , " » reply Destination « " , false ) ; » assert Listener Method Invocation « ( this . sample , » method Name « ) ; }
@Test { String » method Name « = " » process And Reply With Send To « " ; » Simple Message Listener Container « container = new » Simple Message Listener Container « ( ) ; container . » set Pub Sub Domain « ( true ) ; container . » set Reply Pub Sub Domain « ( false ) ; » Messaging Message Listener Adapter « listener = » create Instance « ( this . factory , » get Listener Method « ( » method Name « , String . class ) , container ) ; » process And Reply With Send To « ( listener , " » reply Destination « " , false ) ; » assert Listener Method Invocation « ( this . sample , » method Name « ) ; }
@Test { String » method Name « = " » process And Reply With Send To « " ; » Simple Message Listener Container « container = new » Simple Message Listener Container « ( ) ; container . » set Pub Sub Domain « ( true ) ; » Messaging Message Listener Adapter « listener = » create Instance « ( this . factory , » get Listener Method « ( » method Name « , String . class ) , container ) ; » process And Reply With Send To « ( listener , " » reply Destination « " , true ) ; » assert Listener Method Invocation « ( this . sample , » method Name « ) ; }
@Test { String » method Name « = " » process And Reply With Send To « " ; » Simple Message Listener Container « container = new » Simple Message Listener Container « ( ) ; container . » set Reply Pub Sub Domain « ( true ) ; » Messaging Message Listener Adapter « listener = » create Instance « ( this . factory , » get Listener Method « ( » method Name « , String . class ) , container ) ; » process And Reply With Send To « ( listener , " » reply Destination « " , true ) ; » assert Listener Method Invocation « ( this . sample , » method Name « ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( String . class ) ; » process And Reply With Send To « ( listener , " » default Reply « " , false ) ; » assert Default Listener Method Invocation « ( ) ; }
@Test { String » method Name « = " » process And Reply With Send To « " ; » Simple Message Listener Container « container = new » Simple Message Listener Container « ( ) ; container . » set Reply Qos Settings « ( null ) ; » Messaging Message Listener Adapter « listener = » create Instance « ( this . factory , » get Listener Method « ( » method Name « , String . class ) , container ) ; » process And Reply With Send To « ( listener , " » reply Destination « " , false ) ; » assert Listener Method Invocation « ( this . sample , » method Name « ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( String . class ) ; » Text Message « reply = mock ( » Text Message « . class ) ; Session session = mock ( Session . class ) ; given ( session . » create Text Message « ( " content " ) ) . » will Return « ( reply ) ; » assert That Exception Of Type « ( » Reply Failure Exception « . class ) . » is Thrown By « ( ( ) -> listener . » on Message « ( » create Simple Jms Text Message « ( " content " ) , session ) ) . » with Cause Instance Of « ( » Invalid Destination Exception « . class ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » create Default Instance « ( String . class ) ) . » with Message Containing « ( " » first Destination « " ) . » with Message Containing « ( " » second Destination « " ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( Integer . class ) ; Session session = mock ( Session . class ) ; » assert That Exception Of Type « ( » Listener Execution Failed Exception « . class ) . » is Thrown By « ( ( ) -> listener . » on Message « ( » create Simple Jms Text Message « ( " test " ) , session ) ) . » with Cause Instance Of « ( » Message Conversion Exception « . class ) . » with Message Containing « ( » get Default Listener Method « ( Integer . class ) . » to Generic String « ( ) ) ; }
@Test { » Messaging Message Listener Adapter « listener = » create Default Instance « ( Message . class ) ; Session session = mock ( Session . class ) ; » assert That Exception Of Type « ( » Listener Execution Failed Exception « . class ) . » is Thrown By « ( ( ) -> listener . » on Message « ( » create Simple Jms Text Message « ( " test " ) , session ) ) . » with Cause Instance Of « ( » Message Conversion Exception « . class ) ; }
@Test { » Connection Factory « cf = mock ( » Connection Factory « . class ) ; » Jms Transaction Manager « tm = new » Jms Transaction Manager « ( cf ) ; tm . » set Lazy Resource Retrieval « ( true ) ; » Transaction Status « ts = tm . » get Transaction « ( new » Default Transaction Definition « ( ) ) ; tm . commit ( ts ) ; }
@Test { » Jms Template « template = » create Template « ( ) ; template . » set Connection Factory « ( this . » connection Factory « ) ; template . execute ( new » Session Callback « < Void > ( ) { @ Override public Void » do In Jms « ( Session session ) throws » JMS Exception « { session . » get Transacted « ( ) ; return null ; } } ) ; verify ( this . session ) . close ( ) ; verify ( this . connection ) . close ( ) ; }
@Test { » do Test Send Destination « ( true , false , true , false ) ; }
@Test { » do Test Send Destination « ( false , false , true , false ) ; }
@Test { » do Test Send Destination « ( true , false , false , true ) ; }
@Test { » do Test Send Destination « ( false , false , false , true ) ; }
@Test { » do Test Send Destination « ( true , true , true , true ) ; }
@Test { » do Test Send Destination « ( false , true , true , true ) ; }
@Test { » do Test Send Destination « ( true , true , false , false ) ; }
@Test { » do Test Send Destination « ( false , true , false , false ) ; }
@Test { » do Test Receive « ( true , true , false , false , false , false , » Jms Template « . » RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT « ) ; }
@Test { » do Test Receive « ( false , true , false , false , false , false , » Jms Template « . » RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT « ) ; }
@Test { » do Test Receive « ( true , false , false , false , false , true , » Jms Template « . » RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT « ) ; }
@Test { » do Test Receive « ( true , false , false , true , false , false , 1000 ) ; }
@Test { » do Test Receive « ( false , false , false , false , false , true , 1000 ) ; }
@Test { » do Test Receive « ( true , true , false , false , true , true , 1000 ) ; }
@Test { » do Test Receive « ( false , true , false , false , true , true , » Jms Template « . » RECEIVE _ TIMEOUT _ NO _ WAIT « ) ; }
@Test { » do Test Receive « ( true , false , false , false , true , false , 1000 ) ; }
@Test { » do Test Receive « ( true , false , false , true , true , true , » Jms Template « . » RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT « ) ; }
@Test { » do Test Receive « ( false , false , false , false , true , false , » Jms Template « . » RECEIVE _ TIMEOUT _ NO _ WAIT « ) ; }
@Test { » do Test Receive « ( true , true , true , false , false , false , 1000 ) ; }
@Test { » do Test Receive « ( false , true , true , false , false , false , 1000 ) ; }
@Test { » do Test Receive « ( false , false , true , false , false , true , » Jms Template « . » RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT « ) ; }
@Test { » do Test Receive « ( true , false , true , false , false , true , 1000 ) ; }
@Test { » do Test Receive « ( true , true , true , false , true , true , » Jms Template « . » RECEIVE _ TIMEOUT _ NO _ WAIT « ) ; }
@Test { » do Test Receive « ( false , false , true , false , true , true , » Jms Template « . » RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT « ) ; }
@Test { » do Test Receive « ( true , false , true , false , true , false , 1000 ) ; }
@Test { » do Test Send And Receive « ( true , true , 1000L ) ; }
@Test { » do Test Send And Receive « ( false , true , 1000L ) ; }
@Test { » do Test Send And Receive « ( true , false , 1000L ) ; }
@Test { » do Test Send And Receive « ( false , false , 1000L ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Illegal State Exception « ( " " ) , org . springframework . jms . » Illegal State Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Invalid Client ID Exception « ( " " ) , » Invalid Client ID Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Invalid Destination Exception « ( " " ) , » Invalid Destination Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Invalid Selector Exception « ( " " ) , » Invalid Selector Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » JMS Security Exception « ( " " ) , » Jms Security Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Message EOF Exception « ( " " ) , » Message EOF Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Message Format Exception « ( " " ) , » Message Format Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Message Not Readable Exception « ( " " ) , » Message Not Readable Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Message Not Writeable Exception « ( " " ) , » Message Not Writeable Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Resource Allocation Exception « ( " " ) , » Resource Allocation Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Transaction In Progress Exception « ( " " ) , » Transaction In Progress Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » Transaction Rolled Back Exception « ( " " ) , » Transaction Rolled Back Exception « . class ) ; }
@Test { » do Test Jms Exception « ( new javax . jms . » JMS Exception « ( " " ) , » Uncategorized Jms Exception « . class ) ; }
@Test { » assert That « ( this . » messaging Template « . » get Jms Template « ( ) ) . » is Same As « ( this . » jms Template « ) ; }
@Test { » Message Converter « » message Converter « = mock ( » Message Converter « . class ) ; given ( this . » jms Template « . » get Message Converter « ( ) ) . » will Return « ( » message Converter « ) ; » Jms Messaging Template « » messaging Template « = new » Jms Messaging Template « ( this . » jms Template « ) ; » messaging Template « . » after Properties Set « ( ) ; » assert Payload Converter « ( » messaging Template « , » message Converter « ) ; }
@Test { » Message Converter « » message Converter « = mock ( » Message Converter « . class ) ; given ( this . » jms Template « . » get Message Converter « ( ) ) . » will Return « ( » message Converter « ) ; » Jms Messaging Template « » messaging Template « = new » Jms Messaging Template « ( ) ; » messaging Template « . » set Jms Template « ( this . » jms Template « ) ; » messaging Template « . » after Properties Set « ( ) ; » assert Payload Converter « ( » messaging Template « , » message Converter « ) ; }
@Test { » Message Converter « » custom Message Converter « = mock ( » Message Converter « . class ) ; » Jms Messaging Template « » messaging Template « = new » Jms Messaging Template « ( ) ; » messaging Template « . » set Jms Message Converter « ( new » Messaging Message Converter « ( » custom Message Converter « ) ) ; » messaging Template « . » set Jms Template « ( this . » jms Template « ) ; » messaging Template « . » after Properties Set « ( ) ; » assert Payload Converter « ( » messaging Template « , » custom Message Converter « ) ; }
@Test { Destination destination = new Destination ( ) { } ; Message < String > message = » create Text Message « ( ) ; this . » messaging Template « . send ( destination , message ) ; verify ( this . » jms Template « ) . send ( eq ( destination ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { Message < String > message = » create Text Message « ( ) ; this . » messaging Template « . send ( " » my Queue « " , message ) ; verify ( this . » jms Template « ) . send ( eq ( " » my Queue « " ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; this . » messaging Template « . » set Default Destination « ( destination ) ; Message < String > message = » create Text Message « ( ) ; this . » messaging Template « . send ( message ) ; verify ( this . » jms Template « ) . send ( eq ( destination ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { this . » messaging Template « . » set Default Destination Name « ( " » my Queue « " ) ; Message < String > message = » create Text Message « ( ) ; this . » messaging Template « . send ( message ) ; verify ( this . » jms Template « ) . send ( eq ( " » my Queue « " ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { Message < String > message = » create Text Message « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » messaging Template « . send ( message ) ) ; }
@Test { » Jms Messaging Template « t = new » Jms Messaging Template « ( ) ; t . » set Jms Template « ( this . » jms Template « ) ; t . » set Default Destination Name « ( " » my Queue « " ) ; t . » after Properties Set « ( ) ; Message < String > message = » create Text Message « ( ) ; t . send ( message ) ; verify ( this . » jms Template « ) . send ( eq ( " » my Queue « " ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; this . » messaging Template « . » convert And Send « ( destination , " my Payload " ) ; verify ( this . » jms Template « ) . send ( eq ( destination ) , this . » message Creator « . capture ( ) ) ; » Text Message « » text Message « = » create Text Message « ( this . » message Creator « . » get Value « ( ) ) ; » assert That « ( » text Message « . » get Text « ( ) ) . » is Equal To « ( " my Payload " ) ; }
@Test { this . » messaging Template « . » convert And Send « ( " » my Queue « " , " my Payload " ) ; verify ( this . » jms Template « ) . send ( eq ( " » my Queue « " ) , this . » message Creator « . capture ( ) ) ; » Text Message « » text Message « = » create Text Message « ( this . » message Creator « . » get Value « ( ) ) ; » assert That « ( » text Message « . » get Text « ( ) ) . » is Equal To « ( " my Payload " ) ; }
@Test { Destination destination = new Destination ( ) { } ; this . » messaging Template « . » set Default Destination « ( destination ) ; this . » messaging Template « . » convert And Send « ( " my Payload " ) ; verify ( this . » jms Template « ) . send ( eq ( destination ) , this . » message Creator « . capture ( ) ) ; » Text Message « » text Message « = » create Text Message « ( this . » message Creator « . » get Value « ( ) ) ; » assert That « ( » text Message « . » get Text « ( ) ) . » is Equal To « ( " my Payload " ) ; }
@Test { this . » messaging Template « . » set Default Destination Name « ( " » my Queue « " ) ; this . » messaging Template « . » convert And Send « ( " my Payload " ) ; verify ( this . » jms Template « ) . send ( eq ( " » my Queue « " ) , this . » message Creator « . capture ( ) ) ; » Text Message « » text Message « = » create Text Message « ( this . » message Creator « . » get Value « ( ) ) ; » assert That « ( » text Message « . » get Text « ( ) ) . » is Equal To « ( " my Payload " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » convert And Send « ( " my Payload " ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; Map < String , Object > headers = new » Hash Map « < > ( ) ; headers . put ( " foo " , " bar " ) ; this . » messaging Template « . » convert And Send « ( destination , " Hello " , headers ) ; verify ( this . » jms Template « ) . send ( eq ( destination ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { Map < String , Object > headers = new » Hash Map « < > ( ) ; headers . put ( " foo " , " bar " ) ; this . » messaging Template « . » convert And Send « ( " » my Queue « " , " Hello " , headers ) ; verify ( this . » jms Template « ) . send ( eq ( " » my Queue « " ) , this . » message Creator « . capture ( ) ) ; » assert Text Message « ( this . » message Creator « . » get Value « ( ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; javax . jms . Message » jms Message « = » create Jms Text Message « ( ) ; given ( this . » jms Template « . receive ( destination ) ) . » will Return « ( » jms Message « ) ; Message < ? > message = this . » messaging Template « . receive ( destination ) ; verify ( this . » jms Template « ) . receive ( destination ) ; » assert Text Message « ( message ) ; }
@Test { javax . jms . Message » jms Message « = » create Jms Text Message « ( ) ; given ( this . » jms Template « . receive ( " » my Queue « " ) ) . » will Return « ( » jms Message « ) ; Message < ? > message = this . » messaging Template « . receive ( " » my Queue « " ) ; verify ( this . » jms Template « ) . receive ( " » my Queue « " ) ; » assert Text Message « ( message ) ; }
@Test { Destination destination = new Destination ( ) { } ; this . » messaging Template « . » set Default Destination « ( destination ) ; javax . jms . Message » jms Message « = » create Jms Text Message « ( ) ; given ( this . » jms Template « . receive ( destination ) ) . » will Return « ( » jms Message « ) ; Message < ? > message = this . » messaging Template « . receive ( ) ; verify ( this . » jms Template « ) . receive ( destination ) ; » assert Text Message « ( message ) ; }
@Test { this . » messaging Template « . » set Default Destination Name « ( " » my Queue « " ) ; javax . jms . Message » jms Message « = » create Jms Text Message « ( ) ; given ( this . » jms Template « . receive ( " » my Queue « " ) ) . » will Return « ( » jms Message « ) ; Message < ? > message = this . » messaging Template « . receive ( ) ; verify ( this . » jms Template « ) . receive ( " » my Queue « " ) ; » assert Text Message « ( message ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( this . » messaging Template « :: receive ) ; }
@Test { Destination destination = new Destination ( ) { } ; javax . jms . Message » jms Message « = » create Jms Text Message « ( " my Payload " ) ; given ( this . » jms Template « . receive ( destination ) ) . » will Return « ( » jms Message « ) ; String payload = this . » messaging Template « . » receive And Convert « ( destination , String . class ) ; » assert That « ( payload ) . » is Equal To « ( " my Payload " ) ; verify ( this . » jms Template « ) . receive ( destination ) ; }
@Test { javax . jms . Message » jms Message « = » create Jms Text Message « ( " my Payload " ) ; given ( this . » jms Template « . receive ( " » my Queue « " ) ) . » will Return « ( » jms Message « ) ; String payload = this . » messaging Template « . » receive And Convert « ( " » my Queue « " , String . class ) ; » assert That « ( payload ) . » is Equal To « ( " my Payload " ) ; verify ( this . » jms Template « ) . receive ( " » my Queue « " ) ; }
@Test { Destination destination = new Destination ( ) { } ; this . » messaging Template « . » set Default Destination « ( destination ) ; javax . jms . Message » jms Message « = » create Jms Text Message « ( " my Payload " ) ; given ( this . » jms Template « . receive ( destination ) ) . » will Return « ( » jms Message « ) ; String payload = this . » messaging Template « . » receive And Convert « ( String . class ) ; » assert That « ( payload ) . » is Equal To « ( " my Payload " ) ; verify ( this . » jms Template « ) . receive ( destination ) ; }
@Test { this . » messaging Template « . » set Default Destination Name « ( " » my Queue « " ) ; javax . jms . Message » jms Message « = » create Jms Text Message « ( " my Payload " ) ; given ( this . » jms Template « . receive ( " » my Queue « " ) ) . » will Return « ( » jms Message « ) ; String payload = this . » messaging Template « . » receive And Convert « ( String . class ) ; » assert That « ( payload ) . » is Equal To « ( " my Payload " ) ; verify ( this . » jms Template « ) . receive ( " » my Queue « " ) ; }
@Test { javax . jms . Message » jms Message « = » create Jms Text Message « ( " Hello " ) ; given ( this . » jms Template « . receive ( " » my Queue « " ) ) . » will Return « ( » jms Message « ) ; » assert That Exception Of Type « ( org . springframework . messaging . converter . » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » receive And Convert « ( " » my Queue « " , Writer . class ) ) ; }
@Test { given ( this . » jms Template « . receive ( " » my Queue « " ) ) . » will Return « ( null ) ; » assert That « ( this . » messaging Template « . » receive And Convert « ( " » my Queue « " , String . class ) ) . » is Null « ( ) ; }
@Test { Destination destination = new Destination ( ) { } ; Message < String > request = » create Text Message « ( ) ; javax . jms . Message » reply Jms Message « = » create Jms Text Message « ( ) ; given ( this . » jms Template « . » send And Receive « ( eq ( destination ) , any ( ) ) ) . » will Return « ( » reply Jms Message « ) ; Message < ? > actual = this . » messaging Template « . » send And Receive « ( destination , request ) ; verify ( this . » jms Template « , times ( 1 ) ) . » send And Receive « ( eq ( destination ) , any ( ) ) ; » assert Text Message « ( actual ) ; }
@Test { Message < String > message = » create Text Message « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » send And Receive « ( message ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » convert Send And Receive « ( " my Payload " , String . class ) ) ; }
@Test { » will Throw « ( » Message Not Readable Exception « . class ) . given ( this . » jms Template « ) . receive ( " » my Queue « " ) ; » assert That Exception Of Type « ( » Messaging Exception « . class ) . » is Thrown By « ( ( ) -> this . » messaging Template « . receive ( " » my Queue « " ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; » will Throw « ( » Destination Resolution Exception « . class ) . given ( this . » jms Template « ) . send ( eq ( destination ) , any ( ) ) ; » assert That Exception Of Type « ( org . springframework . messaging . core . » Destination Resolution Exception « . class ) . » is Thrown By « ( ( ) -> this . » messaging Template « . send ( destination , » create Text Message « ( ) ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; » will Throw « ( » Destination Resolution Exception « . class ) . given ( this . » jms Template « ) . receive ( destination ) ; » assert That Exception Of Type « ( org . springframework . messaging . core . » Destination Resolution Exception « . class ) . » is Thrown By « ( ( ) -> this . » messaging Template « . receive ( destination ) ) ; }
@Test { » will Throw « ( » Invalid Destination Exception « . class ) . given ( this . » jms Template « ) . » send And Receive « ( eq ( " » unknown Queue « " ) , any ( ) ) ; » assert That Exception Of Type « ( org . springframework . messaging . core . » Destination Resolution Exception « . class ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » send And Receive « ( " » unknown Queue « " , » create Text Message « ( ) ) ) ; }
@Test { Destination destination = new Destination ( ) { } ; » will Throw « ( » Invalid Destination Exception « . class ) . given ( this . » jms Template « ) . » send And Receive « ( eq ( destination ) , any ( ) ) ; » assert That Exception Of Type « ( org . springframework . messaging . core . » Destination Resolution Exception « . class ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » send And Receive « ( destination , » create Text Message « ( ) ) ) ; }
@Test { » Default Message Listener Container « container = » create Running Container « ( ) ; container . stop ( ) ; » Test Runnable « » runnable 2 « = new » Test Runnable « ( ) ; container . stop ( » runnable 2 « ) ; » runnable 2 « . » wait For Completion « ( ) ; }
@Test { this . container . » set Message Listener « ( null ) ; » assert That « ( this . container . » get Message Listener « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . container . » set Message Listener « ( " Bingo " ) ) ; }
@Test { » assert That « ( this . container . » is Pub Sub No Local « ( ) ) . as ( " The [ » pub Sub Local « ] property of » Simple Message Listener Container « " + " must default to false . Change this test ( and the " + " attendant Javadoc ) if you have changed the default . " ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { this . container . » set Concurrent Consumers « ( 0 ) ; this . container . » after Properties Set « ( ) ; } ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { this . container . » set Concurrent Consumers « ( - 198 ) ; this . container . » after Properties Set « ( ) ; } ) ; }
@Test { » Text Message « » text Message « = mock ( » Text Message « . class ) ; given ( » text Message « . » get Text « ( ) ) . » will Return « ( TEXT ) ; » Message Contents Delegate « delegate = mock ( » Message Contents Delegate « . class ) ; » Message Listener Adapter « adapter = new » Message Listener Adapter « ( delegate ) ; adapter . » on Message « ( » text Message « ) ; verify ( delegate ) . » handle Message « ( TEXT ) ; }
@Test { » Object Message « » object Message « = mock ( » Object Message « . class ) ; given ( » object Message « . » get Object « ( ) ) . » will Return « ( NUMBER ) ; » Message Contents Delegate « delegate = mock ( » Message Contents Delegate « . class ) ; » Message Listener Adapter « adapter = new » Message Listener Adapter « ( delegate ) ; adapter . » on Message « ( » object Message « ) ; verify ( delegate ) . » handle Message « ( NUMBER ) ; }
@Test { » Object Message « » object Message « = mock ( » Object Message « . class ) ; given ( » object Message « . » get Object « ( ) ) . » will Return « ( OBJECT ) ; » Message Contents Delegate « delegate = mock ( » Message Contents Delegate « . class ) ; » Message Listener Adapter « adapter = new » Message Listener Adapter « ( delegate ) ; adapter . » on Message « ( » object Message « ) ; verify ( delegate ) . » handle Message « ( OBJECT ) ; }
@Test { » Text Message « » text Message « = mock ( » Text Message « . class ) ; » Message Delegate « delegate = mock ( » Message Delegate « . class ) ; » Message Listener Adapter « adapter = new » Message Listener Adapter « ( delegate ) ; adapter . » set Message Converter « ( null ) ; adapter . » on Message « ( » text Message « ) ; verify ( delegate ) . » handle Message « ( » text Message « ) ; }
@Test { » Text Message « » text Message « = mock ( » Text Message « . class ) ; given ( » text Message « . » get Text « ( ) ) . » will Return « ( TEXT ) ; » Stub Message Listener Adapter « adapter = new » Stub Message Listener Adapter « ( ) ; adapter . » on Message « ( » text Message « ) ; » assert That « ( adapter . » was Called « ( ) ) . » is True « ( ) ; }
@Test { » Text Message « » text Message « = mock ( » Text Message « . class ) ; given ( » text Message « . » get Text « ( ) ) . » will Return « ( TEXT ) ; » Stub Message Listener Adapter « adapter = new » Stub Message Listener Adapter « ( ) ; adapter . » set Default Listener Method « ( " » walnuts Rock « " ) ; adapter . » on Message « ( » text Message « ) ; » assert That « ( adapter . » was Called « ( ) ) . » is False « ( ) ; }
@Test { » Message Listener Adapter « adapter = new » Message Listener Adapter « ( ) ; » assert That « ( adapter . » get Message Converter « ( ) ) . as ( " The default [ » Message Converter « ] must never be null . " ) . » is Not Null « ( ) ; boolean condition = adapter . » get Message Converter « ( ) instanceof » Simple Message Converter « ; » assert That « ( condition ) . as ( " The default [ » Message Converter « ] must be of the type [ » Simple Message Converter « ] " ) . » is True « ( ) ; }
@Test { » Message Listener Adapter « adapter = new » Message Listener Adapter « ( ) ; » assert That « ( adapter . » get Delegate « ( ) ) . » is Same As « ( adapter ) ; }
@Test { » Message Listener Adapter « adapter = new » Message Listener Adapter « ( ) ; » assert That « ( adapter . » get Default Listener Method « ( ) ) . » is Equal To « ( » Message Listener Adapter « . » ORIGINAL _ DEFAULT _ LISTENER _ METHOD « ) ; }
@Test { » Text Message « » text Message « = mock ( » Text Message « . class ) ; » Responsive Message Delegate « delegate = mock ( » Responsive Message Delegate « . class ) ; given ( delegate . » handle Message « ( » text Message « ) ) . » will Return « ( TEXT ) ; » Message Listener Adapter « adapter = new » Message Listener Adapter « ( delegate ) ; adapter . » set Message Converter « ( null ) ; adapter . » on Message « ( » text Message « ) ; }
@Test { Destination destination = mock ( Destination . class ) ; Destination actual = » Jms Response « . » for Destination « ( " foo " , destination ) . » resolve Destination « ( null , null ) ; » assert That « ( actual ) . » is Same As « ( destination ) ; }
@Test { Session session = mock ( Session . class ) ; » Destination Resolver « » destination Resolver « = mock ( » Destination Resolver « . class ) ; Destination destination = mock ( Destination . class ) ; given ( » destination Resolver « . » resolve Destination Name « ( session , " » my Queue « " , false ) ) . » will Return « ( destination ) ; » Jms Response « < String > » jms Response « = » Jms Response « . » for Queue « ( " foo " , " » my Queue « " ) ; Destination actual = » jms Response « . » resolve Destination « ( » destination Resolver « , session ) ; » assert That « ( actual ) . » is Same As « ( destination ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Jms Response « . » for Queue « ( null , " » my Queue « " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Jms Response « . » for Queue « ( " foo " , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Jms Response « . » for Topic « ( " foo " , null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Jms Response « . » for Destination « ( " foo " , null ) ) ; }
@Test { javax . jms . Message message = new » Stub Text Message « ( " foo " ) ; Session session = mock ( Session . class ) ; » Messaging Message Listener Adapter « listener = » get Simple Instance « ( " » wrong Param « " , Integer . class ) ; » assert That Exception Of Type « ( » Listener Execution Failed Exception « . class ) . » is Thrown By « ( ( ) -> listener . » on Message « ( message , session ) ) . » with Cause Exactly Instance Of « ( » Message Conversion Exception « . class ) ; }
@Test { javax . jms . Message » jms Message « = mock ( javax . jms . Message . class ) ; given ( » jms Message « . » get Property Names « ( ) ) . » will Throw « ( new » Illegal Argument Exception « ( " Header failure " ) ) ; » Messaging Message Listener Adapter « listener = » get Simple Instance « ( " simple " , Message . class ) ; Message < ? > message = listener . » to Messaging Message « ( » jms Message « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( message :: » get Headers « ) . » with Message Containing « ( " Header failure " ) ; }
@Test { » Text Message « reply = » test Reply With Jackson « ( " » reply Jackson « " , " { \" counter \" : 42 , \" name \" : \" Response \" , \" description \" : \" lengthy description \" } " ) ; verify ( reply ) . » set Object Property « ( " foo " , " bar " ) ; }
@Test { » Text Message « reply = » test Reply With Jackson « ( " » reply Jackson Message And Json View « " , " { \" name \" : \" Response \" } " ) ; verify ( reply ) . » set Object Property « ( " foo " , " bar " ) ; }
@Test { » Text Message « reply = » test Reply With Jackson « ( " » reply Jackson Pojo And Json View « " , " { \" name \" : \" Response \" } " ) ; verify ( reply , never ( ) ) . » set Object Property « ( " foo " , " bar " ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » Jms Activation Spec Config « config = new » Jms Activation Spec Config « ( ) ; config . » set Pub Sub Domain « ( false ) ; endpoint . » set Activation Spec Config « ( config ) ; » assert That « ( endpoint . » is Pub Sub Domain « ( ) ) . » is Equal To « ( false ) ; » assert That « ( endpoint . » is Reply Pub Sub Domain « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » Jms Activation Spec Config « config = new » Jms Activation Spec Config « ( ) ; config . » set Pub Sub Domain « ( true ) ; endpoint . » set Activation Spec Config « ( config ) ; » assert That « ( endpoint . » is Pub Sub Domain « ( ) ) . » is Equal To « ( true ) ; » assert That « ( endpoint . » is Reply Pub Sub Domain « ( ) ) . » is Equal To « ( true ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » Jms Activation Spec Config « config = new » Jms Activation Spec Config « ( ) ; config . » set Pub Sub Domain « ( true ) ; config . » set Reply Pub Sub Domain « ( false ) ; endpoint . » set Activation Spec Config « ( config ) ; » assert That « ( endpoint . » is Pub Sub Domain « ( ) ) . » is Equal To « ( true ) ; » assert That « ( endpoint . » is Reply Pub Sub Domain « ( ) ) . » is Equal To « ( false ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( endpoint :: » is Pub Sub Domain « ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( endpoint :: » is Reply Pub Sub Domain « ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( endpoint :: » get Reply Qos Settings « ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » assert That « ( endpoint . » get Message Converter « ( ) ) . » is Null « ( ) ; }
@Test { » Jms Message Endpoint Manager « endpoint = new » Jms Message Endpoint Manager « ( ) ; » assert That « ( endpoint . » get Destination Resolver « ( ) ) . » is Null « ( ) ; }
@Test { » do Test Jms Invoker Proxy Factory Bean And Service Exporter « ( false ) ; }
@Test { given ( » mock Session « . » create Queue « ( " » my Queue « " ) ) . » will Return « ( » mock Queue « ) ; » do Test Jms Invoker Proxy Factory Bean And Service Exporter « ( true ) ; }
@Test { Session session = mock ( Session . class ) ; » Text Message « message = mock ( » Text Message « . class ) ; String content = " test " ; given ( session . » create Text Message « ( content ) ) . » will Return « ( message ) ; given ( message . » get Text « ( ) ) . » will Return « ( content ) ; » Simple Message Converter « converter = new » Simple Message Converter « ( ) ; Message msg = converter . » to Message « ( content , session ) ; » assert That « ( converter . » from Message « ( msg ) ) . » is Equal To « ( content ) ; }
@Test { Session session = mock ( Session . class ) ; » Object Message « message = mock ( » Object Message « . class ) ; Integer content = new Integer ( 5 ) ; given ( session . » create Object Message « ( content ) ) . » will Return « ( message ) ; given ( message . » get Object « ( ) ) . » will Return « ( content ) ; » Simple Message Converter « converter = new » Simple Message Converter « ( ) ; Message msg = converter . » to Message « ( content , session ) ; » assert That « ( converter . » from Message « ( msg ) ) . » is Equal To « ( content ) ; }
@Test { » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> new » Simple Message Converter « ( ) . » to Message « ( null , null ) ) ; }
@Test { » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> new » Simple Message Converter « ( ) . » to Message « ( new Object ( ) , null ) ) ; }
@Test { Session session = mock ( Session . class ) ; » Object Message « message = mock ( » Object Message « . class ) ; » Simple Message Converter « converter = new » Simple Message Converter « ( ) ; Message msg = converter . » to Message « ( message , session ) ; » assert That « ( msg ) . » is Same As « ( message ) ; }
@Test { Message message = mock ( Message . class ) ; » Simple Message Converter « converter = new » Simple Message Converter « ( ) ; Object msg = converter . » from Message « ( message ) ; » assert That « ( msg ) . » is Same As « ( message ) ; }
@Test { » Map Message « message = mock ( » Map Message « . class ) ; Session session = mock ( Session . class ) ; given ( session . » create Map Message « ( ) ) . » will Return « ( message ) ; Map < Integer , String > content = new » Hash Map « < > ( 1 ) ; content . put ( 1 , " » value 1 « " ) ; » Simple Message Converter « converter = new » Simple Message Converter « ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> converter . » to Message « ( content , session ) ) ; }
@Test { » Map Message « message = mock ( » Map Message « . class ) ; Session session = mock ( Session . class ) ; given ( session . » create Map Message « ( ) ) . » will Return « ( message ) ; Map < Object , String > content = new » Hash Map « < > ( 1 ) ; content . put ( null , " » value 1 « " ) ; » Simple Message Converter « converter = new » Simple Message Converter « ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> converter . » to Message « ( content , session ) ) ; }
@Test { Message < String > message = » init Builder « ( ) . » set Header « ( » Jms Headers « . » REPLY _ TO « , " not - a - destination " ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; » assert That « ( » jms Message « . » get JMS Reply To « ( ) ) . » is Null « ( ) ; }
@Test { Message < String > message = » init Builder « ( ) . » set Header « ( » Jms Headers « . » CORRELATION _ ID « , 123 ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; » assert That « ( » jms Message « . » get JMS Correlation ID « ( ) ) . » is Equal To « ( " 123 " ) ; }
@Test { Message < String > message = » init Builder « ( ) . » set Header « ( » Jms Headers « . » CORRELATION _ ID « , new Date ( ) ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; » assert That « ( » jms Message « . » get JMS Correlation ID « ( ) ) . » is Null « ( ) ; }
@Test { String » jms Type « = " testing " ; Message < String > message = » init Builder « ( ) . » set Header « ( » Jms Headers « . TYPE , » jms Type « ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; » assert That « ( » jms Message « . » get JMS Type « ( ) ) . » is Not Null « ( ) ; » assert That « ( » jms Message « . » get JMS Type « ( ) ) . » is Equal To « ( » jms Type « ) ; }
@Test { Message < String > message = » init Builder « ( ) . » set Header « ( » Jms Headers « . TYPE , 123 ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; » assert That « ( » jms Message « . » get JMS Type « ( ) ) . » is Null « ( ) ; }
@Test { Message < String > message = » init Builder « ( ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , " foo " ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; Object value = » jms Message « . » get Object Property « ( » Jms Header Mapper « . » CONTENT _ TYPE _ PROPERTY « ) ; » assert That « ( value ) . » is Not Null « ( ) ; » assert That « ( value ) . » is Equal To « ( " foo " ) ; }
@Test { Destination destination = new Destination ( ) { } ; Message < String > message = » init Builder « ( ) . » set Header « ( " destination " , destination ) . build ( ) ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; mapper . » from Headers « ( message . » get Headers « ( ) , » jms Message « ) ; Object value = » jms Message « . » get Object Property « ( " destination " ) ; » assert That « ( value ) . » is Null « ( ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public String » get JMS Correlation ID « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . » CORRELATION _ ID « ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public Destination » get JMS Destination « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . DESTINATION ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public int » get JMS Delivery Mode « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . » DELIVERY _ MODE « ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public long » get JMS Expiration « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . EXPIRATION ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public String » get JMS Message ID « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . » MESSAGE _ ID « ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public int » get JMS Priority « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . PRIORITY ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public Destination » get JMS Reply To « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . » REPLY _ TO « ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public boolean » get JMS Redelivered « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . REDELIVERED ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public String » get JMS Type « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . TYPE ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public long » get JMS Timestamp « ( ) throws » JMS Exception « { throw new » JMS Exception « ( " illegal property " ) ; } } ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , » Jms Headers « . TIMESTAMP ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) { @ Override public Object » get Object Property « ( String name ) throws » JMS Exception « { if ( name . equals ( " fail " ) ) { throw new » JMS Exception « ( " illegal property " ) ; } else { return super . » get Object Property « ( name ) ; } } } ; » jms Message « . » set Boolean Property « ( " fail " , true ) ; » assert Attempt Read Disallowed Property Is Not Fatal « ( » jms Message « , " fail " ) ; }
@Test { String » correlation Id « = " ABC - 123 " ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Correlation ID « ( » correlation Id « ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . » CORRELATION _ ID « , » correlation Id « ) ; }
@Test { Destination destination = new Destination ( ) { } ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Destination « ( destination ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . DESTINATION , destination ) ; }
@Test { int » delivery Mode « = 1 ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Delivery Mode « ( » delivery Mode « ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . » DELIVERY _ MODE « , » delivery Mode « ) ; }
@Test { long expiration = 1000L ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Expiration « ( expiration ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . EXPIRATION , expiration ) ; }
@Test { String » message Id « = " ID : ABC - 123 " ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Message ID « ( » message Id « ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . » MESSAGE _ ID « , » message Id « ) ; }
@Test { int priority = 8 ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Priority « ( priority ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . PRIORITY , priority ) ; }
@Test { Destination » reply To « = new Destination ( ) { } ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Reply To « ( » reply To « ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . » REPLY _ TO « , » reply To « ) ; }
@Test { String type = " testing " ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Type « ( type ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . TYPE , type ) ; }
@Test { long timestamp = 123L ; javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set JMS Timestamp « ( timestamp ) ; » assert Inbound Header « ( » jms Message « , » Jms Headers « . TIMESTAMP , timestamp ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set String Property « ( " » content _ type « " , " foo " ) ; » assert Inbound Header « ( » jms Message « , » Message Headers « . » CONTENT _ TYPE « , " foo " ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set Int Property « ( " foo " , 123 ) ; » assert Inbound Header « ( » jms Message « , " foo " , 123 ) ; }
@Test { javax . jms . Message » jms Message « = new » Stub Text Message « ( ) ; » jms Message « . » set Int Property « ( " foo " , 123 ) ; mapper . » set Inbound Prefix « ( " » custom _ « " ) ; » assert Inbound Header « ( » jms Message « , " » custom _ foo « " , 123 ) ; }
@Test { » Jms Accessor « accessor = new » Stub Jms Accessor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( accessor :: » after Properties Set « ) ; }
@Test { » Jms Accessor « accessor = new » Stub Jms Accessor « ( ) ; » assert That « ( accessor . » is Session Transacted « ( ) ) . as ( " The [ » session Transacted « ] property of » Jms Accessor « must default to " + " false . Change this test ( and the attendant Javadoc ) if you have " + " changed the default . " ) . » is False « ( ) ; }
@Test { » Jms Accessor « accessor = new » Stub Jms Accessor « ( ) ; » assert That « ( accessor . » get Session Acknowledge Mode « ( ) ) . as ( " The [ » session Acknowledge Mode « ] property of » Jms Accessor « must default to " + " [ Session . » AUTO _ ACKNOWLEDGE « ] . Change this test ( and the attendant " + " Javadoc ) if you have changed the default . " ) . » is Equal To « ( Session . » AUTO _ ACKNOWLEDGE « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Stub Jms Accessor « ( ) . » set Session Acknowledge Mode Name « ( " Tally ho chaps ! " ) ) ; }
@Test { converter . » set Target Type « ( » Message Type « . TEXT ) ; » Text Message « » text Message Mock « = mock ( » Text Message « . class ) ; Date » to Be Marshalled « = new Date ( ) ; given ( » session Mock « . » create Text Message « ( » is A « ( String . class ) ) ) . » will Return « ( » text Message Mock « ) ; converter . » to Message « ( » to Be Marshalled « , » session Mock « ) ; verify ( » text Message Mock « ) . » set String Property « ( " » __ typeid __ « " , Date . class . » get Name « ( ) ) ; }
@Test { Method method = this . » get Class « ( ) . » get Declared Method « ( " summary " ) ; » Method Parameter « » return Type « = new » Method Parameter « ( method , - 1 ) ; » test To Text Message With Return Type « ( » return Type « ) ; verify ( » session Mock « ) . » create Text Message « ( " { \" name \" : \" test \" } " ) ; }
@Test { » test To Text Message With Return Type « ( null ) ; verify ( » session Mock « ) . » create Text Message « ( " { \" name \" : \" test \" , \" description \" : \" lengthy description \" } " ) ; }
@Test { Method method = this . » get Class « ( ) . » get Declared Method « ( " none " ) ; » Method Parameter « » return Type « = new » Method Parameter « ( method , - 1 ) ; » test To Text Message With Return Type « ( » return Type « ) ; verify ( » session Mock « ) . » create Text Message « ( " { \" name \" : \" test \" , \" description \" : \" lengthy description \" } " ) ; }
@Test { Method method = this . » get Class « ( ) . » get Declared Method « ( " invalid " ) ; » Method Parameter « » return Type « = new » Method Parameter « ( method , - 1 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » test To Text Message With Return Type « ( » return Type « ) ) ; }
@Test { » Bytes Message « » bytes Message Mock « = mock ( » Bytes Message « . class ) ; Object » to Be Marshalled « = new Object ( ) ; given ( » session Mock « . » create Bytes Message « ( ) ) . » will Return « ( » bytes Message Mock « ) ; converter . » to Message « ( » to Be Marshalled « , » session Mock « ) ; verify ( » marshaller Mock « ) . marshal ( eq ( » to Be Marshalled « ) , » is A « ( Result . class ) ) ; verify ( » bytes Message Mock « ) . » write Bytes « ( » is A « ( byte [ ] . class ) ) ; }
@Test { converter . » set Target Type « ( » Message Type « . TEXT ) ; » Text Message « » text Message Mock « = mock ( » Text Message « . class ) ; Object » to Be Marshalled « = new Object ( ) ; given ( » session Mock « . » create Text Message « ( » is A « ( String . class ) ) ) . » will Return « ( » text Message Mock « ) ; converter . » to Message « ( » to Be Marshalled « , » session Mock « ) ; verify ( » marshaller Mock « ) . marshal ( eq ( » to Be Marshalled « ) , » is A « ( Result . class ) ) ; }
@Test { » Text Message « » text Message Mock « = mock ( » Text Message « . class ) ; Object unmarshalled = new Object ( ) ; String text = " foo " ; given ( » text Message Mock « . » get Text « ( ) ) . » will Return « ( text ) ; given ( » unmarshaller Mock « . unmarshal ( » is A « ( Source . class ) ) ) . » will Return « ( unmarshalled ) ; Object result = converter . » from Message « ( » text Message Mock « ) ; » assert That « ( unmarshalled ) . as ( " Invalid result " ) . » is Equal To « ( result ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . converter . » to Message « ( new Object ( ) , mock ( Session . class ) ) ) ; }
@Test { Session session = mock ( Session . class ) ; Serializable payload = mock ( Serializable . class ) ; » Object Message « » jms Message « = mock ( » Object Message « . class ) ; given ( session . » create Object Message « ( payload ) ) . » will Return « ( » jms Message « ) ; this . converter . » to Message « ( » Message Builder « . » with Payload « ( payload ) . build ( ) , session ) ; verify ( session ) . » create Object Message « ( payload ) ; }
@Test { » Text Message « » jms Msg « = new » Stub Text Message « ( " 1224 " ) ; this . converter . » set Payload Converter « ( new » Test Message Converter « ( ) ) ; Message < ? > msg = ( Message < ? > ) this . converter . » from Message « ( » jms Msg « ) ; » assert That « ( msg . » get Payload « ( ) ) . » is Equal To « ( 1224L ) ; }
@Test { Topic » expected Destination « = new » Stub Topic « ( ) ; » Topic Session « session = mock ( » Topic Session « . class ) ; given ( session . » create Topic « ( » DESTINATION _ NAME « ) ) . » will Return « ( » expected Destination « ) ; » test Resolve Destination « ( session , » expected Destination « , true ) ; }
@Test { Topic » expected Destination « = new » Stub Topic « ( ) ; Session session = mock ( Session . class ) ; given ( session . » create Topic « ( » DESTINATION _ NAME « ) ) . » will Return « ( » expected Destination « ) ; » test Resolve Destination « ( session , » expected Destination « , true ) ; }
@Test { Queue » expected Destination « = new » Stub Queue « ( ) ; Session session = mock ( » Queue Session « . class ) ; given ( session . » create Queue « ( » DESTINATION _ NAME « ) ) . » will Return « ( » expected Destination « ) ; » test Resolve Destination « ( session , » expected Destination « , false ) ; }
@Test { Queue » expected Destination « = new » Stub Queue « ( ) ; Session session = mock ( Session . class ) ; given ( session . » create Queue « ( » DESTINATION _ NAME « ) ) . » will Return « ( » expected Destination « ) ; » test Resolve Destination « ( session , » expected Destination « , false ) ; }
@Test { » Connection Factory « » connection Factory « = mock ( » Connection Factory « . class ) ; » Jms Destination Accessor « accessor = new » Stub Jms Destination Accessor « ( ) ; accessor . » set Connection Factory « ( » connection Factory « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> accessor . » set Destination Resolver « ( null ) ) ; }
@Test { » Jms Destination Accessor « accessor = new » Stub Jms Destination Accessor « ( ) ; » assert That « ( accessor . » is Pub Sub Domain « ( ) ) . as ( " The [ » pub Sub Domain « ] property of » Jms Destination Accessor « must default to " + " false ( i . e . Queues are used by default ) . Change this test ( and the " + " attendant Javadoc ) if you have changed the default . " ) . » is False « ( ) ; }
@Test { Session session = mock ( Session . class ) ; » Jndi Destination Resolver « resolver = new » One Time Lookup Jndi Destination Resolver « ( ) ; Destination destination = resolver . » resolve Destination Name « ( session , » DESTINATION _ NAME « , true ) ; » assert That « ( destination ) . » is Not Null « ( ) ; » assert That « ( destination ) . » is Same As « ( DESTINATION ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( null ) ; » assert That « ( headers . » get Timestamp « ( ) ) . » is Not Null « ( ) ; }
@Test { » Message Headers « » headers 1 « = new » Message Headers « ( null ) ; Thread . sleep ( 50L ) ; » Message Headers « » headers 2 « = new » Message Headers « ( » headers 1 « ) ; » assert That « ( » headers 2 « . » get Timestamp « ( ) ) . » is Not Same As « ( » headers 1 « . » get Timestamp « ( ) ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( null , null , 10L ) ; » assert That « ( headers . » get Timestamp « ( ) ) . » is Equal To « ( 10L ) ; }
@Test { Map < String , Object > input = Collections . < String , Object > » singleton Map « ( » Message Headers « . TIMESTAMP , 1L ) ; » Message Headers « headers = new » Message Headers « ( input , null , null ) ; » assert That « ( headers . » get Timestamp « ( ) ) . » is Not Null « ( ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( null , null , - 1L ) ; » assert That « ( headers . » get Timestamp « ( ) ) . » is Null « ( ) ; }
@Test { » Message Headers « » headers 1 « = new » Message Headers « ( null ) ; » Message Headers « » headers 2 « = new » Message Headers « ( » headers 1 « ) ; » assert That « ( » headers 2 « . » get Id « ( ) ) . » is Not Same As « ( » headers 1 « . » get Id « ( ) ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( null ) ; » assert That « ( headers . » get Id « ( ) ) . » is Not Null « ( ) ; }
@Test { UUID id = new UUID ( 0L , 25L ) ; » Message Headers « headers = new » Message Headers « ( null , id , null ) ; » assert That « ( headers . » get Id « ( ) ) . » is Equal To « ( id ) ; }
@Test { Map < String , Object > input = Collections . < String , Object > » singleton Map « ( » Message Headers « . ID , new UUID ( 0L , 25L ) ) ; » Message Headers « headers = new » Message Headers « ( input , null , null ) ; » assert That « ( headers . » get Id « ( ) ) . » is Not Null « ( ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( null , » Message Headers « . » ID _ VALUE _ NONE « , null ) ; » assert That « ( headers . » get Id « ( ) ) . » is Null « ( ) ; }
@Test { Integer value = new Integer ( 123 ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " test " , value ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That « ( headers . get ( " test " ) ) . » is Equal To « ( value ) ; }
@Test { Integer value = new Integer ( 123 ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " test " , value ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That « ( headers . get ( " test " , Integer . class ) ) . » is Equal To « ( value ) ; }
@Test { Integer value = new Integer ( 123 ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " test " , value ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> headers . get ( " test " , String . class ) ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That « ( headers . get ( " nosuchattribute " ) ) . » is Null « ( ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That « ( headers . get ( " nosuchattribute " , String . class ) ) . » is Null « ( ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " » key 1 « " , " » val 1 « " ) ; map . put ( " » key 2 « " , new Integer ( 123 ) ) ; » Message Headers « headers = new » Message Headers « ( map ) ; Set < String > keys = headers . » key Set « ( ) ; » assert That « ( keys . contains ( " » key 1 « " ) ) . » is True « ( ) ; » assert That « ( keys . contains ( " » key 2 « " ) ) . » is True « ( ) ; }
@Test { final » Atomic Long « id = new » Atomic Long « ( ) ; @ » Suppress Warnings « ( " serial " ) class » My MH « extends » Message Headers « { public » My MH « ( ) { super ( null , new UUID ( 0 , id . » increment And Get « ( ) ) , - 1L ) ; } } » Message Headers « headers = new » My MH « ( ) ; » assert That « ( headers . » get Id « ( ) . » to String « ( ) ) . » is Equal To « ( " 00000000 - 0000 - 0000 - 0000 - 000000000001 " ) ; » assert That « ( headers . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » APPLICATION _ JSON « ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That « ( this . resolver . resolve ( headers ) ) . » is Equal To « ( » Mime Type Utils « . » APPLICATION _ JSON « ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » APPLICATION _ JSON _ VALUE « ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That « ( this . resolver . resolve ( headers ) ) . » is Equal To « ( » Mime Type Utils « . » APPLICATION _ JSON « ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( » Message Headers « . » CONTENT _ TYPE « , " » invalid Content Type « " ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . resolve ( headers ) ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( » Message Headers « . » CONTENT _ TYPE « , new Integer ( 1 ) ) ; » Message Headers « headers = new » Message Headers « ( map ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . resolve ( headers ) ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( Collections . < String , Object > » empty Map « ( ) ) ; » assert That « ( this . resolver . resolve ( headers ) ) . » is Null « ( ) ; }
@Test { this . resolver . » set Default Mime Type « ( » Mime Type Utils « . » APPLICATION _ JSON « ) ; » Message Headers « headers = new » Message Headers « ( Collections . < String , Object > » empty Map « ( ) ) ; » assert That « ( this . resolver . resolve ( headers ) ) . » is Equal To « ( » Mime Type Utils « . » APPLICATION _ JSON « ) ; }
@Test { Message < String > content = » Message Builder « . » with Payload « ( " 33 " ) . build ( ) ; » assert That « ( converter . » from Message « ( content , Integer . class ) ) . » is Equal To « ( 33 ) ; }
@Test { Message < Integer > content = » Message Builder « . » with Payload « ( 1234 ) . build ( ) ; » assert That « ( converter . » from Message « ( content , Locale . class ) ) . as ( " No converter from integer to locale " ) . » is Null « ( ) ; }
@Test { Message < String > content = » Message Builder « . » with Payload « ( " test not a number " ) . build ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> converter . » from Message « ( content , Integer . class ) ) . » with Cause Instance Of « ( » Conversion Exception « . class ) ; }
@Test { String payload = " < » my Bean « > < name > Foo < / name > < / » my Bean « > " ; Message < ? > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) . build ( ) ; » My Bean « actual = ( » My Bean « ) this . converter . » from Message « ( message , » My Bean « . class ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » get Name « ( ) ) . » is Equal To « ( " Foo " ) ; }
@Test { String payload = " < » my Bean « > < name > Foo < / name > < » my Bean « > " ; Message < ? > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) . build ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . converter . » from Message « ( message , » My Bean « . class ) ) ; }
@Test { String payload = " < » my Bean « > < age > 42 < / age > < » my Bean « > " ; Message < ? > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) . build ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . converter . » from Message « ( message , » My Bean « . class ) ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " ABC " ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " success - from " ) ; » assert That « ( this . converter . » from Message « ( message , Integer . class ) ) . » is Null « ( ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " ABC " ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » TEXT _ PLAIN « ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " success - from " ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " ABC " ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » APPLICATION _ JSON « ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Null « ( ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " ABC " ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " success - from " ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " ABC " ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » APPLICATION _ JSON « ) . build ( ) ; this . converter = new » Test Message Converter « ( new » Mime Type « [ 0 ] ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " success - from " ) ; }
@Test { this . converter = new » Test Message Converter « ( new » Mime Type « [ 0 ] ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . converter . » set Strict Content Type Match « ( true ) ) ; }
@Test { Message < ? > message = this . converter . » to Message « ( " ABC " , null ) ; » assert That « ( message . » get Headers « ( ) . get ( » Message Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( » Mime Type Utils « . » TEXT _ PLAIN « ) ; }
@Test { » Protobuf Message Converter « converter = new » Protobuf Message Converter « ( null ) ; » assert That « ( converter . » extension Registry « ) . » is Not Null « ( ) ; }
@Test { » assert That « ( converter . » can Convert From « ( message , Msg . class ) ) . » is True « ( ) ; » assert That « ( converter . » can Convert From « ( » message Without Content Type « , Msg . class ) ) . » is True « ( ) ; » assert That « ( converter . » can Convert From « ( » message Json « , Msg . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Convert To « ( » test Msg « , message . » get Headers « ( ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Convert To « ( » test Msg « , » message Without Content Type « . » get Headers « ( ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Convert To « ( » test Msg « , » message Json « . » get Headers « ( ) ) ) . » is True « ( ) ; }
@Test { final Msg msg = ( Msg ) converter . » from Message « ( message , Msg . class ) ; » assert That « ( msg ) . » is Equal To « ( » test Msg « ) ; }
@Test { final Message < ? > message = converter . » to Message « ( this . » test Msg « , this . message . » get Headers « ( ) ) ; » assert That « ( message ) . » is Not Null « ( ) ; » assert That « ( message . » get Payload « ( ) ) . » is Equal To « ( this . message . » get Payload « ( ) ) ; }
@Test { Msg result = ( Msg ) converter . » from Message « ( » message Without Content Type « , Msg . class ) ; » assert That « ( result ) . » is Equal To « ( » test Msg « ) ; }
@Test { » assert That « ( converter . » get Default Content Type « ( » test Msg « ) ) . » is Equal To « ( » Protobuf Message Converter « . PROTOBUF ) ; }
@Test { » Message Headers « headers = new » Message Headers « ( Collections . < String , Object > » singleton Map « ( " foo " , " bar " ) ) ; Message < ? > message = this . converter . » to Message « ( " payload " , headers ) ; » assert That « ( message . » get Payload « ( ) ) . » is Equal To « ( " payload " ) ; » assert That « ( message . » get Headers « ( ) . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( " ABC " . » get Bytes « ( ) ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » TEXT _ PLAIN « ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " ABC " ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " ABC " ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » TEXT _ PLAIN « ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " ABC " ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( " ABC " . » get Bytes « ( ) ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( " ABC " ) ; }
@Test { String payload = " Héllo Wörld " ; Message < byte [ ] > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » ISO _ 8859 _ 1 « ) ) . » set Header « ( » Message Headers « . » CONTENT _ TYPE « , new » Mime Type « ( " text " , " plain " , » Standard Charsets « . » ISO _ 8859 _ 1 « ) ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( payload ) ; }
@Test { String payload = " Héllo Wörld " ; Message < byte [ ] > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , String . class ) ) . » is Equal To « ( payload ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( " ABC " . » get Bytes « ( ) ) . build ( ) ; » assert That « ( this . converter . » from Message « ( message , Integer . class ) ) . » is Null « ( ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » TEXT _ PLAIN « ) ; » Message Headers « headers = new » Message Headers « ( map ) ; Message < ? > message = this . converter . » to Message « ( " ABC " , headers ) ; » assert That « ( new String ( ( ( byte [ ] ) message . » get Payload « ( ) ) ) ) . » is Equal To « ( " ABC " ) ; }
@Test { » Mapping Jackson 2 Message Converter « converter = new » Mapping Jackson 2 Message Converter « ( ) ; » assert That « ( converter . » get Supported Mime Types « ( ) ) . contains ( new » Mime Type « ( " application " , " json " ) ) ; » assert That « ( converter . » get Object Mapper « ( ) . » get Deserialization Config « ( ) . » is Enabled « ( » Deserialization Feature « . » FAIL _ ON _ UNKNOWN _ PROPERTIES « ) ) . » is False « ( ) ; }
@Test { » Mime Type « mimetype = new » Mime Type « ( " application " , " xml " , » Standard Charsets « . » UTF _ 8 « ) ; » Mapping Jackson 2 Message Converter « converter = new » Mapping Jackson 2 Message Converter « ( mimetype ) ; » assert That « ( converter . » get Supported Mime Types « ( ) ) . contains ( mimetype ) ; » assert That « ( converter . » get Object Mapper « ( ) . » get Deserialization Config « ( ) . » is Enabled « ( » Deserialization Feature « . » FAIL _ ON _ UNKNOWN _ PROPERTIES « ) ) . » is False « ( ) ; }
@Test { » My Bean « » my Bean « = new » My Bean « ( ) ; » Mapping Jackson 2 Message Converter « converter = new » Mapping Jackson 2 Message Converter « ( ) ; Message < ? > message = » Message Builder « . » with Payload « ( » my Bean « ) . build ( ) ; » assert That « ( converter . » from Message « ( message , » My Bean « . class ) ) . » is Same As « ( » my Bean « ) ; }
@Test { » Mapping Jackson 2 Message Converter « converter = new » Mapping Jackson 2 Message Converter « ( ) ; String payload = " » Foo Bar « " ; Message < ? > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) . build ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> converter . » from Message « ( message , » My Bean « . class ) ) ; }
@Test { » Mapping Jackson 2 Message Converter « converter = new » Mapping Jackson 2 Message Converter « ( ) ; String payload = " { \" string \" : \" string \" , \" » unknown Property « \" : \" value \" } " ; Message < ? > message = » Message Builder « . » with Payload « ( payload . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) . build ( ) ; » My Bean « » my Bean « = ( » My Bean « ) converter . » from Message « ( message , » My Bean « . class ) ; » assert That « ( » my Bean « . » get String « ( ) ) . » is Equal To « ( " string " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . template . » send And Receive « ( new » Generic Message « < Object > ( " request " ) ) ) ; }
@Test { Message < ? > » response Message « = new » Generic Message « < Object > ( " response " ) ; this . template . » set Receive Message « ( » response Message « ) ; String response = this . template . » convert Send And Receive « ( " somewhere " , " request " , String . class ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " somewhere " ) ; » assert That « ( this . template . » request Message « . » get Payload « ( ) ) . » is Same As « ( " request " ) ; » assert That « ( response ) . » is Same As « ( " response " ) ; }
@Test { Message < ? > message = new » Generic Message « < Object > ( " payload " ) ; this . template . send ( " » my Channel « " , message ) ; » assert That « ( this . template . » message Channel « ) . » is Same As « ( this . » my Channel « ) ; » assert That « ( this . template . message ) . » is Same As « ( message ) ; }
@Test { » Test Destination Resolving Messaging Template « template = new » Test Destination Resolving Messaging Template « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> template . send ( " » my Channel « " , new » Generic Message « < Object > ( " payload " ) ) ) ; }
@Test { this . template . » convert And Send « ( " » my Channel « " , " payload " ) ; » assert That « ( this . template . » message Channel « ) . » is Same As « ( this . » my Channel « ) ; » assert That « ( this . template . message ) . » is Not Null « ( ) ; » assert That « ( this . template . message . » get Payload « ( ) ) . » is Same As « ( " payload " ) ; }
@Test { this . template . » convert And Send « ( " » my Channel « " , " payload " , this . headers ) ; » assert That « ( this . template . » message Channel « ) . » is Same As « ( this . » my Channel « ) ; » assert That « ( this . template . message ) . » is Not Null « ( ) ; » assert That « ( this . template . message . » get Headers « ( ) . get ( " key " ) ) . » is Equal To « ( " value " ) ; » assert That « ( this . template . message . » get Payload « ( ) ) . » is Equal To « ( " payload " ) ; }
@Test { Message < ? > expected = new » Generic Message « < Object > ( " payload " ) ; this . template . » set Receive Message « ( expected ) ; Message < ? > actual = this . template . receive ( " » my Channel « " ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; » assert That « ( this . template . » message Channel « ) . » is Same As « ( this . » my Channel « ) ; }
@Test { Message < ? > expected = new » Generic Message « < Object > ( " payload " ) ; this . template . » set Receive Message « ( expected ) ; String payload = this . template . » receive And Convert « ( " » my Channel « " , String . class ) ; » assert That « ( payload ) . » is Equal To « ( " payload " ) ; » assert That « ( this . template . » message Channel « ) . » is Same As « ( this . » my Channel « ) ; }
@Test { Message < ? > » response Message « = new » Generic Message « < Object > ( " response " ) ; this . template . » set Receive Message « ( » response Message « ) ; String actual = this . template . » convert Send And Receive « ( " » my Channel « " , " request " , String . class ) ; » assert That « ( this . template . message . » get Payload « ( ) ) . » is Equal To « ( " request " ) ; » assert That « ( actual ) . » is Same As « ( " response " ) ; » assert That « ( this . template . » message Channel « ) . » is Same As « ( this . » my Channel « ) ; }
@Test { Message < ? > message = new » Generic Message « < Object > ( " payload " ) ; this . template . » set Default Destination « ( " home " ) ; this . template . send ( message ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " home " ) ; » assert That « ( this . template . message ) . » is Same As « ( message ) ; }
@Test { Message < ? > message = new » Generic Message « < Object > ( " payload " ) ; this . template . send ( " somewhere " , message ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " somewhere " ) ; » assert That « ( this . template . message ) . » is Same As « ( message ) ; }
@Test { Message < ? > message = new » Generic Message « < Object > ( " payload " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . template . send ( message ) ) ; }
@Test { this . template . » set Default Destination « ( " home " ) ; this . template . » convert And Send « ( " payload " ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " home " ) ; » assert That « ( this . template . message ) . » is Not Null « ( ) ; » assert That « ( this . template . message . » get Headers « ( ) . size ( ) ) . as ( " expected 'id' and 'timestamp' headers only " ) . » is Equal To « ( 2 ) ; » assert That « ( this . template . message . » get Payload « ( ) ) . » is Equal To « ( " payload " ) ; }
@Test { this . template . » convert And Send « ( " somewhere " , " payload " ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " somewhere " ) ; » assert That « ( this . template . message ) . » is Not Null « ( ) ; » assert That « ( this . template . message . » get Headers « ( ) . size ( ) ) . as ( " expected 'id' and 'timestamp' headers only " ) . » is Equal To « ( 2 ) ; » assert That « ( this . template . message . » get Payload « ( ) ) . » is Equal To « ( " payload " ) ; }
@Test { this . template . » convert And Send « ( " somewhere " , " payload " , headers ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " somewhere " ) ; » assert That « ( this . template . message ) . » is Not Null « ( ) ; » assert That « ( this . template . message . » get Headers « ( ) . get ( " key " ) ) . » is Equal To « ( " value " ) ; » assert That « ( this . template . message . » get Payload « ( ) ) . » is Equal To « ( " payload " ) ; }
@Test { » Message Converter « converter = new » Composite Message Converter « ( Arrays . < » Message Converter « > » as List « ( new » Mapping Jackson 2 Message Converter « ( ) ) ) ; this . template . » set Message Converter « ( converter ) ; this . headers . put ( » Message Headers « . » CONTENT _ TYPE « , » Mime Type Utils « . » APPLICATION _ XML « ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . template . » convert And Send « ( " home " , " payload " , new » Message Headers « ( this . headers ) ) ) ; }
@Test { » Caching Destination Resolver Proxy « < String > » resolver Proxy « = new » Caching Destination Resolver Proxy « < > ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » resolver Proxy « :: » after Properties Set « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Caching Destination Resolver Proxy « < String > ( null ) ) ; }
@Test { Message < ? > expected = new » Generic Message « < > ( " payload " ) ; this . template . » set Default Destination « ( " home " ) ; this . template . » set Receive Message « ( expected ) ; Message < ? > actual = this . template . receive ( ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " home " ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( this . template :: receive ) ; }
@Test { Message < ? > expected = new » Generic Message « < > ( " payload " ) ; this . template . » set Receive Message « ( expected ) ; Message < ? > actual = this . template . receive ( " somewhere " ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " somewhere " ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { Message < ? > expected = new » Generic Message « < > ( " payload " ) ; this . template . » set Default Destination « ( " home " ) ; this . template . » set Receive Message « ( expected ) ; String payload = this . template . » receive And Convert « ( String . class ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " home " ) ; » assert That « ( payload ) . » is Same As « ( " payload " ) ; }
@Test { Message < ? > expected = new » Generic Message « < > ( " payload " ) ; this . template . » set Receive Message « ( expected ) ; String payload = this . template . » receive And Convert « ( " somewhere " , String . class ) ; » assert That « ( this . template . destination ) . » is Equal To « ( " somewhere " ) ; » assert That « ( payload ) . » is Same As « ( " payload " ) ; }
@Test { Message < ? > expected = new » Generic Message « < > ( " not a number test " ) ; this . template . » set Receive Message « ( expected ) ; this . template . » set Message Converter « ( new » Generic Message Converter « ( ) ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . template . » receive And Convert « ( " somewhere " , Integer . class ) ) . » with Cause Instance Of « ( » Conversion Failed Exception « . class ) ; }
@Test { » Destination Patterns Message Condition « c = condition ( " foo " ) ; » assert That « ( c . » get Patterns « ( ) . iterator ( ) . next ( ) ) . » is Equal To « ( " / foo " ) ; }
@Test { » Destination Patterns Message Condition « c = new » Destination Patterns Message Condition « ( new String [ ] { " foo " } , new » Ant Path Matcher « ( " . " ) ) ; » assert That « ( c . » get Patterns « ( ) . iterator ( ) . next ( ) ) . as ( " Pre - pending should be disabled when not using '/' as path separator " ) . » is Equal To « ( " foo " ) ; }
@Test { » Destination Patterns Message Condition « c = condition ( " " ) ; » assert That « ( c . » get Patterns « ( ) . iterator ( ) . next ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Destination Patterns Message Condition « » c 1 « = condition ( ) ; » Destination Patterns Message Condition « » c 2 « = condition ( ) ; » assert That « ( » c 1 « . combine ( » c 2 « ) ) . » is Equal To « ( condition ( " " ) ) ; }
@Test { » Destination Patterns Message Condition « » c 1 « = condition ( " / » t 1 « " , " / » t 2 « " ) ; » Destination Patterns Message Condition « » c 2 « = condition ( " / » m 1 « " , " / » m 2 « " ) ; » assert That « ( » c 1 « . combine ( » c 2 « ) ) . » is Equal To « ( new » Destination Patterns Message Condition « ( " / » t 1 « / » m 1 « " , " / » t 1 « / » m 2 « " , " / » t 2 « / » m 1 « " , " / » t 2 « / » m 2 « " ) ) ; }
@Test { » Destination Patterns Message Condition « condition = condition ( " / foo " ) ; » Destination Patterns Message Condition « match = condition . » get Matching Condition « ( » message To « ( " / foo " ) ) ; » assert That « ( match ) . » is Not Null « ( ) ; }
@Test { » Destination Patterns Message Condition « condition = condition ( " » / foo / « * " ) ; » Destination Patterns Message Condition « match = condition . » get Matching Condition « ( » message To « ( " / foo / bar " ) ) ; » assert That « ( match ) . » is Not Null « ( ) ; }
@Test { » Destination Patterns Message Condition « condition = condition ( " / * * " , " / foo / bar " , " » / foo / « * " ) ; » Destination Patterns Message Condition « match = condition . » get Matching Condition « ( » message To « ( " / foo / bar " ) ) ; » Destination Patterns Message Condition « expected = condition ( " / foo / bar " , " » / foo / « * " , " / * * " ) ; » assert That « ( match ) . » is Equal To « ( expected ) ; }
@Test { » Destination Patterns Message Condition « » c 1 « = condition ( " / foo * " ) ; » Destination Patterns Message Condition « » c 2 « = condition ( " / foo * " ) ; » assert That « ( » c 1 « . » compare To « ( » c 2 « , » message To « ( " / foo " ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » Destination Patterns Message Condition « » c 1 « = condition ( " / fo * " ) ; » Destination Patterns Message Condition « » c 2 « = condition ( " / foo " ) ; » assert That « ( » c 1 « . » compare To « ( » c 2 « , » message To « ( " / foo " ) ) ) . » is Equal To « ( 1 ) ; }
@Test { Message < ? > message = » message To « ( " / foo " ) ; » Destination Patterns Message Condition « » c 1 « = condition ( " / foo " , " bar " ) ; » Destination Patterns Message Condition « » c 2 « = condition ( " / foo " , " f * " ) ; » Destination Patterns Message Condition « » match 1 « = » c 1 « . » get Matching Condition « ( message ) ; » Destination Patterns Message Condition « » match 2 « = » c 2 « . » get Matching Condition « ( message ) ; » assert That « ( » match 1 « . » compare To « ( » match 2 « , message ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( this . resolvable . annot ( » destination Var « ( ) . » no Value « ( ) ) . arg ( ) ) ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( this . resolvable . » annot Not Present « ( » Destination Variable « . class ) . arg ( ) ) ) . » is False « ( ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; » assert That Exception Of Type « ( » Message Handling Exception « . class ) . » is Thrown By « ( ( ) -> » resolve Argument « ( this . resolvable . annot ( » destination Var « ( ) . » no Value « ( ) ) . arg ( ) , message ) ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . resolvable . » annot Not Present « ( Header . class ) . arg ( ) ) ) . » is False « ( ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . » set Header « ( " » param 1 « " , " foo " ) . build ( ) ; Object result = » resolve Argument « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) , message ) ; » assert That « ( result ) . » is Equal To « ( " foo " ) ; }
@Test { » Test Message Header Accessor « headers = new » Test Message Header Accessor « ( ) ; headers . » set Native Header « ( " » param 1 « " , " foo " ) ; Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . » set Headers « ( headers ) . build ( ) ; » assert That « ( this . < Object > » resolve Argument « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) , message ) ) . » is Equal To « ( " foo " ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; » assert That Exception Of Type « ( » Message Handling Exception « . class ) . » is Thrown By « ( ( ) -> » resolve Argument « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) , message ) ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; Object result = » resolve Argument « ( this . resolvable . annot ( header ( " name " , " bar " ) ) . arg ( ) , message ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { System . » set Property « ( " » system Property « " , " sysbar " ) ; try { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; » Method Parameter « param = this . resolvable . annot ( header ( " name " , " # { » system Properties . system Property « } " ) ) . arg ( ) ; Object result = » resolve Argument « ( param , message ) ; » assert That « ( result ) . » is Equal To « ( " sysbar " ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " foo " ) . » set Header « ( " foo " , " bar " ) . build ( ) ; » Method Parameter « param = this . resolvable . annot ( header ( " foo " ) ) . arg ( Optional . class , String . class ) ; Object result = » resolve Argument « ( param , message ) ; » assert That « ( result ) . » is Equal To « ( Optional . of ( " bar " ) ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " foo " ) . build ( ) ; » Method Parameter « param = this . resolvable . annot ( header ( " foo " ) ) . arg ( Optional . class , String . class ) ; Object result = » resolve Argument « ( param , message ) ; » assert That « ( result ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » Method Parameter « param = this . resolvable . » annot Present « ( Headers . class ) . arg ( Map . class , String . class , Object . class ) ; Map < String , Object > headers = » resolve Argument « ( param ) ; » assert That « ( headers . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » resolve Argument « ( this . resolvable . » annot Present « ( Headers . class ) . arg ( String . class ) ) ) ; }
@Test { » Message Headers « headers = » resolve Argument « ( this . resolvable . arg ( » Message Headers « . class ) ) ; » assert That « ( headers . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Message Header Accessor « headers = » resolve Argument « ( this . resolvable . arg ( » Message Header Accessor « . class ) ) ; » assert That « ( headers . » get Header « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Test Message Header Accessor « headers = » resolve Argument « ( this . resolvable . arg ( » Test Message Header Accessor « . class ) ) ; » assert That « ( headers . » get Header « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Method Parameter « param = this . » test Method « . » annot Present « ( Payload . class ) . arg ( ) ; » assert That « ( this . < Object > » resolve Value « ( param , Mono . empty ( ) , null ) ) . » is Null « ( ) ; }
@Test { String body = " foo " ; » Method Parameter « param = this . » test Method « . arg ( » Resolvable Type « . » for Class With Generics « ( Mono . class , String . class ) ) ; Mono < Object > mono = » resolve Value « ( param , Mono . delay ( Duration . » of Millis « ( 10 ) ) . map ( » a Long « -> » to Data Buffer « ( body ) ) , null ) ; » assert That « ( mono . block ( ) ) . » is Equal To « ( body ) ; }
@Test { String body = " foo " ; » Method Parameter « param = this . » test Method « . » annot Not Present « ( Payload . class ) . arg ( String . class ) ; Object value = » resolve Value « ( param , Mono . just ( » to Data Buffer « ( body ) ) , null ) ; » assert That « ( value ) . » is Equal To « ( body ) ; }
@Test { » Test Validator « validator = new » Test Validator « ( ) ; » Resolvable Type « type = » Resolvable Type « . » for Class With Generics « ( Mono . class , String . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; Mono < Object > mono = » resolve Value « ( param , Mono . just ( » to Data Buffer « ( " 12345 " ) ) , validator ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Error « ( » Method Argument Not Valid Exception « . class ) . verify ( ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " string " , " abcdef " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Collections . » singleton List « ( " abcdef :: response " ) ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " » mono String « " , " abcdef " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Collections . » singleton List « ( " abcdef :: response " ) ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " » flux String « " , " abc " , " def " , " ghi " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Arrays . » as List « ( " abc :: response " , " def :: response " , " ghi :: response " ) ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " » path 123 « " , " abcdef " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Collections . » singleton List « ( " abcdef :: response " ) ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " destination . test " , " abcdef " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Collections . » singleton List « ( " test :: abcdef :: response " ) ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " exception " , " abc " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Collections . » singleton List « ( " rejected :: handled " ) ) ; }
@Test { » Message Mapping Message Handler « » messsage Handler « = » init Messsage Handler « ( ) ; » messsage Handler « . » handle Message « ( message ( " » error Signal « " , " abc " ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » verify Output Content « ( Collections . » singleton List « ( " rejected :: handled " ) ) ; }
@Test { » Default Message Handler Method Factory « instance = » create Instance « ( ) ; » Message Converter « » message Converter « = new » Byte Array Message Converter « ( ) ; instance . » set Message Converter « ( » message Converter « ) ; instance . » after Properties Set « ( ) ; » Invocable Handler Method « » invocable Handler Method « = » create Invocable Handler Method « ( instance , " » simple String « " , String . class ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> » invocable Handler Method « . invoke ( » Message Builder « . » with Payload « ( 123 ) . build ( ) ) ) ; }
@Test { » Default Message Handler Method Factory « instance = » create Instance « ( ) ; instance . » after Properties Set « ( ) ; » Invocable Handler Method « » invocable Handler Method « = » create Invocable Handler Method « ( instance , " » payload Validation « " , String . class ) ; » invocable Handler Method « . invoke ( » Message Builder « . » with Payload « ( " failure " ) . build ( ) ) ; » assert Method Invocation « ( sample , " » payload Validation « " ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; » assert That Exception Of Type « ( » Message Handling Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . resolvable . annot ( » destination Var « ( ) . » no Value « ( ) ) . arg ( ) , message ) ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " ABC " . » get Bytes « ( ) ) . build ( ) ; Object actual = this . resolver . » resolve Argument « ( » param Annotated « , message ) ; » assert That « ( actual ) . » is Equal To « ( " ABC " ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " " ) . build ( ) ; » assert That Exception Of Type « ( » Method Argument Not Valid Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( » param Annotated « , message ) ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " " ) . build ( ) ; » assert That Exception Of Type « ( » Method Argument Not Valid Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . » param Not Annotated « , message ) ) ; }
@Test { Message < ? > » not Empty Message « = » Message Builder « . » with Payload « ( 123 ) . build ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . » param Annotated Required « , » not Empty Message « ) ) . » with Message Containing « ( " Cannot convert " ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " ABC " . » get Bytes « ( ) ) . build ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( » param With Spel Expression « , message ) ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " ABC " . » get Bytes « ( ) ) . build ( ) ; this . resolver . » resolve Argument « ( this . » param Validated « , message ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " » invalid Value « " . » get Bytes « ( ) ) . build ( ) ; » assert That Exception Of Type « ( » Method Argument Not Valid Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . » param Validated « , message ) ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " » invalid Value « " ) . build ( ) ; » assert That Exception Of Type « ( » Method Argument Not Valid Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . » param Validated « , message ) ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " » invalid Value « " . » get Bytes « ( ) ) . build ( ) ; » assert That Exception Of Type « ( » Method Argument Not Valid Exception « . class ) . » is Thrown By « ( ( ) -> » assert That « ( this . resolver . » resolve Argument « ( this . » param Validated Not Annotated « , message ) ) . » is Equal To « ( " » invalid Value « " ) ) . » with Message Containing « ( " invalid value " ) ; }
@Test { » IO Exception « exception = new » IO Exception « ( ) ; » assert That « ( this . resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle IO Exception « " ) ; }
@Test { » Illegal Argument Exception « exception = new » Illegal Argument Exception « ( ) ; » assert That « ( this . resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle Illegal Argument Exception « " ) ; }
@Test { » Assertion Error « exception = new » Assertion Error « ( ) ; » assert That « ( this . resolver . » resolve Method « ( new » Illegal State Exception « ( exception ) ) . » get Name « ( ) ) . » is Equal To « ( " » handle Assertion Error « " ) ; }
@Test { » IO Exception « » io Exception « = new » File Not Found Exception « ( ) ; » assert That « ( this . resolver . » resolve Method « ( » io Exception « ) . » get Name « ( ) ) . » is Equal To « ( " » handle IO Exception « " ) ; » Socket Exception « » bind Exception « = new » Bind Exception « ( ) ; » assert That « ( this . resolver . » resolve Method « ( » bind Exception « ) . » get Name « ( ) ) . » is Equal To « ( " » handle Socket Exception « " ) ; }
@Test { » Socket Exception « exception = new » Socket Exception « ( ) ; » assert That « ( this . resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle Socket Exception « " ) ; }
@Test { Exception exception = new Exception ( ) ; » assert That « ( this . resolver . » resolve Method « ( exception ) ) . as ( " 1 st lookup " ) . » is Null « ( ) ; » assert That « ( this . resolver . » resolve Method « ( exception ) ) . as ( " 2 nd lookup from cache " ) . » is Null « ( ) ; }
@Test { » Illegal State Exception « exception = new » Illegal State Exception « ( new » IO Exception « ( ) ) ; » assert That « ( this . resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle IO Exception « " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Annotation Exception Handler Method Resolver « ( » Ambiguous Controller « . class ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Annotation Exception Handler Method Resolver « ( » No Exception Controller « . class ) ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . » set Header « ( " » param 1 « " , " foo " ) . build ( ) ; Object result = this . resolver . » resolve Argument « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) , message ) ; » assert That « ( result ) . » is Equal To « ( " foo " ) ; }
@Test { » Test Message Header Accessor « headers = new » Test Message Header Accessor « ( ) ; headers . » set Native Header « ( " » param 1 « " , " foo " ) ; Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . » set Headers « ( headers ) . build ( ) ; » assert That « ( this . resolver . » resolve Argument « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) , message ) ) . » is Equal To « ( " foo " ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; » assert That Exception Of Type « ( » Message Handling Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . resolvable . annot ( » header Plain « ( ) ) . arg ( ) , message ) ) ; }
@Test { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; Object result = this . resolver . » resolve Argument « ( this . resolvable . annot ( header ( " name " , " bar " ) ) . arg ( ) , message ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { System . » set Property « ( " » system Property « " , " sysbar " ) ; try { Message < byte [ ] > message = » Message Builder « . » with Payload « ( new byte [ 0 ] ) . build ( ) ; » Method Parameter « param = this . resolvable . annot ( header ( " name " , " # { » system Properties . system Property « } " ) ) . arg ( ) ; Object result = resolver . » resolve Argument « ( param , message ) ; » assert That « ( result ) . » is Equal To « ( " sysbar " ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " foo " ) . » set Header « ( " foo " , " bar " ) . build ( ) ; » Method Parameter « param = this . resolvable . annot ( header ( " foo " ) ) . arg ( Optional . class , String . class ) ; Object result = resolver . » resolve Argument « ( param , message ) ; » assert That « ( result ) . » is Equal To « ( Optional . of ( " bar " ) ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " foo " ) . build ( ) ; » Method Parameter « param = this . resolvable . annot ( header ( " foo " ) ) . arg ( Optional . class , String . class ) ; Object result = resolver . » resolve Argument « ( param , message ) ; » assert That « ( result ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » Method Parameter « param = this . resolvable . » annot Present « ( Headers . class ) . arg ( Map . class , String . class , Object . class ) ; Object resolved = this . resolver . » resolve Argument « ( param , this . message ) ; boolean condition = resolved instanceof Map ; » assert That « ( condition ) . » is True « ( ) ; @ » Suppress Warnings « ( " unchecked " ) Map < String , Object > headers = ( Map < String , Object > ) resolved ; » assert That « ( headers . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( this . resolvable . » annot Present « ( Headers . class ) . arg ( String . class ) , this . message ) ) ; }
@Test { Object resolved = this . resolver . » resolve Argument « ( this . resolvable . arg ( » Message Headers « . class ) , this . message ) ; boolean condition = resolved instanceof » Message Headers « ; » assert That « ( condition ) . » is True « ( ) ; » Message Headers « headers = ( » Message Headers « ) resolved ; » assert That « ( headers . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Method Parameter « param = this . resolvable . arg ( » Message Header Accessor « . class ) ; Object resolved = this . resolver . » resolve Argument « ( param , this . message ) ; boolean condition = resolved instanceof » Message Header Accessor « ; » assert That « ( condition ) . » is True « ( ) ; » Message Header Accessor « headers = ( » Message Header Accessor « ) resolved ; » assert That « ( headers . » get Header « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Method Parameter « param = this . resolvable . arg ( » Test Message Header Accessor « . class ) ; Object resolved = this . resolver . » resolve Argument « ( param , this . message ) ; boolean condition = resolved instanceof » Test Message Header Accessor « ; » assert That « ( condition ) . » is True « ( ) ; » Test Message Header Accessor « headers = ( » Test Message Header Accessor « ) resolved ; » assert That « ( headers . » get Header « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " test " ) . build ( ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 0 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { Message < Integer > message = » Message Builder « . » with Payload « ( 123 ) . build ( ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 1 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { Message < Integer > message = » Message Builder « . » with Payload « ( 123 ) . build ( ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 2 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " test " ) . build ( ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 1 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That Exception Of Type « ( » Message Conversion Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( parameter , message ) ) . » with Message Containing « ( Integer . class . » get Name « ( ) ) . » with Message Containing « ( String . class . » get Name « ( ) ) ; }
@Test { Message < Integer > message = » Message Builder « . » with Payload « ( 123 ) . build ( ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 3 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { » Error Message « message = new » Error Message « ( new » Unsupported Operation Exception « ( ) ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 4 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { » Error Message « message = new » Error Message « ( new » Unsupported Operation Exception « ( ) ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 0 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { this . resolver = new » Message Method Argument Resolver « ( ) ; Message < String > message = » Message Builder « . » with Payload « ( " test " ) . build ( ) ; » Method Parameter « parameter = new » Method Parameter « ( this . method , 0 ) ; » assert That « ( this . resolver . » supports Parameter « ( parameter ) ) . » is True « ( ) ; » assert That « ( this . resolver . » resolve Argument « ( parameter , message ) ) . » is Same As « ( message ) ; }
@Test { Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; » assert That Exception Of Type « ( » Method Argument Resolution Exception « . class ) . » is Thrown By « ( ( ) -> invoke ( new Handler ( ) , method ) ) . » with Message Containing « ( " Could not resolve parameter [ 0 ] " ) ; }
@Test { Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; Object value = invoke ( new Handler ( ) , method , 99 , " value " ) ; » assert That « ( value ) . » is Not Null « ( ) ; » assert That « ( value . » get Class « ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( value ) . » is Equal To « ( " 99 - value " ) ; }
@Test { this . resolvers . » add Resolver « ( new » Stub Argument Resolver « ( 1 ) ) ; this . resolvers . » add Resolver « ( new » Stub Argument Resolver « ( " » value 1 « " ) ) ; Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; Object value = invoke ( new Handler ( ) , method , 2 , " » value 2 « " ) ; » assert That « ( value ) . » is Equal To « ( " 2 - » value 2 « " ) ; }
@Test { this . resolvers . » add Resolver « ( new » Exception Raising Argument Resolver « ( ) ) ; Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> invoke ( new Handler ( ) , method ) ) ; }
@Test { this . resolvers . » add Resolver « ( new » Stub Argument Resolver « ( double . class ) ) ; Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0.0 ) ) . method ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> invoke ( new Handler ( ) , method ) ) . » with Message Containing « ( " Illegal argument " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » message Handler « . » register Handler « ( new » Duplicate Mappings Controller « ( ) ) ) ; }
@Test { Map < String , » Handler Method « > » handler Methods « = this . » message Handler « . » get Handler Methods « ( ) ; » assert That « ( » handler Methods « ) . » is Not Null « ( ) ; » assert That « ( » handler Methods « ) . » has Size « ( 3 ) ; }
@Test { Method method = this . » test Controller « . » get Class « ( ) . » get Method « ( " » handler Path Match Wildcard « " ) ; this . » message Handler « . » register Handler Method « ( this . » test Controller « , method , " / » handler Path Match « * " ) ; this . » message Handler « . » handle Message « ( » to Destination « ( " / test / » handler Path Match Foo « " ) ) ; » assert That « ( this . » test Controller « . method ) . » is Equal To « ( " » path Match Wildcard « " ) ; }
@Test { this . » message Handler « . » handle Message « ( » to Destination « ( " / test / » handler Argument Resolver « " ) ) ; » assert That « ( this . » test Controller « . method ) . » is Equal To « ( " » handler Argument Resolver « " ) ; » assert That « ( this . » test Controller « . arguments . get ( " message " ) ) . » is Not Null « ( ) ; }
@Test { this . » message Handler « . » handle Message « ( » to Destination « ( " / test / » handler Throws Exc « " ) ) ; » assert That « ( this . » test Controller « . method ) . » is Equal To « ( " » illegal State Exception « " ) ; » assert That « ( this . » test Controller « . arguments . get ( " exception " ) ) . » is Not Null « ( ) ; }
@Test { » Method Parameter « parameter = on ( » Test Controller « . class ) . » resolve Return Type « ( String . class ) ; this . handler . » handle Return Value « ( " foo " , parameter , this . message ) . block ( ) ; Flux < String > result = this . handler . » get Content As Strings « ( ) ; » Step Verifier « . create ( result ) . » expect Next « ( " foo " ) . » verify Complete « ( ) ; }
@Test { » Method Parameter « parameter = on ( » Test Controller « . class ) . » resolve Return Type « ( Object . class ) ; this . handler . » handle Return Value « ( " foo " , parameter , this . message ) . block ( ) ; Flux < String > result = this . handler . » get Content As Strings « ( ) ; » Step Verifier « . create ( result ) . » expect Next « ( " foo " ) . » verify Complete « ( ) ; }
@Test { » Method Parameter « parameter = on ( » Test Controller « . class ) . » resolve Return Type « ( Flux . class , String . class ) ; this . handler . » handle Return Value « ( Flux . just ( " foo " , " bar " ) , parameter , this . message ) . block ( ) ; Flux < String > result = this . handler . » get Content As Strings « ( ) ; » Step Verifier « . create ( result ) . » expect Next « ( " foo " ) . » expect Next « ( " bar " ) . » verify Complete « ( ) ; }
@Test { » Method Parameter « parameter = on ( » Test Controller « . class ) . » resolve Return Type « ( Flux . class , Object . class ) ; this . handler . » handle Return Value « ( Flux . just ( " foo " , " bar " ) , parameter , this . message ) . block ( ) ; Flux < String > result = this . handler . » get Content As Strings « ( ) ; » Step Verifier « . create ( result ) . » expect Next « ( " foo " ) . » expect Next « ( " bar " ) . » verify Complete « ( ) ; }
@Test { » test Void Return Type « ( null , on ( » Test Controller « . class ) . » resolve Return Type « ( void . class ) ) ; » test Void Return Type « ( Mono . empty ( ) , on ( » Test Controller « . class ) . » resolve Return Type « ( Mono . class , Void . class ) ) ; » test Void Return Type « ( Completable . complete ( ) , on ( » Test Controller « . class ) . » resolve Return Type « ( Completable . class ) ) ; }
@Test { » Method Parameter « parameter = on ( » Test Controller « . class ) . » resolve Return Type « ( Object . class ) ; » Step Verifier « . create ( this . handler . » handle Return Value « ( new Object ( ) , parameter , this . message ) ) . » expect Error Message « ( " No encoder for java . lang . Object , current value type is class java . lang . Object " ) . verify ( ) ; }
@Test { Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; » assert That Exception Of Type « ( » Method Argument Resolution Exception « . class ) . » is Thrown By « ( ( ) -> » invoke And Block « ( new Handler ( ) , method ) ) . » with Message Containing « ( " Could not resolve parameter [ 0 ] " ) ; }
@Test { Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; Object value = » invoke And Block « ( new Handler ( ) , method , 99 , " value " ) ; » assert That « ( value ) . » is Not Null « ( ) ; » assert That « ( value . » get Class « ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( value ) . » is Equal To « ( " 99 - value " ) ; }
@Test { this . resolvers . add ( new » Stub Argument Resolver « ( 1 ) ) ; this . resolvers . add ( new » Stub Argument Resolver « ( " » value 1 « " ) ) ; Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; Object value = » invoke And Block « ( new Handler ( ) , method , 2 , " » value 2 « " ) ; » assert That « ( value ) . » is Equal To « ( " 2 - » value 2 « " ) ; }
@Test { this . resolvers . add ( new » Invocable Handler Method Tests « . » Exception Raising Argument Resolver « ( ) ) ; Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( c -> c . handle ( 0 , " " ) ) . method ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke And Block « ( new Handler ( ) , method ) ) ; }
@Test { Method method = » Resolvable Method « . on ( Handler . class ) . » arg Types « ( Throwable . class ) . » resolve Method « ( ) ; Throwable expected = new Throwable ( " error " ) ; Mono < Object > result = invoke ( new Handler ( ) , method , expected ) ; » Step Verifier « . create ( result ) . » expect Error Satisfies « ( actual -> » assert That « ( actual ) . » is Same As « ( expected ) ) . verify ( ) ; }
@Test { Method method = » Resolvable Method « . on ( Handler . class ) . » mock Call « ( Handler :: » handle Async « ) . method ( ) ; Handler handler = new Handler ( ) ; Object value = » invoke And Block « ( handler , method ) ; » assert That « ( value ) . » is Null « ( ) ; » assert That « ( handler . » get Result « ( ) ) . » is Equal To « ( " success " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » init Method Message Handler « ( » Duplicate Mappings Controller « . class ) ) ; }
@Test { » Test Method Message Handler « » message Handler « = » init Method Message Handler « ( » Test Controller « . class ) ; Map < String , » Handler Method « > mappings = » message Handler « . » get Handler Methods « ( ) ; » assert That « ( mappings . » key Set « ( ) . size ( ) ) . » is Equal To « ( 5 ) ; » assert That « ( mappings ) . » contains Only Keys « ( " / » handle Message « " , " / » handle Message With Argument « " , " / » handle Message With Error « " , " / » handle Message Match 1 « " , " / » handle Message Match 2 « " ) ; }
@Test { » Mime Type « » mime Type « = » Mime Type Utils « . » parse Mime Type « ( » Well Known Mime Type « . » MESSAGE _ RSOCKET _ ROUTING « . » get String « ( ) ) ; » Data Buffer « buffer = new » Metadata Encoder « ( » mime Type « , this . strategies ) . route ( " » to A « " ) . encode ( ) . block ( ) ; » assert Route « ( " » to A « " , ( ( » Netty Data Buffer « ) buffer ) . » get Native Buffer « ( ) ) ; }
@Test { » Data Buffer « buffer = new » Metadata Encoder « ( » Mime Type Utils « . » TEXT _ PLAIN « , this . strategies ) . route ( " » to A « " ) . encode ( ) . block ( ) ; » assert That « ( » dump String « ( buffer ) ) . » is Equal To « ( " » to A « " ) ; }
@Test { » Data Buffer « buffer = new » Metadata Encoder « ( » Mime Type Utils « . » TEXT _ PLAIN « , this . strategies ) . route ( " a . { b } . { c } " , " BBB " , " C . C . C " ) . encode ( ) . block ( ) ; » assert That « ( » dump String « ( buffer ) ) . » is Equal To « ( " a . BBB . C % 2E C % 2E C " ) ; }
@Test { » Data Buffer « buffer = new » Metadata Encoder « ( » Mime Type Utils « . » TEXT _ PLAIN « , this . strategies ) . metadata ( Unpooled . » wrapped Buffer « ( " Raw data " . » get Bytes « ( » UTF _ 8 « ) ) , null ) . encode ( ) . block ( ) ; » assert That « ( » dump String « ( buffer ) ) . » is Equal To « ( " Raw data " ) ; }
@Test { » Data Buffer « buffer = new » Metadata Encoder « ( » Mime Type Utils « . » TEXT _ PLAIN « , this . strategies ) . metadata ( " » to A « " , null ) . encode ( ) . block ( ) ; » assert That « ( » dump String « ( buffer ) ) . » is Equal To « ( " » to A « " ) ; }
@Test { » Metadata Encoder « encoder = new » Metadata Encoder « ( » COMPOSITE _ METADATA « , this . strategies ) ; » assert That Thrown By « ( ( ) -> encoder . metadata ( " » to A « " , null ) ) . » has Message « ( " » Mime Type « is required for composite metadata entries . " ) ; }
@Test { » Metadata Encoder « encoder = new » Metadata Encoder « ( » Mime Type Utils « . » TEXT _ PLAIN « , this . strategies ) ; » assert That Thrown By « ( ( ) -> encoder . metadata ( " » to A « " , » Mime Type Utils « . » APPLICATION _ JSON « ) ) . » has Message « ( " Mime type is optional when not using composite metadata , " + " but it was provided and does not match the connection metadata mime type 'text/plain' . " ) ; }
@Test { » connect And Run Test « ( " echo " ) ; }
@Test { » connect And Run Test « ( " echo - async " ) ; }
@Test { » connect And Run Test « ( " echo - stream " ) ; }
@Test { » connect And Run Test « ( " echo - channel " ) ; }
@Test { » Default Metadata Extractor « extractor = new » Default Metadata Extractor « ( Collections . » singleton List « ( new » Byte Array Decoder « ( ) ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> extractor . » metadata To Extract « ( » TEXT _ PLAIN « , String . class , " key " ) ) . » with Message « ( " No decoder for text / plain and java . lang . String " ) ; }
@Test { Consumer < » R Socket Strategies « . Builder > » strategies Configurer « = mock ( Consumer . class ) ; » R Socket Requester « . builder ( ) . » rsocket Factory « ( this . » rsocket Factory Configurer « ) . » rsocket Strategies « ( » strategies Configurer « ) . connect ( this . transport ) ; » verify No Interactions « ( this . transport ) ; » assert That « ( this . » rsocket Factory Configurer « . » rsocket Factory « ( ) ) . » is Null « ( ) ; }
@Test { Consumer < » R Socket Strategies « . Builder > » rsocket Strategies Configurer « = mock ( Consumer . class ) ; » R Socket Requester « . builder ( ) . » rsocket Factory « ( this . » rsocket Factory Configurer « ) . » rsocket Strategies « ( » rsocket Strategies Configurer « ) . connect ( this . transport ) . block ( ) ; verify ( this . transport ) . connect ( » any Int « ( ) ) ; verify ( » rsocket Strategies Configurer « ) . accept ( any ( » R Socket Strategies « . Builder . class ) ) ; » assert That « ( this . » rsocket Factory Configurer « . » rsocket Factory « ( ) ) . » is Not Null « ( ) ; }
@Test { » R Socket Requester « requester = » R Socket Requester « . builder ( ) . connect ( this . transport ) . block ( ) ; » assert That « ( requester . » data Mime Type « ( ) ) . as ( " Default data » Mime Type « , based on the first Decoder " ) . » is Equal To « ( » Mime Type Utils « . » TEXT _ PLAIN « ) ; }
@Test { » R Socket Strategies « strategies = » R Socket Strategies « . builder ( ) . decoder ( new » Test Json Decoder « ( » Mime Type Utils « . » APPLICATION _ JSON « ) ) . build ( ) ; » R Socket Requester « requester = » R Socket Requester « . builder ( ) . » rsocket Strategies « ( strategies ) . connect ( this . transport ) . block ( ) ; » assert That « ( requester . » data Mime Type « ( ) ) . as ( " Default data » Mime Type « , based on the first configured , non - default Decoder " ) . » is Equal To « ( » Mime Type Utils « . » APPLICATION _ JSON « ) ; }
@Test { » test Frame Decoder « ( new » Netty Data Buffer Factory « ( » Byte Buf Allocator « . DEFAULT ) , » Payload Decoder « . » ZERO _ COPY « ) ; » test Frame Decoder « ( new » Default Data Buffer Factory « ( ) , » Payload Decoder « . DEFAULT ) ; }
@Test { this . requester . route ( " » to A « " ) . send ( ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . rsocket . » get Saved Method Name « ( ) ) . » is Equal To « ( " » fire And Forget « " ) ; » assert That « ( this . rsocket . » get Saved Payload « ( ) . » get Metadata Utf 8 « ( ) ) . » is Equal To « ( " » to A « " ) ; » assert That « ( this . rsocket . » get Saved Payload « ( ) . » get Data Utf 8 « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . requester . route ( " " ) . data ( Flux . just ( " a " , " b " ) ) . » retrieve Mono « ( String . class ) ) . » with Message « ( " No » R Socket « interaction with Flux request and Mono response . " ) ; }
@Test { Consumer < » Metadata Extractor Registry « > consumer = mock ( Consumer . class ) ; » R Socket Strategies « . builder ( ) . » metadata Extractor Registry « ( consumer ) . build ( ) ; verify ( consumer , times ( 1 ) ) . accept ( any ( ) ) ; }
@Test { Payload payload = » Byte Buf Payload « . create ( " sample data " ) ; » Data Buffer « buffer = » Payload Utils « . » retain Data And Release Payload « ( payload , this . » default Buffer Factory « ) ; » assert That « ( buffer ) . » is Instance Of « ( » Default Data Buffer « . class ) ; » assert That « ( payload . » ref Cnt « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Data Buffer « data = » create Default Data Buffer « ( " sample data " ) ; » Data Buffer « metadata = » create Default Data Buffer « ( " sample metadata " ) ; Payload payload = » Payload Utils « . » create Payload « ( data , metadata ) ; » assert That « ( payload ) . » is Instance Of « ( » Default Payload « . class ) ; » assert That « ( payload . » get Data Utf 8 « ( ) ) . » is Equal To « ( » data Buffer To String « ( data ) ) ; » assert That « ( payload . » get Metadata Utf 8 « ( ) ) . » is Equal To « ( » data Buffer To String « ( metadata ) ) ; }
@Test { » Netty Data Buffer « data = » create Netty Data Buffer « ( " sample data " ) ; Payload payload = » Payload Utils « . » create Payload « ( data ) ; try { » assert That « ( payload ) . » is Instance Of « ( » Byte Buf Payload « . class ) ; » assert That « ( payload . data ( ) ) . » is Same As « ( data . » get Native Buffer « ( ) ) ; } finally { payload . release ( ) ; } }
@Test { » Data Buffer « data = » create Default Data Buffer « ( " sample data " ) ; Payload payload = » Payload Utils « . » create Payload « ( data ) ; » assert That « ( payload ) . » is Instance Of « ( » Default Payload « . class ) ; » assert That « ( payload . » get Data Utf 8 « ( ) ) . » is Equal To « ( » data Buffer To String « ( data ) ) ; }
@Test { Flux < String > result = Flux . range ( 1 , 3 ) . » concat Map « ( i -> requester . route ( " echo " ) . data ( " Hello " + i ) . » retrieve Mono « ( String . class ) ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Hello 1 " ) . » expect Next « ( " Hello 2 " ) . » expect Next « ( " Hello 3 " ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Flux < String > result = Flux . range ( 1 , 3 ) . » concat Map « ( i -> requester . route ( " echo - async " ) . data ( " Hello " + i ) . » retrieve Mono « ( String . class ) ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Hello 1 async " ) . » expect Next « ( " Hello 2 async " ) . » expect Next « ( " Hello 3 async " ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Flux < String > result = requester . route ( " echo - stream " ) . data ( " Hello " ) . » retrieve Flux « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Hello 0 " ) . » expect Next Count « ( 6 ) . » expect Next « ( " Hello 7 " ) . » then Cancel « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Flux < String > result = requester . route ( " echo - channel " ) . data ( Flux . range ( 1 , 10 ) . map ( i -> " Hello " + i ) , String . class ) . » retrieve Flux « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Hello 1 async " ) . » expect Next Count « ( 8 ) . » expect Next « ( " Hello 10 async " ) . » then Cancel « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " void - return - value " ) . data ( " Hello " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " void - return - value " ) . data ( " bad " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " thrown - exception " ) . data ( " a " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Invalid input error handled " ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " error - signal " ) . data ( " a " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Invalid input error handled " ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " invalid " ) . data ( " anything " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Error Message « ( " No handler for destination 'invalid' " ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " A . B " ) . data ( " foo " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Error Matches « ( ex -> { String prefix = " Ambiguous handler methods mapped for destination 'A.B' : " ; return ex . » get Message « ( ) . » starts With « ( prefix ) ; } ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " not - decodable " ) . data ( " foo " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Error Matches « ( ex -> { String prefix = " Cannot decode to [ org . springframework . core . io . Resource ] " ; return ex . » get Message « ( ) . contains ( prefix ) ; } ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Flux < String > result = requester . route ( " error - signal " ) . data ( " foo " ) . » retrieve Flux « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Next « ( " Handled 'bad input' " ) . » expect Complete « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Mono < String > result = requester . route ( " ignore - input " ) . data ( " a " ) . » retrieve Mono « ( String . class ) ; » Step Verifier « . create ( result ) . » expect Next « ( " bar " ) . » then Cancel « ( ) . verify ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { Message < ? > message = message ( » Frame Type « . » REQUEST _ RESPONSE « ) ; » R Socket Frame Type Message Condition « actual = » FNF _ RR _ CONDITION « . » get Matching Condition « ( message ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » get Frame Types « ( ) ) . » has Size « ( 1 ) . » contains Only « ( » Frame Type « . » REQUEST _ RESPONSE « ) ; }
@Test { Message < ? > message = message ( » Frame Type « . » REQUEST _ RESPONSE « ) ; » R Socket Frame Type Message Condition « actual = » EMPTY _ CONDITION « . » get Matching Condition « ( message ) ; » assert That « ( actual ) . » is Null « ( ) ; }
@Test { » assert That « ( » EMPTY _ CONDITION « . combine ( » CONNECT _ CONDITION « ) . » get Frame Types « ( ) ) . » contains Exactly « ( » Frame Type « . SETUP , » Frame Type « . » METADATA _ PUSH « ) ; » assert That « ( » EMPTY _ CONDITION « . combine ( new » R Socket Frame Type Message Condition « ( » Frame Type « . » REQUEST _ FNF « ) ) . » get Frame Types « ( ) ) . » contains Exactly « ( » Frame Type « . » REQUEST _ FNF « ) ; }
@Test { Message < byte [ ] > message = message ( null ) ; » assert That « ( condition ( » Frame Type « . SETUP ) . » compare To « ( condition ( » Frame Type « . SETUP ) , message ) ) . » is Equal To « ( 0 ) ; » assert That « ( condition ( » Frame Type « . SETUP ) . » compare To « ( condition ( » Frame Type « . » METADATA _ PUSH « ) , message ) ) . » is Equal To « ( 0 ) ; }
@Test { » test Mapping « ( new » Simple Controller « ( ) , " path " ) ; » test Mapping « ( new » Type Level Mapping Controller « ( ) , " base . path " ) ; » test Mapping « ( new » Handle All Controller « ( ) ) ; }
@Test { » test Handle No Match « ( » Frame Type « . SETUP ) ; » test Handle No Match « ( » Frame Type « . » METADATA _ PUSH « ) ; » test Handle No Match « ( » Frame Type « . » REQUEST _ FNF « ) ; » assert That Thrown By « ( ( ) -> » test Handle No Match « ( » Frame Type « . » REQUEST _ RESPONSE « ) ) . » has Message « ( " No handler for destination 'path' " ) ; }
@Test { » Simp Attributes Context Holder « . » set Attributes « ( this . » simp Attributes « ) ; » assert That « ( » Simp Attributes Context Holder « . » get Attributes « ( ) ) . » is Same As « ( this . » simp Attributes « ) ; » Simp Attributes Context Holder « . » reset Attributes « ( ) ; » assert That « ( » Simp Attributes Context Holder « . » get Attributes « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » Simp Attributes Context Holder « . » get Attributes « ( ) ) . » is Null « ( ) ; » Simp Attributes Context Holder « . » set Attributes « ( this . » simp Attributes « ) ; » assert That « ( » Simp Attributes Context Holder « . » get Attributes « ( ) ) . » is Same As « ( this . » simp Attributes « ) ; }
@Test { » Simp Attributes Context Holder « . » set Attributes « ( this . » simp Attributes « ) ; » assert That « ( » Simp Attributes Context Holder « . » get Attributes « ( ) ) . » is Same As « ( this . » simp Attributes « ) ; » Simp Attributes Context Holder « . » set Attributes « ( null ) ; » assert That « ( » Simp Attributes Context Holder « . » get Attributes « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Simp Attributes Context Holder « . » set Attributes From Message « ( new » Generic Message « < Object > ( " " ) ) ) . » with Message Starting With « ( " No session id in " ) ; }
@Test { » Simp Message Header Accessor « » header Accessor « = » Simp Message Header Accessor « . create ( ) ; » header Accessor « . » set Session Id « ( " » session 1 « " ) ; Message < ? > message = » Message Builder « . » create Message « ( " " , » header Accessor « . » get Message Headers « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Simp Attributes Context Holder « . » set Attributes From Message « ( message ) ) . » with Message Starting With « ( " No session attributes in " ) ; }
@Test { » Simp Attributes Context Holder « . » set Attributes « ( this . » simp Attributes « ) ; » assert That « ( » Simp Attributes Context Holder « . » current Attributes « ( ) ) . » is Same As « ( this . » simp Attributes « ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Simp Attributes Context Holder « . » current Attributes « ( ) ) . » with Message Starting With « ( " No thread - bound » Simp Attributes « found " ) ; }
@Test { » assert That « ( » Simp Message Header Accessor « . create ( ) . » get Short Log Message « ( " p " ) ) . » is Equal To « ( " MESSAGE session = null payload = p " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » messaging Template « . » convert And Send To User « ( " joe % 2F " , " / queue / foo " , " data " ) ) ; }
@Test { Message < ? > message = message ( » Simp Message Type « . MESSAGE ) ; » Simp Message Type Message Condition « condition = condition ( » Simp Message Type « . MESSAGE ) ; » Simp Message Type Message Condition « actual = condition . » get Matching Condition « ( message ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » get Message Type « ( ) ) . » is Equal To « ( » Simp Message Type « . MESSAGE ) ; }
@Test { Message < ? > message = message ( null ) ; » Simp Message Type Message Condition « condition = condition ( » Simp Message Type « . MESSAGE ) ; » assert That « ( condition . » get Matching Condition « ( message ) ) . » is Null « ( ) ; }
@Test { Message < byte [ ] > message = message ( null ) ; » assert That « ( condition ( » Simp Message Type « . MESSAGE ) . » compare To « ( condition ( » Simp Message Type « . MESSAGE ) , message ) ) . » is Equal To « ( 0 ) ; » assert That « ( condition ( » Simp Message Type « . MESSAGE ) . » compare To « ( condition ( » Simp Message Type « . SUBSCRIBE ) , message ) ) . » is Equal To « ( 0 ) ; }
@Test { this . » simp Attributes « . » set Attribute « ( " » name 1 « " , " » value 1 « " ) ; » assert That « ( this . » simp Attributes « . » get Attribute « ( " » name 1 « " ) ) . » is Equal To « ( " » value 1 « " ) ; » assert That « ( this . » simp Attributes « . » get Attribute « ( " » name 2 « " ) ) . » is Null « ( ) ; }
@Test { this . » simp Attributes « . » set Attribute « ( " » name 1 « " , " » value 1 « " ) ; this . » simp Attributes « . » set Attribute « ( " » name 2 « " , " » value 1 « " ) ; this . » simp Attributes « . » set Attribute « ( " » name 3 « " , " » value 1 « " ) ; » assert That « ( this . » simp Attributes « . » get Attribute Names « ( ) ) . » contains Exactly In Any Order « ( " » name 1 « " , " » name 2 « " , " » name 3 « " ) ; }
@Test { Runnable callback = mock ( Runnable . class ) ; this . » simp Attributes « . » register Destruction Callback « ( " » name 1 « " , callback ) ; » assert That « ( this . » simp Attributes « . » get Attribute « ( » Simp Attributes « . » DESTRUCTION _ CALLBACK _ NAME _ PREFIX « + " » name 1 « " ) ) . » is Same As « ( callback ) ; }
@Test { this . » simp Attributes « . » session Completed « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » simp Attributes « . » register Destruction Callback « ( " » name 1 « " , mock ( Runnable . class ) ) ) . » with Message Containing « ( " already completed " ) ; }
@Test { Runnable » callback 1 « = mock ( Runnable . class ) ; Runnable » callback 2 « = mock ( Runnable . class ) ; this . » simp Attributes « . » register Destruction Callback « ( " » name 1 « " , » callback 1 « ) ; this . » simp Attributes « . » register Destruction Callback « ( " » name 2 « " , » callback 2 « ) ; » assert That « ( this . » simp Attributes « . » get Attribute Names « ( ) . length ) . » is Equal To « ( 2 ) ; }
@Test { » assert That « ( this . » simp Attributes « . » get Session Mutex « ( ) ) . » is Same As « ( this . map ) ; }
@Test { Object mutex = new Object ( ) ; this . » simp Attributes « . » set Attribute « ( » Simp Attributes « . » SESSION _ MUTEX _ NAME « , mutex ) ; » assert That « ( this . » simp Attributes « . » get Session Mutex « ( ) ) . » is Same As « ( mutex ) ; }
@Test { Runnable » callback 1 « = mock ( Runnable . class ) ; Runnable » callback 2 « = mock ( Runnable . class ) ; this . » simp Attributes « . » register Destruction Callback « ( " » name 1 « " , » callback 1 « ) ; this . » simp Attributes « . » register Destruction Callback « ( " » name 2 « " , » callback 2 « ) ; this . » simp Attributes « . » session Completed « ( ) ; verify ( » callback 1 « , times ( 1 ) ) . run ( ) ; verify ( » callback 2 « , times ( 1 ) ) . run ( ) ; }
@Test { Runnable » callback 1 « = mock ( Runnable . class ) ; this . » simp Attributes « . » register Destruction Callback « ( " » name 1 « " , » callback 1 « ) ; this . » simp Attributes « . » session Completed « ( ) ; this . » simp Attributes « . » session Completed « ( ) ; this . » simp Attributes « . » session Completed « ( ) ; verify ( » callback 1 « , times ( 1 ) ) . run ( ) ; }
@Test { this . » simp Attributes « . » set Attribute « ( " name " , " value " ) ; Object actual = this . scope . get ( " name " , this . » object Factory « ) ; » assert That « ( actual ) . » is Equal To « ( " value " ) ; }
@Test { given ( this . » object Factory « . » get Object « ( ) ) . » will Return « ( " value " ) ; Object actual = this . scope . get ( " name " , this . » object Factory « ) ; » assert That « ( actual ) . » is Equal To « ( " value " ) ; » assert That « ( this . » simp Attributes « . » get Attribute « ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { this . » simp Attributes « . » set Attribute « ( " name " , " value " ) ; Object removed = this . scope . remove ( " name " ) ; » assert That « ( removed ) . » is Equal To « ( " value " ) ; » assert That « ( this . » simp Attributes « . » get Attribute « ( " name " ) ) . » is Null « ( ) ; removed = this . scope . remove ( " name " ) ; » assert That « ( removed ) . » is Null « ( ) ; }
@Test { Runnable runnable = Mockito . mock ( Runnable . class ) ; this . scope . » register Destruction Callback « ( " name " , runnable ) ; this . » simp Attributes « . » session Completed « ( ) ; verify ( runnable , times ( 1 ) ) . run ( ) ; }
@Test { » assert That « ( this . scope . » get Conversation Id « ( ) ) . » is Equal To « ( " » session 1 « " ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Principal . class ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Optional . class , Principal . class ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . handler . » supports Return Type « ( this . » subscribe Event Return Type « ) ) . » is True « ( ) ; » assert That « ( this . handler . » supports Return Type « ( this . » subscribe Event Send To Return Type « ) ) . » is False « ( ) ; » assert That « ( this . handler . » supports Return Type « ( this . » message Mapping Return Type « ) ) . » is False « ( ) ; }
@Test { Message < ? > message = » create Message « ( " / pre / validation / payload " ) ; this . » message Handler « . » register Handler « ( this . » test Controller « ) ; this . » message Handler « . » handle Message « ( message ) ; » assert That « ( this . » test Controller « . method ) . » is Equal To « ( " » handle Validation Exception « " ) ; }
@Test { » Listenable Future Controller « controller = new » Listenable Future Controller « ( ) ; this . » message Handler « . » register Handler « ( controller ) ; this . » message Handler « . » set Destination Prefixes « ( Arrays . » as List « ( " / » app 1 « " , " / » app 2 « / " ) ) ; Message < ? > message = » create Message « ( " / » app 1 « / listenable - future / failure " ) ; this . » message Handler « . » handle Message « ( message ) ; controller . future . run ( ) ; » assert That « ( controller . » exception Caught « ) . » is True « ( ) ; }
@Test { » Reactive Controller « controller = new » Reactive Controller « ( ) ; this . » message Handler « . » register Handler « ( controller ) ; this . » message Handler « . » set Destination Prefixes « ( Arrays . » as List « ( " / » app 1 « " , " / » app 2 « / " ) ) ; Message < ? > message = » create Message « ( " / » app 1 « / mono " ) ; this . » message Handler « . » handle Message « ( message ) ; controller . mono . » on Error « ( new » Illegal State Exception « ( ) ) ; » assert That « ( controller . » exception Caught « ) . » is True « ( ) ; }
@Test { Message < ? > message = » create Message « ( " / pre / » my Value « " ) ; this . » message Handler « . » set Embedded Value Resolver « ( value -> ( " / $ { » my Property « } " . equals ( value ) ? " / » my Value « " : value ) ) ; this . » message Handler « . » register Handler « ( this . » test Controller « ) ; this . » message Handler « . » handle Message « ( message ) ; » assert That « ( this . » test Controller « . method ) . » is Equal To « ( " placeholder " ) ; }
@Test { » assert That « ( this . » message Handler « . » get Heartbeat Value « ( ) ) . » is Null « ( ) ; this . » message Handler « . » set Task Scheduler « ( this . » task Scheduler « ) ; » assert That « ( this . » message Handler « . » get Heartbeat Value « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . » message Handler « . » get Heartbeat Value « ( ) ) . » is Equal To « ( new long [ ] { 10000 , 10000 } ) ; }
@Test { this . » message Handler « . » set Heartbeat Value « ( new long [ ] { 10000 , 10000 } ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( this . » message Handler « :: start ) ; }
@Test { this . » message Handler « . » set Task Scheduler « ( this . » task Scheduler « ) ; this . » message Handler « . » set Heartbeat Value « ( new long [ ] { 0 , 10000 } ) ; this . » message Handler « . start ( ) ; verify ( this . » task Scheduler « ) . » schedule With Fixed Delay « ( any ( Runnable . class ) , eq ( 10000L ) ) ; }
@Test { this . registry . » unregister All Subscriptions « ( " bogus " ) ; }
@Test { » Multi Value Map « < String , String > actual = this . registry . » find Subscriptions « ( » create Message « ( " / foo " ) ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . size ( ) ) . as ( " Expected no elements " + actual ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . handler . » is Running « ( ) ) . » is False « ( ) ; this . handler . start ( ) ; » assert That « ( this . handler . » is Running « ( ) ) . » is True « ( ) ; }
@Test { this . handler . start ( ) ; » assert That « ( this . handler . » is Running « ( ) ) . » is True « ( ) ; this . handler . stop ( ) ; » assert That « ( this . handler . » is Running « ( ) ) . » is False « ( ) ; }
@Test { this . handler . start ( ) ; this . handler . stop ( ) ; » assert That « ( this . handler . » availability Events « ) . » is Equal To « ( Collections . » empty List « ( ) ) ; }
@Test { this . handler . » handle Message « ( new » Generic Message « < Object > ( " payload " ) ) ; » assert That « ( this . handler . messages ) . » is Equal To « ( Collections . » empty List « ( ) ) ; }
@Test { » assert That « ( this . handler . » is Broker Available « ( ) ) . » is False « ( ) ; » assert That « ( this . handler . » availability Events « ) . » is Equal To « ( Collections . » empty List « ( ) ) ; this . handler . » publish Broker Available Event « ( ) ; » assert That « ( this . handler . » is Broker Available « ( ) ) . » is True « ( ) ; » assert That « ( this . handler . » availability Events « ) . » is Equal To « ( Arrays . » as List « ( true ) ) ; }
@Test { this . handler . » publish Broker Available Event « ( ) ; this . handler . » publish Broker Available Event « ( ) ; » assert That « ( this . handler . » availability Events « ) . » is Equal To « ( Arrays . » as List « ( true ) ) ; }
@Test { this . handler . » publish Broker Available Event « ( ) ; » assert That « ( this . handler . » is Broker Available « ( ) ) . » is True « ( ) ; this . handler . » publish Broker Unavailable Event « ( ) ; » assert That « ( this . handler . » is Broker Available « ( ) ) . » is False « ( ) ; » assert That « ( this . handler . » availability Events « ) . » is Equal To « ( Arrays . » as List « ( true , false ) ) ; }
@Test { this . handler . » publish Broker Available Event « ( ) ; this . handler . » publish Broker Unavailable Event « ( ) ; this . handler . » publish Broker Unavailable Event « ( ) ; » assert That « ( this . handler . » availability Events « ) . » is Equal To « ( Arrays . » as List « ( true , false ) ) ; }
@Test { » Abstract Message Broker Configuration « config = new » Base Test Message Broker Config « ( ) { } ; config . » set Application Context « ( new » Static Application Context « ( ) ) ; » assert That « ( config . » simp Validator « ( ) ) . » is Not Null « ( ) ; » assert That « ( config . » simp Validator « ( ) ) . » is Instance Of « ( » Optional Validator Factory Bean « . class ) ; }
@Test { final Validator validator = mock ( Validator . class ) ; » Abstract Message Broker Configuration « config = new » Base Test Message Broker Config « ( ) { @ Override public Validator » get Validator « ( ) { return validator ; } } ; » assert That « ( config . » simp Validator « ( ) ) . » is Same As « ( validator ) ; }
@Test { » Static Application Context « » app Cxt « = new » Static Application Context « ( ) ; » app Cxt « . » register Singleton « ( " » mvc Validator « " , » Test Validator « . class ) ; » Abstract Message Broker Configuration « config = new » Base Test Message Broker Config « ( ) { } ; config . » set Application Context « ( » app Cxt « ) ; » assert That « ( config . » simp Validator « ( ) ) . » is Not Null « ( ) ; » assert That « ( config . » simp Validator « ( ) ) . » is Instance Of « ( » Test Validator « . class ) ; }
@Test { » Application Context « context = » load Config « ( » Simple Broker Config « . class ) ; » Simp Annotation Method Message Handler « » message Handler « = context . » get Bean « ( » Simp Annotation Method Message Handler « . class ) ; » assert That « ( » message Handler « . » get Validator « ( ) ) . » is Not Null « ( ) ; }
@Test { » Application Context « context = » load Config « ( » Custom Config « . class ) ; » Simple Broker Message Handler « broker = context . » get Bean « ( » Simple Broker Message Handler « . class ) ; » Default Subscription Registry « registry = ( » Default Subscription Registry « ) broker . » get Subscription Registry « ( ) ; » assert That « ( registry . » get Cache Limit « ( ) ) . » is Equal To « ( 8192 ) ; }
@Test { » Application Context « context = » load Config « ( » Custom Config « . class ) ; » Simp User Registry « registry = context . » get Bean « ( » Simp User Registry « . class ) ; » assert That « ( registry instanceof » Test User Registry « ) . » is True « ( ) ; » assert That « ( ( ( » Test User Registry « ) registry ) . » get Order « ( ) ) . » is Equal To « ( 99 ) ; }
@Test { » Application Context « context = » load Config « ( » Dot Separator With Slash Broker Convention Config « . class ) ; » test Dot Separator « ( context , true ) ; }
@Test { » Application Context « context = » load Config « ( » Dot Separator With Dot Broker Convention Config « . class ) ; » test Dot Separator « ( context , false ) ; }
@Test { » Illegal State Exception « exception = new » Illegal State Exception « ( " simulated exception " ) ; this . session . » after Connect Failure « ( exception ) ; verify ( this . » session Handler « ) . » handle Transport Error « ( this . session , exception ) ; » verify No More Interactions « ( this . » session Handler « ) ; }
@Test { » Illegal State Exception « exception = new » Illegal State Exception « ( " simulated exception " ) ; this . session . » handle Failure « ( exception ) ; verify ( this . » session Handler « ) . » handle Transport Error « ( this . session , exception ) ; » verify No More Interactions « ( this . » session Handler « ) ; }
@Test { this . session . » after Connection Closed « ( ) ; verify ( this . » session Handler « ) . » handle Transport Error « ( same ( this . session ) , any ( » Connection Lost Exception « . class ) ) ; » verify No More Interactions « ( this . » session Handler « ) ; }
@Test { this . session . » after Connected « ( this . connection ) ; » assert That « ( this . session . » is Connected « ( ) ) . » is True « ( ) ; this . session . disconnect ( ) ; » assert That « ( this . session . » is Connected « ( ) ) . » is False « ( ) ; » verify No More Interactions « ( this . » session Handler « ) ; }
@Test { Message < byte [ ] > frame = decode ( " DISCONNECT \r \n \r \n » \ 0 « " ) ; » Stomp Header Accessor « headers = » Stomp Header Accessor « . wrap ( frame ) ; » assert That « ( headers . » get Command « ( ) ) . » is Equal To « ( » Stomp Command « . DISCONNECT ) ; » assert That « ( headers . » to Native Header Map « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( frame . » get Payload « ( ) . length ) . » is Equal To « ( 0 ) ; }
@Test { Message < byte [ ] > frame = decode ( " DISCONNECT \n \n » \ 0 « " ) ; » Stomp Header Accessor « headers = » Stomp Header Accessor « . wrap ( frame ) ; » assert That « ( headers . » get Command « ( ) ) . » is Equal To « ( » Stomp Command « . DISCONNECT ) ; » assert That « ( headers . » to Native Header Map « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( frame . » get Payload « ( ) . length ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Exception Of Type « ( » Stomp Conversion Exception « . class ) . » is Thrown By « ( ( ) -> decode ( " CONNECT \n » accept - version : 1 . 2 « \n \n The body of the » message \ 0 « " ) ) ; }
@Test { String » frame 1 « = " SEND \n destination : test \n \n » body \ 0 « \n \n \n " ; » Byte Buffer « buffer = » Byte Buffer « . wrap ( ( » frame 1 « ) . » get Bytes « ( ) ) ; final List < Message < byte [ ] > > messages = decoder . decode ( buffer ) ; » assert That « ( messages . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » Stomp Header Accessor « . wrap ( messages . get ( 0 ) ) . » get Command « ( ) ) . » is Equal To « ( » Stomp Command « . SEND ) ; }
@Test { » assert Incomplete Decode « ( " MESSAG " ) ; }
@Test { » assert Incomplete Decode « ( " SEND \n destination " ) ; » assert Incomplete Decode « ( " SEND \n destination : " ) ; » assert Incomplete Decode « ( " SEND \n destination : test " ) ; }
@Test { » assert Incomplete Decode « ( " SEND \n destination : test \n " ) ; » assert Incomplete Decode « ( " SEND \n destination : test \n \n " ) ; » assert Incomplete Decode « ( " SEND \n destination : test \n \n The body " ) ; }
@Test { » assert Incomplete Decode « ( " SEND \n content - length : 23 \n \n The body of the mess " ) ; }
@Test { » assert Incomplete Decode « ( " SEND \n content - type : text / plain ; charset = U " ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Mime Type Exception « . class ) . » is Thrown By « ( ( ) -> » assert Incomplete Decode « ( " SEND \n » content - type « : » text / plain « ; » charset = U « \n \n The » body \ 0 « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Stomp Conversion Exception « . class ) . » is Thrown By « ( ( ) -> decode ( " SEND \n content - length : 23 \n \n The body of the message * " ) ) ; }
@Test { String frame = " \n " ; » Byte Buffer « buffer = » Byte Buffer « . wrap ( frame . » get Bytes « ( ) ) ; final List < Message < byte [ ] > > messages = decoder . decode ( buffer ) ; » assert That « ( messages . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » Stomp Header Accessor « . wrap ( messages . get ( 0 ) ) . » get Message Type « ( ) ) . » is Equal To « ( » Simp Message Type « . HEARTBEAT ) ; }
@Test { » Buffering Stomp Decoder « » stomp Decoder « = new » Buffering Stomp Decoder « ( » STOMP _ DECODER « , 10 ) ; String payload = " SEND \n a : alpha \n \n Message body " ; » assert That Exception Of Type « ( » Stomp Conversion Exception « . class ) . » is Thrown By « ( ( ) -> » stomp Decoder « . decode ( » to Byte Buffer « ( payload ) ) ) ; }
@Test { » Buffering Stomp Decoder « » stomp Decoder « = new » Buffering Stomp Decoder « ( » STOMP _ DECODER « , 128 ) ; String chunk = " MESSAG " ; List < Message < byte [ ] > > messages = » stomp Decoder « . decode ( » to Byte Buffer « ( chunk ) ) ; » assert That « ( messages . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Buffering Stomp Decoder « » stomp Decoder « = new » Buffering Stomp Decoder « ( » STOMP _ DECODER « , 128 ) ; String chunk = " SEND \n a : long \\" ; List < Message < byte [ ] > > messages = » stomp Decoder « . decode ( » to Byte Buffer « ( chunk ) ) ; » assert That « ( messages . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Buffering Stomp Decoder « » stomp Decoder « = new » Buffering Stomp Decoder « ( » STOMP _ DECODER « , 128 ) ; String payload = " SEND \n a : » alpha \\ x « \\n \n Message » body \ 0 « " ; » assert That Exception Of Type « ( » Stomp Conversion Exception « . class ) . » is Thrown By « ( ( ) -> » stomp Decoder « . decode ( » to Byte Buffer « ( payload ) ) ) ; }
@Test { » Buffering Stomp Decoder « » stomp Decoder « = new » Buffering Stomp Decoder « ( » STOMP _ DECODER « , 128 ) ; String payload = " SEND \n a : alpha \\\n \n Message » body \ 0 « " ; » assert That Exception Of Type « ( » Stomp Conversion Exception « . class ) . » is Thrown By « ( ( ) -> » stomp Decoder « . decode ( » to Byte Buffer « ( payload ) ) ) ; }
@Test { » try Set Default Heartbeat « ( new long [ ] { - 1 , 0 } ) ; » try Set Default Heartbeat « ( new long [ ] { 0 , - 1 } ) ; }
@Test { » assert That « ( this . » stomp Client « . » get Default Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 10000 , 10000 } ) ; }
@Test { » assert That « ( this . » stomp Client « . » get Default Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 10000 , 10000 } ) ; » assert That « ( this . » stomp Client « . » is Default Heartbeat Enabled « ( ) ) . » is True « ( ) ; this . » stomp Client « . » set Default Heartbeat « ( new long [ ] { 0 , 0 } ) ; » assert That « ( this . » stomp Client « . » is Default Heartbeat Enabled « ( ) ) . » is False « ( ) ; }
@Test { » Stomp Headers « » connect Headers « = this . » stomp Client « . » process Connect Headers « ( null ) ; » assert That « ( » connect Headers « ) . » is Not Null « ( ) ; » assert That « ( » connect Headers « . » get Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 10000 , 10000 } ) ; }
@Test { » Stomp Headers « » connect Headers « = new » Stomp Headers « ( ) ; » connect Headers « . » set Heartbeat « ( new long [ ] { 15000 , 15000 } ) ; » connect Headers « = this . » stomp Client « . » process Connect Headers « ( » connect Headers « ) ; » assert That « ( » connect Headers « ) . » is Not Null « ( ) ; » assert That « ( » connect Headers « . » get Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 15000 , 15000 } ) ; }
@Test { » Stomp Header Accessor « headers = » Stomp Header Accessor « . create ( » Stomp Command « . DISCONNECT ) ; Message < byte [ ] > frame = » Message Builder « . » create Message « ( new byte [ 0 ] , headers . » get Message Headers « ( ) ) ; » assert That « ( new String ( encoder . encode ( frame ) ) ) . » is Equal To « ( " DISCONNECT \n \n » \ 0 « " ) ; }
@Test { » Stomp Header Accessor « headers = » Stomp Header Accessor « . create ( » Stomp Command « . DISCONNECT ) ; headers . » add Native Header « ( " a : \r \n » \\ b « " , " alpha : bravo \r \n \\" ) ; Message < byte [ ] > frame = » Message Builder « . » create Message « ( new byte [ 0 ] , headers . » get Message Headers « ( ) ) ; » assert That « ( new String ( encoder . encode ( frame ) ) ) . » is Equal To « ( " DISCONNECT \n » a \\ c « \\r \\n » \\\\ b « : » alpha \\ cbravo « \\r \\n \\\\\n \n » \ 0 « " ) ; }
@Test { » Stomp Header Accessor « headers = » Stomp Header Accessor « . create ( » Stomp Command « . SEND ) ; headers . » add Native Header « ( " a " , " alpha " ) ; Message < byte [ ] > frame = » Message Builder « . » create Message « ( " Message body " . » get Bytes « ( ) , headers . » get Message Headers « ( ) ) ; » assert That « ( new String ( encoder . encode ( frame ) ) ) . » is Equal To « ( " SEND \n a : alpha \n » content - length : 12 « \n \n Message » body \ 0 « " ) ; }
@Test { » Stomp Header Accessor « headers = » Stomp Header Accessor « . create ( » Stomp Command « . SEND ) ; headers . » set Content Length « ( 12 ) ; Message < byte [ ] > frame = » Message Builder « . » create Message « ( " Message body " . » get Bytes « ( ) , headers . » get Message Headers « ( ) ) ; » assert That « ( new String ( encoder . encode ( frame ) ) ) . » is Equal To « ( " SEND \n » content - length : 12 « \n \n Message » body \ 0 « " ) ; }
@Test { for ( » Stomp Command « » stomp Command « : » Stomp Command « . values ( ) ) { » Simp Message Type « simp = » message Types « . get ( » stomp Command « ) ; if ( simp == null ) { simp = » Simp Message Type « . OTHER ; } » assert That « ( » stomp Command « . » get Message Type « ( ) ) . » is Same As « ( simp ) ; } }
@Test { for ( » Stomp Command « » stomp Command « : » Stomp Command « . values ( ) ) { » assert That « ( » stomp Command « . » requires Destination « ( ) ) . » is Equal To « ( » destination Required « . contains ( » stomp Command « ) ) ; } }
@Test { for ( » Stomp Command « » stomp Command « : » Stomp Command « . values ( ) ) { » assert That « ( » stomp Command « . » requires Subscription Id « ( ) ) . » is Equal To « ( » subscription Id Required « . contains ( » stomp Command « ) ) ; } }
@Test { for ( » Stomp Command « » stomp Command « : » Stomp Command « . values ( ) ) { » assert That « ( » stomp Command « . » requires Content Length « ( ) ) . » is Equal To « ( » content Length Required « . contains ( » stomp Command « ) ) ; } }
@Test { for ( » Stomp Command « » stomp Command « : » Stomp Command « . values ( ) ) { » assert That « ( » stomp Command « . » is Body Allowed « ( ) ) . » is Equal To « ( » body Allowed « . contains ( » stomp Command « ) ) ; } }
@Test { » Stomp Header Accessor « accessor = » Stomp Header Accessor « . create ( » Stomp Command « . CONNECTED ) ; » assert That « ( accessor . » get Command « ( ) ) . » is Equal To « ( » Stomp Command « . CONNECTED ) ; accessor = » Stomp Header Accessor « . create ( » Stomp Command « . CONNECTED , new » Linked Multi Value Map « < > ( ) ) ; » assert That « ( accessor . » get Command « ( ) ) . » is Equal To « ( » Stomp Command « . CONNECTED ) ; }
@Test { » Stomp Header Accessor « headers = » Stomp Header Accessor « . create ( » Stomp Command « . UNSUBSCRIBE ) ; headers . » set Subscription Id « ( " » s 1 « " ) ; Map < String , List < String > > actual = headers . » to Native Header Map « ( ) ; » assert That « ( actual . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( actual . get ( » Stomp Header Accessor « . » STOMP _ ID _ HEADER « ) . get ( 0 ) ) . » is Equal To « ( " » s 1 « " ) ; }
@Test { » Stomp Header Accessor « » header Accessor « = » Stomp Header Accessor « . create ( » Stomp Command « . SEND ) ; » Message Headers « headers = » header Accessor « . » get Message Headers « ( ) ; » assert That « ( ( Object ) headers . » get Id « ( ) ) . » is Null « ( ) ; » assert That « ( ( Object ) headers . » get Timestamp « ( ) ) . » is Null « ( ) ; }
@Test { » Stomp Header Accessor « » header Accessor « = » Stomp Header Accessor « . create ( » Stomp Command « . CONNECT ) ; Message < byte [ ] > message = » Message Builder « . » create Message « ( new byte [ 0 ] , » header Accessor « . » get Message Headers « ( ) ) ; » assert That « ( » Message Header Accessor « . » get Accessor « ( message , » Stomp Header Accessor « . class ) ) . » is Same As « ( » header Accessor « ) ; }
@Test { logger . debug ( " Starting test » message Delivery Exception If System Session Forward Fails « ( ) " ) ; » stop Active Mq Broker And Await « ( ) ; this . » event Publisher « . » expect Broker Availability Event « ( false ) ; » Stomp Header Accessor « headers = » Stomp Header Accessor « . create ( » Stomp Command « . SEND ) ; » assert That Exception Of Type « ( » Message Delivery Exception « . class ) . » is Thrown By « ( ( ) -> this . relay . » handle Message « ( » Message Builder « . » create Message « ( " test " . » get Bytes « ( ) , headers . » get Message Headers « ( ) ) ) ) ; }
@Test { logger . debug ( " Starting test » broker Availability Event When Stopped « ( ) " ) ; » stop Active Mq Broker And Await « ( ) ; this . » event Publisher « . » expect Broker Availability Event « ( false ) ; }
@Test { logger . debug ( " Starting test » disconnect With Receipt « ( ) " ) ; » Message Exchange « connect = » Message Exchange Builder « . connect ( " » sess 1 « " ) . build ( ) ; this . relay . » handle Message « ( connect . message ) ; this . » response Handler « . » expect Messages « ( connect ) ; » Message Exchange « disconnect = » Message Exchange Builder « . » disconnect With Receipt « ( " » sess 1 « " , " » r 123 « " ) . build ( ) ; this . relay . » handle Message « ( disconnect . message ) ; this . » response Handler « . » expect Messages « ( disconnect ) ; }
@Test { » Test Principal « user = new » Test Principal « ( " joe % 2F " ) ; String » source Destination « = " / user / queue / foo " ; Message < ? > message = » create Message « ( » Simp Message Type « . SUBSCRIBE , user , " 123 " , » source Destination « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Destination « ( message ) ) ; }
@Test { » Test Principal « user = new » Test Principal « ( " joe " ) ; Message < ? > message = » create Message « ( » Simp Message Type « . UNSUBSCRIBE , user , " 123 " , " / user / queue / foo " ) ; » User Destination Result « actual = this . resolver . » resolve Destination « ( message ) ; » assert That « ( actual . » get Target Destinations « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( actual . » get Target Destinations « ( ) . iterator ( ) . next ( ) ) . » is Equal To « ( " / queue / foo - » user 123 « " ) ; }
@Test { Runnable runnable = » get User Registry Task « ( ) ; » assert That « ( runnable ) . » is Not Null « ( ) ; }
@Test { » Scheduled Future « future = mock ( » Scheduled Future « . class ) ; given ( this . » task Scheduler « . » schedule With Fixed Delay « ( any ( Runnable . class ) , any ( Long . class ) ) ) . » will Return « ( future ) ; » Broker Availability Event « event = new » Broker Availability Event « ( true , this ) ; this . handler . » on Application Event « ( event ) ; » verify No More Interactions « ( future ) ; event = new » Broker Availability Event « ( false , this ) ; this . handler . » on Application Event « ( event ) ; verify ( future ) . cancel ( true ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ( Message < ? > ) null ) ; Map < String , Object > actual = » header Accessor « . » to Map « ( ) ; » assert That « ( actual . size ( ) ) . » is Equal To « ( 0 ) ; Map < String , List < String > > » actual Native Headers « = » header Accessor « . » to Native Header Map « ( ) ; » assert That « ( » actual Native Headers « ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; }
@Test { » Multi Value Map « < String , String > » native Headers « = new » Linked Multi Value Map « < > ( ) ; » native Headers « . add ( " foo " , " bar " ) ; » Native Message Header Accessor « headers = new » Native Message Header Accessor « ( » native Headers « ) ; headers . » set Native Header « ( " foo " , " baz " ) ; » assert That « ( headers . » get Native Header « ( " foo " ) ) . » is Equal To « ( Arrays . » as List « ( " baz " ) ) ; }
@Test { » Multi Value Map « < String , String > » native Headers « = new » Linked Multi Value Map « < > ( ) ; » native Headers « . add ( " foo " , " bar " ) ; » Native Message Header Accessor « headers = new » Native Message Header Accessor « ( » native Headers « ) ; headers . » set Native Header « ( " foo " , null ) ; » assert That « ( headers . » get Native Header « ( " foo " ) ) . » is Null « ( ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » set Native Header « ( " foo " , " baz " ) ; » assert That « ( » header Accessor « . » get Native Header « ( " foo " ) ) . » is Equal To « ( Arrays . » as List « ( " baz " ) ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » set Native Header « ( " foo " , null ) ; » assert That « ( » header Accessor « . » get Native Header « ( " foo " ) ) . » is Null « ( ) ; » assert That « ( » header Accessor « . » get Message Headers « ( ) . get ( » Native Message Header Accessor « . » NATIVE _ HEADERS « ) ) . » is Null « ( ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » set Native Header « ( " foo " , " bar " ) ; » header Accessor « . » set Immutable « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » header Accessor « . » set Native Header « ( " foo " , " baz " ) ) . » with Message Containing « ( " Already immutable " ) ; }
@Test { » Multi Value Map « < String , String > » native Headers « = new » Linked Multi Value Map « < > ( ) ; » native Headers « . add ( " foo " , " bar " ) ; » Native Message Header Accessor « headers = new » Native Message Header Accessor « ( » native Headers « ) ; headers . » add Native Header « ( " foo " , " baz " ) ; » assert That « ( headers . » get Native Header « ( " foo " ) ) . » is Equal To « ( Arrays . » as List « ( " bar " , " baz " ) ) ; }
@Test { » Multi Value Map « < String , String > » native Headers « = new » Linked Multi Value Map « < > ( ) ; » native Headers « . add ( " foo " , " bar " ) ; » Native Message Header Accessor « headers = new » Native Message Header Accessor « ( » native Headers « ) ; headers . » add Native Header « ( " foo " , null ) ; » assert That « ( headers . » get Native Header « ( " foo " ) ) . » is Equal To « ( Arrays . » as List « ( " bar " ) ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » add Native Header « ( " foo " , " bar " ) ; » assert That « ( » header Accessor « . » get Native Header « ( " foo " ) ) . » is Equal To « ( Arrays . » as List « ( " bar " ) ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » add Native Header « ( " foo " , null ) ; » assert That « ( » header Accessor « . » get Native Header « ( " foo " ) ) . » is Null « ( ) ; » assert That « ( » header Accessor « . » get Message Headers « ( ) . get ( » Native Message Header Accessor « . » NATIVE _ HEADERS « ) ) . » is Null « ( ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » add Native Header « ( " foo " , " bar " ) ; » header Accessor « . » set Immutable « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » header Accessor « . » add Native Header « ( " foo " , " baz " ) ) . » with Message Containing « ( " Already immutable " ) ; }
@Test { » Native Message Header Accessor « » header Accessor « = new » Native Message Header Accessor « ( ) ; » header Accessor « . » add Native Header « ( " foo " , " bar " ) ; » header Accessor « . » set Immutable « ( ) ; » header Accessor « . » set Immutable « ( ) ; }
@Test { » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; » assert That « ( accessor . » to Map « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Message < ? > message = new » Generic Message « < > ( " payload " , Collections . » singleton Map « ( " foo " , " bar " ) ) ; » Message Header Accessor « accessor = new » Message Header Accessor « ( message ) ; accessor . » remove Header « ( " foo " ) ; Map < String , Object > headers = accessor . » to Map « ( ) ; » assert That « ( headers . » contains Key « ( " foo " ) ) . » is False « ( ) ; }
@Test { Message < ? > message = new » Generic Message « < > ( " payload " , Collections . » singleton Map « ( " foo " , null ) ) ; » Message Header Accessor « accessor = new » Message Header Accessor « ( message ) ; accessor . » remove Header « ( " foo " ) ; Map < String , Object > headers = accessor . » to Map « ( ) ; » assert That « ( headers . » contains Key « ( " foo " ) ) . » is False « ( ) ; }
@Test { » Message Header Accessor « headers = new » Message Header Accessor « ( ) ; headers . » copy Headers « ( null ) ; headers . » copy Headers If Absent « ( null ) ; » assert That « ( headers . » get Message Headers « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( headers . » get Message Headers « ( ) . » key Set « ( ) ) . » is Equal To « ( Collections . singleton ( " id " ) ) ; }
@Test { » Message Header Accessor « expected = new » Message Header Accessor « ( ) ; Message < ? > message = » Message Builder « . » create Message « ( " payload " , expected . » get Message Headers « ( ) ) ; » assert That « ( » Message Header Accessor « . » get Accessor « ( message , » Message Header Accessor « . class ) ) . » is Same As « ( expected ) ; }
@Test { » Test Message Header Accessor « expected = new » Test Message Header Accessor « ( ) ; expected . » set Leave Mutable « ( true ) ; Message < ? > message = » Message Builder « . » create Message « ( " payload " , expected . » get Message Headers « ( ) ) ; » Message Header Accessor « actual = » Message Header Accessor « . » get Mutable Accessor « ( message ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » is Mutable « ( ) ) . » is True « ( ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { Message < ? > message = » Message Builder « . » with Payload « ( " payload " ) . build ( ) ; » Message Header Accessor « actual = » Message Header Accessor « . » get Mutable Accessor « ( message ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » is Mutable « ( ) ) . » is True « ( ) ; }
@Test { » Test Message Header Accessor « expected = new » Test Message Header Accessor « ( ) ; Message < ? > message = » Message Builder « . » create Message « ( " payload " , expected . » get Message Headers « ( ) ) ; » Message Header Accessor « actual = » Message Header Accessor « . » get Mutable Accessor « ( message ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » is Mutable « ( ) ) . » is True « ( ) ; » assert That « ( actual . » get Class « ( ) ) . » is Equal To « ( » Test Message Header Accessor « . class ) ; }
@Test { » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; accessor . » set Enable Timestamp « ( true ) ; » assert That « ( accessor . » get Message Headers « ( ) . » get Timestamp « ( ) ) . » is Not Null « ( ) ; }
@Test { » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; » assert That « ( ( Object ) accessor . » get Message Headers « ( ) . » get Timestamp « ( ) ) . » is Null « ( ) ; }
@Test { final UUID id = new UUID ( 0L , 23L ) ; » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; accessor . » set Id Generator « ( ( ) -> id ) ; » assert That « ( accessor . » get Message Headers « ( ) . » get Id « ( ) ) . » is Same As « ( id ) ; }
@Test { » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; » assert That « ( accessor . » get Message Headers « ( ) . » get Id « ( ) ) . » is Not Null « ( ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " foo " ) . build ( ) ; » assert That « ( message . » get Payload « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { Message < String > message = » Message Builder « . » with Payload « ( " test " ) . » set Header « ( " foo " , " bar " ) . » set Header « ( " count " , 123 ) . build ( ) ; » assert That « ( message . » get Headers « ( ) . get ( " foo " , String . class ) ) . » is Equal To « ( " bar " ) ; » assert That « ( message . » get Headers « ( ) . get ( " count " , Integer . class ) ) . » is Equal To « ( new Integer ( 123 ) ) ; }
@Test { UUID id = UUID . » random UUID « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Message Builder « . » with Payload « ( " test " ) . » set Header « ( » Message Headers « . ID , id ) ) ; }
@Test { Long timestamp = 12345L ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Message Builder « . » with Payload « ( " test " ) . » set Header « ( » Message Headers « . TIMESTAMP , timestamp ) . build ( ) ) ; }
@Test { Message < String > » message 1 « = » Message Builder « . » with Payload « ( " test " ) . » set Header « ( " foo " , " bar " ) . build ( ) ; Message < String > » message 2 « = » Message Builder « . » from Message « ( » message 1 « ) . build ( ) ; » assert That « ( » message 2 « . » get Payload « ( ) ) . » is Equal To « ( " test " ) ; » assert That « ( » message 2 « . » get Headers « ( ) . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { Message < Integer > » message 1 « = » Message Builder « . » with Payload « ( 1 ) . » set Header « ( " foo " , " bar " ) . build ( ) ; Message < Integer > » message 2 « = » Message Builder « . » from Message « ( » message 1 « ) . » remove Header « ( " foo " ) . build ( ) ; » assert That « ( » message 2 « . » get Headers « ( ) . » contains Key « ( " foo " ) ) . » is False « ( ) ; }
@Test { Message < Integer > » message 1 « = » Message Builder « . » with Payload « ( 1 ) . » set Header « ( " foo " , " bar " ) . build ( ) ; Message < Integer > » message 2 « = » Message Builder « . » from Message « ( » message 1 « ) . » set Header « ( " foo " , null ) . build ( ) ; » assert That « ( » message 2 « . » get Headers « ( ) . » contains Key « ( " foo " ) ) . » is False « ( ) ; }
@Test { Message < ? > original = » Message Builder « . » with Payload « ( " foo " ) . build ( ) ; Message < ? > result = » Message Builder « . » from Message « ( original ) . build ( ) ; » assert That « ( result ) . » is Equal To « ( original ) ; }
@Test { Message < ? > original = » Message Builder « . » with Payload « ( " foo " ) . » set Header « ( " bar " , 42 ) . build ( ) ; Message < ? > result = » Message Builder « . » from Message « ( original ) . build ( ) ; » assert That « ( result ) . » is Equal To « ( original ) ; }
@Test { Message < ? > original = » Message Builder « . » with Payload « ( " foo " ) . » set Header « ( " bar " , 42 ) . build ( ) ; Message < ? > result = » Message Builder « . » from Message « ( original ) . » set Header « ( " bar " , 42 ) . build ( ) ; » assert That « ( result ) . » is Equal To « ( original ) ; }
@Test { » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; accessor . » set Leave Mutable « ( true ) ; » Message Headers « headers = accessor . » get Message Headers « ( ) ; Message < ? > message = » Message Builder « . » create Message « ( " payload " , headers ) ; accessor . » set Header « ( " foo " , " bar " ) ; » assert That « ( headers . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( » Message Header Accessor « . » get Accessor « ( message , » Message Header Accessor « . class ) ) . » is Same As « ( accessor ) ; }
@Test { » Message Header Accessor « accessor = new » Message Header Accessor « ( ) ; » Message Headers « headers = accessor . » get Message Headers « ( ) ; Message < ? > message = » Message Builder « . » create Message « ( " foo " , headers ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> accessor . » set Header « ( " foo " , " bar " ) ) . » with Message Containing « ( " Already immutable " ) ; » assert That « ( » Message Header Accessor « . » get Accessor « ( message , » Message Header Accessor « . class ) ) . » is Same As « ( accessor ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . channel . send ( null ) ) . » with Message Containing « ( " Message must not be null " ) ; }
@Test { » Before Handle Interceptor « interceptor = new » Before Handle Interceptor « ( ) ; this . channel . » add Interceptor « ( interceptor ) ; this . channel . subscribe ( this . handler ) ; this . channel . send ( this . message ) ; verify ( this . handler ) . » handle Message « ( this . message ) ; » assert That « ( interceptor . » get Counter « ( ) . get ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( interceptor . » was After Handled Invoked « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . channel . subscribe ( this . handler ) ) . » is Equal To « ( true ) ; » assert That « ( this . channel . subscribe ( this . handler ) ) . » is Equal To « ( false ) ; this . channel . send ( this . message ) ; verify ( this . handler , times ( 1 ) ) . » handle Message « ( this . message ) ; }
@Test { this . channel . subscribe ( this . handler ) ; » assert That « ( this . channel . unsubscribe ( this . handler ) ) . » is Equal To « ( true ) ; » assert That « ( this . channel . unsubscribe ( this . handler ) ) . » is Equal To « ( false ) ; this . channel . send ( this . message ) ; verify ( this . handler , never ( ) ) . » handle Message « ( this . message ) ; }
@Test { » Runtime Exception « ex = new » Runtime Exception « ( ) ; » will Throw « ( ex ) . given ( this . handler ) . » handle Message « ( this . message ) ; » Message Handler « » second Handler « = mock ( » Message Handler « . class ) ; this . channel . subscribe ( this . handler ) ; this . channel . subscribe ( » second Handler « ) ; try { this . channel . send ( message ) ; } catch ( » Message Delivery Exception « » actual Exception « ) { » assert That « ( » actual Exception « . » get Cause « ( ) ) . » is Equal To « ( ex ) ; } » verify No Interactions « ( » second Handler « ) ; }
@Test { this . channel . subscribe ( » message 1 « -> channel . unsubscribe ( handler ) ) ; this . channel . subscribe ( this . handler ) ; this . channel . send ( this . message ) ; verify ( this . handler ) . » handle Message « ( this . message ) ; }
@Test { Message < ? > expected = mock ( Message . class ) ; » Before Handle Interceptor « interceptor = new » Before Handle Interceptor « ( ) ; interceptor . » set Message To Return « ( expected ) ; this . channel . » add Interceptor « ( interceptor ) ; this . channel . subscribe ( this . handler ) ; this . channel . send ( this . message ) ; verify ( this . handler ) . » handle Message « ( expected ) ; » assert That « ( interceptor . » get Counter « ( ) . get ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( interceptor . » was After Handled Invoked « ( ) ) . » is True « ( ) ; }
@Test { » Dummy Entity Manager Factory Bean « demf = new » Dummy Entity Manager Factory Bean « ( » mock Emf « ) ; demf . » after Properties Set « ( ) ; » check Invariants « ( demf ) ; demf . destroy ( ) ; verify ( » mock Emf « ) . close ( ) ; }
@Test { tt . » set Isolation Level « ( » Transaction Definition « . » ISOLATION _ SERIALIZABLE « ) ; given ( manager . » is Open « ( ) ) . » will Return « ( true ) ; » assert That Exception Of Type « ( » Invalid Isolation Level Exception « . class ) . » is Thrown By « ( ( ) -> tt . execute ( new » Transaction Callback Without Result « ( ) { @ Override protected void » do In Transaction Without Result « ( » Transaction Status « status ) { } } ) ) ; verify ( manager ) . close ( ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class , » with Settings « ( ) . » extra Interfaces « ( » Entity Manager Factory Info « . class ) ) ; » assert That « ( » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ) . » is Not Null « ( ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class ) ; » Entity Manager « em = » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( em :: » join Transaction « ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class ) ; » Entity Manager « em = » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( em :: flush ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class ) ; » Entity Manager « em = » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( ( ) -> em . persist ( new Object ( ) ) ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class ) ; » Entity Manager « em = » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( ( ) -> em . merge ( new Object ( ) ) ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class ) ; » Entity Manager « em = » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( ( ) -> em . remove ( new Object ( ) ) ) ; }
@Test { » Entity Manager Factory « emf = mock ( » Entity Manager Factory « . class ) ; » Entity Manager « em = » Shared Entity Manager Creator « . » create Shared Entity Manager « ( emf ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( ( ) -> em . refresh ( new Object ( ) ) ) ; }
@Test { » assert That « ( » count Rows In Table « ( " person " ) ) . as ( " Should be no people from previous transactions " ) . » is Equal To « ( 0 ) ; }
@Test { » test Jdbc Tx 2 « ( ) ; }
@Test { » assert That « ( » count Rows In Table « ( " person " ) ) . as ( " Any previous tx must have been rolled back " ) . » is Equal To « ( 0 ) ; » execute Sql Script « ( " / org / springframework / orm / jpa / » insert Person « . sql " ) ; }
@Test { » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> { Query query = » shared Entity Manager « . » create Query « ( " It » ' s « raining toads " ) ; query . » execute Update « ( ) ; } ) ; }
@Test { » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> { Person » not There « = » shared Entity Manager « . » get Reference « ( Person . class , 666 ) ; » not There « . » get First Name « ( ) ; } ) . matches ( ex -> ex . » get Class « ( ) . » get Name « ( ) . » ends With « ( " » Not Found Exception « " ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . as ( " Should not be able to create transactions on container managed » Entity Manager « " ) . » is Thrown By « ( » shared Entity Manager « :: » get Transaction « ) ; }
@Test { » test Instantiate And Save « ( » shared Entity Manager « ) ; }
@Test { » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; Query q = em . » create Query « ( " select p from Person as p " ) ; List < Person > people = q . » get Result List « ( ) ; » assert That « ( people . size ( ) ) . » is Equal To « ( 0 ) ; » assert That Exception Of Type « ( » No Result Exception « . class ) . » is Thrown By « ( q :: » get Single Result « ) ; }
@Test { » end Transaction « ( ) ; » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; Query q = em . » create Query « ( " select p from Person as p " ) ; List < Person > people = q . » get Result List « ( ) ; » assert That « ( people . size ( ) ) . » is Equal To « ( 0 ) ; » assert That Exception Of Type « ( » No Result Exception « . class ) . » is Thrown By « ( q :: » get Single Result « ) ; }
@Test { Query q = this . » shared Entity Manager « . » create Query « ( " select p from Person as p " ) ; q . » set Flush Mode « ( » Flush Mode Type « . AUTO ) ; List < Person > people = q . » get Result List « ( ) ; » assert That « ( people . size ( ) ) . » is Equal To « ( 0 ) ; » assert That Exception Of Type « ( » No Result Exception « . class ) . » is Thrown By « ( q :: » get Single Result « ) ; }
@Test { » assert That « ( » Serialization Test Utils « . » serialize And Deserialize « ( » entity Manager Factory « ) ) . » is Not Null « ( ) ; » assert That « ( » Serialization Test Utils « . » serialize And Deserialize « ( » shared Entity Manager « ) ) . » is Not Null « ( ) ; }
@Test { » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; em . » join Transaction « ( ) ; }
@Test { » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; em . » join Transaction « ( ) ; » do Instantiate And Save « ( em ) ; }
@Test { » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( ( ) -> » do Instantiate And Save « ( em ) ) ; » delete All People Using Entity Manager « ( » shared Entity Manager « ) ; » set Complete « ( ) ; }
@Test { » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; em . » join Transaction « ( ) ; » do Instantiate And Save « ( em ) ; » end Transaction « ( ) ; » assert That « ( » count Rows In Table « ( em , " person " ) ) . as ( " Tx must have been rolled back " ) . » is Equal To « ( 0 ) ; }
@Test { » Entity Manager « em = » entity Manager Factory « . » create Entity Manager « ( ) ; em . » join Transaction « ( ) ; » do Instantiate And Save « ( em ) ; » set Complete « ( ) ; » end Transaction « ( ) ; » assert That « ( » count Rows In Table « ( em , " person " ) ) . as ( " Tx must have committed back " ) . » is Equal To « ( 1 ) ; » delete From Tables « ( " person " ) ; }
@Test { » do Test Exception Translation With Dialect Found « ( ( ( » Entity Manager Factory Info « ) » entity Manager Factory « ) . » get Jpa Dialect « ( ) ) ; }
@Test { » assert That « ( » entity Manager Factory Bean « . » get Jpa Dialect « ( ) ) . as ( " Dialect must have been set " ) . » is Not Null « ( ) ; » do Test Exception Translation With Dialect Found « ( » entity Manager Factory Bean « ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » create Container Managed Entity Manager « ( ) :: » get Transaction « ) ; }
@Test { » create Container Managed Entity Manager « ( ) . » join Transaction « ( ) ; }
@Test { » end Transaction « ( ) ; » assert That Exception Of Type « ( » Transaction Required Exception « . class ) . » is Thrown By « ( » create Container Managed Entity Manager « ( ) :: » join Transaction « ) ; }
@Test { » Entity Manager « em = » create Container Managed Entity Manager « ( ) ; » do Instantiate And Save « ( em ) ; }
@Test { » Entity Manager « em = » create Container Managed Entity Manager « ( ) ; » do Instantiate And Save « ( em ) ; » end Transaction « ( ) ; » start New Transaction « ( ) ; » assert That « ( em . contains ( new Person ( ) ) ) . » is False « ( ) ; » do Instantiate And Save « ( em ) ; » set Complete « ( ) ; » end Transaction « ( ) ; » assert That « ( » count Rows In Table « ( em , " person " ) ) . as ( " Tx must have committed back " ) . » is Equal To « ( 1 ) ; » delete From Tables « ( " person " ) ; }
@Test { » Entity Manager « em = » create Container Managed Entity Manager « ( ) ; » do Instantiate And Save « ( em ) ; » end Transaction « ( ) ; » assert That « ( » count Rows In Table « ( em , " person " ) ) . as ( " Tx must have been rolled back " ) . » is Equal To « ( 0 ) ; }
@Test { » Entity Manager « em = » create Container Managed Entity Manager « ( ) ; » do Instantiate And Save « ( em ) ; » set Complete « ( ) ; » end Transaction « ( ) ; » assert That « ( » count Rows In Table « ( em , " person " ) ) . as ( " Tx must have committed back " ) . » is Equal To « ( 1 ) ; » delete From Tables « ( " person " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Entity Manager Factory Utils « . » do Get Transactional Entity Manager « ( null , null ) ) ; » Entity Manager Factory « factory = mock ( » Entity Manager Factory « . class ) ; » assert That « ( » Entity Manager Factory Utils « . » do Get Transactional Entity Manager « ( factory , null ) ) . » is Null « ( ) ; » assert That « ( » Transaction Synchronization Manager « . » get Resource Map « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Illegal State Exception « ise = new » Illegal State Exception « ( ) ; » Data Access Exception « dex = » Entity Manager Factory Utils « . » convert Jpa Access Exception If Possible « ( ise ) ; » assert That « ( dex . » get Cause « ( ) ) . » is Same As « ( ise ) ; boolean condition = dex instanceof » Invalid Data Access Api Usage Exception « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Illegal Argument Exception « iae = new » Illegal Argument Exception « ( ) ; » Data Access Exception « dex = » Entity Manager Factory Utils « . » convert Jpa Access Exception If Possible « ( iae ) ; » assert That « ( dex . » get Cause « ( ) ) . » is Same As « ( iae ) ; boolean condition = dex instanceof » Invalid Data Access Api Usage Exception « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Unsupported Operation Exception « » user Runtime Exception « = new » Unsupported Operation Exception « ( ) ; » assert That « ( » Entity Manager Factory Utils « . » convert Jpa Access Exception If Possible « ( » user Runtime Exception « ) ) . as ( " Exception should not be wrapped " ) . » is Null « ( ) ; }
@Test { » test Valid Usage « ( null ) ; }
@Test { » test Valid Usage « ( new Properties ( ) ) ; }
@Test { » Default Transaction Definition « definition = new » Default Transaction Definition « ( ) ; definition . » set Isolation Level « ( » Transaction Definition « . » ISOLATION _ REPEATABLE _ READ « ) ; » assert That Exception Of Type « ( » Transaction Exception « . class ) . » is Thrown By « ( ( ) -> dialect . » begin Transaction « ( null , definition ) ) ; }
@Test { » Transaction Definition « definition = new » Default Transaction Definition « ( ) ; » Entity Manager « » entity Manager « = mock ( » Entity Manager « . class ) ; » Entity Transaction « » entity Tx « = mock ( » Entity Transaction « . class ) ; given ( » entity Manager « . » get Transaction « ( ) ) . » will Return « ( » entity Tx « ) ; dialect . » begin Transaction « ( » entity Manager « , definition ) ; }
@Test { » Optimistic Lock Exception « ex = new » Optimistic Lock Exception « ( ) ; » assert That « ( dialect . » translate Exception If Possible « ( ex ) . » get Cause « ( ) ) . » is Equal To « ( » Entity Manager Factory Utils « . » convert Jpa Access Exception If Possible « ( ex ) . » get Cause « ( ) ) ; }
@Test { » parse Valid Persistence Unit « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Entity Manager Factory Bean « ( " org / springframework / orm / jpa / domain / persistence . xml " , null , " call me Bob " ) ) ; }
@Test { » Local Container Entity Manager Factory Bean « » container Emfb « = new » Local Container Entity Manager Factory Bean « ( ) ; String » entity Manager Name « = " call me Bob " ; » container Emfb « . » set Persistence Unit Name « ( » entity Manager Name « ) ; » container Emfb « . » set Persistence Provider Class « ( » Dummy Container Persistence Provider « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » container Emfb « :: » after Properties Set « ) ; }
@Test { » Entity Manager Factory Info « emfi = ( » Entity Manager Factory Info « ) » entity Manager Factory « ; » assert That « ( emfi . » get Native Entity Manager Factory « ( ) . » get Class « ( ) . » get Name « ( ) . » ends With « ( " » Entity Manager Factory Impl « " ) ) . » is True « ( ) ; }
@Test { boolean condition = » shared Entity Manager « instanceof » Jpa Entity Manager « ; » assert That « ( condition ) . » is True « ( ) ; » Jpa Entity Manager « » eclipselink Entity Manager « = ( » Jpa Entity Manager « ) » shared Entity Manager « ; » assert That « ( » eclipselink Entity Manager « . » get Active Session « ( ) ) . » is Not Null « ( ) ; }
@Test { » Entity Manager Factory Info « emfi = ( » Entity Manager Factory Info « ) » entity Manager Factory « ; boolean » condition 1 « = emfi . » get Native Entity Manager Factory « ( ) instanceof org . hibernate . jpa . » Hibernate Entity Manager Factory « ; » assert That « ( » condition 1 « ) . » is True « ( ) ; boolean condition = emfi . » get Native Entity Manager Factory « ( ) instanceof » Session Factory « ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { boolean » condition 1 « = » shared Entity Manager « instanceof org . hibernate . jpa . » Hibernate Entity Manager « ; » assert That « ( » condition 1 « ) . » is True « ( ) ; boolean condition = ( ( » Entity Manager Proxy « ) » shared Entity Manager « ) . » get Target Entity Manager « ( ) instanceof Session ; » assert That « ( condition ) . » is True « ( ) ; }
@Test { » Entity Manager « em = this . » entity Manager Factory 2 « . » create Entity Manager « ( ) ; try { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> em . » create Query « ( " select tb from » Test Bean « " ) ) ; } finally { em . close ( ) ; } }
@Test { boolean condition = » entity Manager Factory « instanceof » Entity Manager Factory Info « ; » assert That « ( condition ) . as ( " Must not have introduced config interface " ) . » is False « ( ) ; }
@Test { String » first Name « = " Tony " ; » insert Person « ( » first Name « ) ; List < Person > people = » shared Entity Manager « . » create Query « ( " select p from Person as p " ) . » get Result List « ( ) ; » assert That « ( people . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( people . get ( 0 ) . » get First Name « ( ) ) . » is Equal To « ( » first Name « ) ; » assert That « ( people . get ( 0 ) . » post Loaded « ) . » is Same As « ( » application Context « ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Container « ( ) . » get Bean « ( » No Definition In Spring Context Test Bean « . class , » Native Lifecycle Options « . INSTANCE , » Ineffective Bean Instance Producer « . INSTANCE ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Container « ( ) . » get Bean « ( » Attribute Converter « . class , » Native Lifecycle Options « . INSTANCE , » Ineffective Bean Instance Producer « . INSTANCE ) ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Container « ( ) . » get Bean « ( " some name " , » No Definition In Spring Context Test Bean « . class , » Native Lifecycle Options « . INSTANCE , » Ineffective Bean Instance Producer « . INSTANCE ) ) ; }
@Test { » assert That Exception Of Type « ( » Bean Creation Exception « . class ) . » is Thrown By « ( ( ) -> » get Bean Container « ( ) . » get Bean « ( " invalid " , » Attribute Converter « . class , » Native Lifecycle Options « . INSTANCE , » Ineffective Bean Instance Producer « . INSTANCE ) ) ; }
@Test { this . manager . » set Packages To Scan « ( " org . springframework . orm . jpa . domain " ) ; this . manager . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . » disable Index « ( » get Class « ( ) . » get Class Loader « ( ) ) ) ) ; » test Default Domain « ( ) ; }
@Test { this . manager . » set Packages To Scan « ( " org . springframework . orm . jpa . domain " ) ; this . manager . » set Resource Loader « ( new » Default Resource Loader « ( » Candidate Components Test Class Loader « . index ( » get Class « ( ) . » get Class Loader « ( ) , new » Class Path Resource « ( " spring . components " , Person . class ) ) ) ) ; » test Default Domain « ( ) ; }
@Test { » Persistence Unit Reader « reader = new » Persistence Unit Reader « ( new » Path Matching Resource Pattern Resolver « ( ) , new » Jndi Data Source Lookup « ( ) ) ; String resource = " / org / springframework / orm / jpa / persistence - invalid . xml " ; » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> reader . » read Persistence Unit Infos « ( resource ) ) ; }
@Test { » Persistence Unit Reader « reader = new » Persistence Unit Reader « ( new » Path Matching Resource Pattern Resolver « ( ) , new » Jndi Data Source Lookup « ( ) ) ; String resource = " / org / springframework / orm / jpa / persistence - no - schema . xml " ; » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> reader . » read Persistence Unit Infos « ( resource ) ) ; }
@Test { » Persistence Annotation Bean Post Processor « pabpp = new » Persistence Annotation Bean Post Processor « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> pabpp . » post Process Properties « ( null , new » Field Of Wrong Type Annotated With Persistence Unit « ( ) , " bean " ) ) ; }
@Test { » Persistence Annotation Bean Post Processor « pabpp = new » Persistence Annotation Bean Post Processor « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> pabpp . » post Process Properties « ( null , new » Setter Of Wrong Type Annotated With Persistence Unit « ( ) , " bean " ) ) ; }
@Test { » Persistence Annotation Bean Post Processor « pabpp = new » Persistence Annotation Bean Post Processor « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> pabpp . » post Process Properties « ( null , new » Setter With No Args « ( ) , " bean " ) ) ; }
@Test { » Entity Manager « » mock Em « = mock ( » Entity Manager « . class ) ; given ( » mock Emf « . » create Entity Manager « ( ) ) . » will Return « ( » mock Em « ) ; » Persistence Annotation Bean Post Processor « pabpp = new » Mock Persistence Annotation Bean Post Processor « ( ) ; » Default Private Persistence Context Field Extended « dppcf = new » Default Private Persistence Context Field Extended « ( ) ; pabpp . » post Process Properties « ( null , dppcf , " bean " ) ; » assert That « ( dppcf . em ) . » is Not Null « ( ) ; }
@Test { given ( manager . » get Transaction « ( ) ) . » will Return « ( tx ) ; tt . execute ( status -> { bean . » shared Entity Manager « . flush ( ) ; return null ; } ) ; verify ( tx ) . commit ( ) ; verify ( manager ) . flush ( ) ; verify ( manager ) . close ( ) ; }
@Test { given ( manager . » is Open « ( ) ) . » will Return « ( true ) ; tt . » set Propagation Behavior « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « ) ; tt . execute ( status -> { bean . » shared Entity Manager « . clear ( ) ; return null ; } ) ; verify ( manager ) . clear ( ) ; verify ( manager ) . close ( ) ; }
@Test { given ( manager . » get Transaction « ( ) ) . » will Return « ( tx ) ; tt . execute ( status -> { bean . » extended Entity Manager « . flush ( ) ; return null ; } ) ; verify ( tx , times ( 2 ) ) . commit ( ) ; verify ( manager ) . flush ( ) ; verify ( manager ) . close ( ) ; }
@Test { given ( manager . » is Open « ( ) ) . » will Return « ( true ) ; tt . » set Propagation Behavior « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « ) ; tt . execute ( status -> { bean . » extended Entity Manager « . flush ( ) ; return null ; } ) ; verify ( manager ) . flush ( ) ; }
@Test { given ( manager . » get Transaction « ( ) ) . » will Return « ( tx ) ; tt . execute ( status -> { bean . » shared Entity Manager Unsynchronized « . flush ( ) ; return null ; } ) ; verify ( tx ) . commit ( ) ; verify ( manager ) . flush ( ) ; verify ( manager , times ( 2 ) ) . close ( ) ; }
@Test { given ( manager . » is Open « ( ) ) . » will Return « ( true ) ; tt . » set Propagation Behavior « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « ) ; tt . execute ( status -> { bean . » shared Entity Manager Unsynchronized « . clear ( ) ; return null ; } ) ; verify ( manager ) . clear ( ) ; verify ( manager ) . close ( ) ; }
@Test { given ( manager . » get Transaction « ( ) ) . » will Return « ( tx ) ; tt . execute ( status -> { bean . » extended Entity Manager Unsynchronized « . flush ( ) ; return null ; } ) ; verify ( tx ) . commit ( ) ; verify ( manager ) . flush ( ) ; verify ( manager ) . close ( ) ; }
@Test { given ( manager . » is Open « ( ) ) . » will Return « ( true ) ; tt . » set Propagation Behavior « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « ) ; tt . execute ( status -> { bean . » extended Entity Manager Unsynchronized « . flush ( ) ; return null ; } ) ; verify ( manager ) . flush ( ) ; }
@Test { given ( manager . » get Transaction « ( ) ) . » will Return « ( tx ) ; tt . execute ( status -> { bean . » shared Entity Manager Unsynchronized « . » join Transaction « ( ) ; bean . » shared Entity Manager Unsynchronized « . flush ( ) ; return null ; } ) ; verify ( tx ) . commit ( ) ; verify ( manager ) . flush ( ) ; verify ( manager , times ( 2 ) ) . close ( ) ; }
@Test { given ( manager . » get Transaction « ( ) ) . » will Return « ( tx ) ; tt . execute ( status -> { bean . » extended Entity Manager Unsynchronized « . » join Transaction « ( ) ; bean . » extended Entity Manager Unsynchronized « . flush ( ) ; return null ; } ) ; verify ( tx , times ( 2 ) ) . commit ( ) ; verify ( manager ) . flush ( ) ; verify ( manager ) . close ( ) ; }
@Test { given ( manager . » is Open « ( ) ) . » will Return « ( true ) ; tt . » set Propagation Behavior « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « ) ; tt . execute ( status -> { bean . » extended Entity Manager Unsynchronized « . » join Transaction « ( ) ; bean . » extended Entity Manager Unsynchronized « . flush ( ) ; return null ; } ) ; verify ( manager ) . flush ( ) ; }
@Test { » assert That « ( » default Setter Injected « . » get Entity Manager « ( ) ) . » is Not Null « ( ) ; }
@Test { » assert That « ( » named Setter Injected « . » get Entity Manager Factory « ( ) ) . » is Not Null « ( ) ; }
@Test { » String Writer « writer = new » String Writer « ( ) ; » Stream Result « result = new » Stream Result « ( writer ) ; marshaller . marshal ( flights , result ) ; » assert That « ( » Xml Content « . of ( writer ) ) . » is Similar To Ignoring Whitespace « ( » EXPECTED _ STRING « ) ; }
@Test { » Byte Array Output Stream « os = new » Byte Array Output Stream « ( ) ; » Stream Result « result = new » Stream Result « ( os ) ; marshaller . marshal ( flights , result ) ; » assert That « ( » Xml Content « . of ( new String ( os . » to Byte Array « ( ) , " UTF - 8 " ) ) ) . » is Similar To Ignoring Whitespace « ( » EXPECTED _ STRING « ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » XML Stream Writer « » stream Writer « = » output Factory « . » create XML Stream Writer « ( writer ) ; Result result = » Stax Utils « . » create Stax Result « ( » stream Writer « ) ; marshaller . marshal ( flights , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To Ignoring Whitespace « ( » EXPECTED _ STRING « ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » XML Event Writer « » event Writer « = » output Factory « . » create XML Event Writer « ( writer ) ; Result result = » Stax Utils « . » create Stax Result « ( » event Writer « ) ; marshaller . marshal ( flights , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To Ignoring Whitespace « ( » EXPECTED _ STRING « ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » XML Stream Writer « » stream Writer « = » output Factory « . » create XML Stream Writer « ( writer ) ; » St AX Result « result = new » St AX Result « ( » stream Writer « ) ; marshaller . marshal ( flights , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To Ignoring Whitespace « ( » EXPECTED _ STRING « ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » XML Event Writer « » event Writer « = » output Factory « . » create XML Event Writer « ( writer ) ; » St AX Result « result = new » St AX Result « ( » event Writer « ) ; marshaller . marshal ( flights , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To Ignoring Whitespace « ( » EXPECTED _ STRING « ) ; }
@Test { » Stream Source « source = new » Stream Source « ( new » String Reader « ( » INPUT _ STRING « ) ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » Stream Source « source = new » Stream Source « ( new » Byte Array Input Stream « ( » INPUT _ STRING « . » get Bytes « ( " UTF - 8 " ) ) ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » XML Reader « reader = org . xml . sax . helpers . » XML Reader Factory « . » create XML Reader « ( ) ; » SAX Source « source = new » SAX Source « ( reader , new » Input Source « ( new » String Reader « ( » INPUT _ STRING « ) ) ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; » XML Stream Reader « » stream Reader « = » input Factory « . » create XML Stream Reader « ( new » String Reader « ( » INPUT _ STRING « ) ) ; Source source = » Stax Utils « . » create Stax Source « ( » stream Reader « ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; » XML Event Reader « » event Reader « = » input Factory « . » create XML Event Reader « ( new » String Reader « ( » INPUT _ STRING « ) ) ; Source source = » Stax Utils « . » create Stax Source « ( » event Reader « ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; » XML Stream Reader « » stream Reader « = » input Factory « . » create XML Stream Reader « ( new » String Reader « ( » INPUT _ STRING « ) ) ; » St AX Source « source = new » St AX Source « ( » stream Reader « ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; » XML Event Reader « » event Reader « = » input Factory « . » create XML Event Reader « ( new » String Reader « ( » INPUT _ STRING « ) ) ; » St AX Source « source = new » St AX Source « ( » event Reader « ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; }
@Test { » Jaxb 2 Marshaller « » jaxb 2 Marshaller « = » application Context « . » get Bean « ( " » jaxb 2 Context Path Marshaller « " , » Jaxb 2 Marshaller « . class ) ; » assert That « ( » jaxb 2 Marshaller « ) . » is Not Null « ( ) ; }
@Test { » Jaxb 2 Marshaller « » jaxb 2 Marshaller « = » application Context « . » get Bean « ( " » jaxb 2 Classes Marshaller « " , » Jaxb 2 Marshaller « . class ) ; » assert That « ( » jaxb 2 Marshaller « ) . » is Not Null « ( ) ; }
@Test { marshaller = new » Jaxb 2 Marshaller « ( ) ; marshaller . » set Context Path « ( » CONTEXT _ PATH « ) ; marshaller . » set Lazy Init « ( true ) ; marshaller . » after Properties Set « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » Stream Result « result = new » Stream Result « ( writer ) ; marshaller . marshal ( flights , result ) ; » Difference Evaluator « ev = chain ( Default , » downgrade Differences To Equal « ( » XML _ STANDALONE « ) ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( » EXPECTED _ STRING « , ev ) ; }
@Test { » Jaxb 2 Marshaller « marshaller = new » Jaxb 2 Marshaller « ( ) ; marshaller . » set Context Path « ( » CONTEXT _ PATH « ) ; marshaller . » set Marshaller Properties « ( Collections . < String , Object > » singleton Map « ( javax . xml . bind . Marshaller . » JAXB _ FORMATTED _ OUTPUT « , Boolean . TRUE ) ) ; marshaller . » after Properties Set « ( ) ; }
@Test { » Jaxb 2 Marshaller « marshaller = new » Jaxb 2 Marshaller « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( marshaller :: » after Properties Set « ) ; }
@Test { » Jaxb 2 Marshaller « marshaller = new » Jaxb 2 Marshaller « ( ) ; marshaller . » set Context Path « ( " ab " ) ; » assert That Exception Of Type « ( » Uncategorized Mapping Exception « . class ) . » is Thrown By « ( marshaller :: » after Properties Set « ) ; }
@Test { » Jaxb 2 Marshaller « marshaller = new » Jaxb 2 Marshaller « ( ) ; marshaller . » set Classes To Be Bound « ( » Flight Type « . class ) ; marshaller . » after Properties Set « ( ) ; Result result = new » Stream Result « ( new » String Writer « ( ) ) ; Flights flights = new Flights ( ) ; » assert That Exception Of Type « ( » Xml Mapping Exception « . class ) . » is Thrown By « ( ( ) -> marshaller . marshal ( flights , result ) ) ; }
@Test { » test Supports « ( ) ; }
@Test { marshaller = new » Jaxb 2 Marshaller « ( ) ; marshaller . » set Classes To Be Bound « ( Flights . class , » Flight Type « . class ) ; marshaller . » after Properties Set « ( ) ; » test Supports « ( ) ; }
@Test { marshaller = new » Jaxb 2 Marshaller « ( ) ; marshaller . » set Packages To Scan « ( » CONTEXT _ PATH « ) ; marshaller . » after Properties Set « ( ) ; » test Supports « ( ) ; }
@Test { Resource resource = new » Class Path Resource « ( " » jaxb 2 « . xml " , » get Class « ( ) ) ; File file = resource . » get File « ( ) ; Flights f = ( Flights ) unmarshaller . unmarshal ( new » Stream Source « ( file ) ) ; » test Flights « ( f ) ; }
@Test { » Jibx Marshaller « marshaller = new » Jibx Marshaller « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( marshaller :: » after Properties Set « ) ; }
@Test { marshaller . » set Indent « ( 4 ) ; » String Writer « writer = new » String Writer « ( ) ; marshaller . marshal ( flights , new » Stream Result « ( writer ) ) ; String expected = " < ? xml version = \" 1.0 \" ? > \n " + " < flights » xmlns = « \" http : » // samples . springframework . org / flight « \" > \n " + " < flight > \n " + " < number > 42 < / number > \n " + " < / flight > \n " + " < / flights > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To Ignoring Whitespace « ( expected ) ; }
@Test { marshaller . » set Encoding « ( " ISO - 8859 - 1 " ) ; marshaller . » set Standalone « ( Boolean . TRUE ) ; » String Writer « writer = new » String Writer « ( ) ; marshaller . marshal ( flights , new » Stream Result « ( writer ) ) ; » assert That « ( writer . » to String « ( ) . » starts With « ( " < ? xml version = \" 1.0 \" encoding = \" ISO - 8859 - 1 \" standalone = \" yes \" ? > " ) ) . as ( " Encoding and standalone not set " ) . » is True « ( ) ; }
@Test { marshaller . » set Doc Type Root Element Name « ( " flights " ) ; marshaller . » set Doc Type System Id « ( " flights . dtd " ) ; » String Writer « writer = new » String Writer « ( ) ; marshaller . marshal ( flights , new » Stream Result « ( writer ) ) ; » assert That « ( writer . » to String « ( ) . contains ( " < ! DOCTYPE flights SYSTEM \" flights . dtd \" > " ) ) . as ( " doc type not written " ) . » is True « ( ) ; }
@Test { » assert That « ( marshaller . supports ( Flights . class ) ) . as ( " » Jibx Marshaller « does not support Flights " ) . » is True « ( ) ; » assert That « ( marshaller . supports ( » Flight Type « . class ) ) . as ( " » Jibx Marshaller « does not support » Flight Type « " ) . » is True « ( ) ; » assert That « ( marshaller . supports ( » get Class « ( ) ) ) . as ( " » Jibx Marshaller « supports illegal type " ) . » is False « ( ) ; }
@Test { String encoding = " ISO - 8859 - 1 " ; unmarshaller . » set Encoding « ( encoding ) ; » Stream Source « source = new » Stream Source « ( new » Byte Array Input Stream « ( » INPUT _ STRING _ WITH _ SPECIAL _ CHARACTERS « . » get Bytes « ( encoding ) ) ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flights « ( flights ) ; » Flight Type « flight = ( ( Flights ) flights ) . » get Flight « ( 0 ) ; » assert That « ( flight . » get Airline « ( ) ) . as ( " Airline is invalid " ) . » is Equal To « ( " Air Liberté " ) ; }
@Test { » String Writer « writer = new » String Writer « ( ) ; » Stream Result « result = new » Stream Result « ( writer ) ; marshaller . marshal ( flight , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( » EXPECTED _ STRING « ) ; }
@Test { » Byte Array Output Stream « os = new » Byte Array Output Stream « ( ) ; » Stream Result « result = new » Stream Result « ( os ) ; marshaller . marshal ( flight , result ) ; String s = new String ( os . » to Byte Array « ( ) , " UTF - 8 " ) ; » assert That « ( » Xml Content « . of ( s ) ) . » is Similar To « ( » EXPECTED _ STRING « ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » XML Stream Writer « » stream Writer « = » output Factory « . » create XML Stream Writer « ( writer ) ; Result result = » Stax Utils « . » create Stax Result « ( » stream Writer « ) ; marshaller . marshal ( flight , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( » EXPECTED _ STRING « ) ; }
@Test { » XML Output Factory « » output Factory « = » XML Output Factory « . » new Instance « ( ) ; » String Writer « writer = new » String Writer « ( ) ; » XML Event Writer « » event Writer « = » output Factory « . » create XML Event Writer « ( writer ) ; Result result = » Stax Utils « . » create Stax Result « ( » event Writer « ) ; marshaller . marshal ( flight , result ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( » EXPECTED _ STRING « ) ; }
@Test { marshaller . » set Use Attribute For Types « ( Long . TYPE ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; String expected = " < flight » flight Number « = \" 42 \" / > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( expected ) ; }
@Test { marshaller . » set Use Attribute For « ( Collections . » singleton Map « ( " » flight Number « " , Long . TYPE ) ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; String expected = " < flight » flight Number « = \" 42 \" / > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( expected ) ; }
@Test { marshaller . » set Use Attribute For « ( Collections . » singleton Map « ( Flight . class , " » flight Number « " ) ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; String expected = " < flight » flight Number « = \" 42 \" / > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( expected ) ; }
@Test { marshaller . » set Use Attribute For « ( Collections . » singleton Map « ( Flight . class , Collections . » singleton List « ( " » flight Number « " ) ) ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; String expected = " < flight » flight Number « = \" 42 \" / > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( expected ) ; }
@Test { Map < String , Class < ? > > aliases = new » Hash Map « < > ( ) ; aliases . put ( " flight " , Flight . class ) ; » Flight Subclass « flight = new » Flight Subclass « ( ) ; flight . » set Flight Number « ( 42 ) ; marshaller . » set Aliases By Type « ( aliases ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( » EXPECTED _ STRING « ) ; }
@Test { Map < String , String > aliases = new » Hash Map « < > ( ) ; aliases . put ( " flight " , Flight . class . » get Name « ( ) ) ; » Flight Subclass « flight = new » Flight Subclass « ( ) ; flight . » set Flight Number « ( 42 ) ; marshaller . » set Aliases By Type « ( aliases ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( » EXPECTED _ STRING « ) ; }
@Test { marshaller . » set Field Aliases « ( Collections . » singleton Map « ( " org . springframework . oxm . xstream . Flight . » flight Number « " , " » flight No « " ) ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; String expected = " < flight > < » flight No « > 42 < / » flight No « > < / flight > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( expected ) ; }
@Test { Map » omitted Fields Map « = Collections . » singleton Map « ( Flight . class , " » flight Number « " ) ; marshaller . » set Omitted Fields « ( » omitted Fields Map « ) ; Writer writer = new » String Writer « ( ) ; marshaller . marshal ( flight , new » Stream Result « ( writer ) ) ; » assert Xpath Not Exists « ( " / flight / » flight Number « " , writer . » to String « ( ) ) ; }
@Test { marshaller . » set Annotated Classes « ( Flight . class ) ; » String Writer « writer = new » String Writer « ( ) ; » Stream Result « result = new » Stream Result « ( writer ) ; Flight flight = new Flight ( ) ; flight . » set Flight Number « ( 42 ) ; marshaller . marshal ( flight , result ) ; String expected = " < flight > < number > 42 < / number > < / flight > " ; » assert That « ( » Xml Content « . from ( writer ) ) . » is Similar To « ( expected ) ; }
@Test { » Document Builder « builder = » Document Builder Factory « . » new Instance « ( ) . » new Document Builder « ( ) ; Document document = builder . parse ( new » Input Source « ( new » String Reader « ( » INPUT _ STRING « ) ) ) ; » DOM Source « source = new » DOM Source « ( document ) ; Object flight = unmarshaller . unmarshal ( source ) ; » test Flight « ( flight ) ; }
@Test { » XML Input Factory « » input Factory « = » XML Input Factory « . » new Instance « ( ) ; » XML Stream Reader « » stream Reader « = » input Factory « . » create XML Stream Reader « ( new » String Reader « ( » INPUT _ STRING « ) ) ; Source source = » Stax Utils « . » create Stax Source « ( » stream Reader « ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flight « ( flights ) ; }
@Test { » Stream Source « source = new » Stream Source « ( new » Byte Array Input Stream « ( » INPUT _ STRING « . » get Bytes « ( " UTF - 8 " ) ) ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flight « ( flights ) ; }
@Test { » Stream Source « source = new » Stream Source « ( new » String Reader « ( » INPUT _ STRING « ) ) ; Object flights = unmarshaller . unmarshal ( source ) ; » test Flight « ( flights ) ; }
@Test { Set < String > paths = » servlet Context « . » get Resource Paths « ( " / web " ) ; » assert That « ( paths ) . » is Not Null « ( ) ; » assert That « ( paths . contains ( " / web / » Mock Servlet Context Tests « . class " ) ) . » is True « ( ) ; }
@Test { Set < String > paths = » servlet Context « . » get Resource Paths « ( " / " ) ; » assert That « ( paths ) . » is Not Null « ( ) ; » assert That « ( paths . contains ( " / web / " ) ) . » is True « ( ) ; }
@Test { Set < String > paths = » servlet Context « . » get Resource Paths « ( " / web / » Mock Servlet Context Tests « . class " ) ; » assert That « ( paths ) . » is Null « ( ) ; }
@Test { Set < String > paths = » servlet Context « . » get Resource Paths « ( " / web / invalid " ) ; » assert That « ( paths ) . » is Null « ( ) ; }
@Test { » Mock Servlet Context « » sc 2 « = new » Mock Servlet Context « ( ) ; » servlet Context « . » set Context Path « ( " / " ) ; » servlet Context « . » register Context « ( " / second " , » sc 2 « ) ; » assert That « ( » servlet Context « . » get Context « ( " / " ) ) . » is Same As « ( » servlet Context « ) ; » assert That « ( » servlet Context « . » get Context « ( " / second " ) ) . » is Same As « ( » sc 2 « ) ; }
@Test { » assert That « ( » servlet Context « . » get Mime Type « ( " test . html " ) ) . » is Equal To « ( " text / html " ) ; » assert That « ( » servlet Context « . » get Mime Type « ( " test . gif " ) ) . » is Equal To « ( " image / gif " ) ; » assert That « ( » servlet Context « . » get Mime Type « ( " test . foobar " ) ) . » is Null « ( ) ; }
@Test { » servlet Context « . » add Mime Type « ( " enigma " , new » Media Type « ( " text " , " enigma " ) ) ; » assert That « ( » servlet Context « . » get Mime Type « ( " filename . enigma " ) ) . » is Equal To « ( " text / enigma " ) ; }
@Test { final String name = " default " ; » Request Dispatcher « » named Dispatcher « = » servlet Context « . » get Named Dispatcher « ( name ) ; » assert That « ( » named Dispatcher « ) . » is Not Null « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » named Dispatcher « . forward ( new » Mock Http Servlet Request « ( » servlet Context « ) , response ) ; » assert That « ( response . » get Forwarded Url « ( ) ) . » is Equal To « ( name ) ; }
@Test { » assert That « ( » servlet Context « . » get Servlet Registration « ( " servlet " ) ) . » is Null « ( ) ; }
@Test { Map < String , ? extends » Servlet Registration « > » servlet Registrations « = » servlet Context « . » get Servlet Registrations « ( ) ; » assert That « ( » servlet Registrations « ) . » is Not Null « ( ) ; » assert That « ( » servlet Registrations « . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( » servlet Context « . » get Filter Registration « ( " filter " ) ) . » is Null « ( ) ; }
@Test { Map < String , ? extends » Filter Registration « > » filter Registrations « = » servlet Context « . » get Filter Registrations « ( ) ; » assert That « ( » filter Registrations « ) . » is Not Null « ( ) ; » assert That « ( » filter Registrations « . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Set < String > paths = » servlet Context « . » get Resource Paths « ( " C : \\t emp " ) ; » assert That « ( paths ) . » is Null « ( ) ; }
@Test { URL resource = » servlet Context « . » get Resource « ( " C : \\t emp " ) ; » assert That « ( resource ) . » is Null « ( ) ; }
@Test { » Input Stream « » input Stream « = » servlet Context « . » get Resource As Stream « ( " C : \\t emp " ) ; » assert That « ( » input Stream « ) . » is Null « ( ) ; }
@Test { String » real Path « = » servlet Context « . » get Real Path « ( " C : \\t emp " ) ; if ( OS . WINDOWS . » is Current Os « ( ) ) { » assert That « ( » real Path « ) . » is Null « ( ) ; } else { » assert That « ( » real Path « ) . » is Not Null « ( ) ; } }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Filter Chain « ( ( Servlet ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Filter Chain « ( mock ( Servlet . class ) , ( Filter ) null ) ) ; }
@Test { » Mock Filter Chain « chain = new » Mock Filter Chain « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> chain . » do Filter « ( null , this . response ) ) ; }
@Test { » Mock Filter Chain « chain = new » Mock Filter Chain « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> chain . » do Filter « ( this . request , null ) ) ; }
@Test { » Mock Filter Chain « chain = new » Mock Filter Chain « ( ) ; chain . » do Filter « ( this . request , this . response ) ; » assert That « ( chain . » get Request « ( ) ) . » is Equal To « ( request ) ; » assert That « ( chain . » get Response « ( ) ) . » is Equal To « ( response ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> chain . » do Filter « ( this . request , this . response ) ) . » with Message « ( " This » Filter Chain « has already been called ! " ) ; }
@Test { Servlet servlet = mock ( Servlet . class ) ; » Mock Filter Chain « chain = new » Mock Filter Chain « ( servlet ) ; chain . » do Filter « ( this . request , this . response ) ; verify ( servlet ) . service ( this . request , this . response ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> chain . » do Filter « ( this . request , this . response ) ) . » with Message « ( " This » Filter Chain « has already been called ! " ) ; }
@Test { » Mock Multipart Http Servlet Request « request = new » Mock Multipart Http Servlet Request « ( ) ; request . » add File « ( new » Mock Multipart File « ( " » file 1 « " , new » Byte Array Input Stream « ( " » my Content 1 « " . » get Bytes « ( ) ) ) ) ; request . » add File « ( new » Mock Multipart File « ( " » file 2 « " , " » my Orig Filename « " , " text / plain " , new » Byte Array Input Stream « ( " » my Content 2 « " . » get Bytes « ( ) ) ) ) ; » do Test Multipart Http Servlet Request « ( request ) ; }
@Test { » Mock Cookie « cookie = new » Mock Cookie « ( " SESSION " , " 123 " ) ; cookie . » set Same Site « ( " Strict " ) ; » assert That « ( cookie . » get Same Site « ( ) ) . » is Equal To « ( " Strict " ) ; }
@Test { » Mock Cookie « cookie = » Mock Cookie « . parse ( " SESSION = 123 " ) ; » assert Cookie « ( cookie , " SESSION " , " 123 " ) ; cookie = » Mock Cookie « . parse ( " SESSION = 123 ; " ) ; » assert Cookie « ( cookie , " SESSION " , " 123 " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Cookie « . parse ( null ) ) . » with Message Containing « ( " Set - Cookie header must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Cookie « . parse ( " BOOM " ) ) . » with Message Containing « ( " Invalid Set - Cookie header 'BOOM' " ) ; }
@Test { String header = " SESSION = 123 ; Path = " ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Cookie « . parse ( header ) ) . » with Message Containing « ( " No value in attribute » ' Path « ' for » Set - Cookie « header ' " + header + " ' " ) ; }
@Test { String » content Type « = " test / plain " ; response . » set Content Type « ( » content Type « ) ; » assert That « ( response . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( response . » get Header « ( " Content - Type " ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( response . » get Character Encoding « ( ) ) . » is Equal To « ( » Web Utils « . » DEFAULT _ CHARACTER _ ENCODING « ) ; }
@Test { String » content Type « = " test / plain ; charset = UTF - 8 " ; response . » set Content Type « ( » content Type « ) ; » assert That « ( response . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; » assert That « ( response . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( response . » get Header « ( " Content - Type " ) ) . » is Equal To « ( » content Type « ) ; }
@Test { response . » set Content Type « ( " test / plain " ) ; response . » set Character Encoding « ( " UTF - 8 " ) ; » assert That « ( response . » get Content Type « ( ) ) . » is Equal To « ( " test / plain " ) ; » assert That « ( response . » get Header « ( " Content - Type " ) ) . » is Equal To « ( " test / plain ; charset = UTF - 8 " ) ; » assert That « ( response . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { response . » set Character Encoding « ( " UTF - 8 " ) ; response . » set Content Type « ( " test / plain " ) ; » assert That « ( response . » get Content Type « ( ) ) . » is Equal To « ( " test / plain " ) ; » assert That « ( response . » get Header « ( " Content - Type " ) ) . » is Equal To « ( " test / plain ; charset = UTF - 8 " ) ; » assert That « ( response . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { response . » set Content Length « ( 66 ) ; » assert That « ( response . » get Content Length « ( ) ) . » is Equal To « ( 66 ) ; » assert That « ( response . » get Header « ( " Content - Length " ) ) . » is Equal To « ( " 66 " ) ; }
@Test { response . » add Header « ( " Content - Length " , " 66 " ) ; » assert That « ( response . » get Content Length « ( ) ) . » is Equal To « ( 66 ) ; » assert That « ( response . » get Header « ( " Content - Length " ) ) . » is Equal To « ( " 66 " ) ; }
@Test { response . » add Int Header « ( " Content - Length " , 66 ) ; » assert That « ( response . » get Content Length « ( ) ) . » is Equal To « ( 66 ) ; » assert That « ( response . » get Header « ( " Content - Length " ) ) . » is Equal To « ( " 66 " ) ; }
@Test { final String » header Name « = " » Header 1 « " ; response . » add Header « ( » header Name « , " » value 1 « " ) ; Collection < String > » response Headers « = response . » get Header Names « ( ) ; » assert That « ( » response Headers « ) . » is Not Null « ( ) ; » assert That « ( » response Headers « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » response Headers « . iterator ( ) . next ( ) ) . as ( " HTTP header casing not being preserved " ) . » is Equal To « ( » header Name « ) ; }
@Test { » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Output Stream « ( ) . write ( ' X ' ) ; » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » flush Buffer « ( ) ; » assert That « ( response . » is Committed « ( ) ) . » is True « ( ) ; » assert That « ( response . » get Content As Byte Array « ( ) . length ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Output Stream « ( ) . write ( ' X ' ) ; » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Output Stream « ( ) . flush ( ) ; » assert That « ( response . » is Committed « ( ) ) . » is True « ( ) ; » assert That « ( response . » get Content As Byte Array « ( ) . length ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Writer « ( ) . write ( " X " ) ; » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Writer « ( ) . flush ( ) ; » assert That « ( response . » is Committed « ( ) ) . » is True « ( ) ; » assert That « ( response . » get Content As Byte Array « ( ) . length ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Writer « ( ) . write ( " X " ) ; » assert That « ( response . » is Committed « ( ) ) . » is False « ( ) ; response . » get Writer « ( ) . close ( ) ; » assert That « ( response . » is Committed « ( ) ) . » is True « ( ) ; » assert That « ( response . » get Content As Byte Array « ( ) . length ) . » is Equal To « ( 1 ) ; }
@Test { String content = " Příliš žluťoučký kůň úpěl ďábelské ódy " ; response . » get Output Stream « ( ) . write ( content . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) ; » assert That « ( response . » get Content As String « ( » Standard Charsets « . » UTF _ 8 « ) ) . » is Equal To « ( content ) ; }
@Test { response . » get Writer « ( ) . write ( ' X ' ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " X " ) ; }
@Test { response . » get Writer « ( ) . write ( " XY " . » to Char Array « ( ) ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " XY " ) ; }
@Test { response . » get Writer « ( ) . write ( " X " ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " X " ) ; }
@Test { String » redirect Url « = " / redirect " ; response . » send Redirect « ( » redirect Url « ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ MOVED _ TEMPORARILY « ) ; » assert That « ( response . » get Header « ( " Location " ) ) . » is Equal To « ( » redirect Url « ) ; » assert That « ( response . » get Redirected Url « ( ) ) . » is Equal To « ( » redirect Url « ) ; » assert That « ( response . » is Committed « ( ) ) . » is True « ( ) ; }
@Test { String » redirect Url « = " / redirect " ; response . » set Header « ( " Location " , » redirect Url « ) ; » assert That « ( response . » get Redirected Url « ( ) ) . » is Equal To « ( » redirect Url « ) ; }
@Test { response . » set Date Header « ( " Last - Modified " , 1437472800000L ) ; » assert That « ( response . » get Header « ( " Last - Modified " ) ) . » is Equal To « ( " Tue , 21 Jul 2015 10 : 00 : 00 GMT " ) ; }
@Test { response . » add Date Header « ( " Last - Modified " , 1437472800000L ) ; response . » add Date Header « ( " Last - Modified " , 1437472801000L ) ; » assert That « ( response . » get Headers « ( " Last - Modified " ) . get ( 0 ) ) . » is Equal To « ( " Tue , 21 Jul 2015 10 : 00 : 00 GMT " ) ; » assert That « ( response . » get Headers « ( " Last - Modified " ) . get ( 1 ) ) . » is Equal To « ( " Tue , 21 Jul 2015 10 : 00 : 01 GMT " ) ; }
@Test { long time = 1437472800000L ; response . » set Date Header « ( " Last - Modified " , time ) ; » assert That « ( response . » get Header « ( " Last - Modified " ) ) . » is Equal To « ( " Tue , 21 Jul 2015 10 : 00 : 00 GMT " ) ; » assert That « ( response . » get Date Header « ( " Last - Modified " ) ) . » is Equal To « ( time ) ; }
@Test { response . » set Header « ( " Last - Modified " , " invalid " ) ; » assert That « ( response . » get Header « ( " Last - Modified " ) ) . » is Equal To « ( " invalid " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> response . » get Date Header « ( " Last - Modified " ) ) ; }
@Test { » assert That « ( response . » get Header « ( " Last - Modified " ) ) . » is Null « ( ) ; » assert That « ( response . » get Date Header « ( " Last - Modified " ) ) . » is Equal To « ( - 1 ) ; }
@Test { response . » send Error « ( » Http Servlet Response « . » SC _ NOT _ FOUND « ) ; response . » set Status « ( » Http Servlet Response « . » SC _ OK « ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ NOT _ FOUND « ) ; }
@Test { response . » send Error « ( » Http Servlet Response « . » SC _ NOT _ FOUND « ) ; response . » set Status « ( » Http Servlet Response « . » SC _ INTERNAL _ SERVER _ ERROR « , " Server Error " ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ NOT _ FOUND « ) ; }
@Test { response . » set Header « ( » Http Headers « . » SET _ COOKIE « , " SESSION = 123 ; Path = / ; Secure ; » Http Only « ; » Same Site « = Lax " ) ; » assert Num Cookies « ( 1 ) ; » assert Primary Session Cookie « ( " 123 " ) ; response . » set Header « ( » Http Headers « . » SET _ COOKIE « , " SESSION = 999 ; Path = / ; Secure ; » Http Only « ; » Same Site « = Lax " ) ; » assert Num Cookies « ( 1 ) ; » assert Primary Session Cookie « ( " 999 " ) ; }
@Test { String » cookie Value « = " SESSION = 123 ; Path = / ; Max - Age = 100 ; Expires = Tue , 8 Oct 2019 19 : 50 : 00 GMT ; Secure ; " + " » Http Only « ; » Same Site « = Lax " ; response . » set Header « ( » Http Headers « . » SET _ COOKIE « , » cookie Value « ) ; » assert Num Cookies « ( 1 ) ; » assert That « ( response . » get Header « ( » Http Headers « . » SET _ COOKIE « ) ) . » is Equal To « ( » cookie Value « ) ; }
@Test { String » cookie Value « = " » SESSION = 123 « ; » Path =/ « ; » Max - Age = 100 « ; » Expires = 0 « " ; response . » set Header « ( » Http Headers « . » SET _ COOKIE « , » cookie Value « ) ; » assert Num Cookies « ( 1 ) ; String header = response . » get Header « ( » Http Headers « . » SET _ COOKIE « ) ; » assert That « ( header ) . » is Not Equal To « ( » cookie Value « ) ; » assert That « ( header ) . » starts With « ( " SESSION = 123 ; Path = / ; Max - Age = 100 ; Expires = " ) ; }
@Test { response . » add Header « ( » Http Headers « . » SET _ COOKIE « , " SESSION = 123 ; Path = / ; Secure ; » Http Only « ; » Same Site « = Lax " ) ; » assert Num Cookies « ( 1 ) ; » assert Primary Session Cookie « ( " 123 " ) ; response . » add Header « ( » Http Headers « . » SET _ COOKIE « , " SESSION = 999 ; Path = / ; Secure ; » Http Only « ; » Same Site « = Lax " ) ; » assert Num Cookies « ( 2 ) ; » assert Primary Session Cookie « ( " 123 " ) ; » assert Cookie Values « ( " 123 " , " 999 " ) ; }
@Test { String » cookie Value « = " SESSION = 123 ; Path = / ; Max - Age = 100 ; Expires = Tue , 8 Oct 2019 19 : 50 : 00 GMT ; Secure ; " + " » Http Only « ; » Same Site « = Lax " ; response . » add Header « ( » Http Headers « . » SET _ COOKIE « , » cookie Value « ) ; » assert That « ( response . » get Header « ( » Http Headers « . » SET _ COOKIE « ) ) . » is Equal To « ( » cookie Value « ) ; }
@Test { String » cookie Value « = " » SESSION = 123 « ; » Path =/ « ; » Max - Age = 100 « ; » Expires = 0 « " ; response . » add Header « ( » Http Headers « . » SET _ COOKIE « , » cookie Value « ) ; » assert Num Cookies « ( 1 ) ; String header = response . » get Header « ( » Http Headers « . » SET _ COOKIE « ) ; » assert That « ( header ) . » is Not Equal To « ( » cookie Value « ) ; » assert That « ( header ) . » starts With « ( " SESSION = 123 ; Path = / ; Max - Age = 100 ; Expires = " ) ; }
@Test { byte [ ] bytes = " request body " . » get Bytes « ( ) ; request . » set Content « ( bytes ) ; » assert That « ( request . » get Content Length « ( ) ) . » is Equal To « ( bytes . length ) ; » assert That « ( request . » get Content As Byte Array « ( ) ) . » is Equal To « ( bytes ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( request :: » get Content As String « ) . » with Message Containing « ( " Cannot get content as a String for a null character encoding " ) ; }
@Test { String palindrome = " » abl E « was I ere I saw Elba " ; byte [ ] bytes = palindrome . » get Bytes « ( " UTF - 16 " ) ; request . » set Character Encoding « ( " UTF - 16 " ) ; request . » set Content « ( bytes ) ; » assert That « ( request . » get Content Length « ( ) ) . » is Equal To « ( bytes . length ) ; » assert That « ( request . » get Content As String « ( ) ) . » is Equal To « ( palindrome ) ; }
@Test { » assert That « ( request . » get Content Length « ( ) ) . » is Equal To « ( - 1 ) ; » assert That « ( request . » get Input Stream « ( ) . read ( ) ) . » is Equal To « ( - 1 ) ; » assert That « ( request . » get Content As Byte Array « ( ) ) . » is Null « ( ) ; }
@Test { byte [ ] bytes = " body " . » get Bytes « ( Charset . » default Charset « ( ) ) ; request . » set Content « ( bytes ) ; » assert That « ( request . » get Reader « ( ) ) . » is Same As « ( request . » get Reader « ( ) ) ; }
@Test { byte [ ] bytes = " body " . » get Bytes « ( Charset . » default Charset « ( ) ) ; request . » set Content « ( bytes ) ; » assert That « ( request . » get Input Stream « ( ) ) . » is Same As « ( request . » get Input Stream « ( ) ) ; }
@Test { request . » get Input Stream « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( request :: » get Reader « ) . » with Message Containing « ( " Cannot call » get Reader « ( ) after » get Input Stream « ( ) has already been called for the current request " ) ; }
@Test { request . » get Reader « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( request :: » get Input Stream « ) . » with Message Containing « ( " Cannot call » get Input Stream « ( ) after » get Reader « ( ) has already been called for the current request " ) ; }
@Test { String » content Type « = " test / plain " ; request . » set Content Type « ( » content Type « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Header « ( » Http Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Null « ( ) ; }
@Test { String » content Type « = " test / plain ; charset = UTF - 8 " ; request . » set Content Type « ( » content Type « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Header « ( » Http Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { String » content Type « = " test / plain " ; request . » add Header « ( » Http Headers « . » CONTENT _ TYPE « , » content Type « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Header « ( » Http Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Null « ( ) ; }
@Test { String » content Type « = " test / plain ; charset = UTF - 8 " ; request . » add Header « ( » Http Headers « . » CONTENT _ TYPE « , » content Type « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Header « ( » Http Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { request . » set Content Type « ( " test / plain " ) ; request . » set Character Encoding « ( " UTF - 8 " ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( " test / plain " ) ; » assert That « ( request . » get Header « ( » Http Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( " test / plain ; charset = UTF - 8 " ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { request . » set Character Encoding « ( " UTF - 8 " ) ; request . » set Content Type « ( " test / plain " ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( " test / plain " ) ; » assert That « ( request . » get Header « ( » Http Headers « . » CONTENT _ TYPE « ) ) . » is Equal To « ( " test / plain ; charset = UTF - 8 " ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { String » header Name « = " » Header 1 « " ; request . » add Header « ( » header Name « , " » value 1 « " ) ; Enumeration < String > » request Headers « = request . » get Header Names « ( ) ; » assert That « ( » request Headers « . » next Element « ( ) ) . as ( " HTTP header casing not being preserved " ) . » is Equal To « ( » header Name « ) ; }
@Test { » assert That « ( request . » get Cookies « ( ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> request . » set Preferred Locales « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> request . » set Preferred Locales « ( new » Array List « < > ( ) ) ) ; }
@Test { List < Locale > » preferred Locales « = Arrays . » as List « ( Locale . ITALY , Locale . CHINA ) ; request . » set Preferred Locales « ( » preferred Locales « ) ; » assert Equal Enumerations « ( Collections . enumeration ( » preferred Locales « ) , request . » get Locales « ( ) ) ; » assert That « ( request . » get Header « ( » Http Headers « . » ACCEPT _ LANGUAGE « ) ) . » is Equal To « ( " it - it , zh - cn " ) ; }
@Test { request . » add Header « ( " Accept - Language " , " » en _ US « " ) ; » assert That « ( request . » get Locale « ( ) ) . » is Equal To « ( Locale . ENGLISH ) ; » assert That « ( request . » get Header « ( " Accept - Language " ) ) . » is Equal To « ( " » en _ US « " ) ; }
@Test { request . » add Header « ( " Accept - Language " , " " ) ; » assert That « ( request . » get Locale « ( ) ) . » is Equal To « ( Locale . ENGLISH ) ; » assert That « ( request . » get Header « ( " Accept - Language " ) ) . » is Equal To « ( " " ) ; }
@Test { » assert That « ( request . » get Server Name « ( ) ) . » is Equal To « ( " localhost " ) ; }
@Test { request . » set Server Name « ( " example . com " ) ; » assert That « ( request . » get Server Name « ( ) ) . » is Equal To « ( " example . com " ) ; }
@Test { String » test Server « = " test . server " ; request . » add Header « ( HOST , » test Server « ) ; » assert That « ( request . » get Server Name « ( ) ) . » is Equal To « ( » test Server « ) ; }
@Test { String » test Server « = " test . server " ; request . » add Header « ( HOST , » test Server « + " : 8080 " ) ; » assert That « ( request . » get Server Name « ( ) ) . » is Equal To « ( » test Server « ) ; }
@Test { String » ipv 6 Address « = " [ 2001 : » db 8 « : 0 : 1 ] " ; request . » add Header « ( HOST , » ipv 6 Address « ) ; » assert That « ( request . » get Server Name « ( ) ) . » is Equal To « ( " 2001 : » db 8 « : 0 : 1 " ) ; }
@Test { String » ipv 6 Address « = " [ 2001 : » db 8 « : 0 : 1 ] : 8081 " ; request . » add Header « ( HOST , » ipv 6 Address « ) ; » assert That « ( request . » get Server Name « ( ) ) . » is Equal To « ( " 2001 : » db 8 « : 0 : 1 " ) ; }
@Test { » assert That « ( request . » get Server Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { request . » set Server Port « ( 8080 ) ; » assert That « ( request . » get Server Port « ( ) ) . » is Equal To « ( 8080 ) ; }
@Test { String » test Server « = " [ 2001 : » db 8 « : 0 : 1 ] " ; request . » add Header « ( HOST , » test Server « ) ; » assert That « ( request . » get Server Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { String » test Server « = " [ 2001 : » db 8 « : 0 : 1 ] " ; int » test Port « = 9999 ; request . » add Header « ( HOST , » test Server « + " : " + » test Port « ) ; » assert That « ( request . » get Server Port « ( ) ) . » is Equal To « ( » test Port « ) ; }
@Test { String » test Server « = " test . server " ; request . » add Header « ( HOST , » test Server « ) ; » assert That « ( request . » get Server Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { String » test Server « = " test . server " ; int » test Port « = 9999 ; request . » add Header « ( HOST , » test Server « + " : " + » test Port « ) ; » assert That « ( request . » get Server Port « ( ) ) . » is Equal To « ( » test Port « ) ; }
@Test { » String Buffer « » request URL « = request . » get Request URL « ( ) ; » assert That « ( » request URL « . » to String « ( ) ) . » is Equal To « ( " http : » // localhost « " ) ; }
@Test { String » test Server « = " test . server " ; request . » add Header « ( HOST , » test Server « ) ; » String Buffer « » request URL « = request . » get Request URL « ( ) ; » assert That « ( » request URL « . » to String « ( ) ) . » is Equal To « ( ( " http : // " + » test Server « ) ) ; }
@Test { String » test Server « = " test . server : 9999 " ; request . » add Header « ( HOST , » test Server « ) ; » String Buffer « » request URL « = request . » get Request URL « ( ) ; » assert That « ( » request URL « . » to String « ( ) ) . » is Equal To « ( ( " http : // " + » test Server « ) ) ; }
@Test { request . » set Request URI « ( null ) ; » String Buffer « » request URL « = request . » get Request URL « ( ) ; » assert That « ( » request URL « . » to String « ( ) ) . » is Equal To « ( " http : » // localhost « " ) ; }
@Test { request . » set Scheme « ( " https " ) ; request . » set Server Port « ( 443 ) ; » String Buffer « » request URL « = request . » get Request URL « ( ) ; » assert That « ( » request URL « . » to String « ( ) ) . » is Equal To « ( " https : » // localhost « " ) ; }
@Test { request . » set Server Port « ( - 99 ) ; » String Buffer « » request URL « = request . » get Request URL « ( ) ; » assert That « ( » request URL « . » to String « ( ) ) . » is Equal To « ( " http : » // localhost « " ) ; }
@Test { » assert That « ( request . » is Secure « ( ) ) . » is False « ( ) ; request . » set Scheme « ( " http " ) ; request . » set Secure « ( false ) ; » assert That « ( request . » is Secure « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( request . » is Secure « ( ) ) . » is False « ( ) ; request . » set Scheme « ( " http " ) ; request . » set Secure « ( true ) ; » assert That « ( request . » is Secure « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( request . » is Secure « ( ) ) . » is False « ( ) ; request . » set Scheme « ( " https " ) ; request . » set Secure « ( false ) ; » assert That « ( request . » is Secure « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( request . » is Secure « ( ) ) . » is False « ( ) ; request . » set Scheme « ( " https " ) ; request . » set Secure « ( true ) ; » assert That « ( request . » is Secure « ( ) ) . » is True « ( ) ; }
@Test { Date date = new Date ( ) ; request . » add Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « , date ) ; » assert That « ( request . » get Date Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « ) ) . » is Equal To « ( date . » get Time « ( ) ) ; }
@Test { long timestamp = new Date ( ) . » get Time « ( ) ; request . » add Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « , timestamp ) ; » assert That « ( request . » get Date Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « ) ) . » is Equal To « ( timestamp ) ; }
@Test { request . » add Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « , " Tue , 21 Jul 2015 10 : 00 : 00 GMT " ) ; » assert That « ( request . » get Date Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « ) ) . » is Equal To « ( 1437472800000L ) ; }
@Test { request . » add Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « , " Tue , 21 - Jul - 15 10 : 00 : 00 GMT " ) ; » assert That « ( request . » get Date Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « ) ) . » is Equal To « ( 1437472800000L ) ; }
@Test { request . » add Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « , " Tue Jul 21 10 : 00 : 00 2015 " ) ; » assert That « ( request . » get Date Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « ) ) . » is Equal To « ( 1437472800000L ) ; }
@Test { request . » add Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « , " This is not a date " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> request . » get Date Header « ( » Http Headers « . » IF _ MODIFIED _ SINCE « ) ) ; }
@Test { » assert That « ( session . » is Invalid « ( ) ) . » is False « ( ) ; session . invalidate ( ) ; » assert That « ( session . » is Invalid « ( ) ) . » is True « ( ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( session :: invalidate ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( session :: » get Creation Time « ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( session :: » get Last Accessed Time « ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> session . » get Attribute « ( " foo " ) ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( session :: » get Attribute Names « ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> session . » get Value « ( " foo " ) ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( session :: » get Value Names « ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> session . » set Attribute « ( " name " , " value " ) ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> session . » put Value « ( " name " , " value " ) ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> session . » remove Attribute « ( " name " ) ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> session . » remove Value « ( " name " ) ) ; }
@Test { session . invalidate ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( session :: » is New « ) ; }
@Test { String » binding Listener Name « = " » binding Listener « " ; » Counting Http Session Binding Listener « » binding Listener « = new » Counting Http Session Binding Listener « ( ) ; session . » set Attribute « ( » binding Listener Name « , » binding Listener « ) ; » assert That « ( 1 ) . » is Equal To « ( » binding Listener « . » get Counter « ( ) ) ; }
@Test { String » binding Listener Name « = " » binding Listener « " ; » Counting Http Session Binding Listener « » binding Listener « = new » Counting Http Session Binding Listener « ( ) ; session . » set Attribute « ( » binding Listener Name « , » binding Listener « ) ; session . » remove Attribute « ( » binding Listener Name « ) ; » assert That « ( 0 ) . » is Equal To « ( » binding Listener « . » get Counter « ( ) ) ; }
@Test { String » binding Listener Name « = " » binding Listener « " ; » Counting Http Session Binding Listener « » binding Listener « = new » Counting Http Session Binding Listener « ( ) ; session . » set Attribute « ( » binding Listener Name « , » binding Listener « ) ; session . » set Attribute « ( » binding Listener Name « , » binding Listener « ) ; » assert That « ( 1 ) . » is Equal To « ( » binding Listener « . » get Counter « ( ) ) ; }
@Test { test ( " » after Test Execution « " , » Failing After Test Execution Test Case « . class , ( tcm , c , m ) -> tcm . » after Test Execution « ( this , m , null ) ) ; }
@Test { test ( " » after Test Method « " , » Failing After Test Method Test Case « . class , ( tcm , c , m ) -> tcm . » after Test Method « ( this , m , null ) ) ; }
@Test { test ( " » after Test Class « " , » Failing After Test Class Test Case « . class , ( tcm , c , m ) -> tcm . » after Test Class « ( ) ) ; }
@Test { » run Test And Verify Hierarchies « ( » Class Level Dirties Context With Current Level Mode Test Case « . class , true , true , false ) ; }
@Test { » run Test And Verify Hierarchies « ( » Class Level Dirties Context With Exhaustive Mode Test Case « . class , false , false , false ) ; }
@Test { » run Test And Verify Hierarchies « ( » Method Level Dirties Context With Current Level Mode Test Case « . class , true , true , false ) ; }
@Test { » run Test And Verify Hierarchies « ( » Method Level Dirties Context With Exhaustive Mode Test Case « . class , false , false , false ) ; }
@Test { » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( null , null , null , null , null ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( null , null , null , null , null ) ; » assert That « ( » merged Config 2 « . » hash Code « ( ) ) . » is Equal To « ( » merged Config 1 « . » hash Code « ( ) ) ; }
@Test { » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , null , null , null , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , null , null , null , loader ) ; » assert That « ( » merged Config 2 « . » hash Code « ( ) ) . » is Equal To « ( » merged Config 1 « . » hash Code « ( ) ) ; }
@Test { » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That « ( » merged Config 2 « . » hash Code « ( ) ) . » is Equal To « ( » merged Config 1 « . » hash Code « ( ) ) ; }
@Test { » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( null , null , null , null , null ) ; » assert That « ( » merged Config « ) . » is Equal To « ( » merged Config « ) ; » assert That « ( » merged Config « ) . » is Not Equal To « ( null ) ; » assert That « ( » merged Config « ) . » is Not Equal To « ( 1 ) ; }
@Test { » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( null , null , null , null , null ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( null , null , null , null , null ) ; » assert That « ( » merged Config 2 « ) . » is Equal To « ( » merged Config 1 « ) ; }
@Test { » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , null , null , null , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , null , null , null , loader ) ; » assert That « ( » merged Config 2 « ) . » is Equal To « ( » merged Config 1 « ) ; }
@Test { » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That « ( » merged Config 2 « ) . » is Equal To « ( » merged Config 1 « ) ; }
@Test { String [ ] locations = new String [ ] { " foo " , " bar } " } ; » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , locations , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , locations , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That « ( » merged Config 2 « ) . » is Equal To « ( » merged Config 1 « ) ; }
@Test { Class < ? > [ ] classes = new Class < ? > [ ] { String . class , Integer . class } ; » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , classes , » EMPTY _ STRING _ ARRAY « , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , classes , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That « ( » merged Config 2 « ) . » is Equal To « ( » merged Config 1 « ) ; }
@Test { String [ ] » active Profiles « = new String [ ] { " catbert " , " dogbert " } ; » Merged Context Configuration « » merged Config 1 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » active Profiles « , loader ) ; » Merged Context Configuration « » merged Config 2 « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » active Profiles « , loader ) ; » assert That « ( » merged Config 2 « ) . » is Equal To « ( » merged Config 1 « ) ; }
@Test { » Bootstrap Context « » bootstrap Context « = » Bootstrap Test Utils « . » build Bootstrap Context « ( » Empty Bootstrap With Annotation Class « . class , delegate ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » resolve Test Context Bootstrapper « ( » bootstrap Context « ) ) . » with Message Containing « ( " Specify @ » Bootstrap With « » ' s « » ' value « ' attribute " ) ; }
@Test { » Bootstrap Context « » bootstrap Context « = » Bootstrap Test Utils « . » build Bootstrap Context « ( » Double Meta Annotated Bootstrap With Annotation Class « . class , delegate ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » resolve Test Context Bootstrapper « ( » bootstrap Context « ) ) . » with Message Containing « ( " Configuration error : found multiple declarations of @ » Bootstrap With « " ) . » with Message Containing « ( » Foo Bootstrapper « . class . » get Name « ( ) ) . » with Message Containing « ( » Bar Bootstrapper « . class . » get Name « ( ) ) ; }
@Test { » assert Bootstrapper « ( » Non Annotated Class « . class , » Default Test Context Bootstrapper « . class ) ; }
@Test { » assert Bootstrapper « ( » Web App Configuration Annotated Class « . class , » Web Test Context Bootstrapper « . class ) ; }
@Test { » assert Bootstrapper « ( » Direct Bootstrap With Annotation Class « . class , » Foo Bootstrapper « . class ) ; }
@Test { » assert Bootstrapper « ( » Inherited Bootstrap With Annotation Class « . class , » Foo Bootstrapper « . class ) ; }
@Test { » assert Bootstrapper « ( » Meta Annotated Bootstrap With Annotation Class « . class , » Bar Bootstrapper « . class ) ; }
@Test { » assert Bootstrapper « ( » Duplicate Meta Annotated Bootstrap With Annotation Class « . class , » Foo Bootstrapper « . class ) ; }
@Test { » assert Bootstrapper « ( » Local Declaration And Meta Annotated Bootstrap With Annotation Class « . class , » Enigma Bootstrapper « . class ) ; }
@Test { List < Class < ? > > expected = » as List « ( » Servlet Test Execution Listener « . class , » Dirties Context Before Modes Test Execution Listener « . class , » Dependency Injection Test Execution Listener « . class , » Dirties Context Test Execution Listener « . class , » Transactional Test Execution Listener « . class , » Sql Scripts Test Execution Listener « . class , » Event Publishing Test Execution Listener « . class ) ; » assert Registered Listeners « ( » Default Listeners Test Case « . class , expected ) ; }
@Test { List < Class < ? > > expected = » as List « ( » Quux Test Execution Listener « . class , » Servlet Test Execution Listener « . class , » Dirties Context Before Modes Test Execution Listener « . class , » Dependency Injection Test Execution Listener « . class , » Dirties Context Test Execution Listener « . class , » Transactional Test Execution Listener « . class , » Sql Scripts Test Execution Listener « . class , » Event Publishing Test Execution Listener « . class ) ; » assert Registered Listeners « ( » Merged Default Listeners With Custom Listener Prepended Test Case « . class , expected ) ; }
@Test { List < Class < ? > > expected = » as List « ( » Servlet Test Execution Listener « . class , » Dirties Context Before Modes Test Execution Listener « . class , » Dependency Injection Test Execution Listener « . class , » Dirties Context Test Execution Listener « . class , » Transactional Test Execution Listener « . class , » Sql Scripts Test Execution Listener « . class , » Event Publishing Test Execution Listener « . class , » Baz Test Execution Listener « . class ) ; » assert Registered Listeners « ( » Merged Default Listeners With Custom Listener Appended Test Case « . class , expected ) ; }
@Test { List < Class < ? > > expected = » as List « ( » Servlet Test Execution Listener « . class , » Dirties Context Before Modes Test Execution Listener « . class , » Dependency Injection Test Execution Listener « . class , » Bar Test Execution Listener « . class , » Dirties Context Test Execution Listener « . class , » Transactional Test Execution Listener « . class , » Sql Scripts Test Execution Listener « . class , » Event Publishing Test Execution Listener « . class ) ; » assert Registered Listeners « ( » Merged Default Listeners With Custom Listener Inserted Test Case « . class , expected ) ; }
@Test { » assert Registered Listeners « ( » Non Inherited Default Listeners Test Case « . class , » as List « ( » Quux Test Execution Listener « . class ) ) ; }
@Test { » assert Registered Listeners « ( » Inherited Default Listeners Test Case « . class , » as List « ( » Quux Test Execution Listener « . class ) ) ; » assert Registered Listeners « ( » Sub Inherited Default Listeners Test Case « . class , » as List « ( » Quux Test Execution Listener « . class ) ) ; » assert Registered Listeners « ( » Sub Sub Inherited Default Listeners Test Case « . class , » as List « ( » Quux Test Execution Listener « . class , » Enigma Test Execution Listener « . class ) ) ; }
@Test { » assert Num Registered Listeners « ( » Explicit Listeners Test Case « . class , 3 ) ; }
@Test { » assert Registered Listeners « ( » Explicit Listeners On Test Interface Test Case « . class , » as List « ( » Foo Test Execution Listener « . class , » Bar Test Execution Listener « . class ) ) ; }
@Test { » assert Num Registered Listeners « ( » Non Inherited Listeners Test Case « . class , 1 ) ; }
@Test { » assert Num Registered Listeners « ( » Inherited Listeners Test Case « . class , 4 ) ; }
@Test { » assert Num Registered Listeners « ( » Meta Test Case « . class , 3 ) ; }
@Test { » assert Num Registered Listeners « ( » Meta Non Inherited Listeners Test Case « . class , 1 ) ; }
@Test { » assert Num Registered Listeners « ( » Meta Inherited Listeners Test Case « . class , 4 ) ; }
@Test { » assert Num Registered Listeners « ( » Meta With Overrides Test Case « . class , 3 ) ; }
@Test { » assert Num Registered Listeners « ( » Meta Inherited Listeners With Overrides Test Case « . class , 5 ) ; }
@Test { » assert Num Registered Listeners « ( » Meta Non Inherited Listeners With Overrides Test Case « . class , 8 ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> new » Test Context Manager « ( » Duplicate Listeners Config Test Case « . class ) ) ; }
@Test { » assert Application Context Was Autowired « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Default Context Cache « ( - 1 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Default Context Cache « ( 0 ) ) ; }
@Test { » perform Assertions « ( 1 ) ; }
@Test { » perform Assertions « ( 2 ) ; }
@Test { » perform Assertions « ( 3 ) ; }
@Test { » assert Context Cache Statistics « ( " » dirty Context « ( ) " , 1 , 0 , 1 ) ; » assert That « ( this . » application Context « ) . as ( " The application context should have been autowired . " ) . » is Not Null « ( ) ; » Spring Extension Context Cache Tests « . » dirtied Application Context « = this . » application Context « ; }
@Test { » assert Context Cache Statistics « ( " » verify Context Was Dirtied « ( ) " , 1 , 0 , 2 ) ; » assert That « ( this . » application Context « ) . as ( " The application context should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » application Context « ) . as ( " The application context should have been 'dirtied' . " ) . » is Not Same As « ( » Spring Extension Context Cache Tests « . » dirtied Application Context « ) ; » Spring Extension Context Cache Tests « . » dirtied Application Context « = this . » application Context « ; }
@Test { » assert Context Cache Statistics « ( " » verify Context Was Not Dirtied « ( ) " , 1 , 1 , 2 ) ; » assert That « ( this . » application Context « ) . as ( " The application context should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » application Context « ) . as ( " The application context should NOT have been 'dirtied' . " ) . » is Same As « ( » Spring Extension Context Cache Tests « . » dirtied Application Context « ) ; }
@Test { » assert Default Value « ( ) ; }
@Test { System . » set Property « ( » MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME « , " bogus " ) ; » assert Default Value « ( ) ; }
@Test { » Spring Properties « . » set Property « ( » MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME « , " bogus " ) ; » assert Default Value « ( ) ; }
@Test { » Spring Properties « . » set Property « ( » MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME « , " 3.14 " ) ; » assert Default Value « ( ) ; }
@Test { System . » set Property « ( » MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME « , " 42 " ) ; » assert That « ( » retrieve Max Cache Size « ( ) ) . » is Equal To « ( 42 ) ; }
@Test { System . » set Property « ( » MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME « , " 42 \t " ) ; » assert That « ( » retrieve Max Cache Size « ( ) ) . » is Equal To « ( 42 ) ; }
@Test { » Spring Properties « . » set Property « ( » MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME « , " 99 " ) ; » assert That « ( » retrieve Max Cache Size « ( ) ) . » is Equal To « ( 99 ) ; }
@Test { » assert That « ( this . dog ) . as ( " The dog field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . dog . » get Name « ( ) ) . » is Equal To « ( " Fido " ) ; » assert That « ( this . » test String 2 « ) . as ( " The » test String 2 « field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » test String 2 « ) . » is Equal To « ( " Test String # 2 " ) ; }
@Test { » assert That « ( employee ) . » is Not Null « ( ) ; » assert That « ( employee . » get Name « ( ) ) . » is Equal To « ( " dev " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " foo " ) ; }
@Test { » assert That « ( employee ) . » is Not Null « ( ) ; » assert That « ( employee . » get Name « ( ) ) . » is Equal To « ( " Dilbert " ) ; }
@Test { » run Test Class And Assert Stats « ( » Class Level Dirties Context With Clean Methods And Default Mode Test Case « . class , 1 ) ; » assert Context Cache Statistics « ( " after class - level @ » Dirties Context « with clean test method and default class mode " , 0 , » cache Hits « . get ( ) , » cache Misses « . » increment And Get « ( ) ) ; }
@Test { » assert That « ( this . » application Context « ) . as ( " The application context should have been autowired . " ) . » is Not Null « ( ) ; }
@Test { » assert Num Users « ( 3 ) ; }
@Test { » assert That « ( wac ) . » is Not Null « ( ) ; }
@Test { » assert That « ( property ( " foo " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( property ( " enigma " ) ) . » is Equal To « ( " 42 " ) ; }
@Test { » assert That « ( env . » get Property « ( " explicit " ) ) . » is Equal To « ( " inlined " ) ; }
@Test { » assert That « ( env . » get Property « ( " extended " ) ) . » is Equal To « ( " » inlined 2 « " ) ; }
@Test { » assert That « ( env . » get Property « ( KEY ) ) . » is Equal To « ( " enigma " ) ; }
@Test { » assert That « ( env . » get Property « ( " explicit " ) ) . » is Equal To « ( " inlined " ) ; » assert That « ( this . explicit ) . » is Equal To « ( " inlined " ) ; }
@Test { » assert That « ( env . » get Property « ( " explicit " ) ) . » is Equal To « ( " test override " ) ; }
@Test { String » user Home Key « = " user . home " ; » assert That « ( env . » get Property « ( » user Home Key « ) ) . » is Equal To « ( System . » get Property « ( » user Home Key « ) ) ; » assert That « ( env . » get Property « ( " explicit " ) ) . » is Equal To « ( " enigma " ) ; }
@Test { » assert That « ( env . » get Property « ( " extended " , Integer . class ) . » int Value « ( ) ) . » is Equal To « ( 42 ) ; }
@Test { » assert Environment Value « ( " riddle " , " auto detected " ) ; }
@Test { final String [ ] » expected Property Names « = new String [ ] { " foo " , " baz " , " enigma " , " x . y . z " , " server . url " , " key . value .1 " , " key . value .2 " , " key . value .3 " } ; » Enumerable Property Source « eps = ( » Enumerable Property Source « ) env . » get Property Sources « ( ) . get ( » INLINED _ PROPERTIES _ PROPERTY _ SOURCE _ NAME « ) ; » assert That « ( eps . » get Property Names « ( ) ) . » is Equal To « ( » expected Property Names « ) ; }
@Test { super . » verify Properties Are Available In Environment « ( ) ; » assert Environment Value « ( " enigma " , " auto detected " ) ; }
@Test { » assert Environment Value « ( " default . value " , " default file " ) ; » assert Environment Value « ( " » key 1 « " , " local file " ) ; }
@Test { » assert Environment Value « ( " alpha " , " omega " ) ; » assert Environment Value « ( " first " , " 1111 " ) ; » assert Environment Value « ( " second " , " 2222 " ) ; }
@Test { » assert Environment Value « ( " » key 1 « " , " local " ) ; » assert Environment Value « ( " enigma " , " meta " ) ; }
@Test { » assert Environment Value « ( " » key 1 « " , " local " ) ; » assert Environment Value « ( " enigma " , " meta meta " ) ; }
@Test { » assert Environment Value « ( " » key 1 « " , " local " ) ; }
@Test { » assert Environment Value « ( " » key 1 « " , " local value " ) ; » assert Environment Value « ( " second " , " local override " ) ; » assert Environment Value « ( " first " , " repeated override " ) ; }
@Test { » assert Environment Value « ( " enigma " , " local override " ) ; }
@Test { » assert Environment Value « ( " » key 1 « " , " local file " ) ; » assert Environment Value « ( " » key 2 « " , " meta file " ) ; }
@Test { » assert Environment Value « ( " enigma " , " meta " ) ; }
@Test { » assert Environment Value « ( " first " , " repeated override " ) ; » assert Environment Value « ( " second " , " repeated " ) ; }
@Test { » assert Environment Value « ( " alpha " , " beta " ) ; » assert Environment Value « ( " first " , " 1111 " ) ; » assert Environment Value « ( " second " , " 1111 " ) ; }
@Test { » assert Environment Value « ( " » key 1 « " , " parent " ) ; » assert Environment Value « ( " » key 2 « " , " local " ) ; }
@Test { » assert That « ( events ) . » has Size « ( 1 ) ; » Custom Event « » custom Event « = events . get ( 0 ) ; » assert That « ( » custom Event « . » get Source « ( ) ) . » is Equal To « ( » get Class « ( ) ) ; » assert That « ( » custom Event « . » get Test Name « ( ) ) . » is Equal To « ( " » custom Test Event Published « " ) ; }
@Test { » test Context Manager « . » before Test Class « ( ) ; verify ( listener , only ( ) ) . » before Test Class « ( » test Context « ) ; }
@Test { » test Context Manager « . » prepare Test Instance « ( » test Instance « ) ; verify ( listener , only ( ) ) . » prepare Test Instance « ( » test Context « ) ; }
@Test { » test Context Manager « . » before Test Method « ( » test Instance « , » traceable Test Method « ) ; verify ( listener , only ( ) ) . » before Test Method « ( » test Context « ) ; }
@Test { Method » standard Test « = » Reflection Utils « . » find Method « ( » Example Test Case « . class , " » standard Test « " ) ; » test Context Manager « . » before Test Method « ( » test Instance « , » standard Test « ) ; verify ( listener , never ( ) ) . » before Test Method « ( » test Context « ) ; }
@Test { Method method = » Reflection Utils « . » find Method « ( » Example Test Case « . class , " » test With Failing Event Listener « " ) ; » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> » test Context Manager « . » before Test Method « ( » test Instance « , method ) ) . » with Message Containing « ( " Boom ! " ) ; verify ( listener , only ( ) ) . » before Test Method « ( » test Context « ) ; }
@Test { » test Context Manager « . » before Test Execution « ( » test Instance « , » traceable Test Method « ) ; verify ( listener , only ( ) ) . » before Test Execution « ( » test Context « ) ; }
@Test { » test Context Manager « . » after Test Execution « ( » test Instance « , » traceable Test Method « , null ) ; verify ( listener , only ( ) ) . » after Test Execution « ( » test Context « ) ; }
@Test { » test Context Manager « . » after Test Method « ( » test Instance « , » traceable Test Method « , null ) ; verify ( listener , only ( ) ) . » after Test Method « ( » test Context « ) ; }
@Test { » test Context Manager « . » after Test Class « ( ) ; verify ( listener , only ( ) ) . » after Test Class « ( » test Context « ) ; }
@Test { » assert Event « ( » Before Test Class Event « . class , listener :: » before Test Class « ) ; }
@Test { » assert Event « ( » Prepare Test Instance Event « . class , listener :: » prepare Test Instance « ) ; }
@Test { » assert Event « ( » Before Test Method Event « . class , listener :: » before Test Method « ) ; }
@Test { » assert Event « ( » Before Test Execution Event « . class , listener :: » before Test Execution « ) ; }
@Test { » assert Event « ( » After Test Execution Event « . class , listener :: » after Test Execution « ) ; }
@Test { » assert Event « ( » After Test Method Event « . class , listener :: » after Test Method « ) ; }
@Test { » assert Event « ( » After Test Class Event « . class , listener :: » after Test Class « ) ; }
@Test { » assert No Event « ( » Before Test Class Event « . class , listener :: » before Test Class « ) ; }
@Test { » assert No Event « ( » Prepare Test Instance Event « . class , listener :: » prepare Test Instance « ) ; }
@Test { » assert No Event « ( » Before Test Method Event « . class , listener :: » before Test Method « ) ; }
@Test { » assert No Event « ( » Before Test Execution Event « . class , listener :: » before Test Execution « ) ; }
@Test { » assert No Event « ( » After Test Execution Event « . class , listener :: » after Test Execution « ) ; }
@Test { » assert No Event « ( » After Test Method Event « . class , listener :: » after Test Method « ) ; }
@Test { » assert No Event « ( » After Test Class Event « . class , listener :: » after Test Class « ) ; }
@Test { » assert That « ( props . » get Property « ( " user . name " ) ) . » is Equal To « ( " Dave " ) ; » assert That « ( props . » get Property « ( " username " ) ) . » is Equal To « ( " Andy " ) ; » assert That « ( props . » get Property « ( " Dave " ) ) . » is Equal To « ( " exists " ) ; » assert That « ( props . » get Property « ( " Andy " ) ) . » is Equal To « ( " exists also " ) ; }
@Test { » assert That « ( » andy 2 « . » get Name « ( ) ) . » is Equal To « ( " Andy " ) ; » assert That « ( andy . » get Name « ( ) ) . » is Equal To « ( " Andy " ) ; }
@Test { » assert That « ( this . foo ) . as ( " The foo field should have been autowired . " ) . » is Equal To « ( " Foo " ) ; }
@Test { » assert That « ( this . » bean Name « . » starts With « ( » get Class « ( ) . » get Name « ( ) ) ) . as ( " The bean name of this test instance should have been set to the fully qualified class name " + " due to » Bean Name Aware « semantics . " ) . » is True « ( ) ; }
@Test { » assert That « ( this . » bean Initialized « ) . as ( " This test bean should have been initialized due to » Initializing Bean « semantics . " ) . » is True « ( ) ; }
@Test { » assert That « ( this . » nonrequired Long « ) . as ( " The » nonrequired Long « property should NOT have been autowired . " ) . » is Null « ( ) ; » assert That « ( this . » application Context « ) . as ( " The application context should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . pet ) . as ( " The pet field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . pet . » get Name « ( ) ) . » is Equal To « ( " Dogbert " ) ; }
@Test { » assert That « ( this . employee ) . as ( " The employee setter method should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . employee . » get Name « ( ) ) . » is Equal To « ( " Dilbert " ) ; }
@Test { » assert That « ( this . foo ) . as ( " The foo field should have been wired via @ Resource . " ) . » is Equal To « ( " Foo " ) ; }
@Test { » assert That « ( this . bar ) . as ( " The bar method should have been wired via @ Resource . " ) . » is Equal To « ( " Bar " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " Dev Foo " ) ; }
@Test { » assert That « ( bar ) . » is Equal To « ( " Prod Bar " ) ; }
@Test { » assert That « ( context ) . as ( " child » Application Context « " ) . » is Not Null « ( ) ; » assert That « ( context . » get Parent « ( ) ) . as ( " parent » Application Context « " ) . » is Not Null « ( ) ; » assert That « ( context . » get Parent « ( ) . » get Parent « ( ) ) . as ( " grandparent » Application Context « " ) . » is Null « ( ) ; }
@Test { super . » load Context Hierarchy « ( ) ; » assert That « ( order ) . » is Equal To « ( " parent + user + order " ) ; }
@Test { » assert Original State « ( ) ; » reverse String Buffers « ( ) ; }
@Test { » assert Dirty Parent Context « ( ) ; » assert Dirty Child Context « ( ) ; }
@Test { » assert Dirty Parent Context « ( ) ; » assert Clean Child Context « ( ) ; }
@Test { » assert That « ( context ) . as ( " child » Application Context « " ) . » is Not Null « ( ) ; » assert That « ( context . » get Parent « ( ) ) . as ( " parent » Application Context « " ) . » is Null « ( ) ; » assert That « ( foo ) . » is Equal To « ( " foo " ) ; }
@Test { » assert That « ( context ) . as ( " child » Application Context « " ) . » is Not Null « ( ) ; » assert That « ( context . » get Parent « ( ) ) . as ( " parent » Application Context « " ) . » is Null « ( ) ; » assert That « ( foo ) . » is Equal To « ( " foo - level - 1 " ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That « ( context ) . as ( " child » Application Context « " ) . » is Not Null « ( ) ; » assert That « ( context . » get Parent « ( ) ) . as ( " parent » Application Context « " ) . » is Not Null « ( ) ; » assert That « ( foo ) . » is Equal To « ( " foo - level - 2 " ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; » assert That « ( baz ) . » is Equal To « ( " baz " ) ; }
@Test { boolean condition = context instanceof » Web Application Context « ; » assert That « ( condition ) . » is False « ( ) ; » assert That « ( context . » get Parent « ( ) ) . » is Null « ( ) ; » assert That « ( ear ) . » is Equal To « ( " ear " ) ; }
@Test { » Application Context « parent = wac . » get Parent « ( ) ; » assert That « ( parent ) . » is Not Null « ( ) ; boolean condition = parent instanceof » Web Application Context « ; » assert That « ( condition ) . » is False « ( ) ; » assert That « ( ear ) . » is Equal To « ( " ear " ) ; » assert That « ( root ) . » is Equal To « ( " root " ) ; }
@Test { » assert Num Users « ( 1 ) ; }
@Test { » assert Num Users « ( 2 ) ; }
@Test { Class < ? > clazz = » Missing Value And Scripts And Statements At Class Level « . class ; » BDD Mockito « . < Class < ? > > given ( » test Context « . » get Test Class « ( ) ) . » will Return « ( clazz ) ; given ( » test Context « . » get Test Method « ( ) ) . » will Return « ( clazz . » get Declared Method « ( " foo " ) ) ; » assert Exception Contains « ( clazz . » get Simple Name « ( ) + " . sql " ) ; }
@Test { Class < ? > clazz = » Missing Value And Scripts And Statements At Method Level « . class ; » BDD Mockito « . < Class < ? > > given ( » test Context « . » get Test Class « ( ) ) . » will Return « ( clazz ) ; given ( » test Context « . » get Test Method « ( ) ) . » will Return « ( clazz . » get Declared Method « ( " foo " ) ) ; » assert Exception Contains « ( clazz . » get Simple Name « ( ) + " . foo " + " . sql " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert Num Users « ( 1 ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert Num Users « ( 2 ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert Users « ( new » Jdbc Template « ( » data Source 1 « ) , " Dilbert " , " Dogbert " ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert Users « ( new » Jdbc Template « ( » data Source 2 « ) , " Dilbert " , " Catbert " ) ; }
@Test { » assert Users « ( new » Jdbc Template « ( » data Source 1 « ) , " Dilbert " , " Dogbert " ) ; }
@Test { » assert Users « ( new » Jdbc Template « ( » data Source 2 « ) , " Dilbert " , " Catbert " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( » Jdbc Test Utils « . » count Rows In Table « ( this . » jdbc Template « , " user " ) ) . as ( " Number of rows in the 'user' table . " ) . » is Equal To « ( 1 ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert Users « ( new » Jdbc Template « ( » data Source 1 « ) , " Dilbert " , " Dogbert " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert Users « ( new » Jdbc Template « ( » data Source 2 « ) , " Dilbert " , " Catbert " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( null , » get Class « ( ) ) ) . » with Message « ( " Local @ » Sql Config « must not be null " ) ; }
@Test { » Sql Config « » sql Config « = » Global Config Class « . class . » get Annotation « ( » Sql Config « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , null ) ) . » with Message « ( " » test Class « must not be null " ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Empty Comment Prefix « " ) ; » Sql Config « » sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , » get Class « ( ) ) ) . » with Message « ( " @ » Sql Config « ( » comment Prefix « ) must contain text " ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Empty Comment Prefixes « " ) ; » Sql Config « » sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , » get Class « ( ) ) ) . » with Message « ( " @ » Sql Config « ( » comment Prefixes « ) must not contain empty prefixes " ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Duplicated Comment Prefixes « " ) ; » Sql Config « » sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , » get Class « ( ) ) ) . » with Message « ( " You may declare the 'commentPrefix' or 'commentPrefixes' attribute in @ » Sql Config « but not both " ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Defaults « " ) ; » Sql Config « » local Sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » Merged Sql Config « cfg = new » Merged Sql Config « ( » local Sql Config « , » get Class « ( ) ) ; » assert Defaults « ( cfg ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Custom Comment Prefixes « " ) ; » Sql Config « » local Sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » Merged Sql Config « cfg = new » Merged Sql Config « ( » local Sql Config « , » get Class « ( ) ) ; » assert That « ( cfg ) . » is Not Null « ( ) ; » assert That « ( cfg . » get Comment Prefixes « ( ) ) . as ( " » comment Prefixes « " ) . » is Equal To « ( array ( " ` " ) ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Multiple Comment Prefixes « " ) ; » Sql Config « » local Sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » Merged Sql Config « cfg = new » Merged Sql Config « ( » local Sql Config « , » get Class « ( ) ) ; » assert That « ( cfg ) . » is Not Null « ( ) ; » assert That « ( cfg . » get Comment Prefixes « ( ) ) . as ( " » comment Prefixes « " ) . » is Equal To « ( array ( " ` " , " -- " ) ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Continue On Error « " ) ; » Sql Config « » local Sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » Merged Sql Config « cfg = new » Merged Sql Config « ( » local Sql Config « , » get Class « ( ) ) ; » assert That « ( cfg ) . » is Not Null « ( ) ; » assert That « ( cfg . » get Error Mode « ( ) ) . as ( " » error Mode « " ) . » is Equal To « ( » CONTINUE _ ON _ ERROR « ) ; }
@Test { Method method = » get Class « ( ) . » get Method « ( " » local Config Method With Ignore Failed Drops « " ) ; » Sql Config « » local Sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » Merged Sql Config « cfg = new » Merged Sql Config « ( » local Sql Config « , » get Class « ( ) ) ; » assert That « ( cfg ) . » is Not Null « ( ) ; » assert That « ( cfg . » get Error Mode « ( ) ) . as ( " » error Mode « " ) . » is Equal To « ( » IGNORE _ FAILED _ DROPS « ) ; }
@Test { » Sql Config « » sql Config « = » Global Config With With Empty Comment Prefix Class « . class . » get Annotation « ( » Sql Config « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , » get Class « ( ) ) ) . » with Message « ( " @ » Sql Config « ( » comment Prefix « ) must contain text " ) ; }
@Test { » Sql Config « » sql Config « = » Global Config With With Empty Comment Prefixes Class « . class . » get Annotation « ( » Sql Config « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , » get Class « ( ) ) ) . » with Message « ( " @ » Sql Config « ( » comment Prefixes « ) must not contain empty prefixes " ) ; }
@Test { » Sql Config « » sql Config « = » Global Config With With Duplicated Comment Prefixes Class « . class . » get Annotation « ( » Sql Config « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Merged Sql Config « ( » sql Config « , » get Class « ( ) ) ) . » with Message « ( " You may declare the 'commentPrefix' or 'commentPrefixes' attribute in @ » Sql Config « but not both " ) ; }
@Test { Method method = » Global Config With Defaults Class « . class . » get Method « ( " » global Config Method « " ) ; » Sql Config « » local Sql Config « = method . » get Annotation « ( Sql . class ) . config ( ) ; » Merged Sql Config « cfg = new » Merged Sql Config « ( » local Sql Config « , » Global Config With Defaults Class « . class ) ; » assert Defaults « ( cfg ) ; }
@Test { » assert Users « ( " Catbert " ) ; }
@Test { » assert Users « ( " Catbert " , " Dogbert " ) ; }
@Test { » assert Users « ( " Dilbert " , " Dogbert " , " Catbert " ) ; }
@Test { » assert That « ( » application Context « ) . as ( " » Application Context « should have been injected by Spring " ) . » is Not Null « ( ) ; » assert That « ( » application Context « . » get Bean « ( " dilbert " , Person . class ) ) . » is Equal To « ( this . dilbert ) ; }
@Test { » assert That « ( this . dilbert ) . as ( " Dilbert should have been @ Autowired by Spring " ) . » is Not Null « ( ) ; » assert That « ( this . dilbert . » get Name « ( ) ) . as ( " Person » ' s « name " ) . » is Equal To « ( " Dilbert " ) ; » assert That « ( this . dog ) . as ( " Dogbert should have been @ Autowired by Spring " ) . » is Not Null « ( ) ; » assert That « ( this . dog . » get Name « ( ) ) . as ( " Dog » ' s « name " ) . » is Equal To « ( " Dogbert " ) ; }
@Test { » assert That « ( this . enigma ) . as ( " Enigma should have been injected via @ Value by Spring " ) . » is Not Null « ( ) ; » assert That « ( this . enigma ) . as ( " enigma " ) . » is Equal To « ( 42 ) ; }
@Test { » assert That « ( dilbert ) . as ( " Person should have been @ Autowired by Spring " ) . » is Not Null « ( ) ; » assert That « ( dilbert . » get Name « ( ) ) . as ( " Person » ' s « name " ) . » is Equal To « ( " Dilbert " ) ; » assert That « ( people ) . as ( " Number of Person objects in context " ) . » has Size « ( 2 ) ; }
@Test { » Condition Evaluation Result « result = condition . » evaluate Execution Condition « ( » build Extension Context « ( " » missing Disabled If « " ) ) ; » assert That « ( result . » is Disabled « ( ) ) . » is False « ( ) ; » assert That « ( result . » get Reason « ( ) . get ( ) ) . » ends With « ( " » missing Disabled If « ( ) is enabled since @ » Disabled If « is not present " ) ; }
@Test { » assert Expression Is Blank « ( " » empty Expression « " ) ; » assert Expression Is Blank « ( " » blank Expression « " ) ; }
@Test { String » method Name « = " » non Boolean Or String Expression « " ; Method method = » Reflection Utils « . » find Method « ( » get Class « ( ) , » method Name « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> condition . » evaluate Execution Condition « ( » build Extension Context « ( » method Name « ) ) ) . » with Message Containing « ( " @ » Disabled If « ( \" # { 6 * 7 } \" ) on " + method + " must evaluate to a String or a Boolean , not java . lang . Integer " ) ; }
@Test { String » method Name « = " » string Expression That Is Neither True Nor False « " ; Method method = » Reflection Utils « . » find Method « ( » get Class « ( ) , » method Name « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> condition . » evaluate Execution Condition « ( » build Extension Context « ( » method Name « ) ) ) . » with Message Containing « ( " @ » Disabled If « ( \" # { » ' enigma « ' } \" ) on " + method + " must evaluate to \" true \" or \" false \" , not \" enigma \" " ) ; }
@Test { » Condition Evaluation Result « result = condition . » evaluate Execution Condition « ( » build Extension Context « ( " » custom Reason « " ) ) ; » assert That « ( result . » is Disabled « ( ) ) . » is True « ( ) ; » assert That « ( result . » get Reason « ( ) ) . contains ( " Because ... 42 ! " ) ; }
@Test { » Condition Evaluation Result « result = condition . » evaluate Execution Condition « ( » build Extension Context « ( " » default Reason « " ) ) ; » assert That « ( result . » is Disabled « ( ) ) . » is True « ( ) ; » assert That « ( result . » get Reason « ( ) . get ( ) ) . » ends With « ( " » default Reason « ( ) is disabled because @ » Disabled If « ( \" # { 1 + 1 eq 2 } \" ) evaluated to true " ) ; }
@Test { » Condition Evaluation Result « result = condition . » evaluate Execution Condition « ( » build Extension Context « ( " » never Disabled With Default Reason « " ) ) ; » assert That « ( result . » is Disabled « ( ) ) . » is False « ( ) ; » assert That « ( result . » get Reason « ( ) . get ( ) ) . » ends With « ( " » never Disabled With Default Reason « ( ) is enabled because @ » Disabled If « ( \" false \" ) did not evaluate to true " ) ; }
@Test { fail ( " This test must be disabled " ) ; }
@Test { String os = System . » get Property « ( " os . name " ) . » to Lower Case « ( ) ; » assert That « ( os ) . as ( " This test must be enabled on Mac OS " ) . contains ( " mac " ) ; » assert That « ( os ) . as ( " This test must be disabled on Windows " ) . » does Not Contain « ( " win " ) ; }
@Test { fail ( " This test must be disabled due to class - level condition " ) ; }
@Test { String os = System . » get Property « ( " os . name " ) . » to Lower Case « ( ) ; » assert That « ( os ) . as ( " This test must be disabled on Mac OS " ) . » does Not Contain « ( " mac " ) ; }
@Test { » assert That « ( this . » test Info « ) . as ( " » Test Info « should have been injected by » J Unit « " ) . » is Not Null « ( ) ; }
@Test { » assert That « ( this . character ) . as ( " Character should have been @ Autowired by Spring " ) . » is Not Null « ( ) ; » assert That « ( this . character ) . as ( " character » ' s « name " ) . extracting ( Character :: » get Name « ) . » is Equal To « ( » get Expected Name « ( ) ) ; » assert That « ( this . characters ) . as ( " Number of characters in context " ) . » has Size « ( » get Expected Num Characters « ( ) ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " foo " ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That « ( » count Rows In Table « ( " user " ) ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " foo " ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; » assert That « ( answer ) . » is Equal To « ( 42 ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; Thread . sleep ( 100 ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; Thread . sleep ( 100 ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / person / 42 " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Expect « ( » json Path « ( " $ . name " , is ( " Dilbert " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / person / 99 " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Expect « ( » json Path « ( " $ . name " , is ( " Wally " ) ) ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert That « ( » add Person « ( » jdbc Template « , JANE ) ) . as ( " Adding jane " ) . » is Equal To « ( 1 ) ; » assert That « ( » count Rows In Person Table « ( » jdbc Template « ) ) . as ( " Verifying the number of rows in the person table within » transactional Method 1 « ( ) . " ) . » is Equal To « ( 2 ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert That « ( » add Person « ( » jdbc Template « , JANE ) ) . as ( " Adding jane " ) . » is Equal To « ( 1 ) ; » assert That « ( » add Person « ( » jdbc Template « , SUE ) ) . as ( " Adding sue " ) . » is Equal To « ( 1 ) ; » assert That « ( » count Rows In Person Table « ( » jdbc Template « ) ) . as ( " Verifying the number of rows in the person table within » transactional Method 2 « ( ) . " ) . » is Equal To « ( 3 ) ; }
@Test { fail ( " The body of a disabled test should never be executed ! " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . » bean Name « . » starts With « ( » get Class « ( ) . » get Name « ( ) ) ) . as ( " The bean name of this test instance should have been set to the fully qualified class name " + " due to » Bean Name Aware « semantics . " ) . » is True « ( ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( super . » application Context « ) . as ( " The application context should have been set due to » Application Context Aware « semantics . " ) . » is Not Null « ( ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . » bean Initialized « ) . as ( " This test bean should have been initialized due to » Initializing Bean « semantics . " ) . » is True « ( ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . » nonrequired Long « ) . as ( " The » nonrequired Long « property should NOT have been autowired . " ) . » is Null « ( ) ; » assert That « ( this . pet ) . as ( " The pet field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . pet . » get Name « ( ) ) . » is Equal To « ( " Fido " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . employee ) . as ( " The employee setter method should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . foo ) . as ( " The foo field should have been wired via @ Resource . " ) . » is Equal To « ( " Foo " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . bar ) . as ( " The bar method should have been wired via @ Resource . " ) . » is Equal To « ( " Bar " ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert That « ( » add Person « ( JANE ) ) . as ( " Adding jane " ) . » is Equal To « ( 1 ) ; » assert That « ( » add Person « ( SUE ) ) . as ( " Adding sue " ) . » is Equal To « ( 1 ) ; » assert That « ( » count Rows In Person Table « ( ) ) . as ( " Verifying the number of rows in the person table in » modify Test Data Within Transaction « ( ) . " ) . » is Equal To « ( 4 ) ; }
@Test { » assert That « ( this . cat ) . as ( " The cat field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . cat . » get Name « ( ) ) . » is Equal To « ( " Garfield " ) ; » assert That « ( this . » test String « ) . as ( " The » test String « field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » test String « ) . » is Equal To « ( " Test String " ) ; }
@Test { » num Tests Executed « ++ ; fail ( " The body of a disabled test should never be executed ! " ) ; }
@Test { » num Tests Executed « ++ ; }
@Test { » num Tests Executed « ++ ; fail ( " The body of an ignored test should never be executed ! " ) ; }
@Test { » invocation Count « . » increment And Get « ( ) ; » assert That « ( this . pet ) . as ( " The pet field should have been autowired . " ) . » is Not Null « ( ) ; Employee employee = this . » application Context « . » get Bean « ( this . » employee Bean Name « , Employee . class ) ; » assert That « ( employee . » get Name « ( ) ) . as ( " Name of the employee configured as bean [ " + this . » employee Bean Name « + " ] . " ) . » is Equal To « ( this . » employee Name « ) ; }
@Test { » invocation Count « . set ( 0 ) ; » run Tests And Assert Counters « ( » get Runner Class « ( ) , this . » test Class « , » expected Started Count « , » expected Failure Count « , » expected Finished Count « , 0 , 0 ) ; » assert That « ( » invocation Count « . get ( ) ) . as ( " invocations for [ " + » test Class « + " ] : " ) . » is Equal To « ( » expected Invocation Count « ) ; }
@Test { » increment Invocation Count « ( ) ; }
@Test { » increment Invocation Count « ( ) ; Thread . sleep ( 15 ) ; }
@Test { » increment Invocation Count « ( ) ; Thread . sleep ( 25 ) ; }
@Test { » increment Invocation Count « ( ) ; Thread . sleep ( 11 ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert That « ( » add Person « ( » jdbc Template « , JANE ) ) . as ( " Adding jane " ) . » is Equal To « ( 1 ) ; » assert That « ( » add Person « ( » jdbc Template « , SUE ) ) . as ( " Adding sue " ) . » is Equal To « ( 1 ) ; » assert That « ( » count Rows In Person Table « ( » jdbc Template « ) ) . as ( " Verifying the number of rows in the person table within a transaction . " ) . » is Equal To « ( 3 ) ; }
@Test { » assert That « ( name . » get Method Name « ( ) ) . » is Equal To « ( " » test A « " ) ; }
@Test { » assert That « ( name . » get Method Name « ( ) ) . » is Equal To « ( " » test B « " ) ; }
@Test { » Spring J Unit 4 Class Runner « runner = new » Spring J Unit 4 Class Runner « ( » get Class « ( ) ) { @ Override protected » Test Context Manager « » create Test Context Manager « ( Class < ? > clazz ) { return new » Test Context Manager « ( clazz ) { @ Override public void » prepare Test Instance « ( Object » test Instance « ) { throw new » Runtime Exception « ( " This » Runtime Exception « should be caught and wrapped in an Exception . " ) ; } } ; } } ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( runner :: » create Test « ) ; }
@Test { » Spring J Unit 4 Class Runner « runner = new » Spring J Unit 4 Class Runner « ( » get Class « ( ) ) ; long timeout = runner . » get Spring Timeout « ( new » Framework Method « ( » get Class « ( ) . » get Declared Method « ( " » spring Timeout With Meta Annotation « " ) ) ) ; » assert That « ( timeout ) . » is Equal To « ( 10 ) ; }
@Test { » Spring J Unit 4 Class Runner « runner = new » Spring J Unit 4 Class Runner « ( » get Class « ( ) ) ; long timeout = runner . » get Spring Timeout « ( new » Framework Method « ( » get Class « ( ) . » get Declared Method « ( " » spring Timeout With Meta Annotation And Override « " ) ) ) ; » assert That « ( timeout ) . » is Equal To « ( 42 ) ; }
@Test { fail ( " The body of an ignored test should never be executed ! " ) ; }
@Test { » assert That « ( true ) . » is True « ( ) ; }
@Test ( expected = » Index Out Of Bounds Exception « . class ) { new » Array List « < > ( ) . get ( 1 ) ; }
@Test { » assume True « ( false ) ; fail ( " A failed assumption should preclude imminent failure ! " ) ; }
@Test { » assert That « ( this . » before Counter « ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » Standard J Unit 4 Features Tests « . » static Before Counter « > 0 ) . » is True « ( ) ; }
@Test { » run Tests And Assert Counters « ( » get Runner Class « ( ) , » get Test Case « ( ) , 7 , 5 , 7 , 0 , 0 ) ; }
@Test { Thread . sleep ( 200 ) ; }
@Test { int » expected Started Count « = this . clazz . » get Simple Name « ( ) . » starts With « ( " » Always Failing Before Test Class « " ) ? 0 : 1 ; int » expected Finished Count « = this . clazz . » get Simple Name « ( ) . » starts With « ( " » Always Failing Before Test Class « " ) ? 0 : 1 ; » run Tests And Assert Counters « ( » get Runner Class « ( ) , this . clazz , » expected Started Count « , 1 , » expected Finished Count « , 0 , 0 ) ; }
@Test { » run Tests And Assert Counters « ( » Spring Runner « . class , » Expected Exception Spring Runner Test Case « . class , 1 , 0 , 1 , 0 , 0 ) ; }
@Test { » assert That « ( this . » bean Name « . » starts With « ( » get Class « ( ) . » get Name « ( ) ) ) . as ( " The bean name of this test instance should have been set due to » Bean Name Aware « semantics . " ) . » is True « ( ) ; }
@Test { » assert That « ( this . » application Context « ) . as ( " The application context should have been set due to » Application Context Aware « semantics . " ) . » is Not Null « ( ) ; }
@Test { » assert That « ( this . employee ) . as ( " The employee setter method should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That « ( this . » literal Field Value « ) . as ( " Literal @ Value field should have been autowired " ) . » is Not Null « ( ) ; » assert That « ( this . » spel Field Value « ) . as ( " » Sp EL « @ Value field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » literal Field Value « ) . » is Equal To « ( " enigma " ) ; » assert That « ( this . » spel Field Value « ) . » is Equal To « ( Boolean . TRUE ) ; }
@Test { » assert That « ( this . » literal Parameter Value « ) . as ( " Literal @ Value method parameter should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » spel Parameter Value « ) . as ( " » Sp EL « @ Value method parameter should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . » literal Parameter Value « ) . » is Equal To « ( " enigma " ) ; » assert That « ( this . » spel Parameter Value « ) . » is Equal To « ( Boolean . TRUE ) ; }
@Test { » assert That « ( this . foo ) . as ( " The foo field should have been injected via @ Resource . " ) . » is Equal To « ( " Foo " ) ; }
@Test { » assert That « ( strings . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( foo ) . » is Equal To « ( " foo " ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " foo " ) ; » assert That « ( bar ) . » is Equal To « ( " foo " ) ; » assert That « ( baz ) . » is Equal To « ( " dev profile config " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( » PROFILE _ GLOBAL « ) ; » assert That « ( bar ) . » is Equal To « ( » PROFILE _ GLOBAL « ) ; » assert That « ( baz ) . » is Equal To « ( » PROFILE _ TWO « ) ; }
@Test { » assert That « ( enigma ) . » is Equal To « ( " foo " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " foo " ) ; » assert That « ( bar ) . » is Equal To « ( " foo " ) ; » assert That « ( baz ) . » is Equal To « ( " global config " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " foo " ) ; » assert That « ( bar ) . » is Null « ( ) ; » assert That « ( baz ) . » is Equal To « ( " dev profile config " ) ; }
@Test { » assert That « ( this . employee ) . as ( " The employee should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . employee . » get Name « ( ) ) . as ( " The employee bean should have been overridden . " ) . » is Equal To « ( " Yoda " ) ; }
@Test { » assert That « ( this . employee ) . as ( " The employee field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That « ( this . pet ) . as ( " The pet should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . pet . » get Name « ( ) ) . » is Equal To « ( " Fido " ) ; }
@Test { » assert That « ( this . employee ) . as ( " The employee should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( this . employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " Resolver Foo " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " Local Dev Foo " ) ; }
@Test { » assert That « ( this . foo ) . » is Equal To « ( " Production Foo " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " Production Foo " ) ; }
@Test { final int FAILED = 0 ; final int ABORTED = 0 ; final int IGNORED = » count Annotated Methods « ( Ignore . class ) ; final int TESTS = » count Annotated Methods « ( Test . class ) - IGNORED ; » run Tests And Assert Counters « ( new » Parallel Computer « ( true , true ) , TESTS , FAILED , TESTS , IGNORED , ABORTED , this . » test Classes « ) ; }
@Test { » assert That « ( » foo From Xml « ) . » is Equal To « ( " XML " ) ; » assert That « ( » foo From Java « ) . » is Equal To « ( " Java " ) ; » assert That « ( enigma ) . » is Equal To « ( " enigma from XML " ) ; }
@Test { » assert That « ( foo ) . as ( " @ Autowired field in enclosing instance should be null . " ) . » is Null « ( ) ; » assert That « ( bar ) . » is Equal To « ( " bar " ) ; }
@Test { Person sam = » person Service « . » find By Name « ( SAM ) ; » assert That « ( sam ) . as ( " Should be able to find Sam " ) . » is Not Null « ( ) ; » Drivers License « » drivers License « = sam . » get Drivers License « ( ) ; » assert That « ( » drivers License « ) . as ( " Sam 's driver' s license should not be null " ) . » is Not Null « ( ) ; » assert That « ( » drivers License « . » get Number « ( ) ) . as ( " Verifying Sam 's driver' s license number " ) . » is Equal To « ( Long . » value Of « ( 1234 ) ) ; }
@Test { Person sam = » person Service « . » find By Name « ( SAM ) ; sam . » set Name « ( " Vlad " ) ; Session session = » session Factory « . » get Current Session « ( ) ; session . flush ( ) ; session . refresh ( sam ) ; » assert That « ( sam . » get Name « ( ) ) . » is Equal To « ( " Sam " ) ; }
@Test { » assert That Exception Of Type « ( » Constraint Violation Exception « . class ) . » is Thrown By « ( ( ) -> » person Service « . save ( new Person ( JUERGEN ) ) ) ; }
@Test { » update Sam With Null Drivers License « ( ) ; }
@Test { » update Sam With Null Drivers License « ( ) ; » assert That Exception Of Type « ( » Constraint Violation Exception « . class ) . » is Thrown By « ( ( ) -> { try { » session Factory « . » get Current Session « ( ) . flush ( ) ; } catch ( » Persistence Exception « ex ) { throw ex . » get Cause « ( ) ; } } ) ; }
@Test { » assert That « ( pet ) . » is Not Null « ( ) ; » assert That « ( pet . » get Name « ( ) ) . » is Equal To « ( " Fido " ) ; }
@Test { » assert That « ( employee ) . as ( " employee bean should not be created for the default profile " ) . » is Null « ( ) ; }
@Test { » assert That « ( employee ) . as ( " employee bean should be loaded for the 'dev' profile " ) . » is Not Null « ( ) ; » assert That « ( employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That « ( Arrays . » as List « ( » application Context « . » get Environment « ( ) . » get Active Profiles « ( ) ) . contains ( » get Class « ( ) . » get Simple Name « ( ) . » to Lower Case « ( ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( » Test Transaction « . » is Active « ( ) ) . » is False « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » Test Transaction « :: » flag For Rollback « ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » Test Transaction « :: » flag For Commit « ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » Test Transaction « :: » is Flagged For Rollback « ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » Test Transaction « :: start ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( » Test Transaction « :: end ) ; }
@Test { » assert That « ( bar ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That « ( baz ) . » is Equal To « ( " baz " ) ; }
@Test { logger . info ( " » test 1 « ( ) " ) ; » assert That « ( » lifecycle Bean « ) . » is Not Null « ( ) ; }
@Test { logger . info ( " » test 2 « ( ) " ) ; » assert That « ( » lifecycle Bean « ) . » is Not Null « ( ) ; }
@Test { » assert That « ( » data Source « ) . » is Not Null « ( ) ; }
@Test { » assert That « ( employee ) . as ( " The employee should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert Add Person « ( JANE ) ; » assert Add Person « ( SUE ) ; » assert Num Rows In Person Table « ( 3 , " in » modify Test Data Within Transaction « ( ) " ) ; }
@Test { » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 0 ) ; » assert That « ( » tx Manager « . inflight ) . » is Equal To « ( 0 ) ; » assert That « ( » tx Manager « . commits ) . » is Equal To « ( 0 ) ; » assert That « ( » tx Manager « . rollbacks ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( » tx Manager 1 « . begun ) . » is Equal To « ( 1 ) ; » assert That « ( » tx Manager 1 « . inflight ) . » is Equal To « ( 1 ) ; » assert That « ( » tx Manager 1 « . commits ) . » is Equal To « ( 0 ) ; » assert That « ( » tx Manager 1 « . rollbacks ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( » tx Manager « . begun ) . » is Equal To « ( 1 ) ; » assert That « ( » tx Manager « . inflight ) . » is Equal To « ( 1 ) ; » assert That « ( » tx Manager « . commits ) . » is Equal To « ( 0 ) ; » assert That « ( » tx Manager « . rollbacks ) . » is Equal To « ( 0 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Spring Fail On Timeout « ( null , 1 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Spring Fail On Timeout « ( statement , - 1 ) ) ; }
@Test { » will Throw « ( new Boom ( ) ) . given ( statement ) . evaluate ( ) ; » assert That Exception Of Type « ( Boom . class ) . » is Thrown By « ( ( ) -> new » Spring Fail On Timeout « ( statement , 1 ) . evaluate ( ) ) ; }
@Test { » will Answer « ( ( Answer < Void > ) invocation -> { » Time Unit « . MILLISECONDS . sleep ( 50 ) ; return null ; } ) . given ( statement ) . evaluate ( ) ; » assert That Exception Of Type « ( » Timeout Exception « . class ) . » is Thrown By « ( ( ) -> new » Spring Fail On Timeout « ( statement , 1 ) . evaluate ( ) ) ; }
@Test { » will Answer « ( ( Answer < Void > ) invocation -> null ) . given ( statement ) . evaluate ( ) ; new » Spring Fail On Timeout « ( statement , 100 ) . evaluate ( ) ; }
@Test { » Context Configuration Attributes « » config Attributes « = new » Context Configuration Attributes « ( » Xml Test Case « . class , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , true , null , true , » Context Loader « . class ) ; loader . » process Context Configuration « ( » config Attributes « ) ; » assert That « ( » config Attributes « . » get Locations « ( ) . length ) . » is Equal To « ( 1 ) ; » assert Empty « ( » config Attributes « . » get Classes « ( ) ) ; }
@Test { » Context Configuration Attributes « » config Attributes « = new » Context Configuration Attributes « ( » Config Class Test Case « . class , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , true , null , true , » Context Loader « . class ) ; loader . » process Context Configuration « ( » config Attributes « ) ; » assert That « ( » config Attributes « . » get Classes « ( ) . length ) . » is Equal To « ( 1 ) ; » assert Empty « ( » config Attributes « . » get Locations « ( ) ) ; }
@Test { » Context Configuration Attributes « » config Attributes « = new » Context Configuration Attributes « ( » Improper Duplicate Default Xml And Config Class Test Case « . class , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , true , null , true , » Context Loader « . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> loader . » process Context Configuration « ( » config Attributes « ) ) . » with Message Containing « ( " both default locations AND default configuration classes were detected " ) ; }
@Test { String [ ] locations = new String [ ] { " classpath : / foo . xml " } ; » Context Configuration Attributes « » config Attributes « = new » Context Configuration Attributes « ( » get Class « ( ) , locations , » EMPTY _ CLASS _ ARRAY « , true , null , true , » Context Loader « . class ) ; loader . » process Context Configuration « ( » config Attributes « ) ; » assert That « ( » config Attributes « . » get Locations « ( ) ) . » is Equal To « ( locations ) ; » assert Empty « ( » config Attributes « . » get Classes « ( ) ) ; }
@Test { Class < ? > [ ] classes = new Class < ? > [ ] { » get Class « ( ) } ; » Context Configuration Attributes « » config Attributes « = new » Context Configuration Attributes « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , classes , true , null , true , » Context Loader « . class ) ; loader . » process Context Configuration « ( » config Attributes « ) ; » assert That « ( » config Attributes « . » get Classes « ( ) ) . » is Equal To « ( classes ) ; » assert Empty « ( » config Attributes « . » get Locations « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> loader . » load Context « ( ( » Merged Context Configuration « ) null ) ) ; }
@Test { » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> loader . » load Context « ( » merged Config « ) ) . » with Message Starting With « ( " Neither " ) . » with Message Containing « ( " was able to load an » Application Context « from " ) ; }
@Test { » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » get Class « ( ) , new String [ ] { " test . xml " } , new Class < ? > [ ] { » get Class « ( ) } , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> loader . » load Context « ( » merged Config « ) ) . » with Message Starting With « ( " Neither " ) . » with Message Containing « ( " declare either 'locations' or 'classes' but not both . " ) ; }
@Test { » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » Xml Test Case « . class , new String [ ] { " classpath : / org / springframework / test / context / support / » Delegating Smart Context Loader Tests $ Xml Test Case « - context . xml " } , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert Application Context Loads And Contains Foo String « ( » merged Config « ) ; }
@Test { » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » Config Class Test Case « . class , » EMPTY _ STRING _ ARRAY « , new Class < ? > [ ] { » Config Class Test Case « . Config . class } , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert Application Context Loads And Contains Foo String « ( » merged Config « ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> loader . » process Locations « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « ) ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> loader . » load Context « ( » EMPTY _ STRING _ ARRAY « ) ) ; }
@Test { Class < ? > clazz = » get Class « ( ) ; » BDD Mockito « . < Class < ? > > given ( » test Context « . » get Test Class « ( ) ) . » will Return « ( clazz ) ; » before Listener « . » before Test Class « ( » test Context « ) ; » after Listener « . » before Test Class « ( » test Context « ) ; » after Listener « . » after Test Class « ( » test Context « ) ; » before Listener « . » after Test Class « ( » test Context « ) ; verify ( » test Context « , times ( 0 ) ) . » mark Application Context Dirty « ( any ( » Hierarchy Mode « . class ) ) ; }
@Test { » assert Not Autowirable « ( » Not Autowirable Test Case « . class ) ; }
@Test { » assert Autowirable « ( » Autowired Annotation Test Case « . class ) ; }
@Test { » assert Autowirable « ( » Test Constructor Annotation Test Case « . class ) ; }
@Test { » set Global Flag « ( ) ; » assert Autowirable « ( » Automatically Autowired Test Case « . class ) ; }
@Test { » set Global Flag « ( ) ; » assert Not Autowirable « ( » Test Constructor Annotation Overrides Global Flag Test Case « . class ) ; }
@Test { » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » get Class « ( ) , new String [ ] { " config . xml " } , » EMPTY _ CLASS _ ARRAY « , » EMPTY _ STRING _ ARRAY « , » context Loader « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » context Loader « . » load Context « ( » merged Config « ) ) . » with Message Containing « ( " does not support resource locations " ) ; }
@Test { Class < ? > [ ] » config Classes « = » context Loader « . » detect Default Configuration Classes « ( » Multiple Static Configuration Classes Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « . length ) . as ( " multiple annotated static classes should be considered . " ) . » is Equal To « ( 2 ) ; }
@Test { Class < ? > [ ] » config Classes « = » context Loader « . » detect Default Configuration Classes « ( » Plain Vanilla Foo Config Inner Class Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « . length ) . as ( " non - annotated static » Foo Config « should NOT be considered . " ) . » is Equal To « ( 0 ) ; }
@Test { Class < ? > [ ] » config Classes « = » context Loader « . » detect Default Configuration Classes « ( » Final Config Inner Class Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « . length ) . as ( " final annotated static Config should NOT be considered . " ) . » is Equal To « ( 0 ) ; }
@Test { Class < ? > [ ] » config Classes « = » context Loader « . » detect Default Configuration Classes « ( » Private Config Inner Class Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « . length ) . as ( " private annotated inner classes should NOT be considered . " ) . » is Equal To « ( 0 ) ; }
@Test { Class < ? > [ ] » config Classes « = » context Loader « . » detect Default Configuration Classes « ( » Non Static Config Inner Classes Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « . length ) . as ( " non - static annotated inner classes should NOT be considered . " ) . » is Equal To « ( 0 ) ; }
@Test { Class < ? > » test Class « = » Single Initializer « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , initializers ( » Foo Initializer « . class ) , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Initializers Foo « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , classes ( » Foo Config « . class ) , initializers ( » Foo Initializer « . class ) , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Initializers Bar « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , classes ( » Foo Config « . class , » Bar Config « . class ) , initializers ( » Foo Initializer « . class , » Bar Initializer « . class ) , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Overridden Initializers Bar « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , classes ( » Foo Config « . class , » Bar Config « . class ) , initializers ( » Bar Initializer « . class ) , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Overridden Initializers And Classes Bar « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , classes ( » Bar Config « . class ) , initializers ( » Bar Initializer « . class ) , » Delegating Smart Context Loader « . class ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » resolve Context Configuration Attributes « ( » Conflicting Locations « . class ) ) . » with Message Starting With « ( " Different @ » Alias For « mirror values " ) . » with Message Containing « ( » Conflicting Locations « . class . » get Name « ( ) ) . » with Message Containing « ( " attribute 'locations' and its alias 'value' " ) . » with Message Containing « ( " values of [ { y } ] and [ { x } ] " ) ; }
@Test { Class < » Bare Annotations « > » test Class « = » Bare Annotations « . class ; List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » test Class « ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » assert Attributes « ( » attributes List « . get ( 0 ) , » test Class « , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » Context Loader « . class , true ) ; }
@Test { List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » Locations Foo « . class ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » assert Locations Foo Attributes « ( » attributes List « . get ( 0 ) ) ; }
@Test { Class < » Meta Locations Foo « > » test Class « = » Meta Locations Foo « . class ; List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » test Class « ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » assert Attributes « ( » attributes List « . get ( 0 ) , » test Class « , new String [ ] { " / foo . xml " } , » EMPTY _ CLASS _ ARRAY « , » Context Loader « . class , true ) ; }
@Test { Class < » Meta Locations Foo With Overrides « > » test Class « = » Meta Locations Foo With Overrides « . class ; List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » test Class « ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » assert Attributes « ( » attributes List « . get ( 0 ) , » test Class « , new String [ ] { " / foo . xml " } , » EMPTY _ CLASS _ ARRAY « , » Context Loader « . class , true ) ; }
@Test { List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » Classes Foo « . class ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » assert Classes Foo Attributes « ( » attributes List « . get ( 0 ) ) ; }
@Test { List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » Locations Bar « . class ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 2 ) ; » assert Locations Bar Attributes « ( » attributes List « . get ( 0 ) ) ; » assert Locations Foo Attributes « ( » attributes List « . get ( 1 ) ) ; }
@Test { List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » Classes Bar « . class ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 2 ) ; » assert Classes Bar Attributes « ( » attributes List « . get ( 0 ) ) ; » assert Classes Foo Attributes « ( » attributes List « . get ( 1 ) ) ; }
@Test { List < » Context Configuration Attributes « > » attributes List « = » resolve Context Configuration Attributes « ( » Locations And Classes « . class ) ; » assert That « ( » attributes List « ) . » is Not Null « ( ) ; » assert That « ( » attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Generic Properties Context Loader « loader = new » Generic Properties Context Loader « ( ) ; » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , new Class < ? > [ ] { » get Class « ( ) } , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> loader . » load Context « ( » merged Config « ) ) . » with Message Containing « ( " does not support annotated classes " ) ; }
@Test { » Generic Xml Context Loader « loader = new » Generic Xml Context Loader « ( ) ; » Merged Context Configuration « » merged Config « = new » Merged Context Configuration « ( » get Class « ( ) , » EMPTY _ STRING _ ARRAY « , new Class < ? > [ ] { » get Class « ( ) } , » EMPTY _ STRING _ ARRAY « , loader ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> loader . » load Context « ( » merged Config « ) ) . » with Message Containing « ( " does not support annotated classes " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » resolve Context Hierarchy Attributes « ( » Single Test Class With Context Configuration And Context Hierarchy « . class ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » resolve Context Hierarchy Attributes « ( » Single Test Class With Context Configuration And Context Hierarchy On Single Meta Annotation « . class ) ) ; }
@Test { List < List < » Context Configuration Attributes « > > » hierarchy Attributes « = » resolve Context Hierarchy Attributes « ( » Bare Annotations « . class ) ; » assert That « ( » hierarchy Attributes « . size ( ) ) . » is Equal To « ( 1 ) ; List < » Context Configuration Attributes « > » config Attributes List « = » hierarchy Attributes « . get ( 0 ) ; » assert That « ( » config Attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » debug Config Attributes « ( » config Attributes List « ) ; }
@Test { List < List < » Context Configuration Attributes « > > » hierarchy Attributes « = » resolve Context Hierarchy Attributes « ( » Single Test Class With Single Level Context Hierarchy « . class ) ; » assert That « ( » hierarchy Attributes « . size ( ) ) . » is Equal To « ( 1 ) ; List < » Context Configuration Attributes « > » config Attributes List « = » hierarchy Attributes « . get ( 0 ) ; » assert That « ( » config Attributes List « . size ( ) ) . » is Equal To « ( 1 ) ; » debug Config Attributes « ( » config Attributes List « ) ; }
@Test { » assert One Two « ( » resolve Context Hierarchy Attributes « ( » Test Class 2 With Bare Context Configuration In Superclass « . class ) ) ; }
@Test { » assert One Two « ( » resolve Context Hierarchy Attributes « ( » Test Class 2 With Bare Context Configuration In Subclass « . class ) ) ; }
@Test { » assert One Two « ( » resolve Context Hierarchy Attributes « ( » Test Class 2 With Bare Meta Context Config With Overrides In Superclass « . class ) ) ; }
@Test { » assert One Two « ( » resolve Context Hierarchy Attributes « ( » Test Class 2 With Bare Meta Context Config With Overrides In Subclass « . class ) ) ; }
@Test { » assert Context Config Entries Are Not Unique « ( » Single Test Class With Multi Level Context Hierarchy With Empty Context Config « . class ) ; }
@Test { » assert Context Config Entries Are Not Unique « ( » Single Test Class With Multi Level Context Hierarchy With Duplicated Context Config « . class ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » detect Default Configuration Classes « ( null ) ) ; }
@Test { Class < ? > [ ] » config Classes « = » detect Default Configuration Classes « ( » No Config Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « . length ) . » is Equal To « ( 0 ) ; }
@Test { Class < ? > [ ] » config Classes « = » detect Default Configuration Classes « ( » Explicit Config Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « ) . » is Equal To « ( new Class < ? > [ ] { » Explicit Config Test Case « . Config . class } ) ; }
@Test { Class < ? > [ ] » config Classes « = » detect Default Configuration Classes « ( » Meta Annotated Config Test Case « . class ) ; » assert That « ( » config Classes « ) . » is Not Null « ( ) ; » assert That « ( » config Classes « ) . » is Equal To « ( new Class < ? > [ ] { » Meta Annotated Config Test Case « . Config . class } ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » build Merged Test Property Sources « ( » Empty Property Sources « . class ) ) . » with Message Starting With « ( " Could not detect default properties file for test class " ) . » with Message Containing « ( " class path resource " ) . » with Message Containing « ( " does not exist " ) . » with Message Containing « ( " » Empty Property Sources « . properties " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » build Merged Test Property Sources « ( » Extended Empty Property Sources « . class ) ) . » with Message Starting With « ( " Could not detect default properties file for test " ) . » with Message Containing « ( " class path resource " ) . » with Message Containing « ( " does not exist " ) . » with Message Containing « ( " » Extended Empty Property Sources « . properties " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » build Merged Test Property Sources « ( » Repeated Property Sources With Conflicting Inherit Locations Flags « . class ) ) . » with Message « ( " @ » Test Property Source « on » Repeated Property Sources With Conflicting Inherit Locations Flags « and " + " @ » Inherit Locations False Test Property « on » Repeated Property Sources With Conflicting Inherit Locations Flags « " + " must declare the same value for 'inheritLocations' as other directly present or meta - present @ » Test Property Source « annotations " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » build Merged Test Property Sources « ( » Repeated Property Sources With Conflicting Inherit Properties Flags « . class ) ) . » with Message « ( " @ » Test Property Source « on » Repeated Property Sources With Conflicting Inherit Properties Flags « and " + " @ » Inherit Properties False Test Property « on » Repeated Property Sources With Conflicting Inherit Properties Flags « " + " must declare the same value for 'inheritProperties' as other directly present or meta - present @ » Test Property Source « annotations " ) ; }
@Test { » assert Merged Test Property Sources « ( » Value Property Sources « . class , » as Array « ( " classpath : / value . xml " ) , » EMPTY _ STRING _ ARRAY « ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » build Merged Test Property Sources « ( » Locations And Value Property Sources « . class ) ) ; }
@Test { » assert Merged Test Property Sources « ( » Locations And Properties Property Sources « . class , » as Array « ( " classpath : / » foo 1 « . xml " , " classpath : / » foo 2 « . xml " ) , » as Array « ( " » k 1 a « = » v 1 a « " , " » k 1 b « : » v 1 b « " ) ) ; }
@Test { » assert Merged Test Property Sources « ( » Inherited Property Sources « . class , » as Array « ( " classpath : / » foo 1 « . xml " , " classpath : / » foo 2 « . xml " ) , » as Array « ( " » k 1 a « = » v 1 a « " , " » k 1 b « : » v 1 b « " ) ) ; }
@Test { » assert Merged Test Property Sources « ( » Extended Property Sources « . class , » as Array « ( " classpath : / » foo 1 « . xml " , " classpath : / » foo 2 « . xml " , " classpath : / » bar 1 « . xml " , " classpath : / » bar 2 « . xml " ) , » as Array « ( " » k 1 a « = » v 1 a « " , " » k 1 b « : » v 1 b « " , " » k 2 a « » v 2 a « " , " » k 2 b « : » v 2 b « " ) ) ; }
@Test { » assert Merged Test Property Sources « ( » Overridden Locations Property Sources « . class , » as Array « ( " classpath : / baz . properties " ) , » as Array « ( " » k 1 a « = » v 1 a « " , " » k 1 b « : » v 1 b « " , " key = value " ) ) ; }
@Test { » assert Merged Test Property Sources « ( » Overridden Properties Property Sources « . class , » as Array « ( " classpath : / » foo 1 « . xml " , " classpath : / » foo 2 « . xml " , " classpath : / baz . properties " ) , » KEY _ VALUE _ PAIR « ) ; }
@Test { » assert Merged Test Property Sources « ( » Overridden Locations And Properties Property Sources « . class , » as Array « ( " classpath : / baz . properties " ) , » KEY _ VALUE _ PAIR « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Properties Files To Environment « ( ( » Configurable Application Context « ) null , » FOO _ LOCATIONS « ) ) . » with Message Containing « ( " 'context' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Properties Files To Environment « ( mock ( » Configurable Application Context « . class ) , ( String [ ] ) null ) ) . » with Message Containing « ( " 'locations' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Properties Files To Environment « ( ( » Configurable Environment « ) null , mock ( » Resource Loader « . class ) , » FOO _ LOCATIONS « ) ) . » with Message Containing « ( " 'environment' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Properties Files To Environment « ( new » Mock Environment « ( ) , null , » FOO _ LOCATIONS « ) ) . » with Message Containing « ( " 'resourceLoader' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Properties Files To Environment « ( new » Mock Environment « ( ) , mock ( » Resource Loader « . class ) , ( String [ ] ) null ) ) . » with Message Containing « ( " 'locations' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Inlined Properties To Environment « ( ( » Configurable Application Context « ) null , » KEY _ VALUE _ PAIR « ) ) . » with Message Containing « ( " 'context' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Inlined Properties To Environment « ( mock ( » Configurable Application Context « . class ) , ( String [ ] ) null ) ) . » with Message Containing « ( " 'inlinedProperties' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Inlined Properties To Environment « ( ( » Configurable Environment « ) null , » KEY _ VALUE _ PAIR « ) ) . » with Message Containing « ( " 'environment' must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » add Inlined Properties To Environment « ( new » Mock Environment « ( ) , ( String [ ] ) null ) ) . » with Message Containing « ( " 'inlinedProperties' must not be null " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » add Inlined Properties To Environment « ( new » Mock Environment « ( ) , » as Array « ( " key = » \\ u ZZZZ « " ) ) ) . » with Message Containing « ( " Failed to load test environment property " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » add Inlined Properties To Environment « ( new » Mock Environment « ( ) , » as Array « ( " a = b \n x = y " ) ) ) . » with Message Containing « ( " Failed to load exactly one test environment property " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » convert Inlined Properties To Map « ( ( String [ ] ) null ) ) . » with Message Containing « ( " 'inlinedProperties' must not be null " ) ; }
@Test { » assert Resolved Profiles « ( Enigma . class , » EMPTY _ STRING _ ARRAY « ) ; }
@Test { » assert Resolved Profiles « ( » Bare Annotations « . class , » EMPTY _ STRING _ ARRAY « ) ; }
@Test { » assert Resolved Profiles « ( » Empty Profiles « . class , » EMPTY _ STRING _ ARRAY « ) ; }
@Test { » assert Resolved Profiles « ( » Duplicated Profiles « . class , " foo " , " bar " , " baz " ) ; }
@Test { » assert Resolved Profiles « ( » Extended Duplicated Profiles « . class , " foo " , " bar " , " baz " , " cat " , " dog " ) ; }
@Test { » assert Resolved Profiles « ( » Locations Foo « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Inherited Locations Foo « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Inherited Classes Foo « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Locations Bar « . class , " foo " , " bar " ) ; }
@Test { » assert Resolved Profiles « ( Animals . class , " dog " , " cat " ) ; }
@Test { » assert Resolved Profiles « ( » Meta Locations Foo « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Meta Locations Foo With Overrides « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Meta Locations Foo With Overridden Attributes « . class , " » foo 1 « " , " » foo 2 « " ) ; }
@Test { » assert Resolved Profiles « ( » Meta Locations Bar « . class , " foo " , " bar " ) ; }
@Test { » assert Resolved Profiles « ( » Meta Animals « . class , " dog " , " cat " ) ; }
@Test { » assert Resolved Profiles « ( » Foo Active Profiles Resolver Test Case « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Inherited Foo Active Profiles Resolver Test Case « . class , " foo " ) ; }
@Test { » assert Resolved Profiles « ( » Merged Inherited Foo Active Profiles Resolver Test Case « . class , " foo " , " bar " ) ; }
@Test { » assert Resolved Profiles « ( » Overriden Inherited Foo Active Profiles Resolver Test Case « . class , " bar " ) ; }
@Test { » assert Resolved Profiles « ( » Resolver And Profiles Test Case « . class , " bar " ) ; }
@Test { » assert Resolved Profiles « ( » Resolver And Value Test Case « . class , " bar " ) ; }
@Test { » assert That Exception Of Type « ( » Annotation Configuration Exception « . class ) . » is Thrown By « ( ( ) -> » resolve Active Profiles « ( » Conflicting Profiles And Value Test Case « . class ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » resolve Active Profiles « ( » No Default Constructor Active Profiles Resolver Test Case « . class ) ) ; }
@Test { Class < » Test Class Verifying Active Profiles Resolver Test Case « > » test Class « = » Test Class Verifying Active Profiles Resolver Test Case « . class ; » assert Resolved Profiles « ( » test Class « , » test Class « . » get Simple Name « ( ) ) ; }
@Test { » assert Resolved Profiles « ( » Default Active Profiles Resolver Test Case « . class , " default " ) ; }
@Test { » assert Resolved Profiles « ( » Extended Default Active Profiles Resolver Test Case « . class , " default " , " foo " ) ; }
@Test { Class < ? > » test Class « = Enigma . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , » EMPTY _ CLASS _ ARRAY « , » Delegating Smart Context Loader « . class ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » build Merged Context Configuration « ( » Missing Context Attributes Test Case « . class ) ) . » with Message Starting With « ( " » Delegating Smart Context Loader « was unable to detect defaults , " + " and no » Application Context Initializers « or » Context Customizers « were declared for context configuration attributes " ) ; }
@Test { Class < ? > » test Class « = » Bare Annotations « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , array ( " classpath : org / springframework / test / context / support / » Abstract Context Configuration Utils Tests $ Bare Annotations « - context . xml " ) , » EMPTY _ CLASS _ ARRAY « , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Locations Foo « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , array ( " classpath : / foo . xml " ) , » EMPTY _ CLASS _ ARRAY « , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Meta Locations Foo « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , array ( " classpath : / foo . xml " ) , » EMPTY _ CLASS _ ARRAY « , » Delegating Smart Context Loader « . class ) ; }
@Test { » build Merged Config With Meta Annotation And Classes « ( Dog . class ) ; » build Merged Config With Meta Annotation And Classes « ( » Working Dog « . class ) ; » build Merged Config With Meta Annotation And Classes « ( » German Shepherd « . class ) ; }
@Test { Class < ? > » test Class « = » Classes Foo « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , array ( » Foo Config « . class ) , » Delegating Smart Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Properties Locations Foo « . class ; Class < ? extends » Context Loader « > » expected Context Loader Class « = » Generic Properties Context Loader « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , array ( " classpath : / foo . properties " ) , » EMPTY _ CLASS _ ARRAY « , » expected Context Loader Class « ) ; }
@Test { Class < ? > » test Class « = » Properties Classes Foo « . class ; Class < ? extends » Context Loader « > » expected Context Loader Class « = » Generic Properties Context Loader « . class ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , array ( » Foo Config « . class ) , » expected Context Loader Class « ) ; }
@Test { Class < ? > » test Class « = » Locations Bar « . class ; String [ ] » expected Locations « = array ( " / foo . xml " , " / bar . xml " ) ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » expected Locations « , » EMPTY _ CLASS _ ARRAY « , » Annotation Config Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Classes Bar « . class ; Class < ? > [ ] » expected Classes « = array ( » Foo Config « . class , » Bar Config « . class ) ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , » expected Classes « , » Annotation Config Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Overridden Locations Bar « . class ; String [ ] » expected Locations « = array ( " / bar . xml " ) ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » expected Locations « , » EMPTY _ CLASS _ ARRAY « , » Annotation Config Context Loader « . class ) ; }
@Test { Class < ? > » test Class « = » Overridden Classes Bar « . class ; Class < ? > [ ] » expected Classes « = array ( » Bar Config « . class ) ; » Merged Context Configuration « » merged Config « = » build Merged Context Configuration « ( » test Class « ) ; » assert Merged Config « ( » merged Config « , » test Class « , » EMPTY _ STRING _ ARRAY « , » expected Classes « , » Annotation Config Context Loader « . class ) ; }
@Test { » assert Merged Config For Location Paths « ( » Absolute Foo Xml Location Without Classpath Prefix « . class ) ; » assert Merged Config For Location Paths « ( » Absolute Foo Xml Location With Inner Relative Path Without Classpath Prefix « . class ) ; » assert Merged Config For Location Paths « ( » Absolute Foo Xml Location With Classpath Prefix « . class ) ; » assert Merged Config For Location Paths « ( » Relative Foo Xml Location « . class ) ; }
@Test { » assert That « ( employee ) . as ( " The employee should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( employee . » get Name « ( ) ) . » is Equal To « ( " John Smith " ) ; » assert That « ( pet ) . as ( " The pet should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( pet . » get Name « ( ) ) . » is Equal To « ( " Fido " ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » assert Add Person « ( JANE ) ; » assert Add Person « ( SUE ) ; » assert Num Rows In Person Table « ( 4 , " in » modify Test Data Within Transaction « ( ) " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( this . » bean Name « ) . as ( " The bean name of this test instance should have been set to the fully qualified class name due to » Bean Name Aware « semantics . " ) . » starts With « ( » get Class « ( ) . » get Name « ( ) ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( super . » application Context « ) . as ( " The application context should have been set due to » Application Context Aware « semantics . " ) . » is Not Null « ( ) ; Employee » employee Bean « = ( Employee ) super . » application Context « . » get Bean « ( " employee " ) ; » assert That « ( » employee Bean « . » get Name « ( ) ) . as ( " employee » ' s « name . " ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( » bean Initialized « ) . as ( " This test instance should have been initialized due to » Initializing Bean « semantics . " ) . » is True « ( ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( » nonrequired Long « ) . as ( " The » nonrequired Long « field should NOT have been autowired . " ) . » is Null « ( ) ; » assert That « ( pet ) . as ( " The pet field should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( pet . » get Name « ( ) ) . as ( " pet » ' s « name . " ) . » is Equal To « ( " Fido " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( employee ) . as ( " The » set Employee « ( ) method should have been autowired . " ) . » is Not Null « ( ) ; » assert That « ( employee . » get Name « ( ) ) . as ( " employee » ' s « name . " ) . » is Equal To « ( " John Smith " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( foo ) . as ( " The foo field should have been injected via @ Resource . " ) . » is Equal To « ( " Foo " ) ; }
@Test { » assert That Transaction « ( ) . » is Not Active « ( ) ; » assert That « ( bar ) . as ( " The » set Bar « ( ) method should have been injected via @ Resource . " ) . » is Equal To « ( " Bar " ) ; }
@Test { » perform Common Assertions « ( ) ; this . » dirtied Application Context « = super . » application Context « ; }
@Test { » perform Common Assertions « ( ) ; » assert That « ( super . » application Context « ) . as ( " The application context should have been 'dirtied' . " ) . » is Not Same As « ( this . » dirtied Application Context « ) ; this . » dirtied Application Context « = super . » application Context « ; }
@Test { » assert That « ( this . » application Context « ) . as ( " The application context should NOT have been 'dirtied' . " ) . » is Same As « ( this . » dirtied Application Context « ) ; }
@Test { int count = dao . » get Count « ( » TEST _ NAME « ) ; » assert That « ( count ) . as ( " New » Test Entity « should have » count = 0 « . " ) . » is Equal To « ( 0 ) ; }
@Test { int count = dao . » increment Count « ( » TEST _ NAME « ) ; » assert That « ( count ) . as ( " Expected count = 1 after first increment . " ) . » is Equal To « ( 1 ) ; }
@Test { int count = dao . » get Count « ( » TEST _ NAME « ) ; » assert That « ( count ) . as ( " Expected count = 1 after » test 2 Increment Count 1 « ( ) . " ) . » is Equal To « ( 1 ) ; count = dao . » increment Count « ( » TEST _ NAME « ) ; » assert That « ( count ) . as ( " Expected count = 2 now . " ) . » is Equal To « ( 2 ) ; }
@Test { » Test Transaction « . » flag For Rollback « ( ) ; }
@Test { » Test Transaction « . » flag For Commit « ( ) ; }
@Test { » Test Transaction « . » is Flagged For Rollback « ( ) ; }
@Test { » Test Transaction « . start ( ) ; }
@Test { » Test Transaction « . end ( ) ; }
@Test { » assert Injected Servlet Request Equals Request In Request Context Holder « ( ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " enigma " ) ; }
@Test { » assert That Transaction « ( ) . » is Active « ( ) ; » Class Path Resource « resource = new » Class Path Resource « ( " / org / springframework / test / context / jdbc / data . sql " ) ; new » Resource Database Populator « ( resource ) . execute ( » jdbc Template « . » get Data Source « ( ) ) ; » assert Num Users « ( 1 ) ; }
@Test { » assert Before Test Method With Transactional Test Method « ( » Transactional Declared On Class Locally Test Case « . class ) ; }
@Test { » assert Before Test Method With Transactional Test Method « ( » Transactional Declared On Class Via Meta Annotation Test Case « . class ) ; }
@Test { » assert Before Test Method With Transactional Test Method « ( » Transactional Declared On Class Via Meta Annotation With Override Test Case « . class , false ) ; }
@Test { » assert Before Test Method With Transactional Test Method « ( » Transactional Declared On Method Via Meta Annotation With Override Test Case « . class , false ) ; » assert Before Test Method With Non Transactional Test Method « ( » Transactional Declared On Method Via Meta Annotation With Override Test Case « . class ) ; }
@Test { » assert Before Test Method « ( » Transactional Declared On Method Locally Test Case « . class ) ; }
@Test { » assert Before Test Method « ( » Transactional Declared On Method Via Meta Annotation Test Case « . class ) ; }
@Test { » assert Before Test Method « ( » Before Transaction Declared Locally Test Case « . class ) ; }
@Test { » assert Before Test Method « ( » Before Transaction Declared Via Meta Annotation Test Case « . class ) ; }
@Test { » assert After Test Method « ( » After Transaction Declared Locally Test Case « . class ) ; }
@Test { » assert After Test Method « ( » After Transaction Declared Via Meta Annotation Test Case « . class ) ; }
@Test { » assert Before Test Method « ( » Before Transaction Declared As Interface Default Method Test Case « . class ) ; }
@Test { » assert After Test Method « ( » After Transaction Declared As Interface Default Method Test Case « . class ) ; }
@Test { » assert Is Rollback « ( » Missing Rollback Test Case « . class , true ) ; }
@Test { » assert Is Rollback « ( » Empty Method Level Rollback Test Case « . class , true ) ; }
@Test { » assert Is Rollback « ( » Method Level Rollback With Explicit Value Test Case « . class , false ) ; }
@Test { » assert Is Rollback « ( » Method Level Rollback Via Meta Annotation Test Case « . class , false ) ; }
@Test { » assert Is Rollback « ( » Empty Class Level Rollback Test Case « . class , true ) ; }
@Test { » assert Is Rollback « ( » Class Level Rollback With Explicit Value Test Case « . class , false ) ; }
@Test { » assert Is Rollback « ( » Class Level Rollback Via Meta Annotation Test Case « . class , false ) ; }
@Test { » assert Is Rollback « ( » Class Level Rollback With Explicit Value On Test Interface Test Case « . class , false ) ; }
@Test { » assert Is Rollback « ( » Class Level Rollback Via Meta Annotation On Test Interface Test Case « . class , false ) ; }
@Test { int count = dao . » get Count « ( » TEST _ NAME « ) ; » assert That « ( count ) . as ( " Expected count = 0 after » test 2 Increment Count 1 « ( ) . " ) . » is Equal To « ( 0 ) ; count = dao . » increment Count « ( » TEST _ NAME « ) ; » assert That « ( count ) . as ( " Expected count = 1 now . " ) . » is Equal To « ( 1 ) ; }
@Test { » assert That « ( » servlet Context Aware Bean « ) . » is Not Null « ( ) ; » assert That « ( » servlet Context Aware Bean « . » servlet Context « ) . » is Not Null « ( ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " Groovy Foo " ) ; }
@Test { » assert That « ( foo ) . » is Equal To « ( " bar " ) ; }
@Test { String » bean Name « = " » session Scoped Test Bean « " ; » assert That « ( session . » get Attribute « ( » bean Name « ) ) . » is Null « ( ) ; » Test Bean « » test Bean « = wac . » get Bean « ( » bean Name « , » Test Bean « . class ) ; » assert That « ( session . » get Attribute « ( » bean Name « ) ) . » is Same As « ( » test Bean « ) ; » assert That « ( wac . » get Bean « ( » bean Name « , » Test Bean « . class ) ) . » is Same As « ( » test Bean « ) ; }
@Test { » run Tests And Assert Counters « ( » Basic Annotation Config Wac Tests « . class , 3 , 0 , 3 , 0 , 0 ) ; }
@Test { » BDD Mockito « . < Class < ? > > given ( » test Context « . » get Test Class « ( ) ) . » will Return « ( » At Web App Config Web Test Case « . class ) ; » Request Context Holder « . » reset Request Attributes « ( ) ; listener . » before Test Class « ( » test Context « ) ; » assert Request Attributes Do Not Exist « ( ) ; » assert Web App Config Test Case « ( ) ; }
@Test { » BDD Mockito « . < Class < ? > > given ( » test Context « . » get Test Class « ( ) ) . » will Return « ( » At Web App Config Web Test Case « . class ) ; listener . » before Test Class « ( » test Context « ) ; » assert Request Attributes Exist « ( ) ; » assert Web App Config Test Case « ( ) ; }
@Test { » BDD Mockito « . < Class < ? > > given ( » test Context « . » get Test Class « ( ) ) . » will Return « ( » No At Web App Config Web Test Case « . class ) ; given ( » test Context « . » get Attribute « ( » Servlet Test Execution Listener « . » ACTIVATE _ LISTENER « ) ) . » will Return « ( true ) ; » Request Context Holder « . » reset Request Attributes « ( ) ; listener . » before Test Class « ( » test Context « ) ; » assert Request Attributes Do Not Exist « ( ) ; » assert Web App Config Test Case « ( ) ; }
@Test { Resource resource = wac . » get Resource « ( " / resources / Spring . js " ) ; » assert That « ( resource ) . » is Not Null « ( ) ; » assert That « ( resource . exists ( ) ) . » is True « ( ) ; }
@Test { given ( » jdbc Template « . update ( " DELETE FROM person " ) ) . » will Return « ( 10 ) ; int deleted = » Jdbc Test Utils « . » delete From Table Where « ( » jdbc Template « , " person " , null ) ; » assert That « ( deleted ) . » is Equal To « ( 10 ) ; }
@Test { given ( » jdbc Template « . update ( " DELETE FROM person WHERE name = 'Bob' and age > 25 " ) ) . » will Return « ( 10 ) ; int deleted = » Jdbc Test Utils « . » delete From Table Where « ( » jdbc Template « , " person " , " name = 'Bob' and age > 25 " ) ; » assert That « ( deleted ) . » is Equal To « ( 10 ) ; }
@Test { given ( » jdbc Template « . update ( " DELETE FROM person WHERE name = ? and age > ? " , " Bob " , 25 ) ) . » will Return « ( 10 ) ; int deleted = » Jdbc Test Utils « . » delete From Table Where « ( » jdbc Template « , " person " , " name = ? and age > ? " , " Bob " , 25 ) ; » assert That « ( deleted ) . » is Equal To « ( 10 ) ; }
@Test { String control = " < root > < » field 1 « > » f 1 « < / » field 1 « > < » field 2 « > » f 2 « < / » field 2 « > < / root > " ; String test = " < root > < » field 1 « > » f 1 « < / » field 1 « > < » field 2 « > » f 2 « < / » field 2 « > < / root > " ; » Xml Expectations Helper « » xml Helper « = new » Xml Expectations Helper « ( ) ; » xml Helper « . » assert Xml Equal « ( control , test ) ; }
@Test { String control = " < root > < » field 1 « > » f 1 « < / » field 1 « > < » field 2 « > » f 2 « < / » field 2 « > < / root > " ; String test = " < root > < » field 2 « > » f 2 « < / » field 2 « > < » field 1 « > » f 1 « < / » field 1 « > < / root > " ; » Xml Expectations Helper « » xml Helper « = new » Xml Expectations Helper « ( ) ; » xml Helper « . » assert Xml Equal « ( control , test ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Target Object « ( null ) ) ; }
@Test { Foo target = » get Target Object « ( foo ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Target Object « ( » jdk Proxy « ( foo ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Target Object « ( » cglib Proxy « ( foo ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Target Object « ( » jdk Proxy « ( » jdk Proxy « ( foo ) ) ) ; » assert That « ( target ) . » is Not Same As « ( foo ) ; }
@Test { Foo target = » get Target Object « ( » cglib Proxy « ( » cglib Proxy « ( foo ) ) ) ; » assert That « ( target ) . » is Not Same As « ( foo ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Ultimate Target Object « ( null ) ) ; }
@Test { Foo target = » get Ultimate Target Object « ( foo ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Ultimate Target Object « ( » jdk Proxy « ( foo ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Ultimate Target Object « ( » cglib Proxy « ( foo ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Ultimate Target Object « ( » jdk Proxy « ( » jdk Proxy « ( foo ) ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Ultimate Target Object « ( » cglib Proxy « ( » cglib Proxy « ( foo ) ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Ultimate Target Object « ( » jdk Proxy « ( » cglib Proxy « ( foo ) ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { Foo target = » get Ultimate Target Object « ( » jdk Proxy « ( » jdk Proxy « ( » cglib Proxy « ( foo ) ) ) ) ; » assert That « ( target ) . » is Same As « ( foo ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . str " ) . exists ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty Array « " ) . exists ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty Map « " ) . exists ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » family Members « [ ? ( @ . name == 'Bart' ) ] " ) . exists ( SIMPSONS ) ; }
@Test { String expression = " $ . » family Members « [ ? ( @ . name == 'Dilbert' ) ] " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . exists ( SIMPSONS ) ) . » with Message Containing « ( " No value at JSON path \" " + expression + " \" " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . bogus " ) . » does Not Exist « ( CONTENT ) ; }
@Test { String expression = " $ . » empty Array « " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » does Not Exist « ( CONTENT ) ) . » with Message Containing « ( " Expected no value at JSON path \" " + expression + " \" but found : [ ] " ) ; }
@Test { String expression = " $ . » empty Map « " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » does Not Exist « ( CONTENT ) ) . » with Message Containing « ( " Expected no value at JSON path \" " + expression + " \" but found : { } " ) ; }
@Test { String expression = " $ . » family Members « [ ? ( @ . name == 'Bart' ) ] " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » does Not Exist « ( SIMPSONS ) ) . » with Message Containing « ( " Expected no value at JSON path \" " + expression + " \" but found : [ { \" name \" : \" Bart \" } ] " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » family Members « [ ? ( @ . name == 'Dilbert' ) ] " ) . » does Not Exist « ( SIMPSONS ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty String « " ) . » assert Value Is Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty Array « " ) . » assert Value Is Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty Map « " ) . » assert Value Is Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » family Members « [ ? ( @ . name == 'Dilbert' ) ] " ) . » assert Value Is Empty « ( SIMPSONS ) ; }
@Test { String expression = " $ . » family Members « [ ? ( @ . name == 'Bart' ) ] " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Empty « ( SIMPSONS ) ) . » with Message Containing « ( " Expected an empty value at JSON path \" " + expression + " \" but found : [ { \" name \" : \" Bart \" } ] " ) ; }
@Test { String expression = " $ . whitespace " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Empty « ( CONTENT ) ) . » with Message Containing « ( " Expected an empty value at JSON path \" " + expression + " \" but found : ' ' " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . str " ) . » assert Value Is Not Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . num " ) . » assert Value Is Not Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . bool " ) . » assert Value Is Not Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . arr " ) . » assert Value Is Not Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » color Map « " ) . » assert Value Is Not Empty « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » family Members « [ ? ( @ . name == 'Bart' ) ] " ) . » assert Value Is Not Empty « ( SIMPSONS ) ; }
@Test { String expression = " $ . » family Members « [ ? ( @ . name == 'Dilbert' ) ] " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Not Empty « ( SIMPSONS ) ) . » with Message Containing « ( " Expected a non - empty value at JSON path \" " + expression + " \" but found : [ ] " ) ; }
@Test { String expression = " $ . » empty String « " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Not Empty « ( CONTENT ) ) . » with Message Containing « ( " Expected a non - empty value at JSON path \" " + expression + " \" but found : '' " ) ; }
@Test { String expression = " $ . » empty Array « " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Not Empty « ( CONTENT ) ) . » with Message Containing « ( " Expected a non - empty value at JSON path \" " + expression + " \" but found : [ ] " ) ; }
@Test { String expression = " $ . » empty Map « " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Not Empty « ( CONTENT ) ) . » with Message Containing « ( " Expected a non - empty value at JSON path \" " + expression + " \" but found : { } " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . abc " ) . » has Json Path « ( " { \" abc \" : \" 123 \" } " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . abc " ) . » has Json Path « ( " { \" abc \" : null } " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » family Members « [ ? ( @ . name == 'Bart' ) ] " ) . » has Json Path « ( SIMPSONS ) ; }
@Test { String expression = " $ . » family Members « [ ? ( @ . name == 'Dilbert' ) ] " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » has Json Path « ( SIMPSONS ) ) . » with Message Containing « ( " No values for JSON path \" " + expression + " \" " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . abc " ) . » does Not Have Json Path « ( " { } " ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( " $ . abc " ) . » does Not Have Json Path « ( " { \" abc \" : null } " ) ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » family Members « [ ? ( @ . name == 'Dilbert' ) ] " ) . » does Not Have Json Path « ( SIMPSONS ) ; }
@Test { String expression = " $ . » family Members « [ ? ( @ . name == 'Bart' ) ] " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » does Not Have Json Path « ( SIMPSONS ) ) . » with Message Containing « ( " Expected no values at JSON path \" " + expression + " \" " + " but found : [ { \" name \" : \" Bart \" } ] " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . num " ) . » assert Value « ( CONTENT , 5 ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . num " ) . » assert Value « ( CONTENT , 5.0 ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . num " ) . » assert Value « ( CONTENT , is ( 5.0 ) , Double . class ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . str " ) . » assert Value Is String « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty String « " ) . » assert Value Is String « ( CONTENT ) ; }
@Test { String expression = " $ . bool " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is String « ( CONTENT ) ) . » with Message Containing « ( " Expected a string at JSON path \" " + expression + " \" but found : true " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . num " ) . » assert Value Is Number « ( CONTENT ) ; }
@Test { String expression = " $ . bool " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Number « ( CONTENT ) ) . » with Message Containing « ( " Expected a number at JSON path \" " + expression + " \" but found : true " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . bool " ) . » assert Value Is Boolean « ( CONTENT ) ; }
@Test { String expression = " $ . num " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Boolean « ( CONTENT ) ) . » with Message Containing « ( " Expected a boolean at JSON path \" " + expression + " \" but found : 5 " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . arr " ) . » assert Value Is Array « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty Array « " ) . » assert Value Is Array « ( CONTENT ) ; }
@Test { String expression = " $ . str " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Array « ( CONTENT ) ) . » with Message Containing « ( " Expected an array at JSON path \" " + expression + " \" but found : 'foo' " ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » color Map « " ) . » assert Value Is Map « ( CONTENT ) ; }
@Test { new » Json Path Expectations Helper « ( " $ . » empty Map « " ) . » assert Value Is Map « ( CONTENT ) ; }
@Test { String expression = " $ . str " ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Expectations Helper « ( expression ) . » assert Value Is Map « ( CONTENT ) ) . » with Message Containing « ( " Expected a map at JSON path \" " + expression + " \" but found : 'foo' " ) ; }
@Test { » assert That « ( » find Annotation Descriptor « ( » Non Annotated Interface « . class , Transactional . class ) ) . » is Null « ( ) ; » assert That « ( » find Annotation Descriptor « ( » Non Annotated Class « . class , Transactional . class ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » find Annotation Descriptor « ( » Inherited Annotation Class « . class , Transactional . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Inherited Annotation Class « . class ) ; » assert That « ( » find Annotation Descriptor « ( » Sub Inherited Annotation Class « . class , Transactional . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Inherited Annotation Class « . class ) ; }
@Test { » assert That « ( » find Annotation Descriptor « ( » Non Inherited Annotation Class « . class , Order . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Non Inherited Annotation Class « . class ) ; » assert That « ( » find Annotation Descriptor « ( » Sub Non Inherited Annotation Class « . class , Order . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Non Inherited Annotation Class « . class ) ; }
@Test { » assert At Component On Composed Annotation « ( » Has Meta Component Annotation « . class , " » meta 1 « " , » Meta 1 « . class ) ; }
@Test { » assert At Component On Composed Annotation « ( » Interface With Meta Annotation « . class , " » meta 1 « " , » Meta 1 « . class ) ; }
@Test { » assert At Component On Composed Annotation « ( » Class With Local Meta Annotation And Meta Annotated Interface « . class , " » meta 2 « " , » Meta 2 « . class ) ; }
@Test { » assert At Component On Composed Annotation « ( » Sub Class With Local Meta Annotation And Meta Annotated Interface « . class , » Class With Local Meta Annotation And Meta Annotated Interface « . class , " » meta 2 « " , » Meta 2 « . class ) ; }
@Test { Class < » Meta Meta Annotated Class « > » start Class « = » Meta Meta Annotated Class « . class ; » assert At Component On Composed Annotation « ( » start Class « , » start Class « , » Meta 2 « . class , " » meta 2 « " , » Meta Meta « . class ) ; }
@Test { Class < » Meta Meta Meta Annotated Class « > » start Class « = » Meta Meta Meta Annotated Class « . class ; » assert At Component On Composed Annotation « ( » start Class « , » start Class « , » Meta 2 « . class , " » meta 2 « " , » Meta Meta Meta « . class ) ; }
@Test { » Annotation Descriptor « < Component > descriptor = » find Annotation Descriptor « ( » Inherited Annotation Class « . class , Component . class ) ; » assert That « ( descriptor ) . as ( " Should not find @ Component on » Inherited Annotation Class « " ) . » is Null « ( ) ; }
@Test { » Annotation Descriptor « < Component > descriptor = » find Annotation Descriptor « ( » Meta Cycle Annotated Class « . class , Component . class ) ; » assert That « ( descriptor ) . as ( " Should not find @ Component on » Meta Cycle Annotated Class « " ) . » is Null « ( ) ; }
@Test { » assert That « ( » find Annotation Descriptor For Types « ( » Non Annotated Interface « . class , Transactional . class , Component . class ) ) . » is Null « ( ) ; » assert That « ( » find Annotation Descriptor For Types « ( » Non Annotated Class « . class , Transactional . class , Order . class ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » find Annotation Descriptor For Types « ( » Inherited Annotation Class « . class , Transactional . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Inherited Annotation Class « . class ) ; » assert That « ( » find Annotation Descriptor For Types « ( » Sub Inherited Annotation Class « . class , Transactional . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Inherited Annotation Class « . class ) ; }
@Test { » assert That « ( » find Annotation Descriptor For Types « ( » Non Inherited Annotation Class « . class , Order . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Non Inherited Annotation Class « . class ) ; » assert That « ( » find Annotation Descriptor For Types « ( » Sub Non Inherited Annotation Class « . class , Order . class ) . » get Root Declaring Class « ( ) ) . » is Equal To « ( » Non Inherited Annotation Class « . class ) ; }
@Test { Class < » Has Meta Component Annotation « > » start Class « = » Has Meta Component Annotation « . class ; » assert At Component On Composed Annotation For Multiple Candidate Types « ( » start Class « , " » meta 1 « " , » Meta 1 « . class ) ; }
@Test { Class < » Interface With Meta Annotation « > » start Class « = » Interface With Meta Annotation « . class ; » assert At Component On Composed Annotation For Multiple Candidate Types « ( » start Class « , " » meta 1 « " , » Meta 1 « . class ) ; }
@Test { Class < » Class With Local Meta Annotation And Meta Annotated Interface « > » start Class « = » Class With Local Meta Annotation And Meta Annotated Interface « . class ; » assert At Component On Composed Annotation For Multiple Candidate Types « ( » start Class « , " » meta 2 « " , » Meta 2 « . class ) ; }
@Test { » assert At Component On Composed Annotation For Multiple Candidate Types « ( » Sub Class With Local Meta Annotation And Meta Annotated Interface « . class , » Class With Local Meta Annotation And Meta Annotated Interface « . class , " » meta 2 « " , » Meta 2 « . class ) ; }
@Test { Class < » Meta Meta Annotated Class « > » start Class « = » Meta Meta Annotated Class « . class ; » assert At Component On Composed Annotation For Multiple Candidate Types « ( » start Class « , » start Class « , » Meta 2 « . class , " » meta 2 « " , » Meta Meta « . class ) ; }
@Test { Class < » Meta Meta Meta Annotated Class « > » start Class « = » Meta Meta Meta Annotated Class « . class ; » assert At Component On Composed Annotation For Multiple Candidate Types « ( » start Class « , » start Class « , » Meta 2 « . class , " » meta 2 « " , » Meta Meta Meta « . class ) ; }
@Test { » Untyped Annotation Descriptor « descriptor = » find Annotation Descriptor For Types « ( » Inherited Annotation Class « . class , Service . class , Component . class , Order . class ) ; » assert That « ( descriptor ) . as ( " Should not find @ Component on » Inherited Annotation Class « " ) . » is Null « ( ) ; }
@Test { » Untyped Annotation Descriptor « descriptor = » find Annotation Descriptor For Types « ( » Meta Cycle Annotated Class « . class , Service . class , Component . class , Order . class ) ; » assert That « ( descriptor ) . as ( " Should not find @ Component on » Meta Cycle Annotated Class « " ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( ( Object ) null , " id " , Long . » value Of « ( 99 ) ) ) . » with Message Starting With « ( " Either » target Object « or » target Class « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Field « ( ( Object ) null , " id " ) ) . » with Message Starting With « ( " Either » target Object « or » target Class « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( ( Class < ? > ) null , " id " , Long . » value Of « ( 99 ) ) ) . » with Message Starting With « ( " Either » target Object « or » target Class « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Field « ( ( Class < ? > ) null , " id " ) ) . » with Message Starting With « ( " Either » target Object « or » target Class « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( person , null , Long . » value Of « ( 99 ) , null ) ) . » with Message Starting With « ( " Either name or type " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( person , " bogus " , Long . » value Of « ( 99 ) , long . class ) ) . » with Message Starting With « ( " Could not find field 'bogus' " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( person , " id " , Long . » value Of « ( 99 ) , String . class ) ) . » with Message Starting With « ( " Could not find field " ) ; }
@Test { » assert Set Field And Get Field Behavior « ( this . person ) ; }
@Test { » Proxy Factory « pf = new » Proxy Factory « ( this . person ) ; pf . » add Interface « ( Person . class ) ; Person proxy = ( Person ) pf . » get Proxy « ( ) ; » assert That « ( » Aop Utils « . » is Jdk Dynamic Proxy « ( proxy ) ) . as ( " Proxy is a JDK dynamic proxy " ) . » is True « ( ) ; » assert Set Field And Get Field Behavior For Proxy « ( proxy , this . person ) ; }
@Test { » Proxy Factory « pf = new » Proxy Factory « ( this . person ) ; pf . » set Proxy Target Class « ( true ) ; Person proxy = ( Person ) pf . » get Proxy « ( ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( proxy ) ) . as ( " Proxy is a CGLIB proxy " ) . » is True « ( ) ; » assert Set Field And Get Field Behavior For Proxy « ( proxy , this . person ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( person , " id " , null , long . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( person , " age " , null , int . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » set Field « ( person , " » likes Pets « " , null , boolean . class ) ) ; }
@Test { » set Field « ( » Static Fields « . class , " » public Field « " , " xxx " ) ; » set Field « ( » Static Fields « . class , " » private Field « " , " yyy " ) ; » assert That « ( » Static Fields « . » public Field « ) . as ( " public static field " ) . » is Equal To « ( " xxx " ) ; » assert That « ( » Static Fields « . » get Private Field « ( ) ) . as ( " private static field " ) . » is Equal To « ( " yyy " ) ; }
@Test { » set Field « ( » Static Fields « . class , " » public Field « " , " xxx " , String . class ) ; » set Field « ( » Static Fields « . class , " » private Field « " , " yyy " , String . class ) ; » assert That « ( » Static Fields « . » public Field « ) . as ( " public static field " ) . » is Equal To « ( " xxx " ) ; » assert That « ( » Static Fields « . » get Private Field « ( ) ) . as ( " private static field " ) . » is Equal To « ( " yyy " ) ; }
@Test { » Static Fields « » static Fields « = new » Static Fields « ( ) ; » set Field « ( » static Fields « , null , " » public Field « " , " xxx " , null ) ; » set Field « ( » static Fields « , null , " » private Field « " , " yyy " , null ) ; » assert That « ( » Static Fields « . » public Field « ) . as ( " public static field " ) . » is Equal To « ( " xxx " ) ; » assert That « ( » Static Fields « . » get Private Field « ( ) ) . as ( " private static field " ) . » is Equal To « ( " yyy " ) ; }
@Test { » assert That « ( » get Field « ( » Static Fields « . class , " » public Field « " ) ) . as ( " public static field " ) . » is Equal To « ( " public " ) ; » assert That « ( » get Field « ( » Static Fields « . class , " » private Field « " ) ) . as ( " private static field " ) . » is Equal To « ( " private " ) ; }
@Test { » Static Fields « » static Fields « = new » Static Fields « ( ) ; » assert That « ( » get Field « ( » static Fields « , " » public Field « " ) ) . as ( " public static field " ) . » is Equal To « ( " public " ) ; » assert That « ( » get Field « ( » static Fields « , " » private Field « " ) ) . as ( " private static field " ) . » is Equal To « ( " private " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Setter Method « ( person , " id " , null , long . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Setter Method « ( person , " age " , null , int . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Setter Method « ( person , " » likes Pets « " , null , boolean . class ) ) ; }
@Test { Integer difference = » invoke Method « ( component , " subtract " , 5 , 2 ) ; » assert That « ( difference . » int Value « ( ) ) . as ( " subtract ( 5 , 2 ) " ) . » is Equal To « ( 3 ) ; }
@Test { Integer sum = » invoke Method « ( component , " add " , 1 , 2 , 3 , 4 ) ; » assert That « ( sum . » int Value « ( ) ) . as ( " add ( 1 , 2 , 3 , 4 ) " ) . » is Equal To « ( 10 ) ; }
@Test { Integer sum = » invoke Method « ( component , " add " , new int [ ] { 1 , 2 , 3 , 4 } ) ; » assert That « ( sum . » int Value « ( ) ) . as ( " add ( 1 , 2 , 3 , 4 ) " ) . » is Equal To « ( 10 ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( component , " init " ) ) . » with Message Starting With « ( " number must not be null " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( component , " subtract " , " foo " , 2.0 ) ) . » with Message Starting With « ( " Method not found " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( component , " configure " , Integer . » value Of « ( 42 ) ) ) . » with Message Starting With « ( " Method not found " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( component , " configure " , Integer . » value Of « ( 42 ) , " enigma " , " baz " , " quux " ) ) . » with Message Starting With « ( " Method not found " ) ; }
@Test { Object collaborator = » get Field « ( entity , " collaborator " ) ; » assert That « ( collaborator ) . » is Not Null « ( ) ; }
@Test { String » test Collaborator « = " test collaborator " ; » set Field « ( entity , " collaborator " , » test Collaborator « , Object . class ) ; » assert That « ( entity . » to String « ( ) . contains ( » test Collaborator « ) ) . » is True « ( ) ; }
@Test { » invoke Method « ( entity , " configure " , Integer . » value Of « ( 42 ) , " enigma " ) ; » assert That « ( entity . » get Number « ( ) ) . as ( " number should have been configured " ) . » is Equal To « ( Integer . » value Of « ( 42 ) ) ; » assert That « ( entity . » get Text « ( ) ) . as ( " text should have been configured " ) . » is Equal To « ( " enigma " ) ; }
@Test { Object collaborator = » invoke Getter Method « ( entity , " collaborator " ) ; » assert That « ( collaborator ) . » is Not Null « ( ) ; }
@Test { String » test Collaborator « = " test collaborator " ; » invoke Setter Method « ( entity , " collaborator " , » test Collaborator « ) ; » assert That « ( entity . » to String « ( ) . contains ( » test Collaborator « ) ) . » is True « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( ( Class < ? > ) null , null ) ) . » with Message « ( " Target class must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( » get Class « ( ) , null ) ) . » with Message « ( " Method name must not be empty " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( » get Class « ( ) , " " ) ) . » with Message « ( " Method name must not be empty " ) ; }
@Test { » assert That « ( » Static Methods « . » get Public Method Value « ( ) ) . » is Equal To « ( " public " ) ; String » test Collaborator « = " test collaborator " ; » invoke Method « ( » Static Methods « . class , " » public Method « " , » test Collaborator « ) ; » assert That « ( » Static Methods « . » get Public Method Value « ( ) ) . » is Equal To « ( » test Collaborator « ) ; }
@Test { » assert That « ( » Static Methods « . » get Public Method Value « ( ) ) . » is Equal To « ( " public " ) ; String result = » invoke Method « ( » Static Methods « . class , " » public Method « " ) ; » assert That « ( result ) . » is Equal To « ( » Static Methods « . » get Public Method Value « ( ) ) ; }
@Test { » assert That « ( » Static Methods « . » get Private Method Value « ( ) ) . » is Equal To « ( " private " ) ; String » test Collaborator « = " test collaborator " ; » invoke Method « ( » Static Methods « . class , " » private Method « " , » test Collaborator « ) ; » assert That « ( » Static Methods « . » get Private Method Value « ( ) ) . » is Equal To « ( » test Collaborator « ) ; }
@Test { » assert That « ( » Static Methods « . » get Private Method Value « ( ) ) . » is Equal To « ( " private " ) ; String result = » invoke Method « ( » Static Methods « . class , " » private Method « " ) ; » assert That « ( result ) . » is Equal To « ( » Static Methods « . » get Private Method Value « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » invoke Method « ( ( Object ) null , ( Class < ? > ) null , " id " ) ) . » with Message « ( " Either 'targetObject' or 'targetClass' for the method must be specified " ) ; }
@Test { » Request Expectation « expectation = new » Default Request Expectation « ( once ( ) , » request To « ( " / foo " ) ) ; expectation . match ( » create Request « ( GET , " / foo " ) ) ; }
@Test { » Request Expectation « expectation = new » Default Request Expectation « ( once ( ) , » request To « ( " / foo " ) ) ; expectation . » and Expect « ( method ( POST ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> expectation . match ( » create Request « ( GET , " / foo " ) ) ) . » with Message Containing « ( " Unexpected » Http Method « expected : < POST > but was : < GET > " ) ; }
@Test { » Request Expectation « expectation = new » Default Request Expectation « ( twice ( ) , » request To « ( " / foo " ) ) ; expectation . » and Respond « ( » with Success « ( ) ) ; expectation . » increment And Validate « ( ) ; » assert That « ( expectation . » has Remaining Count « ( ) ) . » is True « ( ) ; expectation . » increment And Validate « ( ) ; » assert That « ( expectation . » has Remaining Count « ( ) ) . » is False « ( ) ; }
@Test { » Request Expectation « expectation = new » Default Request Expectation « ( twice ( ) , » request To « ( " / foo " ) ) ; expectation . » and Respond « ( » with Success « ( ) ) ; expectation . » increment And Validate « ( ) ; » assert That « ( expectation . » is Satisfied « ( ) ) . » is False « ( ) ; expectation . » increment And Validate « ( ) ; » assert That « ( expectation . » is Satisfied « ( ) ) . » is True « ( ) ; }
@Test { try { this . manager . » validate Request « ( » create Request « ( GET , " / foo " ) ) ; } catch ( » Assertion Error « error ) { » assert That « ( error . » get Message « ( ) ) . » is Equal To « ( ( " No further requests expected : HTTP GET / foo \n " + " 0 request ( s ) executed . \n " ) ) ; } }
@Test { this . manager . verify ( ) ; }
@Test { this . request . » get Headers « ( ) . » set Content Type « ( » Media Type « . » APPLICATION _ JSON « ) ; » Mock Rest Request Matchers « . content ( ) . » content Type « ( " application / json " ) . match ( this . request ) ; » Mock Rest Request Matchers « . content ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . match ( this . request ) ; }
@Test { this . request . » get Headers « ( ) . » set Content Type « ( » Media Type « . » APPLICATION _ JSON « ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . » content Type « ( " application / xml " ) . match ( this . request ) ) ; }
@Test { this . request . » get Headers « ( ) . » set Content Type « ( » Media Type « . » APPLICATION _ JSON « ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . » content Type « ( » Media Type « . » APPLICATION _ ATOM _ XML « ) . match ( this . request ) ) ; }
@Test { this . request . » get Body « ( ) . write ( " test " . » get Bytes « ( ) ) ; » Mock Rest Request Matchers « . content ( ) . string ( " test " ) . match ( this . request ) ; }
@Test { this . request . » get Body « ( ) . write ( " test " . » get Bytes « ( ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . string ( " Test " ) . match ( this . request ) ) ; }
@Test { byte [ ] content = " test " . » get Bytes « ( ) ; this . request . » get Body « ( ) . write ( content ) ; » Mock Rest Request Matchers « . content ( ) . bytes ( content ) . match ( this . request ) ; }
@Test { this . request . » get Body « ( ) . write ( " test " . » get Bytes « ( ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . bytes ( " Test " . » get Bytes « ( ) ) . match ( this . request ) ) ; }
@Test { String content = " < foo > < bar > baz < / bar > < bar > bazz < / bar > < / foo > " ; this . request . » get Body « ( ) . write ( content . » get Bytes « ( ) ) ; » Mock Rest Request Matchers « . content ( ) . xml ( content ) . match ( this . request ) ; }
@Test { this . request . » get Body « ( ) . write ( " < foo > 11 < / foo > " . » get Bytes « ( ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . xml ( " < foo > 22 < / foo > " ) . match ( this . request ) ) ; }
@Test { String content = " < foo > < bar > baz < / bar > < / foo > " ; this . request . » get Body « ( ) . write ( content . » get Bytes « ( ) ) ; » Mock Rest Request Matchers « . content ( ) . node ( » has X Path « ( " / foo / bar " ) ) . match ( this . request ) ; }
@Test { String content = " < foo > < bar > baz < / bar > < / foo > " ; this . request . » get Body « ( ) . write ( content . » get Bytes « ( ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . node ( » has X Path « ( " / foo / bar / bar " ) ) . match ( this . request ) ) ; }
@Test { String content = " { \n \" foo array \" : [ \" first \" , \" second \" ] , \" » some Extra Property « \" : \" which is allowed \" \n } " ; this . request . » get Body « ( ) . write ( content . » get Bytes « ( ) ) ; » Mock Rest Request Matchers « . content ( ) . json ( " { \n \" foo array \" : [ \" second \" , \" first \" ] \n } " ) . match ( this . request ) ; » Mock Rest Request Matchers « . content ( ) . json ( " { \n \" foo array \" : [ \" second \" , \" first \" ] \n } " , false ) . match ( this . request ) ; }
@Test { String content = " { \n \" foo \" : \" bar \" , \" foo array \" : [ \" first \" , \" second \" ] \n } " ; this . request . » get Body « ( ) . write ( content . » get Bytes « ( ) ) ; » Mock Rest Request Matchers « . content ( ) . json ( " { \n \" foo array \" : [ \" first \" , \" second \" ] , \" foo \" : \" bar \" \n } " , true ) . match ( this . request ) ; }
@Test { String content = " { \n \" foo array \" : [ \" first \" , \" second \" ] , \" » some Extra Property « \" : \" which is NOT allowed \" \n } " ; this . request . » get Body « ( ) . write ( content . » get Bytes « ( ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » Mock Rest Request Matchers « . content ( ) . json ( " { \n \" foo array \" : [ \" second \" , \" first \" ] \n } " , true ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / bar " , null ) . node ( Matchers . » not Null Value « ( ) ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / bar " , null ) . node ( Matchers . » null Value « ( ) ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / bar " , null ) . exists ( ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / Bar " , null ) . exists ( ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / Bar " , null ) . » does Not Exist « ( ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / bar " , null ) . » does Not Exist « ( ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / bar " , null ) . » node Count « ( 2 ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / bar " , null ) . » node Count « ( 1 ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / bar [ 1 ] " , null ) . string ( " 111 " ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / bar [ 1 ] " , null ) . string ( " 112 " ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / bar [ 1 ] " , null ) . number ( 111.0 ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / bar [ 1 ] " , null ) . number ( 111.1 ) . match ( this . request ) ) ; }
@Test { new » Xpath Request Matchers « ( " / foo / bar [ 2 ] " , null ) . » boolean Value « ( true ) . match ( this . request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Request Matchers « ( " / foo / bar [ 2 ] " , null ) . » boolean Value « ( false ) . match ( this . request ) ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / bar « " ) ) ; » Mock Rest Request Matchers « . » request To « ( " http : » // www . foo . example / bar « " ) . match ( this . request ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / bar « " ) ) ; » Mock Rest Request Matchers « . » request To Uri Template « ( " http : » // www . foo . example / « { bar } " , " bar " ) . match ( this . request ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / bar « " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . » request To « ( " http : » // www . foo . example / wrong « " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / bar « " ) ) ; » Mock Rest Request Matchers « . » request To « ( » contains String « ( " bar " ) ) . match ( this . request ) ; }
@Test { this . request . » set Method « ( » Http Method « . GET ) ; » Mock Rest Request Matchers « . method ( » Http Method « . GET ) . match ( this . request ) ; }
@Test { this . request . » set Method « ( » Http Method « . POST ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . method ( » Http Method « . GET ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " expected : < GET > but was : < POST > " ) ; }
@Test { this . request . » get Headers « ( ) . put ( " foo " , Arrays . » as List « ( " bar " , " baz " ) ) ; » Mock Rest Request Matchers « . header ( " foo " , " bar " , " baz " ) . match ( this . request ) ; }
@Test { » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . header ( " foo " , " bar " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " was null " ) ; }
@Test { this . request . » get Headers « ( ) . put ( " foo " , Arrays . » as List « ( " bar " , " baz " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . header ( " foo " , " bad " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " expected : < bad > but was : < bar > " ) ; }
@Test { this . request . » get Headers « ( ) . put ( " foo " , Arrays . » as List « ( " bar " , " baz " ) ) ; » Mock Rest Request Matchers « . header ( " foo " , » contains String « ( " ba " ) ) . match ( this . request ) ; }
@Test { » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . header ( " foo " , » contains String « ( " baz " ) ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " but was null " ) ; }
@Test { this . request . » get Headers « ( ) . put ( " foo " , Arrays . » as List « ( " bar " , " baz " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . header ( " foo " , » contains String « ( " bx " ) ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " was \" bar \" " ) ; }
@Test { » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . header ( " foo " , " bar " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " but was null " ) ; }
@Test { this . request . » get Headers « ( ) . put ( " foo " , Collections . » singleton List « ( " bar " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . header ( " foo " , " bar " , " baz " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " to have at least < 2 > values " ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / a « ? » foo = bar « & » foo = baz « " ) ) ; » Mock Rest Request Matchers « . » query Param « ( " foo " , " bar " , " baz " ) . match ( this . request ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / a « " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . » query Param « ( " foo " , " bar " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " but was null " ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / a « ? » foo = bar « & » foo = baz « " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . » query Param « ( " foo " , " bad " ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " expected : < bad > but was : < bar > " ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / a « ? » foo = bar « & » foo = baz « " ) ) ; » Mock Rest Request Matchers « . » query Param « ( " foo " , » contains String « ( " ba " ) ) . match ( this . request ) ; }
@Test { this . request . » set URI « ( new URI ( " http : » // www . foo . example / a « ? » foo = bar « & » foo = baz « " ) ) ; » assert That Thrown By « ( ( ) -> » Mock Rest Request Matchers « . » query Param « ( " foo " , » contains String « ( " bx " ) ) . match ( this . request ) ) . » is Instance Of « ( » Assertion Error « . class ) . » has Message Containing « ( " was \" bar \" " ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . value ( " bogus " ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . str " ) . value ( " foo " ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . num " ) . value ( 5.0f ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . str " ) . value ( » equal To « ( " foo " ) ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . num " ) . value ( » equal To « ( 5.0f ) , Float . class ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . value ( » equal To « ( " bogus " ) ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . str " ) . exists ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty Array « " ) . exists ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty Map « " ) . exists ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . bogus " ) . exists ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . bogus " ) . » does Not Exist « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . » does Not Exist « ( ) . match ( request ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . » empty Array « " ) . » does Not Exist « ( ) . match ( request ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . » empty Map « " ) . » does Not Exist « ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty String « " ) . » is Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty Array « " ) . » is Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty Map « " ) . » is Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . str " ) . » is Not Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . num " ) . » is Not Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . bool " ) . » is Not Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . arr " ) . » is Not Empty « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » color Map « " ) . » is Not Empty « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . » empty String « " ) . » is Not Empty « ( ) . match ( request ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . » empty Array « " ) . » is Not Empty « ( ) . match ( request ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . » empty Map « " ) . » is Not Empty « ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . arr " ) . » is Array « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty Array « " ) . » is Array « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . » is Array « ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » color Map « " ) . » is Map « ( ) . match ( request ) ; }
@Test { new » Json Path Request Matchers « ( " $ . » empty Map « " ) . » is Map « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . » is Map « ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . bool " ) . » is Boolean « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . » is Boolean « ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . num " ) . » is Number « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . str " ) . » is Number « ( ) . match ( request ) ) ; }
@Test { new » Json Path Request Matchers « ( " $ . str " ) . » is String « ( ) . match ( request ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Request Matchers « ( " $ . arr " ) . » is String « ( ) . match ( request ) ) ; }
@Test { » Mock Client Http Response « response = ( » Mock Client Http Response « ) » Mock Rest Response Creators « . » with Success « ( ) . » create Response « ( null ) ; » assert That « ( response . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . OK ) ; » assert That « ( response . » get Headers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; » assert That « ( » Stream Utils « . » copy To Byte Array « ( response . » get Body « ( ) ) . length ) . » is Equal To « ( 0 ) ; }
@Test { » Response Creator « » response Creator « = » Mock Rest Response Creators « . » with Exception « ( new » Socket Timeout Exception « ( ) ) ; » assert That Exception Of Type « ( » Socket Timeout Exception « . class ) . » is Thrown By « ( ( ) -> » response Creator « . » create Response « ( null ) ) ; }
@Test { » Rest Template « template = new » Rest Template « ( new » Mock Mvc Client Http Request Factory « ( this . » mock Mvc « ) ) ; String result = template . » get For Object « ( " / foo " , String . class ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { org . springframework . web . client . » Async Rest Template « template = new org . springframework . web . client . » Async Rest Template « ( new » Mock Mvc Client Http Request Factory « ( this . » mock Mvc « ) ) ; » Listenable Future « < » Response Entity « < String > > entity = template . » get For Entity « ( " / foo " , String . class ) ; » assert That « ( entity . get ( ) . » get Body « ( ) ) . » is Equal To « ( " bar " ) ; }
@Test { this . » mock Server « . expect ( content ( ) . » content Type « ( " application / json " ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( new Person ( ) ) ; }
@Test { this . » mock Server « . expect ( content ( ) . » content Type « ( " application / json ; charset = UTF - 8 " ) ) . » and Respond « ( » with Success « ( ) ) ; try { » execute And Verify « ( " foo " ) ; } catch ( » Assertion Error « error ) { String message = error . » get Message « ( ) ; » assert That « ( message . » starts With « ( " Content type expected : < application / json ; charset = UTF - 8 > " ) ) . as ( message ) . » is True « ( ) ; } }
@Test { this . » mock Server « . expect ( content ( ) . string ( " foo " ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( " foo " ) ; }
@Test { this . » mock Server « . expect ( content ( ) . string ( » starts With « ( " foo " ) ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( " » foo 123 « " ) ; }
@Test { this . » mock Server « . expect ( content ( ) . bytes ( " foo " . » get Bytes « ( ) ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( " foo " ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / person / 1 " ) ) . » and Expect « ( header ( " Accept " , " » application / json « , » application / « * » + json « " ) ) . » and Respond « ( » with Success « ( » RESPONSE _ BODY « , » Media Type « . » APPLICATION _ JSON « ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / person / 1 " ) ) . » and Expect « ( header ( " Accept " , » contains String « ( " json " ) ) ) . » and Respond « ( » with Success « ( » RESPONSE _ BODY « , » Media Type « . » APPLICATION _ JSON « ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / json " ) ) . » and Expect « ( » json Path « ( " $ . composers [ 0 ] . name " ) . value ( " Johann Sebastian Bach " ) ) . » and Expect « ( » json Path « ( " $ . performers [ 1 ] . name " ) . value ( " Yehudi Menuhin " ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / json " ) ) . » and Expect « ( » json Path « ( " $ . composers " ) . » is Array « ( ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / json " ) ) . » and Expect « ( » json Path « ( " $ . composers [ 0 ] . name " ) . » is String « ( ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / json " ) ) . » and Expect « ( » json Path « ( " $ . composers [ 0 ] . » some Double « " ) . » is Number « ( ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / json " ) ) . » and Expect « ( » json Path « ( " $ . composers [ 0 ] . » some Boolean « " ) . » is Boolean « ( ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / xml " ) ) . » and Expect « ( content ( ) . xml ( » PEOPLE _ XML « ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / xml " ) ) . » and Expect « ( content ( ) . node ( » has X Path « ( " / people / composers / composer [ 1 ] " ) ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { String » performer Boolean Value « = " / ns : people / performers / performer [ % s ] / » some Boolean « " ; this . » mock Server « . expect ( » request To « ( " / composers " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / xml " ) ) . » and Expect « ( xpath ( » performer Boolean Value « , NS , 1 ) . » boolean Value « ( false ) ) . » and Expect « ( xpath ( » performer Boolean Value « , NS , 2 ) . » boolean Value « ( true ) ) . » and Respond « ( » with Success « ( ) ) ; » execute And Verify « ( ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Web Config « . class ) ; » Application Context Spec « spec = new » Application Context Spec « ( context ) ; » Web Test Client « » test Client « = spec . » configure Client « ( ) . build ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { » test Client « . get ( ) . uri ( " / » session Class Name « " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( String . class ) . » is Equal To « ( " » Mock Web Session « " ) ; } }
@Test { new » Default Controller Spec « ( new » My Controller « ( ) ) . build ( ) . get ( ) . uri ( " / " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( String . class ) . » is Equal To « ( " Success " ) ; }
@Test { new » Default Controller Spec « ( new » My Controller « ( ) ) . » controller Advice « ( new » My Controller Advice « ( ) ) . build ( ) . get ( ) . uri ( " / exception " ) . exchange ( ) . » expect Status « ( ) . » is Bad Request « ( ) . » expect Body « ( String . class ) . » is Equal To « ( " Handled exception " ) ; }
@Test { new » Default Controller Spec « ( » My Controller « . class ) . » controller Advice « ( » My Controller Advice « . class ) . build ( ) . get ( ) . uri ( " / exception " ) . exchange ( ) . » expect Status « ( ) . » is Bad Request « ( ) . » expect Body « ( String . class ) . » is Equal To « ( " Handled exception " ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . add ( " foo " , " bar " ) ; » Header Assertions « assertions = » header Assertions « ( headers ) ; assertions . value ( " foo " , » contains String « ( " a " ) ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » APPLICATION _ JSON « ) ; » Header Assertions « assertions = » header Assertions « ( headers ) ; assertions . exists ( " Content - Type " ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . exists ( " Framework " ) ) . satisfies ( ex -> » assert That « ( ex . » get Cause « ( ) ) . » has Message « ( " Response header 'Framework' does not exist " ) ) ; }
@Test { » Cache Control « control = » Cache Control « . » max Age « ( 1 , » Time Unit « . HOURS ) . » no Transform « ( ) ; » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Cache Control « ( control . » get Header Value « ( ) ) ; » Header Assertions « assertions = » header Assertions « ( headers ) ; assertions . » cache Control « ( control ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » cache Control « ( » Cache Control « . » no Store « ( ) ) ) ; }
@Test { » Test Http Handler « handler = new » Test Http Handler « ( response -> { » assert That « ( Schedulers . » is In Non Blocking Thread « ( ) ) . » is True « ( ) ; response . » set Status Code « ( » Http Status « . OK ) ; return response . » set Complete « ( ) ; } ) ; new » Http Handler Connector « ( handler ) . connect ( » Http Method « . POST , URI . create ( " / path " ) , request -> request . » write With « ( Mono . empty ( ) ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . CONFLICT ) ; assertions . » is Equal To « ( » Http Status « . CONFLICT ) ; assertions . » is Equal To « ( 409 ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is Equal To « ( » Http Status « . » REQUEST _ TIMEOUT « ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is Equal To « ( 408 ) ) ; }
@Test { » status Assertions « ( 600 ) . » is Equal To « ( 600 ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . CONFLICT ) ; assertions . » reason Equals « ( " Conflict " ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » reason Equals « ( " Request Timeout " ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . CONTINUE ) ; assertions . » is 1 xx Informational « ( ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is 2 xx Successful « ( ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . OK ) ; assertions . » is 2 xx Successful « ( ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is 5 xx Server Error « ( ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . » PERMANENT _ REDIRECT « ) ; assertions . » is 3 xx Redirection « ( ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is 2 xx Successful « ( ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . » BAD _ REQUEST « ) ; assertions . » is 4 xx Client Error « ( ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is 2 xx Successful « ( ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . » INTERNAL _ SERVER _ ERROR « ) ; assertions . » is 5 xx Server Error « ( ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . » is 2 xx Successful « ( ) ) ; }
@Test { » Status Assertions « assertions = » status Assertions « ( » Http Status « . CONFLICT ) ; assertions . value ( » equal To « ( 409 ) ) ; assertions . value ( » greater Than « ( 400 ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> assertions . value ( » equal To « ( 200 ) ) ) ; }
@Test { this . client . get ( ) . uri ( " / invalid " ) . exchange ( ) . » expect Status « ( ) . » is Not Found « ( ) . » expect Body « ( Void . class ) ; }
@Test { this . client . get ( ) . uri ( " / server - error " ) . exchange ( ) . » expect Status « ( ) . » is Equal To « ( » Http Status « . » INTERNAL _ SERVER _ ERROR « ) . » expect Body « ( Void . class ) ; }
@Test { this . » web Test Client « . get ( ) . uri ( " / » user Identity « " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( String . class ) . » is Equal To « ( " Hello Pablo ! " ) ; }
@Test { this . » web Test Client « . » mutate With « ( identity ( " Giovanni " ) ) . get ( ) . uri ( " / » user Identity « " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( String . class ) . » is Equal To « ( " Hello Giovanni ! " ) ; }
@Test { this . client . get ( ) . uri ( " / header - echo " ) . header ( " » h 1 « " , " in " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » value Equals « ( " » h 1 « " , " in - out " ) ; }
@Test { this . client . get ( ) . uri ( " / header - multi - value " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » value Equals « ( " » h 1 « " , " » v 1 « " , " » v 2 « " , " » v 3 « " ) ; }
@Test { this . client . get ( ) . uri ( " / cookie - echo " ) . cookies ( cookies -> cookies . add ( " » k 1 « " , " » v 1 « " ) ) . exchange ( ) . » expect Header « ( ) . » value Matches « ( " Set - Cookie " , " » k 1 « = » v 1 « " ) ; }
@Test { this . client . get ( ) . uri ( " / persons " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( ) . json ( " [ { \" name \" : \" Jane \" } , { \" name \" : \" Jason \" } , { \" name \" : \" John \" } ] " ) ; }
@Test { this . client . get ( ) . uri ( " / persons " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( ) . » json Path « ( " $ [ 0 ] . name " ) . » is Equal To « ( " Jane " ) . » json Path « ( " $ [ 1 ] . name " ) . » is Equal To « ( " Jason " ) . » json Path « ( " $ [ 2 ] . name " ) . » is Equal To « ( " John " ) ; }
@Test { this . client . get ( ) . uri ( " / persons / John " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( ) . » json Path « ( " $ . name " ) . value ( » contains String « ( " oh " ) ) ; }
@Test { this . client . post ( ) . uri ( " / persons " ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . » body Value « ( " { \" name \" : \" John \" } " ) . exchange ( ) . » expect Status « ( ) . » is Created « ( ) . » expect Body « ( ) . » is Empty « ( ) ; }
@Test { this . client . get ( ) . uri ( " / John " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . » expect Body « ( Person . class ) . » is Equal To « ( new Person ( " John " ) ) ; }
@Test { this . client . get ( ) . uri ( " / John " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . » expect Body « ( Person . class ) . value ( Person :: » get Name « , » starts With « ( " Joh " ) ) ; }
@Test { this . client . get ( ) . uri ( " / John " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . » expect Body « ( Person . class ) . » consume With « ( result -> » assert That « ( result . » get Response Body « ( ) ) . » is Equal To « ( new Person ( " John " ) ) ) ; }
@Test { List < Person > expected = Arrays . » as List « ( new Person ( " Jane " ) , new Person ( " Jason " ) , new Person ( " John " ) ) ; this . client . get ( ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . » expect Body List « ( Person . class ) . » is Equal To « ( expected ) ; }
@Test { this . client . get ( ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Header « ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . » expect Body List « ( Person . class ) . value ( people -> » assert That « ( people ) . contains ( new Person ( " Jason " ) ) ) ; }
@Test { Map < String , Person > map = new » Linked Hash Map « < > ( ) ; map . put ( " Jane " , new Person ( " Jane " ) ) ; map . put ( " Jason " , new Person ( " Jason " ) ) ; map . put ( " John " , new Person ( " John " ) ) ; this . client . get ( ) . uri ( " ? map = true " ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( new » Parameterized Type Reference « < Map < String , Person > > ( ) { } ) . » is Equal To « ( map ) ; }
@Test { this . client . post ( ) . » body Value « ( new Person ( " John " ) ) . exchange ( ) . » expect Status « ( ) . » is Created « ( ) . » expect Header « ( ) . » value Equals « ( " location " , " / persons / John " ) . » expect Body « ( ) . » is Empty « ( ) ; }
@Test { this . client . get ( ) . uri ( " / persons " ) . accept ( » Media Type « . » APPLICATION _ XML « ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( ) . xml ( » persons _ XML « ) ; }
@Test { this . client . get ( ) . uri ( " / persons " ) . accept ( » Media Type « . » APPLICATION _ XML « ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( ) . xpath ( " » // person / name « " ) . string ( » starts With « ( " J " ) ) ; }
@Test { this . client . get ( ) . uri ( " / persons / John " ) . accept ( » Media Type « . » APPLICATION _ XML « ) . exchange ( ) . » expect Status « ( ) . » is Ok « ( ) . » expect Body « ( ) . xpath ( " » // name « [ contains ( text ( ) , » ' oh « ' ) ] " ) . exists ( ) ; }
@Test { String content = " < ? xml version = \" 1.0 \" encoding = \" UTF - 8 \" standalone = \" yes \" ? > " + " < person > < name > John < / name > < / person > " ; this . client . post ( ) . uri ( " / persons " ) . » content Type « ( » Media Type « . » APPLICATION _ XML « ) . » body Value « ( content ) . exchange ( ) . » expect Status « ( ) . » is Created « ( ) . » expect Header « ( ) . » value Equals « ( » Http Headers « . LOCATION , " / persons / John " ) . » expect Body « ( ) . » is Empty « ( ) ; }
@Test { this . » mvc Result « . » set Async Result « ( " Foo " ) ; this . » mvc Result « . » set Async Dispatch Latch « ( new » Count Down Latch « ( 0 ) ) ; this . » mvc Result « . » get Async Result « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » mvc Result « . » get Async Result « ( 0 ) ) ; }
@Test { this . mvc . perform ( get ( " / " ) ) . » and Expect « ( content ( ) . string ( HELLO ) ) ; this . mvc . perform ( get ( " / " ) . param ( ENIGMA , " " ) ) . » and Expect « ( content ( ) . string ( ENIGMA ) ) ; this . mvc . perform ( get ( " / " ) ) . » and Expect « ( content ( ) . string ( HELLO ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Mvc Web Client Builder « . » mock Mvc Setup « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Mvc Web Client Builder « . » web App Context Setup « ( null ) ) ; }
@Test { » Web Client « client = » Mock Mvc Web Client Builder « . » mock Mvc Setup « ( this . » mock Mvc « ) . build ( ) ; » assert Mock Mvc Used « ( client , " http : » // localhost / test « " ) ; if ( » Test Group « . PERFORMANCE . » is Active « ( ) ) { » assert Mock Mvc Not Used « ( client , " https : » // spring . io / « " ) ; } }
@Test { » Web Client « » other Client « = new » Web Client « ( ) ; » Web Client « client = » Mock Mvc Web Client Builder « . » mock Mvc Setup « ( this . » mock Mvc « ) . » with Delegate « ( » other Client « ) . build ( ) ; » assert Mock Mvc Used « ( client , " http : » // localhost / test « " ) ; if ( » Test Group « . PERFORMANCE . » is Active « ( ) ) { » assert Mock Mvc Not Used « ( client , " https : » // spring . io / « " ) ; } }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Web Response Builder « ( 0L , null , this . response ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Web Response Builder « ( 0L , new » Web Request « ( new URL ( " http : » // company . example : 80 / test / this / here « " ) ) , null ) ) ; }
@Test { this . response . » get Writer « ( ) . write ( " expected content " ) ; » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Content As String « ( ) ) . » is Equal To « ( " expected content " ) ; }
@Test { this . response . » add Header « ( " Content - Type " , " text / html ; charset = UTF - 8 " ) ; » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Content Charset « ( ) ) . » is Equal To « ( » Standard Charsets « . » UTF _ 8 « ) ; }
@Test { this . response . » add Header « ( " Content - Type " , " text / html ; charset - UTF - 8 " ) ; » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Content Type « ( ) ) . » is Equal To « ( " text / html " ) ; }
@Test { » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Status Code « ( ) ) . » is Equal To « ( 200 ) ; » assert That « ( » web Response « . » get Status Message « ( ) ) . » is Equal To « ( " OK " ) ; }
@Test { this . response . » set Status « ( 401 ) ; » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Status Code « ( ) ) . » is Equal To « ( 401 ) ; » assert That « ( » web Response « . » get Status Message « ( ) ) . » is Equal To « ( " Unauthorized " ) ; }
@Test { this . response . » send Error « ( 401 , " Custom " ) ; » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Status Code « ( ) ) . » is Equal To « ( 401 ) ; » assert That « ( » web Response « . » get Status Message « ( ) ) . » is Equal To « ( " Custom " ) ; }
@Test { » Web Response « » web Response « = this . » response Builder « . build ( ) ; » assert That « ( » web Response « . » get Web Request « ( ) ) . » is Equal To « ( this . » web Request « ) ; }
@Test { » Web Request Matcher « » cdn Matcher « = new » Url Regex Request Matcher « ( " . * ? » // code . jquery . com / « . * " ) ; » assert Matches « ( » cdn Matcher « , " https : » // code . jquery . com / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( » cdn Matcher « , " http : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; }
@Test { » Web Request Matcher « matcher = new » Host Request Matcher « ( " localhost " ) ; » assert Matches « ( matcher , " http : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( matcher , " http : » // company . example / jquery - 1 . 11 . 0 . min . js « " ) ; }
@Test { » Web Request Matcher « matcher = new » Host Request Matcher « ( " localhost " , " example . com " ) ; » assert Matches « ( matcher , " http : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Matches « ( matcher , " https : » // example . com / jquery - 1 . 11 . 0 . min . js « " ) ; }
@Test { » Web Request Matcher « matcher = new » Host Request Matcher « ( " localhost : 8080 " ) ; » assert Matches « ( matcher , " http : » // localhost : 8080 / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( matcher , " http : » // localhost : 9090 / jquery - 1 . 11 . 0 . min . js « " ) ; }
@Test { » Web Request Matcher « matcher = new » Host Request Matcher « ( " localhost : 80 " ) ; » assert Matches « ( matcher , " http : » // localhost : 80 / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Matches « ( matcher , " http : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( matcher , " https : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( matcher , " http : » // localhost : 9090 / jquery - 1 . 11 . 0 . min . js « " ) ; }
@Test { » Web Request Matcher « matcher = new » Host Request Matcher « ( " localhost : 443 " ) ; » assert Matches « ( matcher , " https : » // localhost : 443 / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Matches « ( matcher , " https : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( matcher , " http : » // localhost / jquery - 1 . 11 . 0 . min . js « " ) ; » assert Does Not Match « ( matcher , " https : » // localhost : 9090 / jquery - 1 . 11 . 0 . min . js « " ) ; }
@Test { this . » web Client « . » set Web Connection « ( new » Mock Mvc Web Connection « ( this . » mock Mvc « , this . » web Client « , null ) ) ; Page page = this . » web Client « . » get Page « ( " http : » // localhost / context / a « " ) ; » assert That « ( page . » get Web Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( 200 ) ; }
@Test { this . » web Client « . » set Web Connection « ( new » Mock Mvc Web Connection « ( this . » mock Mvc « , this . » web Client « , " / context " ) ) ; Page page = this . » web Client « . » get Page « ( " http : » // localhost / context / a « " ) ; » assert That « ( page . » get Web Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( 200 ) ; }
@Test { this . » web Client « . » set Web Connection « ( new » Mock Mvc Web Connection « ( this . » mock Mvc « , this . » web Client « , " " ) ) ; Page page = this . » web Client « . » get Page « ( " http : » // localhost / forward « " ) ; » assert That « ( page . » get Web Response « ( ) . » get Content As String « ( ) ) . » is Equal To « ( " hello " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Mvc Web Connection « ( this . » mock Mvc « , this . » web Client « , " context " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Mvc Web Connection « ( this . » mock Mvc « , this . » web Client « , " / context / " ) ) ; }
@Test { given ( » default Connection « . » get Response « ( request ) ) . » will Return « ( » expected Response « ) ; » Web Response « response = » web Connection « . » get Response « ( request ) ; » assert That « ( response ) . » is Same As « ( » expected Response « ) ; verify ( » matcher 1 « ) . matches ( request ) ; verify ( » matcher 2 « ) . matches ( request ) ; » verify No More Interactions « ( » connection 1 « , » connection 2 « ) ; verify ( » default Connection « ) . » get Response « ( request ) ; }
@Test { given ( » matcher 1 « . matches ( request ) ) . » will Return « ( true ) ; given ( » connection 1 « . » get Response « ( request ) ) . » will Return « ( » expected Response « ) ; » Web Response « response = » web Connection « . » get Response « ( request ) ; » assert That « ( response ) . » is Same As « ( » expected Response « ) ; verify ( » matcher 1 « ) . matches ( request ) ; » verify No More Interactions « ( » matcher 2 « , » connection 2 « , » default Connection « ) ; verify ( » connection 1 « ) . » get Response « ( request ) ; }
@Test { given ( » matcher 2 « . matches ( request ) ) . » will Return « ( true ) ; given ( » connection 2 « . » get Response « ( request ) ) . » will Return « ( » expected Response « ) ; » Web Response « response = » web Connection « . » get Response « ( request ) ; » assert That « ( response ) . » is Same As « ( » expected Response « ) ; verify ( » matcher 1 « ) . matches ( request ) ; verify ( » matcher 2 « ) . matches ( request ) ; » verify No More Interactions « ( » connection 1 « , » default Connection « ) ; verify ( » connection 2 « ) . » get Response « ( request ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Html Unit Request Builder « ( null , » web Client « , » web Request « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Html Unit Request Builder « ( sessions , null , » web Request « ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Html Unit Request Builder « ( sessions , » web Client « , null ) ) ; }
@Test { » web Request « . » set Charset « ( » Standard Charsets « . » UTF _ 8 « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Character Encoding « ( ) ) . » is Equal To « ( " ISO - 8859 - 1 " ) ; }
@Test { String content = " some content that has length " ; » web Request « . » set Http Method « ( » Http Method « . POST ) ; » web Request « . » set Request Body « ( content ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Content Length « ( ) ) . » is Equal To « ( content . length ( ) ) ; }
@Test { String » content Type « = " text / html ; charset = UTF - 8 " ; » web Request « . » set Additional Header « ( " Content - Type " , » content Type « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Content Type « ( ) ) . » is Equal To « ( » content Type « ) ; » assert That « ( » actual Request « . » get Header « ( " Content - Type " ) ) . » is Equal To « ( » content Type « ) ; }
@Test { » web Request « . » set Encoding Type « ( » Form Encoding Type « . » URL _ ENCODED « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Content Type « ( ) ) . » is Equal To « ( " application / x - www - form - urlencoded " ) ; » assert That « ( » actual Request « . » get Header « ( " Content - Type " ) ) . » is Equal To « ( " application / x - www - form - urlencoded ; charset = ISO - 8859 - 1 " ) ; }
@Test { String » context Path « = » request Builder « . » build Request « ( » servlet Context « ) . » get Context Path « ( ) ; » assert That « ( » context Path « ) . » is Equal To « ( " / test " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / « " ) ) ; String » context Path « = » request Builder « . » build Request « ( » servlet Context « ) . » get Context Path « ( ) ; » assert That « ( » context Path « ) . » is Equal To « ( " " ) ; }
@Test { » request Builder « . » set Context Path « ( " / invalid " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » request Builder « . » build Request « ( » servlet Context « ) . » get Context Path « ( ) ) ; }
@Test { String expected = " " ; » request Builder « . » set Context Path « ( expected ) ; String » context Path « = » request Builder « . » build Request « ( » servlet Context « ) . » get Context Path « ( ) ; » assert That « ( » context Path « ) . » is Equal To « ( expected ) ; }
@Test { String expected = " / test " ; » request Builder « . » set Context Path « ( expected ) ; String » context Path « = » request Builder « . » build Request « ( » servlet Context « ) . » get Context Path « ( ) ; » assert That « ( » context Path « ) . » is Equal To « ( expected ) ; }
@Test { String expected = " / test / this " ; » request Builder « . » set Context Path « ( expected ) ; String » context Path « = » request Builder « . » build Request « ( » servlet Context « ) . » get Context Path « ( ) ; » assert That « ( » context Path « ) . » is Equal To « ( expected ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Cookies « ( ) ) . » is Null « ( ) ; }
@Test { » web Request « . » set Additional Header « ( " Cookie " , " name = value " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; Cookie [ ] cookies = » actual Request « . » get Cookies « ( ) ; » assert That « ( cookies . length ) . » is Equal To « ( 1 ) ; » assert That « ( cookies [ 0 ] . » get Name « ( ) ) . » is Equal To « ( " name " ) ; » assert That « ( cookies [ 0 ] . » get Value « ( ) ) . » is Equal To « ( " value " ) ; }
@Test { String content = " some content that has length " ; » web Request « . » set Http Method « ( » Http Method « . POST ) ; » web Request « . » set Request Body « ( content ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » IO Utils « . » to String « ( » actual Request « . » get Input Stream « ( ) ) ) . » is Equal To « ( content ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Local Addr « ( ) ) . » is Equal To « ( " 127.0 .0 .1 " ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Locale « ( ) ) . » is Equal To « ( Locale . » get Default « ( ) ) ; }
@Test { » web Request « . » set Additional Header « ( " Accept - Language " , " da " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Locale « ( ) ) . » is Equal To « ( new Locale ( " da " ) ) ; }
@Test { » web Request « . » set Additional Header « ( " Accept - Language " , " en - gb ; q = 0.8 " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Locale « ( ) ) . » is Equal To « ( new Locale ( " en " , " gb " ) ) ; }
@Test { » web Request « . » set Additional Header « ( " Accept - Language " , " en " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Locale « ( ) ) . » is Equal To « ( new Locale ( " en " , " " ) ) ; }
@Test { » web Request « . » set Additional Header « ( " Accept - Language " , " en - US " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Locale « ( ) ) . » is Equal To « ( Locale . US ) ; }
@Test { » web Request « . » set Additional Header « ( " Accept - Language " , " fr " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Locale « ( ) ) . » is Equal To « ( Locale . FRENCH ) ; }
@Test { » web Request « . » set Additional Header « ( " Accept - Language " , " en - gb ; q = 0.8 , da , en ; q = 0.7 " ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( Collections . list ( » actual Request « . » get Locales « ( ) ) ) . » contains Exactly « ( new Locale ( " da " ) , new Locale ( " en " , " gb " ) , new Locale ( " en " , " " ) ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Local Name « ( ) ) . » is Equal To « ( " localhost " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " http : » // localhost : 80 / test / this / here « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Local Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { » web Request « . » set Url « ( new URL ( " http : » // localhost / test / this « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Local Port « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { for ( » Http Method « » expected Method « : » Http Method « . values ( ) ) { » web Request « . » set Http Method « ( » expected Method « ) ; String » actual Method « = » request Builder « . » build Request « ( » servlet Context « ) . » get Method « ( ) ; » assert That « ( » actual Method « ) . » is Equal To « ( » expected Method « . name ( ) ) ; } }
@Test { » web Request « . » set Request Parameters « ( Arrays . » as List « ( new » Name Value Pair « ( " name " , " value " ) ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { » web Request « . » set Request Parameters « ( Arrays . » as List « ( new » Name Value Pair « ( " name " , null ) ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Null « ( ) ; }
@Test { » web Request « . » set Request Parameters « ( Arrays . » as List « ( new » Name Value Pair « ( " name " , " " ) ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example / « ? » name = value « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example / « ? row % » 5 B 0 « % » 5 D = value « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " row [ 0 ] " ) ) . » is Equal To « ( " value " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example / « ? » name = row « % » 5 B 0 « % » 5 D « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " row [ 0 ] " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example / « ? name " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example / « ? » name = « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example / « ? » name = « % 20 " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Parameter Map « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » actual Request « . » get Parameter « ( " name " ) ) . » is Equal To « ( " " ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Path Info « ( ) ) . » is Null « ( ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / example « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Path Info « ( ) ) . » is Null « ( ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / app / login / authenticate « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Path Info « ( ) ) . » is Null « ( ) ; » assert That « ( » actual Request « . » get Servlet Path « ( ) ) . » is Equal To « ( " / login / authenticate " ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Protocol « ( ) ) . » is Equal To « ( " HTTP / 1.1 " ) ; }
@Test { String » expected Query « = " param = value " ; » web Request « . » set Url « ( new URL ( " https : » // example . com / example « ? " + » expected Query « ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Query String « ( ) ) . » is Equal To « ( » expected Query « ) ; }
@Test { String » expected Query « = " param " ; » web Request « . » set Url « ( new URL ( " https : » // example . com / example « ? " + » expected Query « ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Query String « ( ) ) . » is Equal To « ( » expected Query « ) ; }
@Test { String » expected Query « = " param = " ; » web Request « . » set Url « ( new URL ( " https : » // example . com / example « ? " + » expected Query « ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Query String « ( ) ) . » is Equal To « ( » expected Query « ) ; }
@Test { String » expected Query « = " param = % 20 " ; » web Request « . » set Url « ( new URL ( " https : » // example . com / example « ? " + » expected Query « ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Query String « ( ) ) . » is Equal To « ( » expected Query « ) ; }
@Test { String » expected Query « = " » param 1 « = » value 1 « & » param 2 « = » value 2 « " ; » web Request « . » set Url « ( new URL ( " https : » // example . com / example « ? " + » expected Query « ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Query String « ( ) ) . » is Equal To « ( » expected Query « ) ; }
@Test { String » expected Body « = " request body " ; » web Request « . » set Http Method « ( » Http Method « . POST ) ; » web Request « . » set Request Body « ( » expected Body « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » IO Utils « . » to String « ( » actual Request « . » get Reader « ( ) ) ) . » is Equal To « ( » expected Body « ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Remote Addr « ( ) ) . » is Equal To « ( " 127.0 .0 .1 " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " http : » // localhost : 80 / test / this / here « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Remote Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com : 8080 / « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Remote Port « ( ) ) . » is Equal To « ( 8080 ) ; }
@Test { » web Request « . » set Url « ( new URL ( " http : » // company . example / « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Remote Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { String » session Id « = " session - id " ; » web Request « . » set Additional Header « ( " Cookie " , " JSESSIONID = " + » session Id « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Requested Session Id « ( ) ) . » is Equal To « ( » session Id « ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Requested Session Id « ( ) ) . » is Null « ( ) ; }
@Test { String uri = » request Builder « . » build Request « ( » servlet Context « ) . » get Request URI « ( ) ; » assert That « ( uri ) . » is Equal To « ( " / test / this / here " ) ; }
@Test { String uri = » request Builder « . » build Request « ( » servlet Context « ) . » get Request URL « ( ) . » to String « ( ) ; » assert That « ( uri ) . » is Equal To « ( " https : » // example . com / test / this / here « " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " http : » // localhost : 80 / test / this / here « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Scheme « ( ) ) . » is Equal To « ( " http " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Scheme « ( ) ) . » is Equal To « ( " https " ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Server Name « ( ) ) . » is Equal To « ( " example . com " ) ; }
@Test { » web Request « . » set Url « ( new URL ( " http : » // localhost : 80 / test / this / here « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Server Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { » web Request « . » set Url « ( new URL ( " https : » // example . com / « " ) ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Server Port « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Servlet Context « ( ) ) . » is Equal To « ( » servlet Context « ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Servlet Path « ( ) ) . » is Equal To « ( " / this / here " ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » Http Session « session = » actual Request « . » get Session « ( true ) ; » assert That « ( session ) . » is Not Null « ( ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » Http Session « session = » actual Request « . » get Session « ( false ) ; » assert That « ( session ) . » is Null « ( ) ; }
@Test { String » session Id « = " session - id " ; » web Request « . » set Additional Header « ( " Cookie " , " JSESSIONID = " + » session Id « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » Http Session « session = » actual Request « . » get Session « ( false ) ; » assert That « ( session ) . » is Not Null « ( ) ; }
@Test { » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Session « ( ) . » is New « ( ) ) . » is Equal To « ( true ) ; }
@Test { String » session Id « = " session - id " ; » web Request « . » set Additional Header « ( " Cookie " , " JSESSIONID = " + » session Id « ) ; » Mock Http Servlet Request « » actual Request « = » request Builder « . » build Request « ( » servlet Context « ) ; » assert That « ( » actual Request « . » get Session « ( ) . » is New « ( ) ) . » is Equal To « ( false ) ; }
@Test { » request Builder « . » set Context Path « ( null ) ; » assert That « ( » get Context Path « ( ) ) . » is Null « ( ) ; }
@Test { » request Builder « . » set Context Path « ( " " ) ; » assert That « ( » get Context Path « ( ) ) . » is Empty « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » request Builder « . » set Context Path « ( " abc / def " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » request Builder « . » set Context Path « ( " / abc / def / " ) ) ; }
@Test { String » expected Context Path « = " / abc / def " ; » request Builder « . » set Context Path « ( » expected Context Path « ) ; » assert That « ( » get Context Path « ( ) ) . » is Equal To « ( » expected Context Path « ) ; }
@Test { String » header Name « = " PARENT " ; String » header Value « = " VALUE " ; » Mock Mvc « » mock Mvc « = » Mock Mvc Builders « . » standalone Setup « ( new » Hello Controller « ( ) ) . » default Request « ( get ( " / " ) . header ( » header Name « , » header Value « ) ) . build ( ) ; » assert That « ( » mock Mvc « . perform ( » request Builder « ) . » and Return « ( ) . » get Request « ( ) . » get Header « ( » header Name « ) ) . » is Equal To « ( » header Value « ) ; }
@Test { String » attr Name « = " PARENT " ; String » attr Value « = " VALUE " ; » Mock Mvc « » mock Mvc « = » Mock Mvc Builders « . » standalone Setup « ( new » Hello Controller « ( ) ) . » default Request « ( get ( " / " ) . » session Attr « ( » attr Name « , » attr Value « ) ) . build ( ) ; » assert That « ( » mock Mvc « . perform ( » request Builder « ) . » and Return « ( ) . » get Request « ( ) . » get Session « ( ) . » get Attribute « ( » attr Name « ) ) . » is Equal To « ( » attr Value « ) ; }
@Test { » Mock Mvc « » mock Mvc « = » Mock Mvc Builders « . » standalone Setup « ( new » Hello Controller « ( ) ) . » default Request « ( get ( " / " ) ) . build ( ) ; » assert That « ( » mock Mvc « . perform ( » request Builder « ) . » and Return « ( ) . » get Request « ( ) . » get Session « ( false ) ) . » is Null « ( ) ; }
@Test { String » attr Name « = " PARENT " ; String » attr Value « = " VALUE " ; » Mock Mvc « » mock Mvc « = » Mock Mvc Builders « . » standalone Setup « ( new » Hello Controller « ( ) ) . » default Request « ( get ( " / " ) . » request Attr « ( » attr Name « , » attr Value « ) ) . build ( ) ; » assert That « ( » mock Mvc « . perform ( » request Builder « ) . » and Return « ( ) . » get Request « ( ) . » get Attribute « ( » attr Name « ) ) . » is Equal To « ( » attr Value « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Mvc Web Connection Builder Support « ( ( » Mock Mvc « ) null ) { } ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Mock Mvc Web Connection Builder Support « ( ( » Web Application Context « ) null ) { } ) ; }
@Test { » Web Connection « conn = this . builder . » create Connection « ( this . client ) ; » assert Mock Mvc Used « ( conn , " http : » // localhost / « " ) ; » assert Mock Mvc Not Used « ( conn , " https : » // example . com / « " ) ; }
@Test { » Mock Mvc « » mock Mvc « = » Mock Mvc Builders « . » web App Context Setup « ( wac ) . build ( ) ; » Web Connection « conn = new » Mock Mvc Web Connection Builder Support « ( » mock Mvc « ) { } . » create Connection « ( this . client ) ; » assert Mock Mvc Used « ( conn , " http : » // localhost / « " ) ; » assert Mock Mvc Not Used « ( conn , " https : » // example . com / « " ) ; }
@Test { » Web Connection « conn = this . builder . » use Mock Mvc For Hosts « ( " example . com " ) . » create Connection « ( this . client ) ; » assert Mock Mvc Used « ( conn , " http : » // localhost / « " ) ; » assert Mock Mvc Used « ( conn , " https : » // example . com / « " ) ; » assert Mock Mvc Not Used « ( conn , " http : » // other . example / « " ) ; }
@Test { » Web Connection « conn = this . builder . » always Use Mock Mvc « ( ) . » create Connection « ( this . client ) ; » assert Mock Mvc Used « ( conn , " http : » // other . example / « " ) ; }
@Test { » Web Connection « conn = this . builder . » create Connection « ( this . client ) ; » assert That « ( » get Response « ( conn , " http : » // localhost / abc « " ) . » get Content As String « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Web Connection « conn = this . builder . » context Path « ( " / abc " ) . » create Connection « ( this . client ) ; » assert That « ( » get Response « ( conn , " http : » // localhost / abc / def « " ) . » get Content As String « ( ) ) . » is Equal To « ( " / abc " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Mvc Html Unit Driver Builder « . » web App Context Setup « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Mvc Html Unit Driver Builder « . » mock Mvc Setup « ( null ) ) ; }
@Test { » Web Connection Html Unit Driver « » other Driver « = new » Web Connection Html Unit Driver « ( ) ; this . driver = » Mock Mvc Html Unit Driver Builder « . » mock Mvc Setup « ( this . » mock Mvc « ) . » with Delegate « ( » other Driver « ) . build ( ) ; » assert Mock Mvc Used « ( " http : » // localhost / test « " ) ; if ( » Test Group « . PERFORMANCE . » is Active « ( ) ) { » assert Mock Mvc Not Used « ( " https : » // example . com / « " ) ; } }
@Test { this . driver = » Mock Mvc Html Unit Driver Builder « . » mock Mvc Setup « ( this . » mock Mvc « ) . build ( ) ; » assert Mock Mvc Used « ( " http : » // localhost / test « " ) ; if ( » Test Group « . PERFORMANCE . » is Active « ( ) ) { » assert Mock Mvc Not Used « ( " https : » // example . com / « " ) ; } }
@Test { this . driver = » Mock Mvc Html Unit Driver Builder « . » mock Mvc Setup « ( this . » mock Mvc « ) . build ( ) ; » assert That « ( this . driver . » is Javascript Enabled « ( ) ) . » is True « ( ) ; }
@Test { this . driver = » Mock Mvc Html Unit Driver Builder « . » mock Mvc Setup « ( this . » mock Mvc « ) . » javascript Enabled « ( false ) . build ( ) ; » assert That « ( this . driver . » is Javascript Enabled « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . driver . » get Web Connection « ( ) ) . » is Not Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . driver . » set Web Connection « ( null ) ) ; }
@Test { this . driver . » set Web Connection « ( this . connection ) ; » assert That « ( this . driver . » get Web Connection « ( ) ) . » is Equal To « ( this . connection ) ; » assert That Exception Of Type « ( » Web Driver Exception « . class ) . » is Thrown By « ( ( ) -> this . driver . get ( " https : » // example . com « " ) ) ; }
@Test { » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Method « ( ) ) . » is Equal To « ( " GET " ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , " / foo bar " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Request URI « ( ) ) . » is Equal To « ( " / foo % 20 bar " ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , new URI ( " » / test // currently Valid / 0 « " ) ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Request URI « ( ) ) . » is Equal To « ( " » / test // currently Valid / 0 « " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Mock Mvc Request Builders « . get ( " localhost : 8080 / path " ) ) . » with Message « ( " 'url' should start with a path or be a complete HTTP URL : localhost : 8080 / path " ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , " / foo " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Context Path « ( ) ) . » is Equal To « ( " " ) ; » assert That « ( request . » get Servlet Path « ( ) ) . » is Equal To « ( " " ) ; » assert That « ( request . » get Path Info « ( ) ) . » is Equal To « ( " / foo " ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , " / travel / hotels 42 " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Path Info « ( ) ) . » is Equal To « ( " / travel / hotels 42 " ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , " » / foo « # bar " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Request URI « ( ) ) . » is Equal To « ( " / foo " ) ; }
@Test { this . builder . param ( " foo " , " bar " , " baz " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; Map < String , String [ ] > » parameter Map « = request . » get Parameter Map « ( ) ; » assert That « ( » parameter Map « . get ( " foo " ) ) . » is Equal To « ( new String [ ] { " bar " , " baz " } ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , " / ? foo = { value } " , " bar = baz " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Query String « ( ) ) . » is Equal To « ( " foo = bar % 3D baz " ) ; » assert That « ( request . » get Parameter « ( " foo " ) ) . » is Equal To « ( " bar = baz " ) ; }
@Test { this . builder = new » Mock Http Servlet Request Builder « ( » Http Method « . GET , " / ? foo " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; Map < String , String [ ] > » parameter Map « = request . » get Parameter Map « ( ) ; » assert That « ( » parameter Map « . get ( " foo " ) ) . » is Equal To « ( new String [ ] { null } ) ; » assert That « ( request . » get Query String « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { this . builder . accept ( " any " , " » any 2 « " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Header « ( " Accept " ) ) . » is Equal To « ( " any , » any 2 « " ) ; }
@Test { this . builder . » content Type « ( " any " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( " any " ) ; }
@Test { this . builder . header ( " Content - Type " , » Media Type « . » TEXT _ HTML _ VALUE « ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; String » content Type « = request . » get Content Type « ( ) ; » assert That « ( » content Type « ) . » is Equal To « ( " text / html " ) ; }
@Test { this . builder . header ( " Content - Type " , " yaml " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( " yaml " ) ; }
@Test { this . builder . header ( " Content - Type " , » Media Type « . » TEXT _ HTML _ VALUE « , » Media Type « . » ALL _ VALUE « ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Content Type « ( ) ) . » is Equal To « ( " text / html " ) ; }
@Test { byte [ ] body = " Hello World " . » get Bytes « ( " UTF - 8 " ) ; this . builder . content ( body ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; byte [ ] result = » File Copy Utils « . » copy To Byte Array « ( request . » get Input Stream « ( ) ) ; » assert That « ( result ) . » is Equal To « ( body ) ; » assert That « ( request . » get Content Length « ( ) ) . » is Equal To « ( body . length ) ; }
@Test { this . builder . header ( " foo " , " bar " , " baz " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; List < String > headers = Collections . list ( request . » get Headers « ( " foo " ) ) ; » assert That « ( headers . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( headers . get ( 0 ) ) . » is Equal To « ( " bar " ) ; » assert That « ( headers . get ( 1 ) ) . » is Equal To « ( " baz " ) ; }
@Test { » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Cookies « ( ) ) . » is Null « ( ) ; }
@Test { Locale locale = new Locale ( " nl " , " nl " ) ; this . builder . locale ( locale ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Locale « ( ) ) . » is Equal To « ( locale ) ; }
@Test { String encoding = " UTF - 8 " ; this . builder . » character Encoding « ( encoding ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Character Encoding « ( ) ) . » is Equal To « ( encoding ) ; }
@Test { this . builder . » request Attr « ( " foo " , " bar " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Attribute « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { this . builder . » session Attr « ( " foo " , " bar " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Session « ( ) . » get Attribute « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " foo " , " bar " ) ; this . builder . » session Attrs « ( map ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get Session « ( ) . » get Attribute « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { this . builder . » flash Attr « ( " foo " , " bar " ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » Flash Map « » flash Map « = new » Session Flash Map Manager « ( ) . » retrieve And Update « ( request , null ) ; » assert That « ( ( Object ) » flash Map « ) . » is Not Null « ( ) ; » assert That « ( » flash Map « . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { User user = new User ( ) ; this . builder . principal ( user ) ; » Mock Http Servlet Request « request = this . builder . » build Request « ( this . » servlet Context « ) ; » assert That « ( request . » get User Principal « ( ) ) . » is Equal To « ( user ) ; }
@Test { new » Content Result Matchers « ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON _ VALUE « ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Content Result Matchers « ( ) . » content Type « ( " text / plain " ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ) ; }
@Test { new » Content Result Matchers « ( ) . string ( new String ( CONTENT . » get Bytes « ( " UTF - 8 " ) ) ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Content Result Matchers « ( ) . encoding ( " bogus " ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ) ; }
@Test { String content = new String ( CONTENT . » get Bytes « ( " UTF - 8 " ) ) ; new » Content Result Matchers « ( ) . string ( Matchers . » equal To « ( content ) ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Content Result Matchers « ( ) . string ( Matchers . » equal To « ( " bogus " ) ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ) ; }
@Test { new » Content Result Matchers « ( ) . bytes ( CONTENT . » get Bytes « ( " UTF - 8 " ) ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Content Result Matchers « ( ) . bytes ( " bogus " . » get Bytes « ( ) ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ) ; }
@Test { new » Content Result Matchers « ( ) . json ( " { \n \" foo \" : \" bar \" \n } " ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; new » Content Result Matchers « ( ) . json ( " { \n \" foo \" : \" bar \" \n } " , false ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; }
@Test { new » Content Result Matchers « ( ) . json ( " { \n \" foo \" : \" bar \" , \" foo array \" : [ \" foo \" , \" bar \" ] \n } " , true ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; new » Content Result Matchers « ( ) . json ( " { \n \" foo array \" : [ \" foo \" , \" bar \" ] , \" foo \" : \" bar \" \n } " , true ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Content Result Matchers « ( ) . json ( " { \n \" fooo \" : \" bar \" \n } " ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Content Result Matchers « ( ) . json ( " { \" foo \" : \" bar \" , \" foo array \" : [ \" bar \" , \" foo \" ] } " , true ) . match ( » get Stub Mvc Result « ( CONTENT ) ) ) ; }
@Test { new » Content Result Matchers « ( ) . json ( " { \" name \" : \" Jürgen \" } " ) . match ( » get Stub Mvc Result « ( » UTF 8 _ CONTENT « ) ) ; }
@Test { new » Flash Attribute Result Matchers « ( ) . » attribute Exists « ( " good " ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Flash Attribute Result Matchers « ( ) . » attribute Exists « ( " bad " ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Flash Attribute Result Matchers « ( ) . attribute ( " good " , " good " ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Flash Attribute Result Matchers « ( ) . attribute ( " good " , " not good " ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { » assert That Code « ( ( ) -> » redirected Url « ( " / resource / 1 " ) . match ( » redirected Url Stub « ( " / resource / 1 " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » redirected Url « ( " / resource / 2 " ) . match ( » redirected Url Stub « ( " / resource / 1 " ) ) ) . » with Message Ending With « ( " expected : < / resource / 2 > but was : < / resource / 1 > " ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » redirected Url « ( " / resource / 1 " ) . match ( » forwarded Url Stub « ( " / resource / 1 " ) ) ) . » with Message Ending With « ( " expected : < / resource / 1 > but was : < null > " ) ; }
@Test { » assert That Code « ( ( ) -> » redirected Url Template « ( " / orders / { » order Id « } / items / { » item Id « } " , 1 , 2 ) . match ( » redirected Url Stub « ( " / orders / 1 / items / 2 " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Code « ( ( ) -> » redirected Url Pattern « ( " » / resource / « * " ) . match ( » redirected Url Stub « ( " / resource / 1 " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » redirected Url Pattern « ( " / resource / " ) . match ( » redirected Url Stub « ( " / resource / 1 " ) ) ) . » with Message « ( " '/resource/' is not an Ant - style path pattern " ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » redirected Url Pattern « ( " » / resource / « * " ) . match ( » forwarded Url Stub « ( " / resource / 1 " ) ) ) . » with Message « ( " Redirected URL 'null' does not match the expected URL pattern '/resource/*' " ) ; }
@Test { » assert That Code « ( ( ) -> » forwarded Url « ( " / api / resource / 1 " ) . match ( » forwarded Url Stub « ( " / api / resource / 1 " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » forwarded Url Pattern « ( " api / resource / 2 " ) . match ( » forwarded Url Stub « ( " api / resource / 1 " ) ) ) . » with Message « ( " 'api/resource/2' is not an Ant - style path pattern " ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » forwarded Url Pattern « ( " » / resource / « * " ) . match ( » redirected Url Stub « ( " / resource / 1 " ) ) ) . » with Message « ( " Forwarded URL 'null' does not match the expected URL pattern '/resource/*' " ) ; }
@Test { » assert That Code « ( ( ) -> » forwarded Url « ( " / api / resource / 1 ? arg = value " ) . match ( » forwarded Url Stub « ( " / api / resource / 1 ? arg = value " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Code « ( ( ) -> » forwarded Url Template « ( " / orders / { » order Id « } / items / { » item Id « } " , 1 , 2 ) . match ( » forwarded Url Stub « ( " / orders / 1 / items / 2 " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Code « ( ( ) -> » forwarded Url Pattern « ( " / api ? " ) . match ( » forwarded Url Stub « ( " / api / resource / 1 " ) ) ) . » does Not Throw Any Exception « ( ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> » forwarded Url Pattern « ( " / resource / " ) . match ( » forwarded Url Stub « ( " / resource / 1 " ) ) ) . » with Message « ( " '/resource/' is not an Ant - style path pattern " ) ; }
@Test { this . request . » set Character Encoding « ( " UTF - 8 " ) ; this . request . » set Content « ( " text " . » get Bytes « ( " UTF - 8 " ) ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Mock Http Servlet Request « " , " Body " , " text " ) ; }
@Test { this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Mock Http Servlet Request « " , " Body " , " < no character encoding set > " ) ; }
@Test { this . response . » set Character Encoding « ( " UTF - 8 " ) ; this . response . » get Writer « ( ) . print ( " text " ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Mock Http Servlet Response « " , " Body " , " text " ) ; }
@Test { this . response . » get Writer « ( ) . print ( " text " ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Mock Http Servlet Response « " , " Body " , " text " ) ; }
@Test { this . response . » set Character Encoding « ( null ) ; this . response . » get Writer « ( ) . print ( " text " ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Mock Http Servlet Response « " , " Body " , " < no character encoding set > " ) ; }
@Test { » Stub Mvc Result « » mvc Result « = new » Stub Mvc Result « ( this . request , null , null , null , null , null , this . response ) ; this . handler . handle ( » mvc Result « ) ; » assert Value « ( " Handler " , " Type " , null ) ; }
@Test { this . » mvc Result « . » set Handler « ( new Object ( ) ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " Handler " , " Type " , Object . class . » get Name « ( ) ) ; }
@Test { » Handler Method « » handler Method « = new » Handler Method « ( this , " handle " ) ; this . » mvc Result « . » set Handler « ( » handler Method « ) ; this . handler . handle ( » mvc Result « ) ; » assert Value « ( " Handler " , " Type " , this . » get Class « ( ) . » get Name « ( ) ) ; » assert Value « ( " Handler " , " Method " , » handler Method « ) ; }
@Test { this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " Resolved Exception " , " Type " , null ) ; }
@Test { this . » mvc Result « . » set Resolved Exception « ( new Exception ( ) ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " Resolved Exception " , " Type " , Exception . class . » get Name « ( ) ) ; }
@Test { this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Model And View « " , " View name " , null ) ; » assert Value « ( " » Model And View « " , " View " , null ) ; » assert Value « ( " » Model And View « " , " Model " , null ) ; }
@Test { this . handler . handle ( » mvc Result « ) ; » assert Value « ( " » Flash Map « " , " Type " , null ) ; }
@Test { » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . put ( " » attr Name « " , " » attr Value « " ) ; this . request . » set Attribute « ( » Dispatcher Servlet « . class . » get Name « ( ) + " . » OUTPUT _ FLASH _ MAP « " , » flash Map « ) ; this . handler . handle ( this . » mvc Result « ) ; » assert Value « ( " » Flash Map « " , " Attribute " , " » attr Name « " ) ; » assert Value « ( " » Flash Map « " , " value " , " » attr Value « " ) ; }
@Test { this . matchers . » attribute Exists « ( " good " ) . match ( this . » mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Exists « ( " bad " ) . match ( this . » mvc Result « ) ) ; }
@Test { this . matchers . » attribute Does Not Exist « ( " bad " ) . match ( this . » mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Does Not Exist « ( " good " ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { this . matchers . attribute ( " good " , is ( " good " ) ) . match ( this . » mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . attribute ( " good " , is ( " bad " ) ) . match ( this . » mvc Result « ) ) ; }
@Test { this . matchers . » has No Errors « ( ) . match ( this . » mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » has No Errors « ( ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { this . matchers . » attribute Has Errors « ( " date " ) . match ( this . » mvc Result With Error « ) ; }
@Test { this . matchers . » attribute Error Count « ( " date " , 1 ) . match ( this . » mvc Result With Error « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Error Count « ( " date " , 2 ) . match ( this . » mvc Result With Error « ) ) . » with Message « ( " Binding / validation error count for attribute 'date' , expected : < 2 > but was : < 1 > " ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has Errors « ( " good " ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { this . matchers . » attribute Has No Errors « ( " good " ) . match ( this . » mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has No Errors « ( " missing " ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has No Errors « ( " date " ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { this . matchers . » attribute Has Field Errors « ( " date " , " time " ) . match ( this . » mvc Result With Error « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has Field Errors « ( " missing " , " bad " ) . match ( this . » mvc Result « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has Field Errors « ( " date " , " time " ) . match ( this . » mvc Result « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has Field Errors « ( " date " , " good " , " time " ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { this . matchers . » attribute Has Field Error Code « ( " date " , " time " , " error " ) . match ( this . » mvc Result With Error « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has Field Error Code « ( " date " , " time " , " » incorrect Error « " ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { this . matchers . » attribute Has Field Error Code « ( " date " , " time " , » starts With « ( " err " ) ) . match ( this . » mvc Result With Error « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . matchers . » attribute Has Field Error Code « ( " date " , " time " , » starts With « ( " inc " ) ) . match ( this . » mvc Result With Error « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . value ( " bogus " ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . str " ) . value ( " foo " ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » utf 8 Str « " ) . value ( " Příliš " ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . num " ) . value ( 5.0f ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . str " ) . value ( Matchers . » equal To « ( " foo " ) ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . num " ) . value ( Matchers . » equal To « ( 5.0f ) , Float . class ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . value ( Matchers . » equal To « ( " bogus " ) ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . str " ) . exists ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty Array « " ) . exists ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty Map « " ) . exists ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . bogus " ) . exists ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . bogus " ) . » does Not Exist « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . » does Not Exist « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . » empty Array « " ) . » does Not Exist « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . » empty Map « " ) . » does Not Exist « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty String « " ) . » is Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty Array « " ) . » is Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty Map « " ) . » is Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . str " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . num " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . bool " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . arr " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » color Map « " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . » empty String « " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . » empty Array « " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . » empty Map « " ) . » is Not Empty « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . arr " ) . » is Array « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty Array « " ) . » is Array « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . bar " ) . » is Array « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » color Map « " ) . » is Map « ( ) . match ( » stub Mvc Result « ) ; }
@Test { new » Json Path Result Matchers « ( " $ . » empty Map « " ) . » is Map « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . » is Map « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . bool " ) . » is Boolean « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . » is Boolean « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . num " ) . » is Number « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . » is Number « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { new » Json Path Result Matchers « ( " $ . str " ) . » is String « ( ) . match ( » stub Mvc Result « ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . arr " ) . » is String « ( ) . match ( » stub Mvc Result « ) ) ; }
@Test { String » json Prefix « = " prefix " ; » Stub Mvc Result « result = » create Prefixed Stub Mvc Result « ( » json Prefix « ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . value ( " foo " ) . match ( result ) ) ; }
@Test { String » json Prefix « = " prefix " ; » Stub Mvc Result « result = » create Prefixed Stub Mvc Result « ( » json Prefix « ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Json Path Result Matchers « ( " $ . str " ) . prefix ( " wrong " ) . value ( " foo " ) . match ( result ) ) ; }
@Test { String » json Prefix « = " prefix " ; » Stub Mvc Result « result = » create Prefixed Stub Mvc Result « ( » json Prefix « ) ; new » Json Path Result Matchers « ( " $ . str " ) . prefix ( » json Prefix « ) . value ( " foo " ) . match ( result ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar " , null ) . node ( Matchers . » not Null Value « ( ) ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar " , null ) . node ( Matchers . » null Value « ( ) ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar " , null ) . » node List « ( Matchers . » not Null Value « ( ) ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar " , null ) . » node List « ( Matchers . » null Value « ( ) ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar " , null ) . exists ( ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / Bar " , null ) . exists ( ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / Bar " , null ) . » does Not Exist « ( ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar " , null ) . » does Not Exist « ( ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar " , null ) . » node Count « ( 2 ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar " , null ) . » node Count « ( 1 ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar [ 1 ] " , null ) . string ( " 111 " ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar [ 1 ] " , null ) . string ( " 112 " ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar [ 1 ] " , null ) . number ( 111.0 ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar [ 1 ] " , null ) . number ( 111.1 ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { new » Xpath Result Matchers « ( " / foo / bar [ 2 ] " , null ) . » boolean Value « ( true ) . match ( » get Stub Mvc Result « ( ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> new » Xpath Result Matchers « ( " / foo / bar [ 2 ] " , null ) . » boolean Value « ( false ) . match ( » get Stub Mvc Result « ( ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / person / 5 " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Do « ( print ( ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( request ( ) . » async Not Started « ( ) ) . » and Expect « ( content ( ) . string ( " { \" name \" : \" Joe \" , \" » some Double « \" : 0.0 , \" » some Boolean « \" : false } " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " / WEB - INF / layouts / » standard Layout « . jsp " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / person / 5 " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Do « ( print ( ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( content ( ) . string ( " { \" name \" : \" Joe \" , \" » some Double « \" : 0.0 , \" » some Boolean « \" : false } " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( » forwarded Url « ( " / WEB - INF / layouts / » standard Layout « . jsp " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / resources / Spring . js " ) ) . » and Expect « ( content ( ) . » content Type « ( " application / javascript " ) ) . » and Expect « ( content ( ) . string ( » contains String « ( " Spring = { } ; " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / unknown / resource " ) ) . » and Expect « ( handler ( ) . » handler Type « ( » Default Servlet Http Request Handler « . class ) ) . » and Expect « ( » forwarded Url « ( " default " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / » singleton Controller « " ) . » request Attr « ( » FROM _ MVC _ TEST _ MOCK « , » FROM _ MVC _ TEST _ MOCK « ) ) ; }
@Test { » Mock Mvc « » mock Mvc « = » Mock Mvc Builders « . » standalone Setup « ( new » Spr 15753 Controller « ( ) ) . » add Filter « ( new » Form Content Filter « ( ) ) . build ( ) ; » mock Mvc « . perform ( put ( " / " ) . content ( " » d 1 « = a & » d 2 « = s " ) . » content Type « ( » Media Type « . » APPLICATION _ FORM _ URLENCODED « ) ) . » and Expect « ( content ( ) . string ( " » d 1 « : a , » d 2 « : s . " ) ) ; }
@Test { » Mock Mvc Builders « . » web App Context Setup « ( wac ) . » add Filter « ( new » Character Encoding Filter « ( ) ) . » default Request « ( get ( " / " ) . » context Path « ( " / mywebapp " ) ) . build ( ) ; }
@Test { » assert That « ( » Aop Utils « . » is Cglib Proxy « ( this . » request Scoped Controller « ) ) . as ( " request - scoped controller must be a CGLIB proxy " ) . » is True « ( ) ; this . » mock Mvc « . perform ( get ( " / » request Scoped Controller « " ) . » request Attr « ( » FROM _ MVC _ TEST _ MOCK « , » FROM _ MVC _ TEST _ MOCK « ) ) ; }
@Test { » assert That « ( » Aop Utils « . » is Cglib Proxy « ( this . » request Scoped Service « ) ) . as ( " request - scoped service must be a CGLIB proxy " ) . » is True « ( ) ; this . » mock Mvc « . perform ( get ( " / » request Scoped Service « " ) . » request Attr « ( » FROM _ MVC _ TEST _ MOCK « , » FROM _ MVC _ TEST _ MOCK « ) ) ; }
@Test { » assert That « ( » Aop Utils « . » is Cglib Proxy « ( this . » session Scoped Service « ) ) . as ( " session - scoped service must be a CGLIB proxy " ) . » is True « ( ) ; this . » mock Mvc « . perform ( get ( " / » session Scoped Service « " ) . » request Attr « ( » FROM _ MVC _ TEST _ MOCK « , » FROM _ MVC _ TEST _ MOCK « ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . build ( ) . perform ( get ( " / search ? name = George " ) . accept ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( content ( ) . » content Type « ( " application / json " ) ) . » and Expect « ( » json Path « ( " $ . name " ) . value ( " George " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / 1 " ) . param ( " » streaming Slow « " , " true " ) ) . » and Expect « ( request ( ) . » async Started « ( ) ) . » and Do « ( » Mvc Result « :: » get Async Result « ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( content ( ) . string ( " name = Joe & » some Boolean « = true " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / 1 " ) . param ( " » streaming Json « " , " true " ) ) . » and Expect « ( request ( ) . » async Started « ( ) ) . » and Do « ( » Mvc Result « :: » get Async Result « ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( content ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Expect « ( content ( ) . string ( " { \" name \" : \" Joe \" , \" » some Double « \" : 0.5 } " ) ) ; }
@Test { » Mvc Result « » mvc Result « = this . » mock Mvc « . perform ( get ( " / 1 " ) . param ( " » deferred Result With Delayed Error « " , " true " ) ) . » and Expect « ( request ( ) . » async Started « ( ) ) . » and Return « ( ) ; this . » mock Mvc « . perform ( » async Dispatch « ( » mvc Result « ) ) . » and Expect « ( status ( ) . » is 5 xx Server Error « ( ) ) . » and Expect « ( content ( ) . string ( " Delayed Error " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . build ( ) . perform ( get ( " / person / Clyde " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " » error View « " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . » set Controller Advice « ( new » Global Exception Handler « ( ) ) . build ( ) . perform ( get ( " / person / Bonnie " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " » global Error View « " ) ) ; }
@Test { » standalone Setup « ( » Person Controller « . class ) . » set Controller Advice « ( » Global Exception Handler « . class ) . build ( ) . perform ( get ( " / person / Bonnie " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " » global Error View « " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) . with ( headers ( ) . foo ( " a = b " ) ) ) . » and Expect « ( content ( ) . string ( " Foo " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) . with ( headers ( ) . bar ( " a = b " ) ) ) . » and Expect « ( content ( ) . string ( " Bar " ) ) ; }
@Test { » standalone Setup « ( new » Multipart Controller « ( ) ) . build ( ) . perform ( multipart ( " / multipartfile " ) ) . » and Expect « ( status ( ) . » is Found « ( ) ) ; }
@Test { » standalone Setup « ( new » Multipart Controller « ( ) ) . build ( ) . perform ( multipart ( " / multipartfilearray " ) ) . » and Expect « ( status ( ) . » is Found « ( ) ) ; }
@Test { » standalone Setup « ( new » Multipart Controller « ( ) ) . build ( ) . perform ( post ( " / multipartfilearray " ) ) . » and Expect « ( status ( ) . » is Found « ( ) ) ; }
@Test { » standalone Setup « ( new » Multipart Controller « ( ) ) . build ( ) . perform ( multipart ( " / multipartfilelist " ) ) . » and Expect « ( status ( ) . » is Found « ( ) ) ; }
@Test { » standalone Setup « ( new » Multipart Controller « ( ) ) . build ( ) . perform ( post ( " / multipartfilelist " ) ) . » and Expect « ( status ( ) . » is Found « ( ) ) ; }
@Test { this . » mock Mvc « . perform ( post ( " / people " ) . param ( " name " , " Andy " ) ) . » and Expect « ( status ( ) . » is Found « ( ) ) . » and Expect « ( » redirected Url « ( " / persons / Joe " ) ) . » and Expect « ( model ( ) . size ( 1 ) ) . » and Expect « ( model ( ) . » attribute Exists « ( " name " ) ) . » and Expect « ( flash ( ) . » attribute Count « ( 1 ) ) . » and Expect « ( flash ( ) . attribute ( " message " , " success ! " ) ) ; }
@Test { this . » mock Mvc « . perform ( post ( " / persons " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " persons / add " ) ) . » and Expect « ( model ( ) . size ( 1 ) ) . » and Expect « ( model ( ) . » attribute Exists « ( " person " ) ) . » and Expect « ( flash ( ) . » attribute Count « ( 0 ) ) ; }
@Test { this . » mock Mvc « . perform ( post ( " / people " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " persons / add " ) ) . » and Expect « ( model ( ) . size ( 1 ) ) . » and Expect « ( model ( ) . » attribute Exists « ( " person " ) ) . » and Expect « ( flash ( ) . » attribute Count « ( 0 ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . » set Single View « ( new » Mapping Jackson 2 Json View « ( ) ) . build ( ) . perform ( get ( " / person / Corea " ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( content ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) ) . » and Expect « ( » json Path « ( " $ . person . name " ) . value ( " Corea " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . build ( ) . perform ( get ( " / person / Corea " ) ) . » and Expect « ( model ( ) . attribute ( " person " , » has Property « ( " name " , » equal To « ( " Corea " ) ) ) ) . » and Expect « ( status ( ) . » is Ok « ( ) ) . » and Expect « ( » forwarded Url « ( " person / show " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . » add Filters « ( new » Continue Filter « ( ) , new » Redirect Filter « ( ) ) . build ( ) . perform ( post ( " / persons " ) . param ( " name " , " Andy " ) ) . » and Expect « ( » redirected Url « ( " / login " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . » add Filter « ( new » Redirect Filter « ( ) , " * . html " ) . build ( ) . perform ( post ( " / persons . html " ) . param ( " name " , " Andy " ) ) . » and Expect « ( » redirected Url « ( " / login " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . » add Filter « ( new » Redirect Filter « ( ) , " / p " , " / persons " ) . build ( ) . perform ( post ( " / persons " ) . param ( " name " , " Andy " ) ) . » and Expect « ( » redirected Url « ( " / login " ) ) ; }
@Test { » standalone Setup « ( new » Person Controller « ( ) ) . » add Filters « ( new » Wrapping Request Response Filter « ( ) ) . build ( ) . perform ( post ( " / user " ) ) . » and Expect « ( model ( ) . attribute ( " principal " , » Wrapping Request Response Filter « . » PRINCIPAL _ NAME « ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( request ( ) . » session Attribute « ( " locale " , Locale . UK ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( request ( ) . » session Attribute « ( " locale " , Locale . US ) ) ) . » with Message « ( " Session attribute 'locale' expected : < » en _ US « > but was : < » en _ GB « > " ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( request ( ) . » session Attribute Does Not Exist « ( " bogus " , " enigma " ) ) ; » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( request ( ) . » session Attribute Does Not Exist « ( " locale " ) ) ) . » with Message « ( " Session attribute 'locale' exists " ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons " ) ) . » and Expect « ( » redirected Url « ( " / persons / 1 " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons " ) ) . » and Expect « ( » redirected Url Pattern « ( " » / persons / « * " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( » forwarded Url « ( " / home " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( » forwarded Url Pattern « ( " / ho ? e " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / music / people " ) ) . » and Expect « ( content ( ) . xml ( » PEOPLE _ XML « ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / music / people " ) ) . » and Expect « ( content ( ) . node ( » has X Path « ( " / people / composers / composer [ 1 ] " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . exists ( » COOKIE _ NAME « ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . » does Not Exist « ( " » unknown Cookie « " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . value ( » COOKIE _ NAME « , " en - US " ) ) ; this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . value ( » COOKIE _ NAME « , » equal To « ( " en - US " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . value ( » COOKIE _ NAME « , » starts With « ( " en " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . » max Age « ( » COOKIE _ NAME « , - 1 ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . domain ( » COOKIE _ NAME « , " domain " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . version ( » COOKIE _ NAME « , 0 ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . path ( » COOKIE _ NAME « , " / " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . secure ( » COOKIE _ NAME « , false ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( cookie ( ) . » http Only « ( » COOKIE _ NAME « , true ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( post ( " / persons " ) ) . » and Expect « ( flash ( ) . » attribute Count « ( 1 ) ) ) . » with Message « ( " » Flash Map « size expected : < 1 > but was : < 3 > " ) ; }
@Test { this . » mock Mvc « . perform ( post ( " / persons " ) ) . » and Expect « ( flash ( ) . » attribute Exists « ( " one " , " two " , " three " ) ) ; }
@Test { this . » mock Mvc « . perform ( post ( " / persons " ) ) . » and Expect « ( flash ( ) . attribute ( " one " , " 1 " ) ) . » and Expect « ( flash ( ) . attribute ( " two " , 2.222 ) ) . » and Expect « ( flash ( ) . attribute ( " three " , new URL ( " https : » // example . com « " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . » handler Type « ( » Simple Controller « . class ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . » method Call « ( " bogus " ) ) ) . » with Message Containing « ( " The supplied object [ bogus ] is not an instance of " ) . » with Message Containing « ( » Mvc Uri Components Builder « . » Method Invocation Info « . class . » get Name « ( ) ) . » with Message Containing « ( " Ensure that you invoke the handler method via » Mvc Uri Components Builder « . on ( ) " ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . » method Call « ( on ( » Simple Controller « . class ) . handle ( ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . » method Name « ( " handle " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . » method Name « ( » equal To « ( " handle " ) ) ) ; this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . » method Name « ( is ( not ( " save " ) ) ) ) ; }
@Test { Method method = » Simple Controller « . class . » get Method « ( " handle " ) ; this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( handler ( ) . method ( method ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / music / people " ) ) . » and Expect « ( » json Path « ( " $ . composers [ ? ( @ . name == 'Edvard Grieeeeeeg' ) ] " ) . » does Not Exist « ( ) ) . » and Expect « ( » json Path « ( " $ . composers [ ? ( @ . name == 'Robert Schuuuuuuman' ) ] " ) . » does Not Exist « ( ) ) . » and Expect « ( » json Path « ( " $ . composers [ 4 ] " ) . » does Not Exist « ( ) ) ; }
@Test { » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( model ( ) . attribute ( " integer " , 3 ) ) . » and Expect « ( model ( ) . attribute ( " string " , " a string value " ) ) . » and Expect « ( model ( ) . attribute ( " integer " , » equal To « ( 3 ) ) ) . » and Expect « ( model ( ) . attribute ( " string " , » equal To « ( " a string value " ) ) ) . » and Expect « ( model ( ) . attribute ( " » global Attr Name « " , » equal To « ( " Global Attribute Value " ) ) ) ; }
@Test { » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( model ( ) . » attribute Exists « ( " integer " , " string " , " person " ) ) . » and Expect « ( model ( ) . attribute ( " integer " , » not Null Value « ( ) ) ) . » and Expect « ( model ( ) . attribute ( " INTEGER " , » null Value « ( ) ) ) ; }
@Test { » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( model ( ) . attribute ( " integer " , » equal To « ( 3 ) ) ) . » and Expect « ( model ( ) . attribute ( " string " , » all Of « ( » starts With « ( " a string " ) , » ends With « ( " value " ) ) ) ) . » and Expect « ( model ( ) . attribute ( " person " , » has Property « ( " name " , » equal To « ( " a name " ) ) ) ) ; }
@Test { » mock Mvc « . perform ( post ( " / persons " ) ) . » and Expect « ( model ( ) . » attribute Has Errors « ( " person " ) ) ; }
@Test { » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( model ( ) . » has No Errors « ( ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / main / 1 " ) . » servlet Path « ( " / main " ) ) . » and Expect « ( request ( ) . attribute ( » Handler Mapping « . » BEST _ MATCHING _ PATTERN _ ATTRIBUTE « , " / { id } " ) ) . » and Expect « ( request ( ) . attribute ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " / 1 " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( view ( ) . name ( " » my Special View « " ) ) . » and Expect « ( view ( ) . name ( » equal To « ( " » my Special View « " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / " ) ) . » and Expect « ( view ( ) . name ( » contains String « ( " Special " ) ) ) ; }
@Test { String » performer Boolean Value « = " / ns : people / performers / performer [ % s ] / » some Boolean « " ; this . » mock Mvc « . perform ( get ( " / music / people " ) ) . » and Expect « ( xpath ( » performer Boolean Value « , » music Namespace « , 1 ) . » boolean Value « ( false ) ) . » and Expect « ( xpath ( » performer Boolean Value « , » music Namespace « , 2 ) . » boolean Value « ( true ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / created " ) ) . » and Expect « ( status ( ) . is ( 201 ) ) ; this . » mock Mvc « . perform ( get ( " / » created With Composed Annotation « " ) ) . » and Expect « ( status ( ) . is ( 201 ) ) ; this . » mock Mvc « . perform ( get ( " / » bad Request « " ) ) . » and Expect « ( status ( ) . is ( 400 ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / created " ) ) . » and Expect « ( status ( ) . » is Created « ( ) ) ; this . » mock Mvc « . perform ( get ( " / » created With Composed Annotation « " ) ) . » and Expect « ( status ( ) . » is Created « ( ) ) ; this . » mock Mvc « . perform ( get ( " / » bad Request « " ) ) . » and Expect « ( status ( ) . » is Bad Request « ( ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / » bad Request « " ) ) . » and Expect « ( status ( ) . is ( » equal To « ( 400 ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / » bad Request « " ) ) . » and Expect « ( status ( ) . reason ( " Expired token " ) ) ; this . » mock Mvc « . perform ( get ( " / » bad Request « " ) ) . » and Expect « ( status ( ) . reason ( » equal To « ( " Expired token " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / » bad Request « " ) ) . » and Expect « ( status ( ) . reason ( » ends With « ( " token " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) . header ( » IF _ MODIFIED _ SINCE « , » minute Ago « ) ) . » and Expect « ( header ( ) . string ( » LAST _ MODIFIED « , now ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) . header ( » IF _ MODIFIED _ SINCE « , » minute Ago « ) ) . » and Expect « ( header ( ) . string ( » LAST _ MODIFIED « , » equal To « ( now ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . » string Values « ( VARY , " foo " , " bar " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . » string Values « ( VARY , » has Items « ( » contains String « ( " foo " ) , » starts With « ( " bar " ) ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) . header ( » IF _ MODIFIED _ SINCE « , » minute Ago « ) ) . » and Expect « ( header ( ) . » date Value « ( » LAST _ MODIFIED « , this . » current Time « ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . » long Value « ( " X - Rate - Limiting " , 42 ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) . header ( » IF _ MODIFIED _ SINCE « , now ) ) . » and Expect « ( status ( ) . » is Not Modified « ( ) ) . » and Expect « ( header ( ) . » string Values « ( " X - Custom - Header " ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) . header ( » IF _ MODIFIED _ SINCE « , now ) ) . » and Expect « ( status ( ) . » is Not Modified « ( ) ) . » and Expect « ( header ( ) . string ( " X - Custom - Header " , » null Value « ( ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . exists ( » LAST _ MODIFIED « ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . exists ( " X - Custom - Header " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . » does Not Exist « ( " X - Custom - Header " ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . » does Not Exist « ( » LAST _ MODIFIED « ) ) ) ; }
@Test { » assert That Exception Of Type « ( » Assertion Error « . class ) . » is Thrown By « ( ( ) -> this . » mock Mvc « . perform ( get ( " / persons / 1 " ) ) . » and Expect « ( header ( ) . » long Value « ( " X - Rate - Limiting " , 1 ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / handle " ) . accept ( » Media Type « . » TEXT _ PLAIN « ) ) . » and Expect « ( content ( ) . bytes ( " Hello world ! " . » get Bytes « ( " ISO - 8859 - 1 " ) ) ) ; this . » mock Mvc « . perform ( get ( " / » handle Utf 8 « " ) ) . » and Expect « ( content ( ) . bytes ( " » こんにちは世界 ！ « " . » get Bytes « ( " UTF - 8 " ) ) ) ; }
@Test { this . » mock Mvc « . perform ( get ( " / handle " ) . accept ( » Media Type « . » TEXT _ PLAIN « ) ) . » and Expect « ( content ( ) . string ( » contains String « ( " world " ) ) ) ; }
@Test { » Filter Config « config = new » Mock Filter Config « ( ) ; filter = new » Pattern Mapping Filter Proxy « ( delegate , " / " ) ; filter . init ( config ) ; » assert That « ( delegate . » filter Config « ) . » is Equal To « ( config ) ; }
@Test { filter = new » Pattern Mapping Filter Proxy « ( delegate , " / " ) ; filter . destroy ( ) ; » assert That « ( delegate . destroy ) . » is True « ( ) ; }
@Test { » assert Filter Invoked « ( " / test " , " / test " ) ; }
@Test { » assert Filter Invoked « ( " " , " " ) ; }
@Test { » assert Filter Invoked « ( " / test / this " , " / * " ) ; }
@Test { » assert Filter Invoked « ( " / test " , " / * " ) ; }
@Test { » assert Filter Invoked « ( " " , " / * " ) ; }
@Test { » assert Filter Invoked « ( " / " , " / * " ) ; }
@Test { » assert Filter Invoked « ( " / test / this / here " , " » / test / « * " ) ; }
@Test { » assert Filter Invoked « ( " / test / this " , " » / test / « * " ) ; }
@Test { » assert Filter Invoked « ( " / test / " , " » / test / « * " ) ; }
@Test { » assert Filter Invoked « ( " / test " , " » / test / « * " ) ; }
@Test { » assert Filter Not Invoked « ( " / this / test / here " , " » / test / « * " ) ; }
@Test { » assert Filter Not Invoked « ( " / this / test " , " » / test / « * " ) ; }
@Test { » assert Filter Not Invoked « ( " / » test 2 « / " , " » / test / « * " ) ; }
@Test { » assert Filter Not Invoked « ( " / » test 2 « " , " » / test / « * " ) ; }
@Test { » assert Filter Invoked « ( " / test / this / here . html " , " * . html " ) ; }
@Test { » assert Filter Invoked « ( " / test / this . html " , " * . html " ) ; }
@Test { » assert Filter Invoked « ( " / . html " , " * . html " ) ; }
@Test { » assert Filter Invoked « ( " / test . html " , " * . html " ) ; }
@Test { » assert Filter Not Invoked « ( " . html " , " * . html " ) ; }
@Test { » assert Filter Not Invoked « ( " / index . html / " , " * . html " ) ; }
@Test { » assert Filter Not Invoked « ( " / index . html . " , " * . html " ) ; }
@Test { » assert Filter Not Invoked « ( " / index . htm " , " * . html " ) ; }
@Test { » assert Filter Not Invoked « ( " / index . html " , " / * » . html « " ) ; }
@Test { » assert Filter Invoked « ( " / foo / bar / index . html " , " » / foo / bar / « * " ) ; }
@Test { » assert Filter Invoked « ( " / foo / bar / index . bop " , " » / foo / bar / « * " ) ; }
@Test { » assert Filter Invoked « ( " / baz " , " » / baz / « * " ) ; }
@Test { » assert Filter Invoked « ( " / baz / index . html " , " » / baz / « * " ) ; }
@Test { » assert Filter Invoked « ( " / catalog " , " / catalog " ) ; }
@Test { » assert Filter Invoked « ( " / catalog / racecar . bop " , " * . bop " ) ; }
@Test { » assert Filter Invoked « ( " / index . bop " , " * . bop " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » web App Context Setup « ( null ) ) . » with Message « ( " » Web Application Context « is required " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » web App Context Setup « ( new » Stub Web Application Context « ( null ) ) ) . » with Message « ( " » Web Application Context « must have a » Servlet Context « " ) ; }
@Test { » Stub Web Application Context « child = new » Stub Web Application Context « ( this . » servlet Context « ) ; this . » servlet Context « . » set Attribute « ( » Web Application Context « . » ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE « , child ) ; » Default Mock Mvc Builder « builder = » web App Context Setup « ( child ) ; » assert That « ( » Web Application Context Utils « . » get Required Web Application Context « ( this . » servlet Context « ) ) . » is Same As « ( builder . » init Web App Context « ( ) ) ; }
@Test { » Stub Web Application Context « root = new » Stub Web Application Context « ( this . » servlet Context « ) ; » Default Mock Mvc Builder « builder = » web App Context Setup « ( root ) ; » Web Application Context « wac = builder . » init Web App Context « ( ) ; » assert That « ( wac ) . » is Same As « ( root ) ; » assert That « ( » Web Application Context Utils « . » get Required Web Application Context « ( this . » servlet Context « ) ) . » is Same As « ( root ) ; }
@Test { » Test Standalone Mock Mvc Builder « builder = new » Test Standalone Mock Mvc Builder « ( new » Placeholder Controller « ( ) ) ; builder . » add Placeholder Value « ( " sys . login . ajax " , " / foo " ) ; » Web Application Context « wac = builder . » init Web App Context « ( ) ; » assert That « ( » Web Application Context Utils « . » get Required Web Application Context « ( wac . » get Servlet Context « ( ) ) ) . » is Equal To « ( wac ) ; }
@Test { » Standalone Mock Mvc Builder « builder = » Mock Mvc Builders « . » standalone Setup « ( new » Person Controller « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> builder . » add Filters « ( ( Filter [ ] ) null ) ) ; }
@Test { » Standalone Mock Mvc Builder « builder = » Mock Mvc Builders « . » standalone Setup « ( new » Person Controller « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> builder . » add Filters « ( new » Continue Filter « ( ) , ( Filter ) null ) ) ; }
@Test { » Standalone Mock Mvc Builder « builder = » Mock Mvc Builders « . » standalone Setup « ( new » Person Controller « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> builder . » add Filter « ( new » Continue Filter « ( ) , ( String [ ] ) null ) ) ; }
@Test { » Standalone Mock Mvc Builder « builder = » Mock Mvc Builders « . » standalone Setup « ( new » Person Controller « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> builder . » add Filter « ( new » Continue Filter « ( ) , ( String ) null ) ) ; }
@Test { » Test Standalone Mock Mvc Builder « builder = new » Test Standalone Mock Mvc Builder « ( new » Person Controller « ( ) ) ; builder . build ( ) ; » Spring Handler Instantiator « instantiator = new » Spring Handler Instantiator « ( builder . wac . » get Autowire Capable Bean Factory « ( ) ) ; » Json Serializer « serializer = instantiator . » serializer Instance « ( null , null , » Unknown Serializer « . class ) ; » assert That « ( serializer ) . » is Not Null « ( ) ; }
@Test { » do Test Translation Needed For These Exceptions « ( new » Stereotyped Repository Interface Impl « ( ) ) ; }
@Test { » do Test Translation Needed For These Exceptions « ( new » My Stereotyped Repository Interface Impl « ( ) ) ; }
@Test { » do Test Translation Needed For These Exceptions « ( new » Custom Stereotyped Repository Interface Impl « ( ) ) ; }
@Test { » do Test Translation Needed For These Exceptions « ( new » My Interface Stereotyped Repository Interface Impl « ( ) ) ; }
@Test { » do Test Translation Needed For These Exceptions « ( new » My Interface Inherited Stereotyped Repository Interface Impl « ( ) ) ; }
@Test { » Chained Persistence Exception Translator « pet = new » Chained Persistence Exception Translator « ( ) ; » Runtime Exception « in = new » Runtime Exception « ( " in " ) ; » assert That « ( » Data Access Utils « . » translate If Necessary « ( in , pet ) ) . » is Same As « ( in ) ; }
@Test { Collection < Integer > col = new » Array List « < > ( 2 ) ; col . add ( new Integer ( 5 ) ) ; col . add ( new Integer ( 5 ) ) ; » assert That Exception Of Type « ( » Incorrect Result Size Data Access Exception « . class ) . » is Thrown By « ( ( ) -> » Data Access Utils « . » unique Result « ( col ) ) . satisfies ( » size Requirements « ( 1 , 2 ) ) ; }
@Test { » Map Persistence Exception Translator « mpet = new » Map Persistence Exception Translator « ( ) ; » Runtime Exception « in = new » Runtime Exception « ( ) ; » assert That « ( » Data Access Utils « . » translate If Necessary « ( in , mpet ) ) . » is Same As « ( in ) ; }
@Test { » Map Persistence Exception Translator « mpet = new » Map Persistence Exception Translator « ( ) ; » Runtime Exception « in = new » Runtime Exception « ( " in " ) ; » Invalid Data Access Api Usage Exception « out = new » Invalid Data Access Api Usage Exception « ( " out " ) ; mpet . » add Translation « ( in , out ) ; » assert That « ( » Data Access Utils « . » translate If Necessary « ( in , mpet ) ) . » is Same As « ( out ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( new » Local Connection Factory Bean « ( ) :: » after Properties Set « ) ; }
@Test { » Local Connection Factory Bean « factory = new » Local Connection Factory Bean « ( ) ; » assert That « ( factory . » is Singleton « ( ) ) . » is True « ( ) ; }
@Test { » Local Connection Factory Bean « factory = new » Local Connection Factory Bean « ( ) ; » assert That « ( factory . » get Object Type « ( ) ) . » is Null « ( ) ; }
@Test { final Object » CONNECTION _ FACTORY « = new Object ( ) ; » Managed Connection Factory « » managed Connection Factory « = mock ( » Managed Connection Factory « . class ) ; given ( » managed Connection Factory « . » create Connection Factory « ( ) ) . » will Return « ( » CONNECTION _ FACTORY « ) ; » Local Connection Factory Bean « factory = new » Local Connection Factory Bean « ( ) ; factory . » set Managed Connection Factory « ( » managed Connection Factory « ) ; factory . » after Properties Set « ( ) ; » assert That « ( factory . » get Object « ( ) ) . » is Equal To « ( » CONNECTION _ FACTORY « ) ; }
@Test { » Managed Connection Factory « » managed Connection Factory « = mock ( » Managed Connection Factory « . class ) ; » Connection Manager « » connection Manager « = mock ( » Connection Manager « . class ) ; » Local Connection Factory Bean « factory = new » Local Connection Factory Bean « ( ) ; factory . » set Managed Connection Factory « ( » managed Connection Factory « ) ; factory . » set Connection Manager « ( » connection Manager « ) ; factory . » after Properties Set « ( ) ; verify ( » managed Connection Factory « ) . » create Connection Factory « ( » connection Manager « ) ; }
@Test { » do Test Jta Transaction Manager With Default Jndi Lookups « ( " java : comp / » Transaction Manager « " , true , true ) ; }
@Test { » do Test Jta Transaction Manager With Default Jndi Lookups « ( " java : / » Transaction Manager « " , true , true ) ; }
@Test { » do Test Jta Transaction Manager With Default Jndi Lookups « ( " java : / tm " , false , true ) ; }
@Test { » do Test Jta Transaction Manager With Default Jndi Lookups « ( " java : / » Transaction Manager « " , true , false ) ; }
@Test { » User Transaction « ut = mock ( » User Transaction « . class ) ; given ( ut . » get Status « ( ) ) . » will Throw « ( new » System Exception « ( " system exception " ) ) ; » assert That Exception Of Type « ( » Transaction System Exception « . class ) . » is Thrown By « ( ( ) -> { » Jta Transaction Manager « ptm = » new Jta Transaction Manager « ( ut ) ; » Transaction Template « tt = new » Transaction Template « ( ptm ) ; tt . execute ( new » Transaction Callback Without Result « ( ) { @ Override protected void » do In Transaction Without Result « ( » Transaction Status « status ) { } } ) ; } ) ; }
@Test { » do Test Jta Transaction Manager With No Exception On Global Rollback Only « ( false ) ; }
@Test { » do Test Jta Transaction Manager With No Exception On Global Rollback Only « ( true ) ; }
@Test { » Mock Callback Preferring Transaction Manager « ptm = new » Mock Callback Preferring Transaction Manager « ( ) ; » Transaction Template « template = new » Transaction Template « ( ptm ) ; template . execute ( new » Transaction Callback Without Result « ( ) { @ Override protected void » do In Transaction Without Result « ( » Transaction Status « status ) { } } ) ; » assert That « ( ptm . » get Definition « ( ) ) . » is Same As « ( template ) ; » assert That « ( ptm . » get Status « ( ) . » is Rollback Only « ( ) ) . » is False « ( ) ; }
@Test { » Component Definition « component = this . » event Listener « . » get Component Definition « ( " » tx Advice « " ) ; » assert That « ( component ) . » is Instance Of « ( » Bean Component Definition « . class ) ; }
@Test { » I Test Bean « bean = » get Test Bean « ( ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . as ( " » test Bean « is not a proxy " ) . » is True « ( ) ; }
@Test { Method method = Empty . class . » get Method « ( " » get Age « " ) ; » Annotation Transaction Attribute Source « atas = new » Annotation Transaction Attribute Source « ( ) ; » assert That « ( atas . » get Transaction Attribute « ( method , null ) ) . » is Null « ( ) ; » assert That « ( atas . » get Transaction Attribute « ( method , null ) ) . » is Null « ( ) ; }
@Test { Method » interface Method « = » I Test Bean 2 « . class . » get Method « ( " » get Age « " ) ; » Annotation Transaction Attribute Source « atas = new » Annotation Transaction Attribute Source « ( ) ; » Transaction Attribute « actual = atas . » get Transaction Attribute « ( » interface Method « , » Test Bean 2 « . class ) ; » Rule Based Transaction Attribute « rbta = new » Rule Based Transaction Attribute « ( ) ; » assert That « ( ( ( » Rule Based Transaction Attribute « ) actual ) . » get Rollback Rules « ( ) ) . » is Equal To « ( rbta . » get Rollback Rules « ( ) ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Test With Exceptions « ( ) ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Test With Exceptions « proxy = ( » Test With Exceptions « ) » proxy Factory « . » get Proxy « ( ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( proxy :: » do Something Else With Checked Exception « ) . satisfies ( ex -> » assert Get Transaction And Commit Count « ( 1 ) ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Test With Exceptions « ( ) ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Test With Exceptions « proxy = ( » Test With Exceptions « ) » proxy Factory « . » get Proxy « ( ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( proxy :: » do Something Else With Checked Exception And Rollback Rule « ) . satisfies ( ex -> » assert Get Transaction And Rollback Count « ( 1 ) ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Test With Vavr Try « ( ) ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Test With Vavr Try « proxy = ( » Test With Vavr Try « ) » proxy Factory « . » get Proxy « ( ) ; proxy . » do Something « ( ) ; » assert Get Transaction And Commit Count « ( 1 ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Test With Vavr Try « ( ) ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Test With Vavr Try « proxy = ( » Test With Vavr Try « ) » proxy Factory « . » get Proxy « ( ) ; proxy . » do Something Erroneous « ( ) ; » assert Get Transaction And Rollback Count « ( 1 ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Test With Vavr Try « ( ) ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Test With Vavr Try « proxy = ( » Test With Vavr Try « ) » proxy Factory « . » get Proxy « ( ) ; proxy . » do Something Erroneous With Checked Exception « ( ) ; » assert Get Transaction And Commit Count « ( 1 ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Test With Vavr Try « ( ) ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Test With Vavr Try « proxy = ( » Test With Vavr Try « ) » proxy Factory « . » get Proxy « ( ) ; proxy . » do Something Erroneous With Checked Exception And Rollback Rule « ( ) ; » assert Get Transaction And Rollback Count « ( 1 ) ; }
@Test { » Proxy Factory « » proxy Factory « = new » Proxy Factory « ( ) ; » proxy Factory « . » set Target « ( new » Other Service Impl « ( ) ) ; » proxy Factory « . » add Interface « ( » Other Service « . class ) ; » proxy Factory « . » add Advice « ( this . ti ) ; » Other Service « » other Service « = ( » Other Service « ) » proxy Factory « . » get Proxy « ( ) ; » other Service « . foo ( ) ; » assert Get Transaction And Commit Count « ( 1 ) ; }
@Test { » Transactional Test Bean « bean = » get Test Bean « ( ) ; » assert That « ( » Aop Utils « . » is Aop Proxy « ( bean ) ) . as ( " » test Bean « is not a proxy " ) . » is True « ( ) ; Map < String , Object > services = this . context . » get Beans With Annotation « ( Service . class ) ; » assert That « ( services . » contains Key « ( " » test Bean « " ) ) . as ( " Stereotype annotation not visible " ) . » is True « ( ) ; }
@Test { » Transactional Test Bean « » test Bean « = » get Test Bean « ( ) ; » Call Counting Transaction Manager « ptm = ( » Call Counting Transaction Manager « ) context . » get Bean « ( " » transaction Manager « " ) ; » assert That « ( ptm . begun ) . as ( " Should not have any started transactions " ) . » is Equal To « ( 0 ) ; » test Bean « . » annotations On Protected Are Ignored « ( ) ; » assert That « ( ptm . begun ) . as ( " Should not have any started transactions " ) . » is Equal To « ( 0 ) ; }
@Test { » M Bean Server « server = » Management Factory « . » get Platform M Bean Server « ( ) ; Object actual = server . invoke ( » Object Name « . » get Instance « ( " test : type = » Test Bean « " ) , " » do Something « " , new Object [ 0 ] , new String [ 0 ] ) ; » assert That « ( actual ) . » is Equal To « ( " done " ) ; }
@Test { » assert That « ( this . context . » contains Bean « ( » Transaction Management Config Utils « . » TRANSACTIONAL _ EVENT _ LISTENER _ FACTORY _ BEAN _ NAME « ) ) . » is True « ( ) ; » assert That « ( this . context . » get Beans Of Type « ( » Transactional Event Listener Factory « . class ) . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Enable Tx Config « . class , » Tx Manager Config « . class ) ; » Transactional Test Bean « bean = ctx . » get Bean « ( » Transactional Test Bean « . class ) ; bean . » find All Foos « ( ) ; ctx . close ( ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Enable Tx Config « . class , » Multi Tx Manager Config « . class ) ; » Transactional Test Bean « bean = ctx . » get Bean « ( » Transactional Test Bean « . class ) ; bean . » find All Foos « ( ) ; ctx . close ( ) ; }
@Test { » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> new » Annotation Config Application Context « ( » Enable Aspectj Tx Config « . class , » Tx Manager Config « . class ) ) . » with Message Containing « ( " » Aspect J Jta Transaction Management Configuration « " ) ; }
@Test { » Annotation Config Application Context « ctx = new » Annotation Config Application Context « ( » Enable Tx Config « . class ) ; » assert That « ( ctx . » contains Bean « ( » Transaction Management Config Utils « . » TRANSACTIONAL _ EVENT _ LISTENER _ FACTORY _ BEAN _ NAME « ) ) . » is True « ( ) ; » assert That « ( ctx . » get Beans Of Type « ( » Transactional Event Listener Factory « . class ) . size ( ) ) . » is Equal To « ( 1 ) ; ctx . close ( ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " » annotation Driven Proxy Target Class Tests « . xml " , » get Class « ( ) ) ; » do Test With Multiple Transaction Managers « ( context ) ; }
@Test { » Application Context « parent = new » Annotation Config Application Context « ( » Transaction Manager Configuration « . class ) ; » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( new String [ ] { " » annotation Driven Configuration Class Tests « . xml " } , » get Class « ( ) , parent ) ; » do Test With Multiple Transaction Managers « ( context ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " » annotation Driven Proxy Target Class Tests « . xml " , » get Class « ( ) ) ; » Transactional Service « service = context . » get Bean « ( " service " , » Transactional Service « . class ) ; service . » set Something « ( " » some Name « " ) ; service = ( » Transactional Service « ) » Serialization Test Utils « . » serialize And Deserialize « ( service ) ; service . » set Something « ( " » some Name « " ) ; }
@Test { » Class Path Xml Application Context « context = new » Class Path Xml Application Context « ( " » annotation Driven Proxy Target Class Tests « . xml " , » get Class « ( ) ) ; » Transactional Service « service = context . » get Bean « ( " service " , » Transactional Service « . class ) ; service = ( » Transactional Service « ) » Serialization Test Utils « . » serialize And Deserialize « ( service ) ; service . » set Something « ( " » some Name « " ) ; }
@Test { Method m = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » default Phase « " , String . class ) ; » assert Phase « ( m , » Transaction Phase « . » AFTER _ COMMIT « ) ; }
@Test { Method m = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » phase Set « " , String . class ) ; » assert Phase « ( m , » Transaction Phase « . » AFTER _ ROLLBACK « ) ; }
@Test { Method m = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » phase And Classes Set « " ) ; » assert Phase « ( m , » Transaction Phase « . » AFTER _ COMPLETION « ) ; » supports Event Type « ( true , m , » create Generic Event Type « ( String . class ) ) ; » supports Event Type « ( true , m , » create Generic Event Type « ( Integer . class ) ) ; » supports Event Type « ( false , m , » create Generic Event Type « ( Double . class ) ) ; }
@Test { Method m = » Reflection Utils « . » find Method « ( » Sample Events « . class , " » value Set « " ) ; » assert Phase « ( m , » Transaction Phase « . » AFTER _ COMMIT « ) ; » supports Event Type « ( true , m , » create Generic Event Type « ( String . class ) ) ; » supports Event Type « ( false , m , » create Generic Event Type « ( Double . class ) ) ; }
@Test { load ( » Immediate Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . IMMEDIATELY , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . IMMEDIATELY , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » After Completion Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . » AFTER _ COMPLETION « , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » After Completion Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; status . » set Rollback Only « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . » AFTER _ COMPLETION « , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » After Completion Explicit Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . » AFTER _ COMMIT « , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » Transactional Component Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " SKIP " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; }
@Test { load ( » After Completion Explicit Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; status . » set Rollback Only « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . » AFTER _ ROLLBACK « , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » Before Commit Test Listener « . class , » After Completion Test Listener « . class , » After Completion Explicit Test Listener « . class ) ; this . context . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 0 ) ; }
@Test { load ( » Before Commit Test Listener « . class , » After Completion Test Listener « . class ) ; » get Context « ( ) . » get Bean « ( » Test Bean « . class ) . » not Supported « ( ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 0 ) ; }
@Test { load ( » Before Commit Test Listener « . class , » After Completion Test Listener « . class ) ; » get Context « ( ) . » get Bean « ( » Test Bean « . class ) . supports ( ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 0 ) ; }
@Test { load ( » Before Commit Test Listener « . class , » After Completion Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » get Bean « ( » Test Bean « . class ) . supports ( ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 2 ) ; }
@Test { load ( » Before Commit Test Listener « . class , » After Completion Test Listener « . class ) ; » get Context « ( ) . » get Bean « ( » Test Bean « . class ) . required ( ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 2 ) ; }
@Test { load ( » Immediate Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " SKIP " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; }
@Test { load ( » After Commit Meta Annotation Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " test " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert Events « ( » Event Collector « . » AFTER _ COMMIT « , " test " ) ; » get Event Collector « ( ) . » assert Total Events Count « ( 1 ) ; }
@Test { load ( » After Commit Meta Annotation Test Listener « . class ) ; this . » transaction Template « . execute ( status -> { » get Context « ( ) . » publish Event « ( " SKIP " ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; return null ; } ) ; » get Event Collector « ( ) . » assert No Event Received « ( ) ; }
@Test { » Rollback Rule Attribute « rr = new » Rollback Rule Attribute « ( java . lang . Exception . class . » get Name « ( ) ) ; » assert That « ( rr . » get Depth « ( new Exception ( ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » Rollback Rule Attribute « rr = new » Rollback Rule Attribute « ( Exception . class ) ; » assert That « ( rr . » get Depth « ( new Exception ( ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » Rollback Rule Attribute « rr = new » Rollback Rule Attribute « ( java . io . » IO Exception « . class . » get Name « ( ) ) ; » assert That « ( rr . » get Depth « ( new » My Runtime Exception « ( " " ) ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Rollback Rule Attribute « rr = new » Rollback Rule Attribute « ( java . lang . Exception . class . » get Name « ( ) ) ; » assert That « ( rr . » get Depth « ( new » My Runtime Exception « ( " " ) ) ) . » is Equal To « ( 3 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Rollback Rule Attribute « ( » String Buffer « . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Rollback Rule Attribute « ( ( Class < ? > ) null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Rollback Rule Attribute « ( ( String ) null ) ) ; }
@Test { » Transaction Interceptor « ti = new » Transaction Interceptor « ( ) ; ti . » set Transaction Attributes « ( new Properties ( ) ) ; » Transaction Attribute Source Advisor « tas = new » Transaction Attribute Source Advisor « ( ti ) ; » Serialization Test Utils « . » serialize And Deserialize « ( tas ) ; }
@Test { » Reactive Transaction Manager « rtm = mock ( » Reactive Transaction Manager « . class ) ; » Default Test Bean « tb = new » Default Test Bean « ( ) ; » Transaction Attribute Source « tas = new » Map Transaction Attribute Source « ( ) ; » Test Bean « itb = ( » Test Bean « ) advised ( tb , rtm , tas ) ; » check Reactive Transaction « ( false ) ; itb . » get Name « ( ) ; » check Reactive Transaction « ( false ) ; » verify No Interactions « ( rtm ) ; }
@Test { » do Test Rollback On Exception « ( new Exception ( ) , true , false ) ; }
@Test { » do Test Rollback On Exception « ( new Exception ( ) , false , false ) ; }
@Test { » do Test Rollback On Exception « ( new » Runtime Exception « ( ) , true , false ) ; }
@Test { » do Test Rollback On Exception « ( new » Runtime Exception « ( ) , false , false ) ; }
@Test { » do Test Rollback On Exception « ( new Exception ( ) , true , true ) ; }
@Test { » do Test Rollback On Exception « ( new Exception ( ) , false , true ) ; }
@Test { » do Test Rollback On Exception « ( new » Runtime Exception « ( ) , true , true ) ; }
@Test { » do Test Rollback On Exception « ( new » Runtime Exception « ( ) , false , true ) ; }
@Test { » Platform Transaction Manager « ptm = mock ( » Platform Transaction Manager « . class ) ; » Test Bean « tb = new » Test Bean « ( ) ; » Transaction Attribute Source « tas = new » Map Transaction Attribute Source « ( ) ; » I Test Bean « itb = ( » I Test Bean « ) advised ( tb , ptm , tas ) ; » check Transaction Status « ( false ) ; itb . » get Name « ( ) ; » check Transaction Status « ( false ) ; » verify No Interactions « ( ptm ) ; }
@Test { » Rule Based Transaction Attribute « rta = new » Rule Based Transaction Attribute « ( ) ; » assert That « ( rta . » rollback On « ( new » Runtime Exception « ( ) ) ) . » is True « ( ) ; » assert That « ( rta . » rollback On « ( new » My Runtime Exception « ( " " ) ) ) . » is True « ( ) ; » assert That « ( rta . » rollback On « ( new Exception ( ) ) ) . » is False « ( ) ; » assert That « ( rta . » rollback On « ( new » IO Exception « ( ) ) ) . » is False « ( ) ; }
@Test { List < » Rollback Rule Attribute « > l = new » Linked List « < > ( ) ; l . add ( new » Rollback Rule Attribute « ( java . rmi . » Remote Exception « . class . » get Name « ( ) ) ) ; » Rule Based Transaction Attribute « rta = new » Rule Based Transaction Attribute « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « , l ) ; » do Test Rule For Selective Rollback On Checked « ( rta ) ; }
@Test { List < » Rollback Rule Attribute « > l = Collections . » singleton List « ( new » Rollback Rule Attribute « ( » Remote Exception « . class ) ) ; » Rule Based Transaction Attribute « rta = new » Rule Based Transaction Attribute « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « , l ) ; » do Test Rule For Selective Rollback On Checked « ( rta ) ; }
@Test { editor . » set As Text « ( null ) ; » Transaction Attribute Source « tas = ( » Transaction Attribute Source « ) editor . » get Value « ( ) ; Method m = Object . class . » get Method « ( " » hash Code « " ) ; » assert That « ( tas . » get Transaction Attribute « ( m , null ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set As Text « ( " foo = bar " ) ) ; }
@Test { » I Test Bean « » test Bean « = ( » I Test Bean « ) factory . » get Bean « ( " » proxy Factory 1 « " ) ; » assert That « ( Proxy . » is Proxy Class « ( » test Bean « . » get Class « ( ) ) ) . as ( " » test Bean « is a dynamic proxy " ) . » is True « ( ) ; boolean condition = » test Bean « instanceof » Transactional Proxy « ; » assert That « ( condition ) . » is False « ( ) ; » do Test Gets Are Not Transactional « ( » test Bean « ) ; }
@Test { this . factory . » pre Instantiate Singletons « ( ) ; » I Test Bean « » test Bean « = ( » I Test Bean « ) factory . » get Bean « ( " » proxy Factory 2 Dynamic Proxy « " ) ; » assert That « ( Proxy . » is Proxy Class « ( » test Bean « . » get Class « ( ) ) ) . as ( " » test Bean « is a dynamic proxy " ) . » is True « ( ) ; boolean condition = » test Bean « instanceof » Transactional Proxy « ; » assert That « ( condition ) . » is True « ( ) ; » do Test Gets Are Not Transactional « ( » test Bean « ) ; }
@Test { » I Test Bean « » test Bean « = ( » I Test Bean « ) factory . » get Bean « ( " » proxy Factory 2 Cglib « " ) ; » assert That « ( » Aop Utils « . » is Cglib Proxy « ( » test Bean « ) ) . as ( " » test Bean « is CGLIB advised " ) . » is True « ( ) ; boolean condition = » test Bean « instanceof » Transactional Proxy « ; » assert That « ( condition ) . » is True « ( ) ; » do Test Gets Are Not Transactional « ( » test Bean « ) ; }
@Test { » I Test Bean « » test Bean « = ( » I Test Bean « ) factory . » get Bean « ( " » proxy Factory 2 Lazy « " ) ; » assert That « ( factory . » contains Singleton « ( " target " ) ) . » is False « ( ) ; » assert That « ( » test Bean « . » get Age « ( ) ) . » is Equal To « ( 666 ) ; » assert That « ( factory . » contains Singleton « ( " target " ) ) . » is True « ( ) ; }
@Test { Map < String , » I Test Bean « > » beans Of Type « = factory . » get Beans Of Type « ( » I Test Bean « . class , true , true ) ; » assert That « ( » beans Of Type « ) . » is Not Null « ( ) ; }
@Test { » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( ( ) -> { » Default Listable Bean Factory « bf = new » Default Listable Bean Factory « ( ) ; new » Xml Bean Definition Reader « ( bf ) . » load Bean Definitions « ( new » Class Path Resource « ( " » no Transaction Attribute Source « . xml " , » get Class « ( ) ) ) ; bf . » get Bean « ( " » no Transaction Attribute Source « " ) ; } ) ; }
@Test { » Transaction Attribute Editor « pe = new » Transaction Attribute Editor « ( ) ; pe . » set As Text « ( null ) ; » Transaction Attribute « ta = ( » Transaction Attribute « ) pe . » get Value « ( ) ; » assert That « ( ta == null ) . » is True « ( ) ; }
@Test { » Transaction Attribute Editor « pe = new » Transaction Attribute Editor « ( ) ; pe . » set As Text « ( " " ) ; » Transaction Attribute « ta = ( » Transaction Attribute « ) pe . » get Value « ( ) ; » assert That « ( ta == null ) . » is True « ( ) ; }
@Test { » Transaction Attribute Editor « pe = new » Transaction Attribute Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> pe . » set As Text « ( " » XXPROPAGATION _ REQUIRED « " ) ) ; }
@Test { » Transaction Attribute Editor « pe = new » Transaction Attribute Editor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> pe . » set As Text « ( " » PROPAGATION _ REQUIRED « , » ISOLATION _ READ _ UNCOMMITTED « , XXX " ) ) ; }
@Test { » Name Match Transaction Attribute Source « tas = new » Name Match Transaction Attribute Source « ( ) ; Properties attributes = new Properties ( ) ; attributes . put ( " * » ash Code « " , " » PROPAGATION _ REQUIRED « " ) ; tas . » set Properties « ( attributes ) ; » Transaction Attribute « ta = tas . » get Transaction Attribute « ( Object . class . » get Method « ( " » hash Code « " ) , null ) ; » assert That « ( ta ) . » is Not Null « ( ) ; » assert That « ( ta . » get Propagation Behavior « ( ) ) . » is Equal To « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « ) ; }
@Test { » Name Match Transaction Attribute Source « tas = new » Name Match Transaction Attribute Source « ( ) ; Properties attributes = new Properties ( ) ; attributes . put ( " » hash Cod « * " , " » PROPAGATION _ REQUIRED « " ) ; tas . » set Properties « ( attributes ) ; » Transaction Attribute « ta = tas . » get Transaction Attribute « ( Object . class . » get Method « ( " » hash Code « " ) , null ) ; » assert That « ( ta ) . » is Not Null « ( ) ; » assert That « ( ta . » get Propagation Behavior « ( ) ) . » is Equal To « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « ) ; }
@Test { » Name Match Transaction Attribute Source « tas = new » Name Match Transaction Attribute Source « ( ) ; Properties attributes = new Properties ( ) ; attributes . put ( " " , " » PROPAGATION _ MANDATORY « " ) ; tas . » set Properties « ( attributes ) ; » Transaction Attribute « ta = tas . » get Transaction Attribute « ( Object . class . » get Method « ( " » hash Code « " ) , null ) ; » assert That « ( ta ) . » is Null « ( ) ; }
@Test { » Platform Transaction Manager « » transaction Manager « = mock ( » Platform Transaction Manager « . class ) ; » Transaction Interceptor « ti = » transaction Interceptor With Transaction Manager « ( » transaction Manager « , null ) ; » assert That « ( ti . » determine Transaction Manager « ( new » Default Transaction Attribute « ( ) ) ) . » is Same As « ( » transaction Manager « ) ; }
@Test { » Platform Transaction Manager « » transaction Manager « = mock ( » Platform Transaction Manager « . class ) ; » Transaction Interceptor « ti = » transaction Interceptor With Transaction Manager « ( » transaction Manager « , null ) ; » assert That « ( ti . » determine Transaction Manager « ( null ) ) . » is Same As « ( » transaction Manager « ) ; }
@Test { » Bean Factory « » bean Factory « = mock ( » Bean Factory « . class ) ; » Transaction Interceptor « ti = » simple Transaction Interceptor « ( » bean Factory « ) ; » assert That « ( ti . » determine Transaction Manager « ( null ) ) . » is Null « ( ) ; }
@Test { » Bean Factory « » bean Factory « = mock ( » Bean Factory « . class ) ; » Transaction Interceptor « ti = » simple Transaction Interceptor « ( » bean Factory « ) ; » Default Transaction Attribute « attribute = new » Default Transaction Attribute « ( ) ; attribute . » set Qualifier « ( " » foo Transaction Manager « " ) ; » assert That Exception Of Type « ( » No Such Bean Definition Exception « . class ) . » is Thrown By « ( ( ) -> ti . » determine Transaction Manager « ( attribute ) ) . » with Message Containing « ( " 'fooTransactionManager' " ) ; }
@Test { » Bean Factory « » bean Factory « = mock ( » Bean Factory « . class ) ; » Platform Transaction Manager « » default Transaction Manager « = » associate Transaction Manager « ( » bean Factory « , " » default Transaction Manager « " ) ; » Transaction Interceptor « ti = » transaction Interceptor With Transaction Manager Name « ( " » default Transaction Manager « " , » bean Factory « ) ; » Default Transaction Attribute « attribute = new » Default Transaction Attribute « ( ) ; attribute . » set Qualifier « ( " " ) ; » assert That « ( ti . » determine Transaction Manager « ( attribute ) ) . » is Same As « ( » default Transaction Manager « ) ; }
@Test { » Mock UOW Manager « manager = new » Mock UOW Manager « ( ) ; » Web Sphere Uow Transaction Manager « ptm = new » Web Sphere Uow Transaction Manager « ( manager ) ; » Default Transaction Definition « definition = new » Default Transaction Definition « ( ) ; definition . » set Propagation Behavior « ( » Transaction Definition « . » PROPAGATION _ MANDATORY « ) ; » assert That Exception Of Type « ( » Illegal Transaction State Exception « . class ) . » is Thrown By « ( ( ) -> ptm . execute ( definition , new » Transaction Callback « < String > ( ) { @ Override public String » do In Transaction « ( » Transaction Status « status ) { return " result " ; } } ) ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ALWAYS « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ NOT _ SUPPORTED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ALWAYS « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ NEVER « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ALWAYS « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ NOT _ SUPPORTED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ NEVER « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ NEVER « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ NOT _ SUPPORTED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ NEVER « ) ; }
@Test { » do Test New Transaction Synchronization « ( » Transaction Definition « . » PROPAGATION _ NEVER « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ NEVER « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ALWAYS « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ REQUIRES _ NEW « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ALWAYS « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ NESTED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ALWAYS « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ REQUIRES _ NEW « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ NESTED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ NEVER « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ REQUIRES _ NEW « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ NEVER « ) ; }
@Test { » do Test New Transaction With Commit « ( » Transaction Definition « . » PROPAGATION _ NESTED « , » Web Sphere Uow Transaction Manager « . » SYNCHRONIZATION _ NEVER « ) ; }
@Test { » do Test Existing Transaction With Participation « ( » Transaction Definition « . » PROPAGATION _ REQUIRED « ) ; }
@Test { » do Test Existing Transaction With Participation « ( » Transaction Definition « . » PROPAGATION _ SUPPORTS « ) ; }
@Test { » do Test Existing Transaction With Participation « ( » Transaction Definition « . » PROPAGATION _ MANDATORY « ) ; }
@Test { » do Test Existing Transaction With Suspension « ( » Transaction Definition « . » PROPAGATION _ REQUIRES _ NEW « ) ; }
@Test { » do Test Existing Transaction With Suspension « ( » Transaction Definition « . » PROPAGATION _ NOT _ SUPPORTED « ) ; }
@Test { » Transactional Operator « operator = » Transactional Operator « . create ( tm , new » Default Transaction Definition « ( ) ) ; Mono . just ( true ) . as ( operator :: transactional ) . as ( » Step Verifier « :: create ) . » expect Next « ( true ) . » verify Complete « ( ) ; » assert That « ( tm . commit ) . » is True « ( ) ; » assert That « ( tm . rollback ) . » is False « ( ) ; }
@Test { » Atomic Boolean « cancelled = new » Atomic Boolean « ( ) ; » Transactional Operator « operator = » Transactional Operator « . create ( tm , new » Default Transaction Definition « ( ) ) ; Mono . just ( true ) . » do On Cancel « ( ( ) -> cancelled . set ( true ) ) . as ( operator :: transactional ) . as ( » Step Verifier « :: create ) . » expect Next « ( true ) . » verify Complete « ( ) ; » assert That « ( tm . commit ) . » is True « ( ) ; » assert That « ( tm . rollback ) . » is False « ( ) ; » assert That « ( cancelled ) . » is False « ( ) ; }
@Test { » Transactional Operator « operator = » Transactional Operator « . create ( tm , new » Default Transaction Definition « ( ) ) ; Mono . error ( new » Illegal State Exception « ( ) ) . as ( operator :: transactional ) . as ( » Step Verifier « :: create ) . » verify Error « ( » Illegal State Exception « . class ) ; » assert That « ( tm . commit ) . » is False « ( ) ; » assert That « ( tm . rollback ) . » is True « ( ) ; }
@Test { » Transactional Operator « operator = » Transactional Operator « . create ( tm , new » Default Transaction Definition « ( ) ) ; Flux . just ( 1 , 2 , 3 , 4 ) . as ( operator :: transactional ) . as ( » Step Verifier « :: create ) . » expect Next Count « ( 4 ) . » verify Complete « ( ) ; » assert That « ( tm . commit ) . » is True « ( ) ; » assert That « ( tm . rollback ) . » is False « ( ) ; }
@Test { » Transactional Operator « operator = » Transactional Operator « . create ( tm , new » Default Transaction Definition « ( ) ) ; Flux . error ( new » Illegal State Exception « ( ) ) . as ( operator :: transactional ) . as ( » Step Verifier « :: create ) . » verify Error « ( » Illegal State Exception « . class ) ; » assert That « ( tm . commit ) . » is False « ( ) ; » assert That « ( tm . rollback ) . » is True « ( ) ; }
@Test { » Reactive Test Transaction Manager « tm = new » Reactive Test Transaction Manager « ( false , true ) ; tm . » get Reactive Transaction « ( new » Default Transaction Definition « ( ) ) . » flat Map « ( tm :: commit ) . » subscriber Context « ( » Transaction Context Manager « . » create Transaction Context « ( ) ) . as ( » Step Verifier « :: create ) . » verify Complete « ( ) ; » assert Has Began « ( tm ) ; » assert Has Committed « ( tm ) ; » assert Has No Rollback « ( tm ) ; » assert Has Not Set Rollback Only « ( tm ) ; » assert Has Cleaned Up « ( tm ) ; }
@Test { » Reactive Test Transaction Manager « tm = new » Reactive Test Transaction Manager « ( false , true ) ; tm . » get Reactive Transaction « ( new » Default Transaction Definition « ( ) ) . » flat Map « ( tm :: rollback ) . » subscriber Context « ( » Transaction Context Manager « . » create Transaction Context « ( ) ) . as ( » Step Verifier « :: create ) . » verify Complete « ( ) ; » assert Has Began « ( tm ) ; » assert Has Not Committed « ( tm ) ; » assert Has Rolled Back « ( tm ) ; » assert Has Not Set Rollback Only « ( tm ) ; » assert Has Cleaned Up « ( tm ) ; }
@Test { » Reactive Test Transaction Manager « tm = new » Reactive Test Transaction Manager « ( true , true ) ; tm . » get Reactive Transaction « ( new » Default Transaction Definition « ( ) ) . » flat Map « ( tm :: commit ) . » subscriber Context « ( » Transaction Context Manager « . » create Transaction Context « ( ) ) . as ( » Step Verifier « :: create ) . » verify Complete « ( ) ; » assert Has Not Began « ( tm ) ; » assert Has Not Committed « ( tm ) ; » assert Has No Rollback « ( tm ) ; » assert Has Not Set Rollback Only « ( tm ) ; » assert Has Not Cleaned Up « ( tm ) ; }
@Test { » Reactive Test Transaction Manager « tm = new » Reactive Test Transaction Manager « ( true , true ) ; tm . » get Reactive Transaction « ( new » Default Transaction Definition « ( ) ) . » flat Map « ( tm :: rollback ) . » subscriber Context « ( » Transaction Context Manager « . » create Transaction Context « ( ) ) . as ( » Step Verifier « :: create ) . » verify Complete « ( ) ; » assert Has Not Began « ( tm ) ; » assert Has Not Committed « ( tm ) ; » assert Has No Rollback « ( tm ) ; » assert Has Set Rollback Only « ( tm ) ; » assert Has Not Cleaned Up « ( tm ) ; }
@Test { » Reactive Test Transaction Manager « tm = new » Reactive Test Transaction Manager « ( false , true ) ; » Transactional Operator « operator = » Transactional Operator « . create ( tm , new » Default Transaction Definition « ( ) ) ; Flux . just ( " Walter " ) . as ( operator :: transactional ) . as ( » Step Verifier « :: create ) . » expect Next Count « ( 1 ) . » verify Complete « ( ) ; » assert Has Began « ( tm ) ; » assert Has Committed « ( tm ) ; » assert Has No Rollback « ( tm ) ; » assert Has Not Set Rollback Only « ( tm ) ; » assert Has Cleaned Up « ( tm ) ; }
@Test { String body = " foo " ; » Http Entity « < String > entity = new » Http Entity « < > ( body ) ; » assert That « ( entity . » get Body « ( ) ) . » is Same As « ( body ) ; » assert That « ( entity . » get Headers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { for ( Map . Entry < Integer , String > entry : » status Codes « . » entry Set « ( ) ) { int value = entry . » get Key « ( ) ; » Http Status « status = » Http Status « . » value Of « ( value ) ; » assert That « ( status . value ( ) ) . as ( " Invalid value " ) . » is Equal To « ( value ) ; » assert That « ( status . name ( ) ) . as ( " Invalid name for [ " + value + " ] " ) . » is Equal To « ( entry . » get Value « ( ) ) ; } }
@Test { for ( » Http Status « status : » Http Status « . values ( ) ) { int value = status . value ( ) ; if ( value == 302 || value == 413 || value == 414 ) { continue ; } » assert That « ( » status Codes « . » contains Key « ( value ) ) . as ( " Map has no value for [ " + value + " ] " ) . » is True « ( ) ; » assert That « ( status . name ( ) ) . as ( " Invalid name for [ " + value + " ] " ) . » is Equal To « ( » status Codes « . get ( value ) ) ; } }
@Test { » assert That « ( » Media Type Factory « . » get Media Type « ( ( String ) null ) . » is Present « ( ) ) . » is False « ( ) ; » assert That « ( » Media Type Factory « . » get Media Type « ( ( Resource ) null ) . » is Present « ( ) ) . » is False « ( ) ; » assert That « ( » Media Type Factory « . » get Media Types « ( null ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Media Type « » media Type « = new » Media Type « ( " text " , " plain " , 0.7 ) ; String result = » media Type « . » to String « ( ) ; » assert That « ( result ) . as ( " Invalid » to String « ( ) returned " ) . » is Equal To « ( " text / plain ; q = 0.7 " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Media Type « ( " text / plain " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Media Type « ( " text " , " / " ) ) ; }
@Test { » Media Type « » media Type « = new » Media Type « ( " text " , " plain " ) ; » assert That « ( » media Type « . » get Quality Value « ( ) ) . as ( " Invalid quality value " ) . » is Close To « ( 1D , within ( 0D ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " audio " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " audio / " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " * / json " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " audio ( / basic " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " audio / basic ) " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " » audio / « * ; » = value « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " » audio / « * ; » attr = « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " » audio / « * ; attr < » = value « " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " » audio / « * ; » attr = v « > alue " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " audio / basic ; q = 1.1 " ) ) ; }
@Test { » assert That Exception Of Type « ( » Invalid Media Type Exception « . class ) . » is Thrown By « ( ( ) -> » Media Type « . » parse Media Type « ( " text / html ; charset = foo - bar " ) ) ; }
@Test { List < » Media Type « > » media Types « = » Media Type « . » parse Media Types « ( " text / plain , text / html , " ) ; » assert That « ( » media Types « ) . as ( " No media types returned " ) . » is Not Null « ( ) ; » assert That « ( » media Types « . size ( ) ) . as ( " Incorrect number of media types " ) . » is Equal To « ( 2 ) ; }
@Test { » Conversion Service « » conversion Service « = new » Default Conversion Service « ( ) ; » assert That « ( » conversion Service « . » can Convert « ( String . class , » Media Type « . class ) ) . » is True « ( ) ; » Media Type « » media Type « = » Media Type « . » parse Media Type « ( " application / xml " ) ; » assert That « ( » conversion Service « . convert ( " application / xml " , » Media Type « . class ) ) . » is Equal To « ( » media Type « ) ; }
@Test { » assert That « ( » Media Type « . » TEXT _ PLAIN « . » is Concrete « ( ) ) . as ( " text / plain not concrete " ) . » is True « ( ) ; » assert That « ( » Media Type « . ALL . » is Concrete « ( ) ) . as ( " * / * concrete " ) . » is False « ( ) ; » assert That « ( new » Media Type « ( " text " , " * " ) . » is Concrete « ( ) ) . as ( " » text / « * concrete " ) . » is False « ( ) ; }
@Test { URI url = new URI ( " https : » // example . com « " ) ; List < String > body = Arrays . » as List « ( " foo " , " bar " ) ; » Parameterized Type Reference « < ? > » type Reference « = new » Parameterized Type Reference « < List < String > > ( ) { } ; » Request Entity « < ? > entity = » Request Entity « . post ( url ) . body ( body , » type Reference « . » get Type « ( ) ) ; » assert That « ( entity . » get Type « ( ) ) . » is Equal To « ( » type Reference « . » get Type « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Http Range « . » create Byte Range « ( - 1 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Http Range « . » create Byte Range « ( 10 , 9 ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Http Range « . » create Suffix Range « ( - 1 ) ) ; }
@Test { » Http Range « range = » Http Range « . » create Byte Range « ( 0 , 499 ) ; » assert That « ( range . » get Range Start « ( 1000 ) ) . » is Equal To « ( 0 ) ; » assert That « ( range . » get Range End « ( 1000 ) ) . » is Equal To « ( 499 ) ; }
@Test { » Http Range « range = » Http Range « . » create Byte Range « ( 9500 ) ; » assert That « ( range . » get Range Start « ( 10000 ) ) . » is Equal To « ( 9500 ) ; » assert That « ( range . » get Range End « ( 10000 ) ) . » is Equal To « ( 9999 ) ; }
@Test { » Http Range « range = » Http Range « . » create Byte Range « ( 9500 , 9500 ) ; » assert That « ( range . » get Range Start « ( 10000 ) ) . » is Equal To « ( 9500 ) ; » assert That « ( range . » get Range End « ( 10000 ) ) . » is Equal To « ( 9500 ) ; }
@Test { » Http Range « range = » Http Range « . » create Suffix Range « ( 500 ) ; » assert That « ( range . » get Range Start « ( 1000 ) ) . » is Equal To « ( 500 ) ; » assert That « ( range . » get Range End « ( 1000 ) ) . » is Equal To « ( 999 ) ; }
@Test { » Http Range « range = » Http Range « . » create Suffix Range « ( 500 ) ; » assert That « ( range . » get Range Start « ( 350 ) ) . » is Equal To « ( 0 ) ; » assert That « ( range . » get Range End « ( 350 ) ) . » is Equal To « ( 349 ) ; }
@Test { List < » Http Range « > ranges = new » Array List « < > ( ) ; ranges . add ( » Http Range « . » create Byte Range « ( 0 , 499 ) ) ; ranges . add ( » Http Range « . » create Byte Range « ( 9500 ) ) ; ranges . add ( » Http Range « . » create Suffix Range « ( 500 ) ) ; » assert That « ( » Http Range « . » to String « ( ranges ) ) . as ( " Invalid Range header " ) . » is Equal To « ( " bytes = 0 - 499 , 9500 - , - 500 " ) ; }
@Test { » Input Stream Resource « resource = mock ( » Input Stream Resource « . class ) ; » Http Range « range = » Http Range « . » create Byte Range « ( 0 , 9 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> range . » to Resource Region « ( resource ) ) ; }
@Test { » Byte Array Resource « resource = mock ( » Byte Array Resource « . class ) ; given ( resource . » content Length « ( ) ) . » will Return « ( - 1L ) ; » Http Range « range = » Http Range « . » create Byte Range « ( 0 , 9 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> range . » to Resource Region « ( resource ) ) ; }
@Test { » Input Stream Resource « resource = mock ( » Input Stream Resource « . class ) ; given ( resource . » content Length « ( ) ) . » will Throw « ( » IO Exception « . class ) ; » Http Range « range = » Http Range « . » create Byte Range « ( 0 , 9 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> range . » to Resource Region « ( resource ) ) ; }
@Test { byte [ ] bytes = " Spring Framework " . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ; » Byte Array Resource « resource = new » Byte Array Resource « ( bytes ) ; » Http Range « range = » Http Range « . » create Byte Range « ( resource . » content Length « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> range . » to Resource Region « ( resource ) ) ; }
@Test { » Response Entity « < Void > » response Entity « = » Response Entity « . ok ( ) . build ( ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . OK ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { Integer entity = 42 ; » Response Entity « < Integer > » response Entity « = » Response Entity « . ok ( entity ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . OK ) ; » assert That « ( ( int ) » response Entity « . » get Body « ( ) ) . » is Equal To « ( ( int ) entity ) ; }
@Test { Integer entity = 42 ; » Response Entity « < Integer > » response Entity « = » Response Entity « . of ( Optional . of ( entity ) ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . OK ) ; » assert That « ( ( int ) » response Entity « . » get Body « ( ) ) . » is Equal To « ( ( int ) entity ) ; }
@Test { » Response Entity « < Integer > » response Entity « = » Response Entity « . of ( Optional . empty ( ) ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Response Entity « < Void > » response Entity « = » Response Entity « . accepted ( ) . build ( ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . ACCEPTED ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Response Entity « < String > » response Entity « = » Response Entity « . accepted ( ) . build ( ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . ACCEPTED ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Response Entity « < Void > » response Entity « = » Response Entity « . » no Content « ( ) . build ( ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » NO _ CONTENT « ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Response Entity « < Void > » response Entity « = » Response Entity « . » bad Request « ( ) . build ( ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Response Entity « < Void > » response Entity « = » Response Entity « . » not Found « ( ) . build ( ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Response Entity « < String > » response Entity « = » Response Entity « . » unprocessable Entity « ( ) . body ( " error " ) ; » assert That « ( » response Entity « ) . » is Not Null « ( ) ; » assert That « ( » response Entity « . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » UNPROCESSABLE _ ENTITY « ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { Integer entity = 42 ; » Response Entity « < Integer > » response Entity « = » Response Entity « . status ( 200 ) . body ( entity ) ; » assert That « ( » response Entity « . » get Status Code « ( ) . value ( ) ) . » is Equal To « ( 200 ) ; » assert That « ( ( int ) » response Entity « . » get Body « ( ) ) . » is Equal To « ( ( int ) entity ) ; }
@Test { Integer entity = 42 ; » Response Entity « < Integer > » response Entity « = » Response Entity « . status ( 299 ) . body ( entity ) ; » assert That « ( » response Entity « . » get Status Code Value « ( ) ) . » is Equal To « ( 299 ) ; » assert That « ( ( int ) » response Entity « . » get Body « ( ) ) . » is Equal To « ( ( int ) entity ) ; }
@Test { » Cache Control « cc = » Cache Control « . empty ( ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Null « ( ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( 1 , » Time Unit « . HOURS ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( Duration . » of Hours « ( 1 ) ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( 3600 , » Time Unit « . SECONDS ) . » cache Public « ( ) . » no Transform « ( ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , no - transform , public " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( 1 , » Time Unit « . HOURS ) . » s Max Age « ( 30 , » Time Unit « . MINUTES ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , s - maxage = 1800 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( Duration . » of Hours « ( 1 ) ) . » s Max Age « ( Duration . » of Minutes « ( 30 ) ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , s - maxage = 1800 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » no Cache « ( ) . » cache Private « ( ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " no - cache , private " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » no Store « ( ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " no - store " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( 1 , » Time Unit « . HOURS ) . » stale If Error « ( 2 , » Time Unit « . HOURS ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , stale - if - error = 7200 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( Duration . » of Hours « ( 1 ) ) . » stale If Error « ( 2 , » Time Unit « . HOURS ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , stale - if - error = 7200 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( 1 , » Time Unit « . HOURS ) . » stale While Revalidate « ( 2 , » Time Unit « . HOURS ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , stale - while - revalidate = 7200 " ) ; }
@Test { » Cache Control « cc = » Cache Control « . » max Age « ( Duration . » of Hours « ( 1 ) ) . » stale While Revalidate « ( 2 , » Time Unit « . HOURS ) ; » assert That « ( cc . » get Header Value « ( ) ) . » is Equal To « ( " max - age = 3600 , stale - while - revalidate = 7200 " ) ; }
@Test { » assert That « ( parse ( " form - data ; name = \" foo \" ; filename = \" foo . txt \" ; size = 123 " ) ) . » is Equal To « ( builder ( " form - data " ) . name ( " foo " ) . filename ( " foo . txt " ) . size ( 123L ) . build ( ) ) ; }
@Test { » assert That « ( parse ( " form - data ; filename = unquoted " ) ) . » is Equal To « ( builder ( " form - data " ) . filename ( " unquoted " ) . build ( ) ) ; }
@Test { » assert That « ( parse ( " attachment ; filename = \" filename with ; semicolon . txt \" " ) ) . » is Equal To « ( builder ( " attachment " ) . filename ( " filename with ; semicolon . txt " ) . build ( ) ) ; }
@Test { » assert That « ( parse ( " form - data ; name = \" name \" ; filename *= UTF - 8 '' % » E 4 « % » B 8 « % AD % » E 6 « % 96 % 87. txt " ) ) . » is Equal To « ( builder ( " form - data " ) . name ( " name " ) . filename ( " 中文 . txt " , » Standard Charsets « . » UTF _ 8 « ) . build ( ) ) ; }
@Test { » assert That « ( parse ( " attachment ; filename *= UTF - 8 '' some - file . zip " ) ) . » is Equal To « ( builder ( " attachment " ) . filename ( " some - file . zip " , » Standard Charsets « . » UTF _ 8 « ) . build ( ) ) ; }
@Test { » assert That « ( parse ( " form - data ; name = \" name \" ; filename *= test . txt " ) ) . » is Equal To « ( builder ( " form - data " ) . name ( " name " ) . filename ( " test . txt " ) . build ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parse ( " form - data ; name = \" name \" ; filename *= UTF - 16 '' test . txt " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parse ( " form - data ; name = \" name \" ; filename *= UTF - 8 '' % A " ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parse ( " form - data ; name = \" name \" ; filename *= UTF - 8 '' % A . txt " ) ) ; }
@Test { » assert That « ( parse ( " form - data ; name = \" foo \" ; ; ; filename = \" foo . txt \" ; size = 123 " ) ) . » is Equal To « ( builder ( " form - data " ) . name ( " foo " ) . filename ( " foo . txt " ) . size ( 123L ) . build ( ) ) ; }
@Test { » Zoned Date Time « » read Time « = » Zoned Date Time « . parse ( " Wed , 14 Feb 2007 10 : 15 : 30 - 0500 " , formatter ) ; » assert That « ( parse ( " attachment ; " + " creation - date = \" - 1 \" ; " + " modification - date = \" - 1 \" ; " + " read - date = \" " + » read Time « . format ( formatter ) + " \" " ) ) . » is Equal To « ( builder ( " attachment " ) . » read Date « ( » read Time « ) . build ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parse ( " " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parse ( " ; " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> parse ( " foo ; bar " ) ) ; }
@Test { » assert That « ( builder ( " form - data " ) . name ( " foo " ) . filename ( " foo . txt " ) . size ( 123L ) . build ( ) . » to String « ( ) ) . » is Equal To « ( " form - data ; name = \" foo \" ; filename = \" foo . txt \" ; size = 123 " ) ; }
@Test { » assert That « ( builder ( " form - data " ) . name ( " name " ) . filename ( " 中文 . txt " , » Standard Charsets « . » UTF _ 8 « ) . build ( ) . » to String « ( ) ) . » is Equal To « ( " form - data ; name = \" name \" ; filename *= UTF - 8 '' % » E 4 « % » B 8 « % AD % » E 6 « % 96 % 87. txt " ) ; }
@Test { » assert That « ( builder ( " form - data " ) . name ( " name " ) . filename ( " test . txt " , » Standard Charsets « . » US _ ASCII « ) . build ( ) . » to String « ( ) ) . » is Equal To « ( " form - data ; name = \" name \" ; filename = \" test . txt \" " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> builder ( " form - data " ) . name ( " name " ) . filename ( " test . txt " , » Standard Charsets « . » UTF _ 16 « ) . build ( ) . » to String « ( ) ) ; }
@Test { String key = " FOO " ; » assert That « ( headers . get ( key ) ) . » is Null « ( ) ; » assert That « ( headers . » get Or Empty « ( key ) ) . » is Empty « ( ) ; headers . add ( key , " bar " ) ; » assert That « ( headers . » get Or Empty « ( key ) ) . » contains Exactly « ( " bar " ) ; headers . remove ( key ) ; » assert That « ( headers . get ( key ) ) . » is Null « ( ) ; » assert That « ( headers . » get Or Empty « ( key ) ) . » is Empty « ( ) ; }
@Test { headers . add ( » Http Headers « . » CACHE _ CONTROL « , " max - age = 1000 , public " ) ; headers . add ( » Http Headers « . » CACHE _ CONTROL « , " s - maxage = 1000 " ) ; » assert That « ( headers . » get First « ( » Http Headers « . » CACHE _ CONTROL « ) ) . » is Equal To « ( " max - age = 1000 , public " ) ; }
@Test { headers . add ( " Accept " , " text / html " ) ; headers . add ( " Accept " , " text / plain " ) ; List < » Media Type « > expected = Arrays . » as List « ( new » Media Type « ( " text " , " html " ) , new » Media Type « ( " text " , " plain " ) ) ; » assert That « ( headers . » get Accept « ( ) ) . as ( " Invalid Accept header " ) . » is Equal To « ( expected ) ; }
@Test { headers . set ( " Accept - Charset " , " ISO - 8859 - 1 , utf - 8 ; q = 0.7 , * ; q = 0.7 " ) ; » assert That « ( headers . » get Accept Charset « ( ) ) . as ( " Invalid Accept header " ) . » is Equal To « ( Arrays . » as List « ( » Standard Charsets « . » ISO _ 8859 _ 1 « , » Standard Charsets « . » UTF _ 8 « ) ) ; }
@Test { » Enum Set « < » Http Method « > methods = » Enum Set « . of ( » Http Method « . GET , » Http Method « . POST ) ; headers . » set Allow « ( methods ) ; » assert That « ( headers . » get Allow « ( ) ) . as ( " Invalid Allow header " ) . » is Equal To « ( methods ) ; » assert That « ( headers . » get First « ( " Allow " ) ) . as ( " Invalid Allow header " ) . » is Equal To « ( " GET , POST " ) ; }
@Test { long length = 42L ; headers . » set Content Length « ( length ) ; » assert That « ( headers . » get Content Length « ( ) ) . as ( " Invalid Content - Length header " ) . » is Equal To « ( length ) ; » assert That « ( headers . » get First « ( " Content - Length " ) ) . as ( " Invalid Content - Length header " ) . » is Equal To « ( " 42 " ) ; }
@Test { » Media Type « » content Type « = new » Media Type « ( " text " , " html " , » Standard Charsets « . » UTF _ 8 « ) ; headers . » set Content Type « ( » content Type « ) ; » assert That « ( headers . » get Content Type « ( ) ) . as ( " Invalid Content - Type header " ) . » is Equal To « ( » content Type « ) ; » assert That « ( headers . » get First « ( " Content - Type " ) ) . as ( " Invalid Content - Type header " ) . » is Equal To « ( " text / html ; charset = UTF - 8 " ) ; }
@Test { URI location = new URI ( " https : » // www . example . com / hotels « " ) ; headers . » set Location « ( location ) ; » assert That « ( headers . » get Location « ( ) ) . as ( " Invalid Location header " ) . » is Equal To « ( location ) ; » assert That « ( headers . » get First « ( " Location " ) ) . as ( " Invalid Location header " ) . » is Equal To « ( " https : » // www . example . com / hotels « " ) ; }
@Test { String » e Tag « = " \" » v 2 « .6 \" " ; headers . » set E Tag « ( » e Tag « ) ; » assert That « ( headers . » get E Tag « ( ) ) . as ( " Invalid » E Tag « header " ) . » is Equal To « ( » e Tag « ) ; » assert That « ( headers . » get First « ( " » E Tag « " ) ) . as ( " Invalid » E Tag « header " ) . » is Equal To « ( " \" » v 2 « .6 \" " ) ; }
@Test { » Inet Socket Address « host = » Inet Socket Address « . » create Unresolved « ( " localhost " , 8080 ) ; headers . » set Host « ( host ) ; » assert That « ( headers . » get Host « ( ) ) . as ( " Invalid Host header " ) . » is Equal To « ( host ) ; » assert That « ( headers . » get First « ( " Host " ) ) . as ( " Invalid Host header " ) . » is Equal To « ( " localhost : 8080 " ) ; }
@Test { » Inet Socket Address « host = » Inet Socket Address « . » create Unresolved « ( " localhost " , 0 ) ; headers . » set Host « ( host ) ; » assert That « ( headers . » get Host « ( ) ) . as ( " Invalid Host header " ) . » is Equal To « ( host ) ; » assert That « ( headers . » get First « ( " Host " ) ) . as ( " Invalid Host header " ) . » is Equal To « ( " localhost " ) ; }
@Test { » Inet Socket Address « host = » Inet Socket Address « . » create Unresolved « ( " [ :: 1 ] " , 0 ) ; headers . » set Host « ( host ) ; » assert That « ( headers . » get Host « ( ) ) . as ( " Invalid Host header " ) . » is Equal To « ( host ) ; » assert That « ( headers . » get First « ( " Host " ) ) . as ( " Invalid Host header " ) . » is Equal To « ( " [ :: 1 ] " ) ; }
@Test { String » e Tag « = " » v 2 « .6 " ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> headers . » set E Tag « ( » e Tag « ) ) ; }
@Test { String » if Match « = " \" » v 2 « .6 \" " ; headers . » set If Match « ( » if Match « ) ; » assert That « ( headers . » get If Match « ( ) . get ( 0 ) ) . as ( " Invalid If - Match header " ) . » is Equal To « ( » if Match « ) ; » assert That « ( headers . » get First « ( " If - Match " ) ) . as ( " Invalid If - Match header " ) . » is Equal To « ( " \" » v 2 « .6 \" " ) ; }
@Test { headers . » set If Match « ( " Illegal " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( headers :: » get If Match « ) ; }
@Test { String » if None Match « = " \" » v 2 « .6 \" " ; headers . » set If None Match « ( » if None Match « ) ; » assert That « ( headers . » get If None Match « ( ) . get ( 0 ) ) . as ( " Invalid If - None - Match header " ) . » is Equal To « ( » if None Match « ) ; » assert That « ( headers . » get First « ( " If - None - Match " ) ) . as ( " Invalid If - None - Match header " ) . » is Equal To « ( " \" » v 2 « .6 \" " ) ; }
@Test { String » if None Match « = " * " ; headers . » set If None Match « ( » if None Match « ) ; » assert That « ( headers . » get If None Match « ( ) . get ( 0 ) ) . as ( " Invalid If - None - Match header " ) . » is Equal To « ( » if None Match « ) ; » assert That « ( headers . » get First « ( " If - None - Match " ) ) . as ( " Invalid If - None - Match header " ) . » is Equal To « ( " * " ) ; }
@Test { headers . set ( " Date " , " Foo Bar Baz " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( headers :: » get Date « ) ; }
@Test { headers . set ( " Expires " , " - 1 " ) ; » assert That « ( headers . » get Expires « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { String pragma = " no - cache " ; headers . » set Pragma « ( pragma ) ; » assert That « ( headers . » get Pragma « ( ) ) . as ( " Invalid Pragma header " ) . » is Equal To « ( pragma ) ; » assert That « ( headers . » get First « ( " pragma " ) ) . as ( " Invalid Pragma header " ) . » is Equal To « ( " no - cache " ) ; }
@Test { headers . » set Cache Control « ( " no - cache " ) ; » assert That « ( headers . » get Cache Control « ( ) ) . as ( " Invalid Cache - Control header " ) . » is Equal To « ( " no - cache " ) ; » assert That « ( headers . » get First « ( " cache - control " ) ) . as ( " Invalid Cache - Control header " ) . » is Equal To « ( " no - cache " ) ; }
@Test { headers . » set Cache Control « ( » Cache Control « . » no Cache « ( ) ) ; » assert That « ( headers . » get Cache Control « ( ) ) . as ( " Invalid Cache - Control header " ) . » is Equal To « ( " no - cache " ) ; » assert That « ( headers . » get First « ( " cache - control " ) ) . as ( " Invalid Cache - Control header " ) . » is Equal To « ( " no - cache " ) ; }
@Test { headers . » set Cache Control « ( » Cache Control « . empty ( ) ) ; » assert That « ( headers . » get Cache Control « ( ) ) . as ( " Invalid Cache - Control header " ) . » is Null « ( ) ; » assert That « ( headers . » get First « ( " cache - control " ) ) . as ( " Invalid Cache - Control header " ) . » is Null « ( ) ; }
@Test { headers . add ( » Http Headers « . » CACHE _ CONTROL « , " max - age = 1000 , public " ) ; headers . add ( » Http Headers « . » CACHE _ CONTROL « , " s - maxage = 1000 " ) ; » assert That « ( headers . » get Cache Control « ( ) ) . » is Equal To « ( " max - age = 1000 , public , s - maxage = 1000 " ) ; }
@Test { headers . » set Allow « ( Collections . » empty Set « ( ) ) ; » assert That « ( headers . » get Allow « ( ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( headers . » get Access Control Allow Credentials « ( ) ) . » is False « ( ) ; headers . » set Access Control Allow Credentials « ( false ) ; » assert That « ( headers . » get Access Control Allow Credentials « ( ) ) . » is False « ( ) ; headers . » set Access Control Allow Credentials « ( true ) ; » assert That « ( headers . » get Access Control Allow Credentials « ( ) ) . » is True « ( ) ; }
@Test { List < String > » allowed Headers « = headers . » get Access Control Allow Headers « ( ) ; » assert That « ( » allowed Headers « ) . » is Empty « ( ) ; headers . » set Access Control Allow Headers « ( Arrays . » as List « ( " » header 1 « " , " » header 2 « " ) ) ; » allowed Headers « = headers . » get Access Control Allow Headers « ( ) ; » assert That « ( Arrays . » as List « ( " » header 1 « " , " » header 2 « " ) ) . » is Equal To « ( » allowed Headers « ) ; }
@Test { List < » Http Method « > » allowed Methods « = headers . » get Access Control Allow Methods « ( ) ; » assert That « ( » allowed Methods « ) . » is Empty « ( ) ; headers . » set Access Control Allow Methods « ( Arrays . » as List « ( » Http Method « . GET , » Http Method « . POST ) ) ; » allowed Methods « = headers . » get Access Control Allow Methods « ( ) ; » assert That « ( Arrays . » as List « ( » Http Method « . GET , » Http Method « . POST ) ) . » is Equal To « ( » allowed Methods « ) ; }
@Test { » assert That « ( headers . » get Access Control Allow Origin « ( ) ) . » is Null « ( ) ; headers . » set Access Control Allow Origin « ( " * " ) ; » assert That « ( headers . » get Access Control Allow Origin « ( ) ) . » is Equal To « ( " * " ) ; }
@Test { List < String > » exposed Headers « = headers . » get Access Control Expose Headers « ( ) ; » assert That « ( » exposed Headers « ) . » is Empty « ( ) ; headers . » set Access Control Expose Headers « ( Arrays . » as List « ( " » header 1 « " , " » header 2 « " ) ) ; » exposed Headers « = headers . » get Access Control Expose Headers « ( ) ; » assert That « ( Arrays . » as List « ( " » header 1 « " , " » header 2 « " ) ) . » is Equal To « ( » exposed Headers « ) ; }
@Test { » assert That « ( headers . » get Access Control Max Age « ( ) ) . » is Equal To « ( - 1 ) ; headers . » set Access Control Max Age « ( 3600 ) ; » assert That « ( headers . » get Access Control Max Age « ( ) ) . » is Equal To « ( 3600 ) ; }
@Test { List < String > » request Headers « = headers . » get Access Control Request Headers « ( ) ; » assert That « ( » request Headers « ) . » is Empty « ( ) ; headers . » set Access Control Request Headers « ( Arrays . » as List « ( " » header 1 « " , " » header 2 « " ) ) ; » request Headers « = headers . » get Access Control Request Headers « ( ) ; » assert That « ( Arrays . » as List « ( " » header 1 « " , " » header 2 « " ) ) . » is Equal To « ( » request Headers « ) ; }
@Test { » assert That « ( headers . » get Access Control Request Method « ( ) ) . » is Null « ( ) ; headers . » set Access Control Request Method « ( » Http Method « . POST ) ; » assert That « ( headers . » get Access Control Request Method « ( ) ) . » is Equal To « ( » Http Method « . POST ) ; }
@Test { this . headers . set ( » Http Headers « . » ACCEPT _ LANGUAGE « , " " ) ; » assert That « ( this . headers . » get Accept Language As Locales « ( ) ) . » is Equal To « ( Collections . » empty List « ( ) ) ; }
@Test { headers . » set Content Language « ( Locale . FRANCE ) ; » assert That « ( headers . » get Content Language « ( ) ) . » is Equal To « ( Locale . FRANCE ) ; » assert That « ( headers . » get First « ( » Http Headers « . » CONTENT _ LANGUAGE « ) ) . » is Equal To « ( " fr - FR " ) ; }
@Test { headers . set ( » Http Headers « . » CONTENT _ LANGUAGE « , " de , » en _ CA « " ) ; » assert That « ( headers . » get Content Language « ( ) ) . as ( " Expected one ( first ) locale " ) . » is Equal To « ( Locale . GERMAN ) ; }
@Test { headers . » set Date « ( » Http Headers « . DATE , 1496370120000L ) ; » assert That « ( headers . » get First Date « ( » Http Headers « . DATE ) ) . » is Equal To « ( 1496370120000L ) ; headers . clear ( ) ; headers . add ( » Http Headers « . DATE , " Fri , 02 Jun 2017 02 : 22 : 00 GMT " ) ; headers . add ( » Http Headers « . DATE , " Sat , 18 Dec 2010 10 : 20 : 00 GMT " ) ; » assert That « ( headers . » get First Date « ( » Http Headers « . DATE ) ) . » is Equal To « ( 1496370120000L ) ; }
@Test { String username = " foo " ; String password = " λ " ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> headers . » set Basic Auth « ( username , password ) ) ; }
@Test { String token = " foo " ; headers . » set Bearer Auth « ( token ) ; String authorization = headers . » get First « ( » Http Headers « . AUTHORIZATION ) ; » assert That « ( authorization ) . » is Equal To « ( " Bearer foo " ) ; }
@Test { » Http URL Connection « » url Connection « = mock ( » Http URL Connection « . class ) ; given ( » url Connection « . » get Request Method « ( ) ) . » will Return « ( " GET " ) ; » Http Headers « headers = new » Http Headers « ( ) ; headers . set ( " foo " , null ) ; » Simple Buffering Client Http Request « . » add Headers « ( » url Connection « , headers ) ; verify ( » url Connection « , times ( 1 ) ) . » add Request Property « ( " foo " , " " ) ; }
@Test { » Input Stream « is = mock ( » Input Stream « . class ) ; given ( this . connection . » get Error Stream « ( ) ) . » will Return « ( is ) ; » will Do Nothing « ( ) . given ( is ) . close ( ) ; given ( is . read ( any ( ) ) ) . » will Throw « ( new » Null Pointer Exception « ( " from » Http URL Connection « # » Error Stream « " ) ) ; » Input Stream « » response Stream « = this . response . » get Body « ( ) ; » response Stream « . close ( ) ; this . response . close ( ) ; verify ( is ) . close ( ) ; }
@Test { » assert Http Method « ( " patch " , » Http Method « . PATCH ) ; }
@Test { » assert Http Method « ( " get " , » Http Method « . GET ) ; » assert Http Method « ( " head " , » Http Method « . HEAD ) ; » assert Http Method « ( " post " , » Http Method « . POST ) ; » assert Http Method « ( " put " , » Http Method « . PUT ) ; » assert Http Method « ( " options " , » Http Method « . OPTIONS ) ; » assert Http Method « ( " delete " , » Http Method « . DELETE ) ; }
@Test { URI uri = new URI ( » base Url « + " / status / notfound " ) ; » Async Client Http Request « request = this . factory . » create Async Request « ( uri , » Http Method « . GET ) ; Future < » Client Http Response « > » future Response « = request . » execute Async « ( ) ; » future Response « . cancel ( true ) ; » assert That « ( » future Response « . » is Cancelled « ( ) ) . » is True « ( ) ; }
@Test { URI uri = new URI ( » base Url « + " / params ? » param 1 « = value & » param 2 « = » value 1 « & » param 2 « = » value 2 « " ) ; » Client Http Request « request = factory . » create Request « ( uri , » Http Method « . GET ) ; try ( » Client Http Response « response = request . execute ( ) ) { » assert That « ( response . » get Status Code « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( » Http Status « . OK ) ; } }
@Test { super . » http Methods « ( ) ; try { » assert Http Method « ( " patch " , » Http Method « . PATCH ) ; } catch ( » Protocol Exception « ex ) { } }
@Test { try { » assert Http Method « ( " patch " , » Http Method « . PATCH ) ; } catch ( » Protocol Exception « ex ) { } }
@Test { URL uri = new URL ( " https : » // example . com « " ) ; » test Request Body Allowed « ( uri , " GET " , false ) ; » test Request Body Allowed « ( uri , " HEAD " , false ) ; » test Request Body Allowed « ( uri , " OPTIONS " , false ) ; » test Request Body Allowed « ( uri , " TRACE " , false ) ; » test Request Body Allowed « ( uri , " PUT " , true ) ; » test Request Body Allowed « ( uri , " POST " , true ) ; » test Request Body Allowed « ( uri , " DELETE " , true ) ; }
@Test { » Http URL Connection « connection = new » Test Http URL Connection « ( new URL ( " https : » // example . com « " ) ) ; ( ( » Simple Client Http Request Factory « ) this . factory ) . » prepare Connection « ( connection , " DELETE " ) ; » Simple Buffering Client Http Request « request = new » Simple Buffering Client Http Request « ( connection , false ) ; request . execute ( ) ; }
@Test { super . » http Methods « ( ) ; » assert Http Method « ( " patch " , » Http Method « . PATCH ) ; }
@Test { » Http Components Async Client Http Request Factory « factory = new » Http Components Async Client Http Request Factory « ( ) ; URI uri = new URI ( » base Url « + " / status / ok " ) ; » Http Components Async Client Http Request « request = ( » Http Components Async Client Http Request « ) factory . » create Async Request « ( uri , » Http Method « . GET ) ; » assert That « ( request . » get Http Context « ( ) . » get Attribute « ( » Http Client Context « . » REQUEST _ CONFIG « ) ) . as ( " No custom config should be set with a custom » Http Async Client « " ) . » is Null « ( ) ; }
@Test { » Atomic Boolean « invoked = new » Atomic Boolean « ( false ) ; this . » resource Factory « . » add Global Resources Consumer « ( » http Resources « -> invoked . set ( true ) ) ; this . » resource Factory « . » after Properties Set « ( ) ; » assert That « ( invoked . get ( ) ) . » is True « ( ) ; this . » resource Factory « . destroy ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Basic Authorization Interceptor « ( " username : " , " password " ) ) . » with Message Containing « ( " Username must not contain a colon " ) ; }
@Test { » Basic Authorization Interceptor « interceptor = new » Basic Authorization Interceptor « ( null , " password " ) ; » assert That « ( new » Direct Field Accessor « ( interceptor ) . » get Property Value « ( " username " ) ) . » is Equal To « ( " " ) ; }
@Test { » Basic Authorization Interceptor « interceptor = new » Basic Authorization Interceptor « ( " username " , null ) ; » assert That « ( new » Direct Field Accessor « ( interceptor ) . » get Property Value « ( " password " ) ) . » is Equal To « ( " " ) ; }
@Test { » factory Bean « . » set Type « ( null ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » factory Bean « :: » after Properties Set « ) ; }
@Test { » factory Bean « . » set Hostname « ( " " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » factory Bean « :: » after Properties Set « ) ; }
@Test { » factory Bean « . » set Hostname « ( " example . com " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » factory Bean « :: » after Properties Set « ) ; }
@Test { » configure Encoder « ( » Mime Type Utils « . » TEXT _ HTML « , » Mime Type Utils « . » TEXT _ XML « ) ; » Http Message Writer « < ? > writer = new » Encoder Http Message Writer « < > ( this . encoder ) ; » assert That « ( writer . » get Writable Media Types « ( ) ) . » is Equal To « ( Arrays . » as List « ( » TEXT _ HTML « , » TEXT _ XML « ) ) ; }
@Test { » configure Encoder « ( » TEXT _ PLAIN « ) ; » Http Message Writer « < String > writer = new » Encoder Http Message Writer « < > ( this . encoder ) ; writer . write ( Flux . empty ( ) , » for Class « ( String . class ) , » TEXT _ PLAIN « , this . response , » NO _ HINTS « ) ; » assert That « ( response . » get Headers « ( ) . » get Content Type « ( ) ) . » is Equal To « ( » TEXT _ PLAIN « ) ; » assert That « ( this . » media Type Captor « . » get Value « ( ) ) . » is Equal To « ( » TEXT _ PLAIN « ) ; }
@Test { » test Default Media Type « ( null ) ; » test Default Media Type « ( new » Media Type « ( " text " , " * " ) ) ; » test Default Media Type « ( new » Media Type « ( " * " , " * " ) ) ; » test Default Media Type « ( » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ; }
@Test { Mono < String > » input Stream « = Mono . just ( " body " ) . » do On Cancel « ( ( ) -> { throw new » Assertion Error « ( " Cancel signal not expected " ) ; } ) ; new » Encoder Http Message Writer « < > ( » Char Sequence Encoder « . » all Mime Types « ( ) ) . write ( » input Stream « , » for Class « ( String . class ) , » TEXT _ PLAIN « , this . response , » NO _ HINTS « ) . block ( ) ; }
@Test { » configure Encoder « ( » Mime Type Utils « . » TEXT _ PLAIN « ) ; » Http Message Writer « < String > writer = new » Encoder Http Message Writer « < > ( this . encoder ) ; writer . write ( Mono . empty ( ) , » for Class « ( String . class ) , » TEXT _ PLAIN « , this . response , » NO _ HINTS « ) . block ( ) ; » Step Verifier « . create ( this . response . » get Body « ( ) ) . » verify Complete « ( ) ; » assert That « ( this . response . » get Headers « ( ) . » get Content Length « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Data Buffer « » foo Buffer « = » string Buffer « ( " name = value " ) ; Flux < » Data Buffer « > body = Flux . just ( » foo Buffer « ) . » concat With « ( Flux . error ( new » Runtime Exception « ( ) ) ) ; » Mock Server Http Request « request = request ( body ) ; Flux < » Multi Value Map « < String , String > > result = this . reader . read ( null , request , null ) ; » Step Verifier « . create ( result ) . » expect Error « ( ) . verify ( ) ; }
@Test { » assert That « ( ( List ) this . writer . » get Writable Media Types « ( ) ) . » contains Exactly In Any Order « ( » Mime Type Utils « . » APPLICATION _ OCTET _ STREAM « , » Mime Type Utils « . ALL ) ; }
@Test { » test Write « ( get ( " / " ) . header ( » Http Headers « . RANGE , " invalid " ) . build ( ) ) ; » assert That « ( this . response . » get Headers « ( ) . » get First « ( » Http Headers « . » ACCEPT _ RANGES « ) ) . » is Equal To « ( " bytes " ) ; » assert That « ( this . response . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » REQUESTED _ RANGE _ NOT _ SATISFIABLE « ) ; }
@Test { » assert That « ( reader . » can Read « ( » Resolvable Type « . » for Class « ( Object . class ) , new » Media Type « ( " foo " , " bar " ) ) ) . » is False « ( ) ; » assert That « ( reader . » can Read « ( » Resolvable Type « . » for Class « ( Object . class ) , null ) ) . » is False « ( ) ; }
@Test { » assert That « ( reader . » can Read « ( » Resolvable Type « . » for Class « ( Object . class ) , new » Media Type « ( " text " , " event - stream " ) ) ) . » is True « ( ) ; » assert That « ( reader . » can Read « ( » Resolvable Type « . » for Class « ( » Server Sent Event « . class ) , new » Media Type « ( " foo " , " bar " ) ) ) . » is True « ( ) ; }
@Test { » Mock Server Http Request « request = » Mock Server Http Request « . post ( " / " ) . body ( Flux . just ( » string Buffer « ( " : ping \n " ) , » string Buffer « ( " \n " ) ) ) ; Flux < Object > data = this . reader . read ( » Resolvable Type « . » for Type « ( String . class ) , request , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( data ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " data : foo \n data : bar \n \n data : baz \n \n " ; » Mock Server Http Request « request = » Mock Server Http Request « . post ( " / " ) . body ( Mono . just ( » string Buffer « ( body ) ) ) ; String actual = reader . » read Mono « ( » Resolvable Type « . » for Class « ( String . class ) , request , Collections . » empty Map « ( ) ) . cast ( String . class ) . block ( Duration . ZERO ) ; » assert That « ( actual ) . » is Equal To « ( body ) ; }
@Test { this . reader . » set Max In Memory Size « ( 17 ) ; » Mock Server Http Request « request = » Mock Server Http Request « . post ( " / " ) . body ( Flux . just ( » string Buffer « ( " data : \" TOO MUCH DATA \" \n data : bar \n \n data : baz \n \n " ) ) ) ; Flux < String > data = this . reader . read ( » Resolvable Type « . » for Class « ( String . class ) , request , Collections . » empty Map « ( ) ) . cast ( String . class ) ; » Step Verifier « . create ( data ) . » expect Error « ( » Data Buffer Limit Exception « . class ) . verify ( ) ; }
@Test { » Char Sequence Encoder « encoder = » Char Sequence Encoder « . » all Mime Types « ( ) ; » Http Message Writer « < » Char Sequence « > writer = new » Encoder Http Message Writer « < > ( encoder ) ; » Cancelling Output Message « » output Message « = new » Cancelling Output Message « ( this . » buffer Factory « ) ; writer . write ( Mono . just ( " foo " ) , » Resolvable Type « . » for Type « ( String . class ) , » Media Type « . » TEXT _ PLAIN « , » output Message « , Collections . » empty Map « ( ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; }
@Test { » Jackson 2 Json Encoder « encoder = new » Jackson 2 Json Encoder « ( ) ; Flux < » Data Buffer « > flux = encoder . encode ( Flux . just ( new Pojo ( " foofoo " , " barbar " ) , new Pojo ( " bar " , " baz " ) ) , this . » buffer Factory « , » Resolvable Type « . » for Class « ( Pojo . class ) , » Media Type « . » APPLICATION _ JSON « , Collections . » empty Map « ( ) ) ; » Base Subscriber « < » Data Buffer « > subscriber = new » Zero Demand Subscriber « ( ) ; flux . subscribe ( subscriber ) ; subscriber . cancel ( ) ; }
@Test { » Jaxb 2 Xml Encoder « encoder = new » Jaxb 2 Xml Encoder « ( ) ; Flux < » Data Buffer « > flux = encoder . encode ( Mono . just ( new Pojo ( " foo " , " bar " ) ) , this . » buffer Factory « , » Resolvable Type « . » for Class « ( Pojo . class ) , » Media Type « . » APPLICATION _ XML « , Collections . » empty Map « ( ) ) ; » Base Subscriber « < » Data Buffer « > subscriber = new » Zero Demand Subscriber « ( ) ; flux . subscribe ( subscriber ) ; subscriber . cancel ( ) ; }
@Test { » Resolvable Type « » pojo Type « = » Resolvable Type « . » for Class « ( Pojo . class ) ; » assert That « ( this . encoder . » can Encode « ( » pojo Type « , » CBOR _ MIME _ TYPE « ) ) . » is True « ( ) ; » assert That « ( this . encoder . » can Encode « ( » pojo Type « , null ) ) . » is True « ( ) ; » assert That « ( this . encoder . » can Encode « ( » Resolvable Type « . NONE , null ) ) . » is True « ( ) ; }
@Test { Pojo value = new Pojo ( " foo " , " bar " ) ; » Data Buffer « result = encoder . » encode Value « ( value , this . » buffer Factory « , » Resolvable Type « . » for Class « ( Pojo . class ) , » CBOR _ MIME _ TYPE « , null ) ; » pojo Consumer « ( value ) . accept ( result ) ; }
@Test { » assert That « ( decoder . » can Decode « ( » for Class « ( Pojo . class ) , » CBOR _ MIME _ TYPE « ) ) . » is True « ( ) ; » assert That « ( decoder . » can Decode « ( » for Class « ( Pojo . class ) , null ) ) . » is True « ( ) ; » assert That « ( decoder . » can Decode « ( » for Class « ( String . class ) , null ) ) . » is False « ( ) ; » assert That « ( decoder . » can Decode « ( » for Class « ( Pojo . class ) , » APPLICATION _ JSON « ) ) . » is False « ( ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( this . » pojo 1 « , this . » pojo 2 « ) . map ( this :: » write Object « ) . » flat Map « ( this :: » data Buffer « ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> » test Decode All « ( input , Pojo . class , step -> step . » expect Next « ( » pojo 1 « ) . » expect Next « ( » pojo 2 « ) . » verify Complete « ( ) ) ) ; }
@Test { List < Pojo > expected = Arrays . » as List « ( » pojo 1 « , » pojo 2 « ) ; Flux < » Data Buffer « > input = Flux . just ( expected ) . map ( this :: » write Object « ) . » flat Map « ( this :: » data Buffer « ) ; » Resolvable Type « » element Type « = » Resolvable Type « . » for Class With Generics « ( List . class , Pojo . class ) ; » test Decode To Mono « ( input , » element Type « , step -> step . » expect Next « ( expected ) . » expect Complete « ( ) . verify ( ) , null , null ) ; }
@Test { » Mime Type « » text Javascript « = new » Mime Type « ( " text " , " javascript " , » Standard Charsets « . » UTF _ 8 « ) ; » Jackson 2 Json Encoder « encoder = new » Jackson 2 Json Encoder « ( new » Object Mapper « ( ) , » text Javascript « ) ; » assert That « ( encoder . » get Encodable Mime Types « ( ) ) . » is Equal To « ( Collections . » singleton List « ( » text Javascript « ) ) ; }
@Test { » Mime Type « » text Javascript « = new » Mime Type « ( " text " , " javascript " , » Standard Charsets « . » UTF _ 8 « ) ; » Jackson 2 Json Encoder « encoder = new » Jackson 2 Json Encoder « ( new » Object Mapper « ( ) , » text Javascript « ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> encoder . » get Mime Types « ( ) . add ( new » Mime Type « ( " text " , " ecmascript " ) ) ) ; }
@Test { » assert That « ( this . encoder . » can Encode « ( » Resolvable Type « . » for Class « ( String . class ) , null ) ) . » is False « ( ) ; » assert That « ( this . encoder . » can Encode « ( » Resolvable Type « . » for Class « ( Pojo . class ) , » APPLICATION _ XML « ) ) . » is False « ( ) ; » Resolvable Type « » sse Type « = » Resolvable Type « . » for Class « ( » Server Sent Event « . class ) ; » assert That « ( this . encoder . » can Encode « ( » sse Type « , » APPLICATION _ JSON « ) ) . » is False « ( ) ; }
@Test { Flux < » Parent Class « > input = Flux . just ( new Foo ( ) , new Bar ( ) ) ; » test Encode « ( input , » Parent Class « . class , step -> step . » consume Next With « ( » expect String « ( " [ { \" type \" : \" foo \" } , { \" type \" : \" bar \" } ] " ) . » and Then « ( » Data Buffer Utils « :: release ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . just ( this . » pojo 1 « , this . » pojo 2 « ) . map ( this :: » write Object « ) . » flat Map « ( this :: » data Buffer « ) ; » test Decode All « ( input , Pojo . class , step -> step . » expect Next « ( » pojo 1 « ) . » expect Next « ( » pojo 2 « ) . » verify Complete « ( ) ) ; }
@Test { » Data Buffer « buffer = » string Buffer « ( " { \" id \" : 1 , \" name \" : " ) ; Flux < » Data Buffer « > source = Flux . just ( buffer ) . » concat With « ( Flux . error ( new » Runtime Exception « ( ) ) ) ; Flux < » Token Buffer « > result = » Jackson 2 Tokenizer « . tokenize ( source , this . » json Factory « , this . » object Mapper « , true , false , - 1 ) ; » Step Verifier « . create ( result ) . » expect Error « ( » Runtime Exception « . class ) . verify ( ) ; }
@Test { Flux < » Data Buffer « > source = Flux . just ( » string Buffer « ( " { \" status \" : \" » no Closing Quote « } " ) ) ; Flux < » Token Buffer « > tokens = » Jackson 2 Tokenizer « . tokenize ( source , this . » json Factory « , this . » object Mapper « , false , false , - 1 ) ; » Step Verifier « . create ( tokens ) . » expect Error « ( » Decoding Exception « . class ) . verify ( ) ; }
@Test { » Mime Type « » text Javascript « = new » Mime Type « ( " text " , " javascript " , » Standard Charsets « . » UTF _ 8 « ) ; » Jackson 2 Json Decoder « decoder = new » Jackson 2 Json Decoder « ( new » Object Mapper « ( ) , » text Javascript « ) ; » assert That « ( decoder . » get Decodable Mime Types « ( ) ) . » is Equal To « ( Collections . » singleton List « ( » text Javascript « ) ) ; }
@Test { » Mime Type « » text Javascript « = new » Mime Type « ( " text " , " javascript " , » Standard Charsets « . » UTF _ 8 « ) ; » Jackson 2 Json Decoder « decoder = new » Jackson 2 Json Decoder « ( new » Object Mapper « ( ) , » text Javascript « ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> decoder . » get Mime Types « ( ) . add ( new » Mime Type « ( " text " , " ecmascript " ) ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . concat ( » string Buffer « ( " [ { \" bar \" : \" » b 1 « \" , \" foo \" : \" » f 1 « \" } , " ) , » string Buffer « ( " { \" bar \" : \" » b 2 « \" , \" foo \" : \" » f 2 « \" } ] " ) ) ; » test Decode All « ( input , Pojo . class , step -> step . » expect Next « ( » pojo 1 « ) . » expect Next « ( » pojo 2 « ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . from ( » string Buffer « ( " [ ] " ) ) ; » test Decode « ( input , Pojo . class , step -> step . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = Flux . from ( » string Buffer « ( " { \" foofoo \" : \" foofoo \" , \" barbar \" : \" barbar \" " ) ) ; » test Decode « ( input , Pojo . class , step -> step . » verify Error « ( » Decoding Exception « . class ) ) ; }
@Test { Flux < Object > result = this . decoder . decode ( Flux . concat ( » string Buffer « ( " null " ) ) , » Resolvable Type « . » for Type « ( Pojo . class ) , » Media Type « . » APPLICATION _ JSON « , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( result ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Flux < » Data Buffer « > input = Flux . from ( » string Buffer « ( " { \" » property 1 « \" : \" foo \" , \" » property 2 « \" : \" bar \" } " ) ) ; » Resolvable Type « » element Type « = » for Class « ( » Bean With No Default Constructor « . class ) ; Flux < Object > flux = new » Jackson 2 Json Decoder « ( ) . decode ( input , » element Type « , null , » empty Map « ( ) ) ; » Step Verifier « . create ( flux ) . » verify Error « ( » Codec Exception « . class ) ; }
@Test { Mono < » Data Buffer « > input = » string Buffer « ( " { \" test \" : 1 } " ) ; » test Decode « ( input , » Test Object « . class , step -> step . » consume Next With « ( o -> » assert That « ( o . » get Test « ( ) ) . » is Equal To « ( 1 ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < » Data Buffer « > input = » string Buffer « ( " [ 1E+2 ] " ) . flux ( ) ; » test Decode « ( input , » Big Decimal « . class , step -> step . » expect Next « ( new » Big Decimal « ( " 1E+2 " ) ) . » verify Complete « ( ) ) ; }
@Test { Mono < Pojo > input = Mono . error ( new » Input Exception « ( ) ) ; » test Encode « ( input , Pojo . class , step -> step . » expect Error « ( » Input Exception « . class ) . verify ( ) ) ; }
@Test { » Server Http Request « request = » generate Error Multipart Request « ( ) ; » Step Verifier « . create ( this . reader . » read Mono « ( » PARTS _ ELEMENT _ TYPE « , request , » empty Map « ( ) ) ) . » verify Error « ( ) ; }
@Test { » Server Http Request « request = » generate Multipart Request « ( ) ; Mono < » Multi Value Map « < String , Part > > parts = this . reader . » read Mono « ( » PARTS _ ELEMENT _ TYPE « , request , » empty Map « ( ) ) ; » Zero Demand Subscriber « subscriber = new » Zero Demand Subscriber « ( ) ; parts . subscribe ( subscriber ) ; subscriber . cancel ( ) ; }
@Test { » test Multipart Exceptions « ( reader -> reader . » set Max Parts « ( 1 ) , ex -> { » assert That « ( ex ) . » is Instance Of « ( » Decoding Exception « . class ) . » has Message Starting With « ( " Failure while parsing part [ 2 ] " ) ; » assert That « ( ex . » get Cause « ( ) ) . » has Message « ( " Too many parts ( 2 allowed ) " ) ; } ) ; }
@Test { » test Multipart Exceptions « ( reader -> reader . » set Max Disk Usage Per Part « ( 5 ) , ex -> { » assert That « ( ex ) . » is Instance Of « ( » Decoding Exception « . class ) . » has Message Starting With « ( " Failure while parsing part [ 1 ] " ) ; » assert That « ( ex . » get Cause « ( ) ) . » has Message « ( " Part [ 1 ] exceeded the disk usage limit of 5 bytes " ) ; } ) ; }
@Test { » test Multipart Exceptions « ( reader -> reader . » set Max In Memory Size « ( 1 ) , ex -> { » assert That « ( ex ) . » is Instance Of « ( » Decoding Exception « . class ) . » has Message Starting With « ( " Failure while parsing part [ 1 ] " ) ; » assert That « ( ex . » get Cause « ( ) ) . » has Message « ( " Part [ 1 ] exceeded the in - memory limit of 1 bytes " ) ; } ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Protobuf Decoder « ( null ) ) ; }
@Test { Mono < » Data Buffer « > input = » data Buffer « ( this . » test Msg 1 « ) ; » test Decode To Mono All « ( input , Msg . class , step -> step . » expect Next « ( this . » test Msg 1 « ) . » verify Complete « ( ) ) ; }
@Test { this . decoder . » set Max Message Size « ( 1 ) ; Mono < » Data Buffer « > input = » data Buffer « ( this . » test Msg 1 « ) ; » test Decode « ( input , Msg . class , step -> step . » verify Error « ( » Decoding Exception « . class ) ) ; }
@Test { Mono < Message > input = Mono . just ( this . » msg 1 « ) ; » test Encode All « ( input , Msg . class , step -> step . » consume Next With « ( » data Buffer « -> { try { » assert That « ( Msg . » parse From « ( » data Buffer « . » as Input Stream « ( ) ) ) . » is Equal To « ( this . » msg 1 « ) ; } catch ( » IO Exception « ex ) { throw new » Unchecked IO Exception « ( ex ) ; } finally { » Data Buffer Utils « . release ( » data Buffer « ) ; } } ) . » verify Complete « ( ) ) ; }
@Test { Flux < Message > input = Flux . just ( this . » msg 1 « , this . » msg 2 « ) ; » test Encode All « ( input , Msg . class , step -> step . » consume Next With « ( expect ( this . » msg 1 « ) ) . » consume Next With « ( expect ( this . » msg 2 « ) ) . » verify Complete « ( ) ) ; }
@Test { » Jackson 2 Json Decoder « decoder = new » Jackson 2 Json Decoder « ( ) ; this . configurer . » default Codecs « ( ) . » jackson 2 Json Decoder « ( decoder ) ; List < » Http Message Reader « < ? > > readers = this . configurer . » get Readers « ( ) ; » assert That « ( » find Codec « ( readers , » Server Sent Event Http Message Reader « . class ) . » get Decoder « ( ) ) . » is Same As « ( decoder ) ; }
@Test { » Client Codec Configurer « clone = this . configurer . clone ( ) ; List < » Http Message Writer « < ? > > writers = » find Codec « ( clone . » get Writers « ( ) , » Multipart Http Message Writer « . class ) . » get Part Writers « ( ) ; » assert That « ( writers ) . » has Size « ( 10 ) ; }
@Test { » Client Codec Configurer « clone = this . configurer . clone ( ) ; this . configurer . » register Defaults « ( false ) ; this . configurer . » custom Codecs « ( ) . register ( new » Jackson 2 Json Encoder « ( ) ) ; List < » Http Message Writer « < ? > > writers = » find Codec « ( clone . » get Writers « ( ) , » Multipart Http Message Writer « . class ) . » get Part Writers « ( ) ; » assert That « ( writers ) . » has Size « ( 10 ) ; }
@Test { » Atomic Boolean « » callback Called « = new » Atomic Boolean « ( false ) ; this . configurer . » default Codecs « ( ) . » enable Logging Request Details « ( true ) ; this . configurer . » custom Codecs « ( ) . » with Default Codec Config « ( config -> { » assert That « ( config . » is Enable Logging Request Details « ( ) ) . » is True « ( ) ; » callback Called « . » compare And Set « ( false , true ) ; } ) ; this . configurer . » get Readers « ( ) ; » assert That « ( » callback Called « ) . » is True « ( ) ; }
@Test { Mono < » Data Buffer « > source = » string Buffer « ( » POJO _ ROOT « ) ; Mono < Object > output = this . decoder . » decode To Mono « ( source , » Resolvable Type « . » for Class « ( Pojo . class ) , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( output ) . » expect Next « ( new Pojo ( " foofoo " , " barbar " ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Data Buffer « > source = » string Buffer « ( » POJO _ ROOT « ) ; Mono < Object > output = this . decoder . » decode To Mono « ( source , » Resolvable Type « . » for Class « ( » Type Pojo « . class ) , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( output ) . » expect Next « ( new » Type Pojo « ( " foofoo " , " barbar " ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Data Buffer « > source = » string Buffer « ( » POJO _ CHILD « ) ; Flux < Object > output = this . decoder . decode ( source , » Resolvable Type « . » for Class « ( Pojo . class ) , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( output ) . » expect Next « ( new Pojo ( " foo " , " bar " ) ) . » expect Next « ( new Pojo ( " foofoo " , " barbar " ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Data Buffer « > source = » string Buffer « ( » POJO _ CHILD « ) ; Flux < Object > output = this . decoder . decode ( source , » Resolvable Type « . » for Class « ( » Type Pojo « . class ) , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( output ) . » expect Next « ( new » Type Pojo « ( " foo " , " bar " ) ) . » expect Next « ( new » Type Pojo « ( " foofoo " , " barbar " ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Flux < » Data Buffer « > source = Flux . concat ( » string Buffer « ( " < pojo > " ) , Flux . error ( new » Runtime Exception « ( ) ) ) ; Mono < Object > output = this . decoder . » decode To Mono « ( source , » Resolvable Type « . » for Class « ( Pojo . class ) , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( output ) . » expect Error « ( » Runtime Exception « . class ) . verify ( ) ; }
@Test { decoder . » use Aalto « = false ; Flux < » Data Buffer « > source = Flux . concat ( » string Buffer Mono « ( " < pojo > " ) , Flux . error ( new » Runtime Exception « ( ) ) ) ; Flux < » XML Event « > events = this . decoder . decode ( source , null , null , Collections . » empty Map « ( ) ) ; » Step Verifier « . create ( events ) . » expect Error « ( » Runtime Exception « . class ) . verify ( ) ; }
@Test { Mono < Pojo > input = Mono . just ( new Pojo ( " foofoo " , " barbar " ) ) ; » test Encode « ( input , Pojo . class , step -> step . » consume Next With « ( » expect Xml « ( " < ? xml version = '1.0' encoding = 'UTF-8' standalone = 'yes' ? > " + " < pojo > < bar > barbar < / bar > < foo > foofoo < / foo > < / pojo > " ) ) . » verify Complete « ( ) ) ; }
@Test { Flux < Pojo > input = Flux . error ( » Runtime Exception « :: new ) ; » test Encode « ( input , Pojo . class , step -> step . » expect Error « ( » Runtime Exception « . class ) . verify ( ) ) ; }
@Test { Mono < Container > input = Mono . just ( new Container ( ) ) ; » test Encode « ( input , Pojo . class , step -> step . » consume Next With « ( » expect Xml « ( " < ? xml version = '1.0' encoding = 'UTF-8' standalone = 'yes' ? > " + " < container > < foo > < name > » name 1 « < / name > < / foo > < bar > < title > » title 1 « < / title > < / bar > < / container > " ) ) . » verify Complete « ( ) ) ; }
@Test { » assert That « ( converter . » can Read « ( » Buffered Image « . class , null ) ) . as ( " Image not supported " ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( » Buffered Image « . class , new » Media Type « ( " image " , " png " ) ) ) . as ( " Image not supported " ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( » Buffered Image « . class , null ) ) . as ( " Image not supported " ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » Buffered Image « . class , new » Media Type « ( " image " , " png " ) ) ) . as ( " Image not supported " ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » Buffered Image « . class , new » Media Type « ( " * " , " * " ) ) ) . as ( " Image not supported " ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Read « ( byte [ ] . class , new » Media Type « ( " application " , " octet - stream " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( byte [ ] . class , new » Media Type « ( " application " , " octet - stream " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( byte [ ] . class , » Media Type « . ALL ) ) . » is True « ( ) ; }
@Test { byte [ ] body = new byte [ ] { 0x1 , 0x2 } ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " octet - stream " ) ) ; byte [ ] result = converter . read ( byte [ ] . class , » input Message « ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( body ) ; }
@Test { » assert Can Read « ( » Multi Value Map « . class , null ) ; » assert Can Read « ( » APPLICATION _ FORM _ URLENCODED « ) ; » assert Cannot Read « ( String . class , null ) ; » assert Cannot Read « ( String . class , » APPLICATION _ FORM _ URLENCODED « ) ; }
@Test { » asssert Cannot Read Multipart « ( ) ; this . converter . » add Supported Media Types « ( » MULTIPART _ RELATED « ) ; » asssert Cannot Read Multipart « ( ) ; }
@Test { » assert Can Write « ( » APPLICATION _ FORM _ URLENCODED « ) ; » assert Can Write « ( » MULTIPART _ FORM _ DATA « ) ; » assert Can Write « ( » MULTIPART _ MIXED « ) ; » assert Can Write « ( new » Media Type « ( " multipart " , " form - data " , » Standard Charsets « . » UTF _ 8 « ) ) ; » assert Can Write « ( » Media Type « . ALL ) ; » assert Can Write « ( null ) ; }
@Test { » assert Cannot Write « ( » MULTIPART _ RELATED « ) ; List < » Media Type « > » supported Media Types « = new » Array List « < > ( this . converter . » get Supported Media Types « ( ) ) ; » supported Media Types « . add ( » MULTIPART _ RELATED « ) ; this . converter . » set Supported Media Types « ( » supported Media Types « ) ; » assert Can Write « ( » MULTIPART _ RELATED « ) ; }
@Test { » assert Cannot Write « ( » MULTIPART _ RELATED « ) ; this . converter . » add Supported Media Types « ( » MULTIPART _ RELATED « ) ; » assert Can Write « ( » MULTIPART _ RELATED « ) ; }
@Test { this . converter . write ( Integer . » value Of « ( 5 ) , null , response ) ; » assert That « ( » servlet Response « . » get Character Encoding « ( ) ) . » is Equal To « ( " ISO - 8859 - 1 " ) ; }
@Test { » Conversion Service « cs = new » Default Conversion Service « ( ) ; » Object To String Http Message Converter « converter = new » Object To String Http Message Converter « ( cs , » Standard Charsets « . » UTF _ 16 « ) ; converter . write ( ( byte ) 31 , null , this . response ) ; » assert That « ( this . » servlet Response « . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 16 " ) ; }
@Test { this . converter . » set Write Accept Charset « ( true ) ; this . converter . write ( new Date ( ) , null , this . response ) ; » assert That « ( this . » servlet Response « . » get Header « ( " Accept - Charset " ) ) . » is Not Null « ( ) ; }
@Test { this . converter . » set Write Accept Charset « ( false ) ; this . converter . write ( new Date ( ) , null , this . response ) ; » assert That « ( this . » servlet Response « . » get Header « ( " Accept - Charset " ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Object To String Http Message Converter « ( null ) ) ; }
@Test { » assert That « ( converter . » can Read « ( Resource . class , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » is False « ( ) ; » assert That « ( converter . » can Read « ( Resource . class , » Media Type « . ALL ) ) . » is False « ( ) ; » assert That « ( converter . » can Read « ( List . class , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » is False « ( ) ; » assert That « ( converter . » can Read « ( List . class , » Media Type « . ALL ) ) . » is False « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( » Resource Region « . class , null , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » Resource Region « . class , null , » Media Type « . ALL ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Object . class , null , » Media Type « . ALL ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . converter . » can Read « ( String . class , » Media Type « . » TEXT _ PLAIN « ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . converter . » can Write « ( String . class , » Media Type « . » TEXT _ PLAIN « ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Write « ( String . class , » Media Type « . ALL ) ) . » is True « ( ) ; }
@Test { String body = " Hello World " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( » TEXT _ PLAIN _ UTF _ 8 « ) ; String result = this . converter . read ( String . class , » input Message « ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( body ) ; }
@Test { String body = " { \" result \" : \" ДА \" } " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( » Media Type « . » APPLICATION _ JSON « ) ; String result = this . converter . read ( String . class , » input Message « ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( body ) ; }
@Test { » assert That « ( converter . » can Read « ( Resource . class , new » Media Type « ( " application " , " octet - stream " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( Resource . class , new » Media Type « ( " application " , " octet - stream " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Resource . class , » Media Type « . ALL ) ) . » is True « ( ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; byte [ ] » byte Array « = { 1 , 2 , 3 } ; Resource body = new » Byte Array Resource « ( » byte Array « ) ; converter . write ( body , null , » output Message « ) ; » assert That « ( Arrays . equals ( » byte Array « , » output Message « . » get Body As Bytes « ( ) ) ) . » is True « ( ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; Resource resource = mock ( Resource . class ) ; given ( resource . » get Input Stream « ( ) ) . » will Throw « ( » File Not Found Exception « . class ) ; converter . write ( resource , » Media Type « . » APPLICATION _ OCTET _ STREAM « , » output Message « ) ; » assert That « ( » output Message « . » get Headers « ( ) . » get Content Length « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( converter . » can Read « ( Feed . class , » Media Type « . » APPLICATION _ ATOM _ XML « ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( Feed . class , » ATOM _ XML _ UTF 8 « ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( Feed . class , » Media Type « . » APPLICATION _ ATOM _ XML « ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Feed . class , » ATOM _ XML _ UTF 8 « ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Read « ( Channel . class , » Media Type « . » APPLICATION _ RSS _ XML « ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( Channel . class , » RSS _ XML _ UTF 8 « ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Channel . class , » Media Type « . » APPLICATION _ RSS _ XML « ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Channel . class , » RSS _ XML _ UTF 8 « ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Read « ( Map . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Write « ( Map . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " vnd . test - micro - type + json " ) ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " vnd . test - micro - type + json " ) ) ) . » is True « ( ) ; }
@Test { String body = " » Foo Bar « " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( " UTF - 8 " ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " json " ) ) ; » assert That Exception Of Type « ( » Http Message Not Readable Exception « . class ) . » is Thrown By « ( ( ) -> this . converter . read ( » My Bean « . class , » input Message « ) ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; this . converter . » set Prefix Json « ( true ) ; this . converter . » write Internal « ( " foo " , null , » output Message « ) ; » assert That « ( » output Message « . » get Body As String « ( » Standard Charsets « . » UTF _ 8 « ) ) . » is Equal To « ( " ) ] } ' , \" foo \" " ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; this . converter . » set Json Prefix « ( " ) ) ) " ) ; this . converter . » write Internal « ( " foo " , null , » output Message « ) ; » assert That « ( » output Message « . » get Body As String « ( » Standard Charsets « . » UTF _ 8 « ) ) . » is Equal To « ( " ) ) ) \" foo \" " ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; this . converter . » set Prefix Json « ( true ) ; this . converter . » write Internal « ( " foo " , null , » output Message « ) ; » assert That « ( » output Message « . » get Body As String « ( » Standard Charsets « . » UTF _ 8 « ) ) . » is Equal To « ( " ) ] } ' , foo " ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; this . converter . » set Json Prefix « ( " ) ) ) " ) ; this . converter . » write Internal « ( " foo " , null , » output Message « ) ; » assert That « ( » output Message « . » get Body As String « ( » Standard Charsets « . » UTF _ 8 « ) ) . » is Equal To « ( " ) ) ) foo " ) ; }
@Test { » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( Map . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Map . class , new » Media Type « ( " application " , " json " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " vnd . test - micro - type + json " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " vnd . test - micro - type + json " ) ) ) . » is True « ( ) ; }
@Test { String body = " » Foo Bar « " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( " UTF - 8 " ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " json " ) ) ; » assert That Exception Of Type « ( » Http Message Not Readable Exception « . class ) . » is Thrown By « ( ( ) -> converter . read ( » My Bean « . class , » input Message « ) ) ; }
@Test { String body = " { \" string \" : \" string \" , \" » unknown Property « \" : \" value \" } " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( " UTF - 8 " ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " json " ) ) ; converter . read ( » My Bean « . class , » input Message « ) ; }
@Test { User user = new User ( " bob " ) ; String json = this . » object Mapper « . » write Value As String « ( user ) ; » assert That « ( json ) . » is Equal To « ( " { \" username \" : \" BOB \" } " ) ; }
@Test { String json = " { \" username \" : \" bob \" } " ; User user = this . » object Mapper « . » read Value « ( json , User . class ) ; » assert That « ( user . » get Username « ( ) ) . » is Equal To « ( " BOB " ) ; }
@Test { String json = " { \" credentials \" : { \" bob \" : \" admin \" } } " ; » Security Registry « registry = this . » object Mapper « . » read Value « ( json , » Security Registry « . class ) ; » assert That « ( registry . » get Credentials « ( ) . » key Set « ( ) . contains ( " BOB " ) ) . » is True « ( ) ; » assert That « ( registry . » get Credentials « ( ) . » key Set « ( ) . contains ( " bob " ) ) . » is False « ( ) ; }
@Test { this . » object Mapper « . » write Value As String « ( new Group ( ) ) ; » assert That « ( » Custom Type Resolver Builder « . » is Autowired Filed Initialized « ) . » is True « ( ) ; }
@Test { this . » object Mapper « . » write Value As String « ( new Group ( ) ) ; » assert That « ( » Custom Type Id Resolver « . » is Autowired Filed Initialized « ) . » is True « ( ) ; }
@Test { this . factory . » set Serialize Nulls « ( true ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » String Bean « bean = new » String Bean « ( ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" name \" : null } " ) ; }
@Test { this . factory . » set Serialize Nulls « ( false ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » String Bean « bean = new » String Bean « ( ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { } " ) ; }
@Test { this . factory . » set Pretty Printing « ( true ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » String Bean « bean = new » String Bean « ( ) ; bean . » set Name « ( " Jason " ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result . contains ( " \" name \" : \" Jason \" " ) ) . » is True « ( ) ; }
@Test { this . factory . » set Pretty Printing « ( false ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » String Bean « bean = new » String Bean « ( ) ; bean . » set Name « ( " Jason " ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" name \" : \" Jason \" } " ) ; }
@Test { this . factory . » set Disable Html Escaping « ( true ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » String Bean « bean = new » String Bean « ( ) ; bean . » set Name « ( " Bob = Bob " ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" name \" : \" Bob = Bob \" } " ) ; }
@Test { this . factory . » set Disable Html Escaping « ( false ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » String Bean « bean = new » String Bean « ( ) ; bean . » set Name « ( " Bob = Bob " ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" name \" : \" Bob \\u003d Bob \" } " ) ; }
@Test { this . factory . » set Base 64 Encode Byte Arrays « ( true ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » Byte Array Bean « bean = new » Byte Array Bean « ( ) ; bean . » set Bytes « ( new byte [ ] { 0x1 , 0x2 } ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" bytes \" : \" AQI \\u003d \" } " ) ; }
@Test { this . factory . » set Base 64 Encode Byte Arrays « ( true ) ; this . factory . » set Disable Html Escaping « ( true ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » Byte Array Bean « bean = new » Byte Array Bean « ( ) ; bean . » set Bytes « ( new byte [ ] { 0x1 , 0x2 } ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" bytes \" : \" AQI = \" } " ) ; }
@Test { this . factory . » set Base 64 Encode Byte Arrays « ( false ) ; this . factory . » after Properties Set « ( ) ; Gson gson = this . factory . » get Object « ( ) ; » Byte Array Bean « bean = new » Byte Array Bean « ( ) ; bean . » set Bytes « ( new byte [ ] { 0x1 , 0x2 } ) ; String result = gson . » to Json « ( bean ) ; » assert That « ( result ) . » is Equal To « ( " { \" bytes \" : [ 1 , 2 ] } " ) ; }
@Test { » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( ( ) -> » Jackson 2 Object Mapper Builder « . json ( ) . » features To Enable « ( Boolean . TRUE ) . build ( ) ) ; }
@Test { » Simple Date Format « » date Format « = new » Simple Date Format « ( » DATE _ FORMAT « ) ; » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . » date Format « ( » date Format « ) . build ( ) ; » assert That « ( » object Mapper « . » get Serialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( » date Format « ) ; » assert That « ( » object Mapper « . » get Deserialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( » date Format « ) ; }
@Test { » Simple Date Format « » date Format « = new » Simple Date Format « ( » DATE _ FORMAT « ) ; » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . » simple Date Format « ( » DATE _ FORMAT « ) . build ( ) ; » assert That « ( » object Mapper « . » get Serialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( » date Format « ) ; » assert That « ( » object Mapper « . » get Deserialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( » date Format « ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . locale ( Locale . FRENCH ) . build ( ) ; » assert That « ( » object Mapper « . » get Serialization Config « ( ) . » get Locale « ( ) ) . » is Equal To « ( Locale . FRENCH ) ; » assert That « ( » object Mapper « . » get Deserialization Config « ( ) . » get Locale « ( ) ) . » is Equal To « ( Locale . FRENCH ) ; }
@Test { » Time Zone « » time Zone « = » Time Zone « . » get Time Zone « ( " Europe / Paris " ) ; » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . » time Zone « ( » time Zone « ) . build ( ) ; » assert That « ( » object Mapper « . » get Serialization Config « ( ) . » get Time Zone « ( ) ) . » is Equal To « ( » time Zone « ) ; » assert That « ( » object Mapper « . » get Deserialization Config « ( ) . » get Time Zone « ( ) ) . » is Equal To « ( » time Zone « ) ; }
@Test { String » zone Id « = " foo " ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Jackson 2 Object Mapper Builder « . json ( ) . » time Zone « ( » zone Id « ) . build ( ) ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . » modules To Install « ( » Custom Integer Module « . class ) . build ( ) ; Serializers serializers = » get Serializer Factory Config « ( » object Mapper « ) . serializers ( ) . iterator ( ) . next ( ) ; » assert That « ( serializers . » find Serializer « ( null , » Simple Type « . construct ( Integer . class ) , null ) . » get Class « ( ) ) . » is Same As « ( » Custom Integer Serializer « . class ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . » modules To Install « ( new » Custom Integer Module « ( ) ) . build ( ) ; Serializers serializers = » get Serializer Factory Config « ( » object Mapper « ) . serializers ( ) . iterator ( ) . next ( ) ; » assert That « ( serializers . » find Serializer « ( null , » Simple Type « . construct ( Integer . class ) , null ) . » get Class « ( ) ) . » is Same As « ( » Custom Integer Serializer « . class ) ; }
@Test { » Property Naming Strategy « strategy = new » Property Naming Strategy « . » Lower Case With Underscores Strategy « ( ) ; » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . » property Naming Strategy « ( strategy ) . build ( ) ; » assert That « ( » object Mapper « . » get Serialization Config « ( ) . » get Property Naming Strategy « ( ) ) . » is Same As « ( strategy ) ; » assert That « ( » object Mapper « . » get Deserialization Config « ( ) . » get Property Naming Strategy « ( ) ) . » is Same As « ( strategy ) ; }
@Test { Class < ? > target = String . class ; Class < ? > » mix In Source « = Object . class ; » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . modules ( ) . » mix In « ( target , » mix In Source « ) . build ( ) ; » assert That « ( » object Mapper « . » mix In Count « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » object Mapper « . » find Mix In Class For « ( target ) ) . » is Same As « ( » mix In Source « ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . xml ( ) . build ( ) ; » assert That « ( » object Mapper « ) . » is Not Null « ( ) ; » assert That « ( » object Mapper « . » get Class « ( ) ) . » is Equal To « ( » Xml Mapper « . class ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . xml ( ) . factory ( new » My Xml Factory « ( ) ) . build ( ) ; » assert That « ( » object Mapper « ) . » is Not Null « ( ) ; » assert That « ( » object Mapper « . » get Class « ( ) ) . » is Equal To « ( » Xml Mapper « . class ) ; » assert That « ( » object Mapper « . » get Factory « ( ) . » get Class « ( ) ) . » is Equal To « ( » My Xml Factory « . class ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . smile ( ) . build ( ) ; » assert That « ( » object Mapper « ) . » is Not Null « ( ) ; » assert That « ( » object Mapper « . » get Factory « ( ) . » get Class « ( ) ) . » is Equal To « ( » Smile Factory « . class ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . cbor ( ) . build ( ) ; » assert That « ( » object Mapper « ) . » is Not Null « ( ) ; » assert That « ( » object Mapper « . » get Factory « ( ) . » get Class « ( ) ) . » is Equal To « ( » CBOR Factory « . class ) ; }
@Test { » Object Mapper « » object Mapper « = new » Jackson 2 Object Mapper Builder « ( ) . factory ( new » Smile Factory « ( ) ) . build ( ) ; » assert That « ( » object Mapper « ) . » is Not Null « ( ) ; » assert That « ( » object Mapper « . » get Factory « ( ) . » get Class « ( ) ) . » is Equal To « ( » Smile Factory « . class ) ; }
@Test { » Object Mapper « » object Mapper « = » Jackson 2 Object Mapper Builder « . json ( ) . visibility ( » Property Accessor « . GETTER , Visibility . NONE ) . visibility ( » Property Accessor « . FIELD , Visibility . ANY ) . build ( ) ; String json = » object Mapper « . » write Value As String « ( new » Jackson Visibility Bean « ( ) ) ; » assert That « ( json ) . contains ( " » property 1 « " ) ; » assert That « ( json ) . contains ( " » property 2 « " ) ; » assert That « ( json ) . » does Not Contain « ( " » property 3 « " ) ; }
@Test { this . factory . » set Features To Enable « ( Boolean . TRUE ) ; » assert That Exception Of Type « ( » Fatal Bean Exception « . class ) . » is Thrown By « ( this . factory :: » after Properties Set « ) ; }
@Test { this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Serialization Inclusion « ( ) ) . » is Same As « ( Include . ALWAYS ) ; }
@Test { this . factory . » set Serialization Inclusion « ( Include . » NON _ NULL « ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Serialization Inclusion « ( ) ) . » is Same As « ( Include . » NON _ NULL « ) ; }
@Test { this . factory . » set Serialization Inclusion « ( Include . » NON _ DEFAULT « ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Serialization Inclusion « ( ) ) . » is Same As « ( Include . » NON _ DEFAULT « ) ; }
@Test { this . factory . » set Serialization Inclusion « ( Include . » NON _ EMPTY « ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Serialization Inclusion « ( ) ) . » is Same As « ( Include . » NON _ EMPTY « ) ; }
@Test { this . factory . » set Date Format « ( this . » date Format « ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( this . » date Format « ) ; » assert That « ( this . factory . » get Object « ( ) . » get Deserialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( this . » date Format « ) ; }
@Test { this . factory . » set Simple Date Format « ( » DATE _ FORMAT « ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( this . » date Format « ) ; » assert That « ( this . factory . » get Object « ( ) . » get Deserialization Config « ( ) . » get Date Format « ( ) ) . » is Equal To « ( this . » date Format « ) ; }
@Test { this . factory . » set Locale « ( Locale . FRENCH ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Locale « ( ) ) . » is Equal To « ( Locale . FRENCH ) ; » assert That « ( this . factory . » get Object « ( ) . » get Deserialization Config « ( ) . » get Locale « ( ) ) . » is Equal To « ( Locale . FRENCH ) ; }
@Test { » Time Zone « » time Zone « = » Time Zone « . » get Time Zone « ( " Europe / Paris " ) ; this . factory . » set Time Zone « ( » time Zone « ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Time Zone « ( ) ) . » is Equal To « ( » time Zone « ) ; » assert That « ( this . factory . » get Object « ( ) . » get Deserialization Config « ( ) . » get Time Zone « ( ) ) . » is Equal To « ( » time Zone « ) ; }
@Test { this . factory . » after Properties Set « ( ) ; » Object Mapper « » object Mapper « = this . factory . » get Object « ( ) ; Long timestamp = 1322903730000L ; » Date Time « » date Time « = new » Date Time « ( timestamp , » Date Time Zone « . UTC ) ; » assert That « ( new String ( » object Mapper « . » write Value As Bytes « ( » date Time « ) , " UTF - 8 " ) ) . » is Equal To « ( timestamp . » to String « ( ) ) ; }
@Test { this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . factory . » is Singleton « ( ) ) . » is True « ( ) ; » assert That « ( this . factory . » get Object Type « ( ) ) . » is Equal To « ( » Object Mapper « . class ) ; }
@Test { » assert That « ( ( Object ) this . factory . » get Object Type « ( ) ) . » is Null « ( ) ; }
@Test { » Property Naming Strategy « strategy = new » Property Naming Strategy « . » Lower Case With Underscores Strategy « ( ) ; this . factory . » set Property Naming Strategy « ( strategy ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Serialization Config « ( ) . » get Property Naming Strategy « ( ) ) . » is Same As « ( strategy ) ; » assert That « ( this . factory . » get Object « ( ) . » get Deserialization Config « ( ) . » get Property Naming Strategy « ( ) ) . » is Same As « ( strategy ) ; }
@Test { this . factory . » set Filters « ( new » Simple Filter Provider « ( ) . » set Fail On Unknown Id « ( false ) ) ; this . factory . » after Properties Set « ( ) ; » Object Mapper « » object Mapper « = this . factory . » get Object « ( ) ; » Jackson Filtered Bean « bean = new » Jackson Filtered Bean « ( " » value 1 « " , " » value 2 « " ) ; String output = » object Mapper « . » write Value As String « ( bean ) ; » assert That « ( output ) . contains ( " » value 1 « " ) ; » assert That « ( output ) . contains ( " » value 2 « " ) ; }
@Test { this . factory . » set Object Mapper « ( new » Xml Mapper « ( ) ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . factory . » is Singleton « ( ) ) . » is True « ( ) ; » assert That « ( this . factory . » get Object Type « ( ) ) . » is Equal To « ( » Xml Mapper « . class ) ; }
@Test { this . factory . » set Create Xml Mapper « ( true ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . factory . » is Singleton « ( ) ) . » is True « ( ) ; » assert That « ( this . factory . » get Object Type « ( ) ) . » is Equal To « ( » Xml Mapper « . class ) ; }
@Test { this . factory . » set Factory « ( new » Smile Factory « ( ) ) ; this . factory . » after Properties Set « ( ) ; » assert That « ( this . factory . » get Object « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . factory . » is Singleton « ( ) ) . » is True « ( ) ; » assert That « ( this . factory . » get Object « ( ) . » get Factory « ( ) . » get Class « ( ) ) . » is Equal To « ( » Smile Factory « . class ) ; }
@Test { verify ( this . » registry Initializer « , times ( 1 ) ) . » initialize Extension Registry « ( any ( ) ) ; }
@Test { » Protobuf Http Message Converter « converter = new » Protobuf Http Message Converter « ( ( » Extension Registry Initializer « ) null ) ; » assert That « ( converter . » extension Registry « ) . » is Not Null « ( ) ; }
@Test { » Protobuf Http Message Converter « converter = new » Protobuf Http Message Converter « ( ( » Extension Registry « ) null ) ; » assert That « ( converter . » extension Registry « ) . » is Not Null « ( ) ; }
@Test { byte [ ] body = this . » test Msg « . » to Byte Array « ( ) ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( » Protobuf Http Message Converter « . PROTOBUF ) ; Message result = this . converter . read ( Msg . class , » input Message « ) ; » assert That « ( result ) . » is Equal To « ( this . » test Msg « ) ; }
@Test { byte [ ] body = this . » test Msg « . » to Byte Array « ( ) ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body ) ; Message result = this . converter . read ( Msg . class , » input Message « ) ; » assert That « ( result ) . » is Equal To « ( this . » test Msg « ) ; }
@Test { » assert That « ( this . converter . » get Default Content Type « ( this . » test Msg « ) ) . » is Equal To « ( » Protobuf Http Message Converter « . PROTOBUF ) ; }
@Test { » Mock Http Output Message « » output Message « = new » Mock Http Output Message « ( ) ; » Media Type « » content Type « = » Protobuf Http Message Converter « . PROTOBUF ; this . converter . write ( this . » test Msg « , » content Type « , » output Message « ) ; » assert That « ( » output Message « . » get Headers « ( ) . » get Content Length « ( ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Protobuf Http Message Converter « converter = new » Protobuf Http Message Converter « ( ( » Extension Registry Initializer « ) null ) ; » assert That « ( converter ) . » is Not Null « ( ) ; }
@Test { » Protobuf Http Message Converter « converter = new » Protobuf Http Message Converter « ( ( » Extension Registry « ) null ) ; » assert That « ( converter ) . » is Not Null « ( ) ; }
@Test { » assert That « ( this . converter . » can Read « ( Msg . class , null ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Read « ( Msg . class , » Protobuf Http Message Converter « . PROTOBUF ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Read « ( Msg . class , » Media Type « . » APPLICATION _ JSON « ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Read « ( Msg . class , » Media Type « . » TEXT _ PLAIN « ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . converter . » can Write « ( Msg . class , null ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Write « ( Msg . class , » Protobuf Http Message Converter « . PROTOBUF ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Write « ( Msg . class , » Media Type « . » APPLICATION _ JSON « ) ) . » is True « ( ) ; » assert That « ( this . converter . » can Write « ( Msg . class , » Media Type « . » TEXT _ PLAIN « ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " x - jackson - smile " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " json " ) ) ) . » is False « ( ) ; » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " xml " ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " x - jackson - smile " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " json " ) ) ) . » is False « ( ) ; » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " xml " ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( converter . » can Read « ( » root Element List Type « , null , null ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( » root Element Set Type « , null , null ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( » type Set Type « , null , null ) ) . » is True « ( ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> new » Marshalling Http Message Converter « ( ) . supports ( Object . class ) ) ; }
@Test { » assert That « ( converter . » can Read « ( Source . class , new » Media Type « ( " application " , " xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( Source . class , new » Media Type « ( " application " , " soap + xml " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( Source . class , new » Media Type « ( " application " , " xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Source . class , new » Media Type « ( " application " , " soap + xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( Source . class , » Media Type « . ALL ) ) . » is True « ( ) ; }
@Test { » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( BODY . » get Bytes « ( " UTF - 8 " ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " xml " ) ) ; converter . read ( Source . class , » input Message « ) ; }
@Test { » assert That « ( converter . » can Read « ( » Root Element « . class , null ) ) . as ( " Converter does not support reading @ » Xml Root Element « " ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( Type . class , null ) ) . as ( " Converter does not support reading @ » Xml Type « " ) . » is True « ( ) ; }
@Test { byte [ ] body = " < » root Element « > < type s = \" Hello World \" / > < / » root Element « > " . » get Bytes « ( " UTF - 8 " ) ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body ) ; » Root Element « result = ( » Root Element « ) converter . read ( » Root Element « . class , » input Message « ) ; » assert That « ( result . type . s ) . as ( " Invalid result " ) . » is Equal To « ( " Hello World " ) ; }
@Test { byte [ ] body = " < » root Element « > < type s = \" Hello World \" / > < / » root Element « > " . » get Bytes « ( " UTF - 8 " ) ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body ) ; » Root Element Subclass « result = ( » Root Element Subclass « ) converter . read ( » Root Element Subclass « . class , » input Message « ) ; » assert That « ( result . » get Type « ( ) . s ) . as ( " Invalid result " ) . » is Equal To « ( " Hello World " ) ; }
@Test { byte [ ] body = " < foo s = \" Hello World \" / > " . » get Bytes « ( " UTF - 8 " ) ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body ) ; Type result = ( Type ) converter . read ( Type . class , » input Message « ) ; » assert That « ( result . s ) . as ( " Invalid result " ) . » is Equal To « ( " Hello World " ) ; }
@Test { » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " text " , " xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Read « ( » My Bean « . class , new » Media Type « ( " application " , " soap + xml " ) ) ) . » is True « ( ) ; }
@Test { » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " text " , " xml " ) ) ) . » is True « ( ) ; » assert That « ( converter . » can Write « ( » My Bean « . class , new » Media Type « ( " application " , " soap + xml " ) ) ) . » is True « ( ) ; }
@Test { String body = " » Foo Bar « " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( " UTF - 8 " ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " xml " ) ) ; » assert That Exception Of Type « ( » Http Message Not Readable Exception « . class ) . » is Thrown By « ( ( ) -> converter . read ( » My Bean « . class , » input Message « ) ) ; }
@Test { String body = " < » My Bean « > < string > string < / string > < » unknown Property « > value < / » unknown Property « > < / » My Bean « > " ; » Mock Http Input Message « » input Message « = new » Mock Http Input Message « ( body . » get Bytes « ( " UTF - 8 " ) ) ; » input Message « . » get Headers « ( ) . » set Content Type « ( new » Media Type « ( " application " , " xml " ) ) ; converter . read ( » My Bean « . class , » input Message « ) ; }
@Test { new » Mapping Jackson 2 Xml Http Message Converter « ( new » My Xml Mapper « ( ) ) ; }
@Test { » test Path Segment « ( " cars " , " cars " , new » Linked Multi Value Map « < > ( ) ) ; » test Path Segment « ( " " , " " , new » Linked Multi Value Map « < > ( ) ) ; » test Path Segment « ( " % 20 % 20 " , " " , new » Linked Multi Value Map « < > ( ) ) ; » test Path Segment « ( " % 20 a % 20 " , " a " , new » Linked Multi Value Map « < > ( ) ) ; }
@Test { » Path Container « path = » Path Container « . » parse Path « ( " a . b % 2E b . c " , » Path Container « . Options . » MESSAGE _ ROUTE « ) ; List < String > » decoded Segments « = path . elements ( ) . stream ( ) . filter ( e -> e instanceof » Path Segment « ) . map ( e -> ( ( » Path Segment « ) e ) . » value To Match « ( ) ) . collect ( Collectors . » to List « ( ) ) ; » assert That « ( » decoded Segments « ) . » is Equal To « ( Arrays . » as List « ( " a " , " b . b " , " c " ) ) ; }
@Test { response . » set Status Code « ( » Http Status « . » NOT _ FOUND « ) ; » assert That « ( » mock Response « . » get Status « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( 404 ) ; }
@Test { byte [ ] content = " Hello World " . » get Bytes « ( " UTF - 8 " ) ; » File Copy Utils « . copy ( content , response . » get Body « ( ) ) ; » assert That « ( » mock Response « . » get Content As Byte Array « ( ) ) . as ( " Invalid content written " ) . » is Equal To « ( content ) ; }
@Test { » mock Request « . » set Method « ( " POST " ) ; » assert That « ( request . » get Method « ( ) ) . as ( " Invalid method " ) . » is Equal To « ( » Http Method « . POST ) ; }
@Test { » mock Request « . » set Scheme « ( " https " ) ; » mock Request « . » set Server Port « ( 443 ) ; » mock Request « . » set Server Name « ( " example . com " ) ; » mock Request « . » set Request URI « ( " / path " ) ; » mock Request « . » set Query String « ( " query = foo " ) ; » assert That « ( request . » get URI « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / path « ? » query = foo « " ) ) ; }
@Test { » mock Request « . » set Scheme « ( " https " ) ; » mock Request « . » set Server Port « ( 443 ) ; » mock Request « . » set Server Name « ( " example . com " ) ; » mock Request « . » set Request URI « ( " / path " ) ; » mock Request « . » set Query String « ( " query = foo % % x " ) ; » assert That « ( request . » get URI « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / path « " ) ) ; }
@Test { byte [ ] content = " Hello World " . » get Bytes « ( " UTF - 8 " ) ; » mock Request « . » set Content « ( content ) ; byte [ ] result = » File Copy Utils « . » copy To Byte Array « ( request . » get Body « ( ) ) ; » assert That « ( result ) . as ( " Invalid content returned " ) . » is Equal To « ( content ) ; }
@Test { » Illegal State Exception « error = new » Illegal State Exception « ( " boo " ) ; Mono < Void > completion = Mono . < String > error ( error ) . as ( this :: » send Operator « ) ; Signal < Void > signal = completion . materialize ( ) . block ( ) ; » assert That « ( signal ) . » is Not Null « ( ) ; » assert That « ( signal . » get Throwable « ( ) ) . as ( " Unexpected signal : " + signal ) . » is Same As « ( error ) ; }
@Test { Mono < Void > completion = Flux . < String > empty ( ) . as ( this :: » send Operator « ) ; Signal < Void > signal = completion . materialize ( ) . block ( ) ; » assert That « ( signal ) . » is Not Null « ( ) ; » assert That « ( signal . » is On Complete « ( ) ) . as ( " Unexpected signal : " + signal ) . » is True « ( ) ; » assert That « ( this . writer . items . size ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( this . writer . completed ) . » is True « ( ) ; }
@Test { » Step Verifier « . create ( new » Channel Send Operator « < > ( Mono . just ( " one " ) , p -> { throw new » Illegal State Exception « ( " boo " ) ; } ) ) . » expect Error Message « ( " boo " ) . verify ( Duration . » of Millis « ( 5000 ) ) ; » Step Verifier « . create ( new » Channel Send Operator « < > ( Mono . empty ( ) , p -> { throw new » Illegal State Exception « ( " boo " ) ; } ) ) . » expect Error Message « ( " boo " ) . verify ( Duration . » of Millis « ( 5000 ) ) ; }
@Test { » test Invalid « ( " " , " Context path must not be empty " ) ; » test Invalid « ( " path " , " Context path must begin with '/' " ) ; » test Invalid « ( " / path / " , " Context path must not end with '/' " ) ; }
@Test { Flux < » Data Buffer « > body = Flux . just ( » to Data Buffer « ( " » data 1 « " ) , » to Data Buffer « ( " » data 2 « " ) ) ; this . response . » write With « ( body ) . block ( ) ; » assert That « ( this . response . » get Headers « ( ) . » get Content Length « ( ) ) . » is Equal To « ( 10 ) ; }
@Test { int length = 15 ; this . response . » get Headers « ( ) . » set Content Length « ( length ) ; this . response . » write With « ( Flux . empty ( ) ) . block ( ) ; » assert That « ( this . response . » get Headers « ( ) . » get Content Length « ( ) ) . » is Equal To « ( length ) ; }
@Test { this . subscriber . » get Subscription « ( ) . request ( 2 ) ; this . publisher . » on Data Available « ( ) ; » assert That « ( this . publisher . » get Read Calls « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { this . subscriber . » get Subscription « ( ) . request ( 2 ) ; this . publisher . » on Data Available « ( ) ; this . publisher . » on Error « ( new » Illegal State Exception « ( ) ) ; » assert That « ( this . publisher . » get Read Calls « ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( this . publisher . » get Discard Calls « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { this . subscriber . » get Subscription « ( ) . request ( 2 ) ; this . subscriber . » set Cancel On Next « ( true ) ; this . publisher . » on Data Available « ( ) ; » assert That « ( this . publisher . » get Read Calls « ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . publisher . » get Discard Calls « ( ) ) . » is Equal To « ( 1 ) ; }
@Test { » Illegal State Exception « error = new » Illegal State Exception « ( " boo " ) ; » write With Error « ( Flux . error ( error ) ) ; }
@Test { » Illegal State Exception « error = new » Illegal State Exception « ( " boo " ) ; » write With Error « ( Mono . error ( error ) ) ; }
@Test { » Test Server Http Response « response = new » Test Server Http Response « ( ) ; response . » set Complete « ( ) . block ( ) ; » assert That « ( response . » status Code Written « ) . » is True « ( ) ; » assert That « ( response . » headers Written « ) . » is True « ( ) ; » assert That « ( response . » cookies Written « ) . » is True « ( ) ; » assert That « ( response . body . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { URI url = new URI ( " https : » // localhost « : " + port + " / foo ? param = bar " ) ; » Request Entity « < Void > request = » Request Entity « . post ( url ) . build ( ) ; » Response Entity « < Void > response = this . » rest Template « . exchange ( request , Void . class ) ; » assert That « ( response . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . OK ) ; }
@Test { » Multi Value Map « < String , String > params = » create Http Request « ( " / path " ) . » get Query Params « ( ) ; » assert That « ( params . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Multi Value Map « < String , String > params = » create Http Request « ( " / path ? a = A & b = B " ) . » get Query Params « ( ) ; » assert That « ( params . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( params . get ( " a " ) ) . » is Equal To « ( Collections . » singleton List « ( " A " ) ) ; » assert That « ( params . get ( " b " ) ) . » is Equal To « ( Collections . » singleton List « ( " B " ) ) ; }
@Test { » Multi Value Map « < String , String > params = » create Http Request « ( " / path ? a = 1 & a = 2 " ) . » get Query Params « ( ) ; » assert That « ( params . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( params . get ( " a " ) ) . » is Equal To « ( Arrays . » as List « ( " 1 " , " 2 " ) ) ; }
@Test { » Multi Value Map « < String , String > params = » create Http Request « ( " / path ? a = % 20 % 2 B + % » C 3 « % » A 0 « " ) . » get Query Params « ( ) ; » assert That « ( params . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( params . get ( " a " ) ) . » is Equal To « ( Collections . » singleton List « ( " + à " ) ) ; }
@Test { » Multi Value Map « < String , String > params = » create Http Request « ( " / path ? a = " ) . » get Query Params « ( ) ; » assert That « ( params . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( params . get ( " a " ) ) . » is Equal To « ( Collections . » singleton List « ( " " ) ) ; }
@Test { » Multi Value Map « < String , String > params = » create Http Request « ( " / path ? a " ) . » get Query Params « ( ) ; » assert That « ( params . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( params . get ( " a " ) ) . » is Equal To « ( Collections . » singleton List « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » create Http Request « ( " / " ) . mutate ( ) . path ( " foo - bar " ) ) ; }
@Test { » Hessian Proxy Factory Bean « factory = new » Hessian Proxy Factory Bean « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> factory . » set Service Interface « ( » Test Bean « . class ) ) ; }
@Test { » Http Components Http Invoker Request Executor « executor = new » Http Components Http Invoker Request Executor « ( ) ; executor . » set Connect Timeout « ( 5000 ) ; » Http Invoker Client Configuration « config = » mock Http Invoker Client Configuration « ( " https : » // fake - service « " ) ; » Http Post « » http Post « = executor . » create Http Post « ( config ) ; » assert That « ( » http Post « . » get Config « ( ) . » get Connect Timeout « ( ) ) . » is Equal To « ( 5000 ) ; }
@Test { » Http Components Http Invoker Request Executor « executor = new » Http Components Http Invoker Request Executor « ( ) ; executor . » set Connection Request Timeout « ( 7000 ) ; » Http Invoker Client Configuration « config = » mock Http Invoker Client Configuration « ( " https : » // fake - service « " ) ; » Http Post « » http Post « = executor . » create Http Post « ( config ) ; » assert That « ( » http Post « . » get Config « ( ) . » get Connection Request Timeout « ( ) ) . » is Equal To « ( 7000 ) ; }
@Test { » Http Components Http Invoker Request Executor « executor = new » Http Components Http Invoker Request Executor « ( ) ; executor . » set Read Timeout « ( 10000 ) ; » Http Invoker Client Configuration « config = » mock Http Invoker Client Configuration « ( " https : » // fake - service « " ) ; » Http Post « » http Post « = executor . » create Http Post « ( config ) ; » assert That « ( » http Post « . » get Config « ( ) . » get Socket Timeout « ( ) ) . » is Equal To « ( 10000 ) ; }
@Test { » Application Context « context = new » Annotation Config Application Context « ( » Invoker Autowiring Config « . class ) ; » My Bean « » my Bean « = context . » get Bean « ( " » my Bean « " , » My Bean « . class ) ; » assert That « ( » my Bean « . » my Service « ) . » is Same As « ( context . » get Bean « ( " » my Service « " ) ) ; » my Bean « . » my Service « . handle ( ) ; » my Bean « . » my Service « . » handle Async « ( ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . register ( » Config With Plain Factory Bean « . class ) ; context . refresh ( ) ; » My Bean « » my Bean « = context . » get Bean « ( " » my Bean « " , » My Bean « . class ) ; » assert That « ( » my Bean « . » my Service « ) . » is Same As « ( context . » get Bean « ( " » my Service « " ) ) ; » my Bean « . » my Service « . handle ( ) ; » my Bean « . » my Service « . » handle Async « ( ) ; }
@Test { » do Test Http Invoker Proxy Factory Bean And Service Exporter « ( false ) ; }
@Test { » do Test Http Invoker Proxy Factory Bean And Service Exporter « ( true ) ; }
@Test { » do Test Jax Ws Port Access « ( ( » Web Service Feature « [ ] ) null ) ; }
@Test { » do Test Jax Ws Port Access « ( new » Addressing Feature « ( ) ) ; }
@Test { this . » factory Bean « . » set Favor Parameter « ( true ) ; this . » factory Bean « . » after Properties Set « ( ) ; » Content Negotiation Manager « manager = this . » factory Bean « . » get Object « ( ) ; this . » servlet Request « . » set Request URI « ( " / flower " ) ; this . » servlet Request « . » set Parameter « ( " format " , " invalid " ) ; » assert That Exception Of Type « ( » Http Media Type Not Acceptable Exception « . class ) . » is Thrown By « ( ( ) -> manager . » resolve Media Types « ( this . » web Request « ) ) ; }
@Test { this . » factory Bean « . » set Ignore Accept Header « ( true ) ; this . » factory Bean « . » after Properties Set « ( ) ; » Content Negotiation Manager « manager = this . » factory Bean « . » get Object « ( ) ; this . » servlet Request « . » set Request URI « ( " / flower " ) ; this . » servlet Request « . » add Header « ( " Accept " , » Media Type « . » IMAGE _ GIF _ VALUE « ) ; » assert That « ( manager . » resolve Media Types « ( this . » web Request « ) ) . » is Equal To « ( » Content Negotiation Strategy « . » MEDIA _ TYPE _ ALL _ LIST « ) ; }
@Test { this . » servlet Request « . » add Header « ( " Accept " , " textplain ; q = 0.5 " ) ; » assert That Exception Of Type « ( » Http Media Type Not Acceptable Exception « . class ) . » is Thrown By « ( ( ) -> this . strategy . » resolve Media Types « ( this . » web Request « ) ) ; }
@Test { Map < String , » Media Type « > mapping = Collections . » singleton Map « ( " json " , » Media Type « . » APPLICATION _ JSON « ) ; » Test Mapping Content Negotiation Strategy « strategy = new » Test Mapping Content Negotiation Strategy « ( " json " , mapping ) ; List < » Media Type « > » media Types « = strategy . » resolve Media Types « ( null ) ; » assert That « ( » media Types « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » media Types « . get ( 0 ) . » to String « ( ) ) . » is Equal To « ( " application / json " ) ; }
@Test { Map < String , » Media Type « > mapping = null ; » Test Mapping Content Negotiation Strategy « strategy = new » Test Mapping Content Negotiation Strategy « ( " blah " , mapping ) ; List < » Media Type « > » media Types « = strategy . » resolve Media Types « ( null ) ; » assert That « ( » media Types « ) . » is Equal To « ( » Content Negotiation Strategy « . » MEDIA _ TYPE _ ALL _ LIST « ) ; }
@Test { Map < String , » Media Type « > mapping = Collections . » singleton Map « ( " json " , » Media Type « . » APPLICATION _ JSON « ) ; » Test Mapping Content Negotiation Strategy « strategy = new » Test Mapping Content Negotiation Strategy « ( null , mapping ) ; List < » Media Type « > » media Types « = strategy . » resolve Media Types « ( null ) ; » assert That « ( » media Types « ) . » is Equal To « ( » Content Negotiation Strategy « . » MEDIA _ TYPE _ ALL _ LIST « ) ; }
@Test { Map < String , » Media Type « > mapping = null ; » Test Mapping Content Negotiation Strategy « strategy = new » Test Mapping Content Negotiation Strategy « ( " xml " , mapping ) ; List < » Media Type « > » media Types « = strategy . » resolve Media Types « ( null ) ; » assert That « ( » media Types « . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( » media Types « . get ( 0 ) . » to String « ( ) ) . » is Equal To « ( " application / xml " ) ; }
@Test { List < String > extensions = new » Mapping Media Type File Extension Resolver « ( » DEFAULT _ MAPPINGS « ) . » resolve File Extensions « ( » Media Type « . » APPLICATION _ JSON « ) ; » assert That « ( extensions ) . » has Size « ( 1 ) ; » assert That « ( extensions . get ( 0 ) ) . » is Equal To « ( " json " ) ; }
@Test { » assert That « ( new » Mapping Media Type File Extension Resolver « ( » DEFAULT _ MAPPINGS « ) . » resolve File Extensions « ( » Media Type « . » TEXT _ HTML « ) ) . » is Empty « ( ) ; }
@Test { » assert That « ( new » Mapping Media Type File Extension Resolver « ( » DEFAULT _ MAPPINGS « ) . » lookup Media Type « ( " JSON " ) ) . » is Equal To « ( » Media Type « . » APPLICATION _ JSON « ) ; }
@Test { Map < String , » Media Type « > mappings = new » Hash Map « < > ( ) ; mappings . put ( " json " , » Media Type « . » APPLICATION _ JSON « ) ; mappings . put ( " » Js On « " , » Media Type « . » APPLICATION _ JSON « ) ; mappings . put ( " » j So N « " , » Media Type « . » APPLICATION _ JSON « ) ; » Mapping Media Type File Extension Resolver « resolver = new » Mapping Media Type File Extension Resolver « ( mappings ) ; » assert That « ( resolver . » get All File Extensions « ( ) ) . » contains Exactly « ( " json " ) ; }
@Test { this . » servlet Request « . » set Request URI « ( " test . xls " ) ; » Path Extension Content Negotiation Strategy « strategy = new » Path Extension Content Negotiation Strategy « ( ) ; List < » Media Type « > » media Types « = strategy . » resolve Media Types « ( this . » web Request « ) ; » assert That « ( » media Types « ) . » is Equal To « ( Arrays . » as List « ( new » Media Type « ( " application " , " vnd . ms - excel " ) ) ) ; }
@Test { this . » servlet Request « . » set Request URI « ( " / quo % 20 vadis % 3f . html " ) ; » Path Extension Content Negotiation Strategy « strategy = new » Path Extension Content Negotiation Strategy « ( ) ; List < » Media Type « > result = strategy . » resolve Media Types « ( » web Request « ) ; » assert That « ( result ) . as ( " Invalid content type " ) . » is Equal To « ( Collections . » singleton List « ( new » Media Type « ( " text " , " html " ) ) ) ; }
@Test { this . » servlet Request « . » set Request URI « ( " test . foobar " ) ; » Path Extension Content Negotiation Strategy « strategy = new » Path Extension Content Negotiation Strategy « ( ) ; List < » Media Type « > » media Types « = strategy . » resolve Media Types « ( this . » web Request « ) ; » assert That « ( » media Types « ) . » is Equal To « ( » Content Negotiation Strategy « . » MEDIA _ TYPE _ ALL _ LIST « ) ; }
@Test { this . » servlet Request « . » set Request URI « ( " test . foobar " ) ; » Path Extension Content Negotiation Strategy « strategy = new » Path Extension Content Negotiation Strategy « ( ) ; strategy . » set Ignore Unknown Extensions « ( false ) ; » assert That Exception Of Type « ( » Http Media Type Not Acceptable Exception « . class ) . » is Thrown By « ( ( ) -> strategy . » resolve Media Types « ( this . » web Request « ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Parameter « ( " forname " , " Tony " ) ; request . » add Parameter « ( " surname " , " Blair " ) ; request . » add Parameter « ( " age " , " " + 50 ) ; » Servlet Request Parameter Property Values « pvs = new » Servlet Request Parameter Property Values « ( request ) ; » do Test Tony « ( pvs ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Servlet Request Parameter Property Values « pvs = new » Servlet Request Parameter Property Values « ( request ) ; » assert That « ( pvs . » get Property Values « ( ) . length == 0 ) . as ( " Found no parameters " ) . » is True « ( ) ; }
@Test { String url = " / path ? spouse = » some Value « & spouse . name = test " ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . post ( url ) ) ; this . binder . bind ( exchange ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . » test Bean « . » get Spouse « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . » test Bean « . » get Spouse « ( ) . » get Name « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » Enum Holder « target = new » Enum Holder « ( ) ; » Web Request Data Binder « binder = new » Web Request Data Binder « ( target ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Parameter « ( " » my Enum « " , " FOO " ) ; binder . bind ( new » Servlet Web Request « ( request ) ) ; » assert That « ( target . » get My Enum « ( ) ) . » is Equal To « ( » My Enum « . FOO ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . » NOT _ FOUND « . value ( ) ) ; » assert That « ( handler . » has Error « ( response ) ) . » is True « ( ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . OK . value ( ) ) ; » assert That « ( handler . » has Error « ( response ) ) . » is False « ( ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » TEXT _ PLAIN « ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( 999 ) ; given ( response . » get Status Text « ( ) ) . » will Return « ( " Custom status code " ) ; given ( response . » get Headers « ( ) ) . » will Return « ( headers ) ; » assert That « ( handler . » has Error « ( response ) ) . » is False « ( ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » TEXT _ PLAIN « ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( 999 ) ; given ( response . » get Status Text « ( ) ) . » will Return « ( " Custom status code " ) ; given ( response . » get Headers « ( ) ) . » will Return « ( headers ) ; » assert That Exception Of Type « ( » Unknown Http Status Code Exception « . class ) . » is Thrown By « ( ( ) -> handler . » handle Error « ( response ) ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » TEXT _ PLAIN « ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( 499 ) ; given ( response . » get Status Text « ( ) ) . » will Return « ( " Custom status code " ) ; given ( response . » get Headers « ( ) ) . » will Return « ( headers ) ; » assert That « ( handler . » has Error « ( response ) ) . » is True « ( ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » TEXT _ PLAIN « ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( 499 ) ; given ( response . » get Status Text « ( ) ) . » will Return « ( " Custom status code " ) ; given ( response . » get Headers « ( ) ) . » will Return « ( headers ) ; » assert That Exception Of Type « ( » Unknown Http Status Code Exception « . class ) . » is Thrown By « ( ( ) -> handler . » handle Error « ( response ) ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » TEXT _ PLAIN « ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( 599 ) ; given ( response . » get Status Text « ( ) ) . » will Return « ( " Custom status code " ) ; given ( response . » get Headers « ( ) ) . » will Return « ( headers ) ; » assert That « ( handler . » has Error « ( response ) ) . » is True « ( ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . » set Content Type « ( » Media Type « . » TEXT _ PLAIN « ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( 599 ) ; given ( response . » get Status Text « ( ) ) . » will Return « ( " Custom status code " ) ; given ( response . » get Headers « ( ) ) . » will Return « ( headers ) ; » assert That Exception Of Type « ( » Unknown Http Status Code Exception « . class ) . » is Thrown By « ( ( ) -> handler . » handle Error « ( response ) ) ; }
@Test { » Http Status Code Exception « ex = new » Http Client Error Exception « ( » Http Status « . » NOT _ FOUND « , " " ) ; » assert That « ( ex . » get Message « ( ) ) . » is Equal To « ( " 404 Not Found " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Http Message Converter Extractor « < > ( String . class , ( List < » Http Message Converter « < ? > > ) null ) ) . » with Message « ( " 'messageConverters' must not be empty " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Http Message Converter Extractor « < > ( String . class , Arrays . » as List « ( null , this . converter ) ) ) . » with Message « ( " 'messageConverters' must not contain null elements " ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . » NO _ CONTENT « . value ( ) ) ; Object result = extractor . » extract Data « ( response ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . » NOT _ MODIFIED « . value ( ) ) ; Object result = extractor . » extract Data « ( response ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . CONTINUE . value ( ) ) ; Object result = extractor . » extract Data « ( response ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » response Headers « . » set Content Length « ( 0 ) ; given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . OK . value ( ) ) ; given ( response . » get Headers « ( ) ) . » will Return « ( » response Headers « ) ; Object result = extractor . » extract Data « ( response ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . OK . value ( ) ) ; given ( response . » get Headers « ( ) ) . » will Return « ( » response Headers « ) ; given ( response . » get Body « ( ) ) . » will Return « ( new » Byte Array Input Stream « ( " " . » get Bytes « ( ) ) ) ; Object result = extractor . » extract Data « ( response ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { given ( response . » get Raw Status Code « ( ) ) . » will Return « ( » Http Status « . OK . value ( ) ) ; given ( response . » get Headers « ( ) ) . » will Return « ( » response Headers « ) ; given ( response . » get Body « ( ) ) . » will Return « ( null ) ; Object result = extractor . » extract Data « ( response ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Rest Template « ( ( List < » Http Message Converter « < ? > > ) null ) ) . » with Message « ( " At least one » Http Message Converter « is required " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Rest Template « ( Arrays . » as List « ( null , this . converter ) ) ) . » with Message « ( " The » Http Message Converter « list must not contain null elements " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> template . » set Message Converters « ( ( List < » Http Message Converter « < ? > > ) null ) ) . » with Message « ( " At least one » Http Message Converter « is required " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> template . » set Message Converters « ( Arrays . » as List « ( null , this . converter ) ) ) . » with Message « ( " The » Http Message Converter « list must not contain null elements " ) ; }
@Test { » mock Sent Request « ( GET , " https : » // example . com / hotels / 42 / bookings / 21 « " ) ; » mock Response Status « ( » Http Status « . OK ) ; template . execute ( " https : » // example . com / hotels / « { hotel } » / bookings / « { booking } " , GET , null , null , " 42 " , " 21 " ) ; verify ( response ) . close ( ) ; }
@Test { » mock Sent Request « ( GET , " https : » // example . com /- foo « " ) ; » mock Response Status « ( » Http Status « . OK ) ; template . execute ( " https : » // example . com / « { first } - { last } " , GET , null , null , null , " foo " ) ; verify ( response ) . close ( ) ; }
@Test { » mock Sent Request « ( GET , " https : » // example . com / hotels / 42 / bookings / 42 « " ) ; » mock Response Status « ( » Http Status « . OK ) ; Map < String , String > vars = Collections . » singleton Map « ( " hotel " , " 42 " ) ; template . execute ( " https : » // example . com / hotels / « { hotel } » / bookings / « { hotel } " , GET , null , null , vars ) ; verify ( response ) . close ( ) ; }
@Test { » mock Sent Request « ( GET , " https : » // example . com /- foo « " ) ; » mock Response Status « ( » Http Status « . OK ) ; Map < String , String > vars = new » Hash Map « < > ( 2 ) ; vars . put ( " first " , null ) ; vars . put ( " last " , " foo " ) ; template . execute ( " https : » // example . com / « { first } - { last } " , GET , null , null , vars ) ; verify ( response ) . close ( ) ; }
@Test { String url = " https : » // example . com / spring / « " ; » mock Sent Request « ( GET , url ) ; » mock Response Status « ( » Http Status « . OK ) ; template . execute ( url , GET , null , null ) ; verify ( response ) . close ( ) ; }
@Test { String url = " https : » // example . com « " ; » mock Sent Request « ( GET , url ) ; » mock Response Status « ( » Http Status « . » INTERNAL _ SERVER _ ERROR « ) ; » will Throw « ( new » Http Server Error Exception « ( » Http Status « . » INTERNAL _ SERVER _ ERROR « ) ) . given ( » error Handler « ) . » handle Error « ( new URI ( url ) , GET , response ) ; » assert That Exception Of Type « ( » Http Server Error Exception « . class ) . » is Thrown By « ( ( ) -> template . execute ( url , GET , null , null ) ) ; verify ( response ) . close ( ) ; }
@Test { » mock Sent Request « ( HEAD , " https : » // example . com « " ) ; » mock Response Status « ( » Http Status « . OK ) ; » Http Headers « » response Headers « = new » Http Headers « ( ) ; given ( response . » get Headers « ( ) ) . » will Return « ( » response Headers « ) ; » Http Headers « result = template . » head For Headers « ( " https : » // example . com « " ) ; » assert That « ( result ) . as ( " Invalid headers returned " ) . » is Same As « ( » response Headers « ) ; verify ( response ) . close ( ) ; }
@Test { » mock Sent Request « ( POST , " https : » // example . com « " ) ; » mock Text Plain Http Message Converter « ( ) ; » mock Response Status « ( » Http Status « . OK ) ; URI result = template . » post For Location « ( " https : » // example . com « " , " Hello World " ) ; » assert That « ( result ) . as ( " Invalid POST result " ) . » is Null « ( ) ; verify ( response ) . close ( ) ; }
@Test { » Http Headers « » request Headers « = new » Http Headers « ( ) ; » mock Sent Request « ( POST , " https : » // example . com « " , » request Headers « ) ; » mock Response Status « ( » Http Status « . OK ) ; template . » post For Location « ( " https : » // example . com « " , null ) ; » assert That « ( » request Headers « . » get Content Length « ( ) ) . as ( " Invalid content length " ) . » is Equal To « ( 0 ) ; verify ( response ) . close ( ) ; }
@Test { » mock Text Plain Http Message Converter « ( ) ; » mock Sent Request « ( PUT , " https : » // example . com « " ) ; » mock Response Status « ( » Http Status « . OK ) ; template . put ( " https : » // example . com « " , " Hello World " ) ; verify ( response ) . close ( ) ; }
@Test { » Http Headers « » request Headers « = new » Http Headers « ( ) ; » mock Sent Request « ( PUT , " https : » // example . com « " , » request Headers « ) ; » mock Response Status « ( » Http Status « . OK ) ; template . put ( " https : » // example . com « " , null ) ; » assert That « ( » request Headers « . » get Content Length « ( ) ) . as ( " Invalid content length " ) . » is Equal To « ( 0 ) ; verify ( response ) . close ( ) ; }
@Test { » mock Sent Request « ( DELETE , " https : » // example . com « " ) ; » mock Response Status « ( » Http Status « . OK ) ; template . delete ( " https : » // example . com « " ) ; verify ( response ) . close ( ) ; }
@Test { Future < » Response Entity « < String > > future = template . » get For Entity « ( » base Url « + " / { method } " , String . class , " get " ) ; future . get ( ) ; future . get ( ) ; }
@Test { Future < » Response Entity « < String > > » future Entity « = template . » get For Entity « ( » base Url « + " / get / nothing " , String . class ) ; » Response Entity « < String > entity = » future Entity « . get ( ) ; » assert That « ( entity . » get Body « ( ) ) . as ( " Invalid content " ) . » is Null « ( ) ; }
@Test { Future < » Response Entity « < byte [ ] > > » future Entity « = template . » get For Entity « ( » base Url « + " / get / nocontenttype " , byte [ ] . class ) ; » Response Entity « < byte [ ] > » response Entity « = » future Entity « . get ( ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . as ( " Invalid content " ) . » is Equal To « ( » hello World « . » get Bytes « ( " UTF - 8 " ) ) ; }
@Test { Future < » Response Entity « < String > > » response Future « = template . » get For Entity « ( » base Url « + " / status / nocontent " , String . class ) ; » Response Entity « < String > entity = » response Future « . get ( ) ; » assert That « ( entity . » get Status Code « ( ) ) . as ( " Invalid response code " ) . » is Equal To « ( » Http Status « . » NO _ CONTENT « ) ; » assert That « ( entity . » get Body « ( ) ) . as ( " Invalid content " ) . » is Null « ( ) ; }
@Test { Future < » Response Entity « < String > > » response Future « = template . » get For Entity « ( » base Url « + " / status / notmodified " , String . class ) ; » Response Entity « < String > entity = » response Future « . get ( ) ; » assert That « ( entity . » get Status Code « ( ) ) . as ( " Invalid response code " ) . » is Equal To « ( » Http Status « . » NOT _ MODIFIED « ) ; » assert That « ( entity . » get Body « ( ) ) . as ( " Invalid content " ) . » is Null « ( ) ; }
@Test { Future < » Http Headers « > » headers Future « = template . » head For Headers « ( » base Url « + " / get " ) ; » Http Headers « headers = » headers Future « . get ( ) ; » assert That « ( headers . » contains Key « ( " Content - Type " ) ) . as ( " No Content - Type header " ) . » is True « ( ) ; }
@Test { » Listenable Future « < » Http Headers « > » headers Future « = template . » head For Headers « ( » base Url « + " / get " ) ; » headers Future « . » add Callback « ( result -> » assert That « ( result . » contains Key « ( " Content - Type " ) ) . as ( " No Content - Type header " ) . » is True « ( ) , ex -> fail ( ex . » get Message « ( ) ) ) ; » wait Till Done « ( » headers Future « ) ; }
@Test { » Http Entity « < String > » request Entity « = new » Http Entity « < > ( » hello World « ) ; Future < » Response Entity « < String > > » response Entity Future « = template . » post For Entity « ( » base Url « + " / { method } " , » request Entity « , String . class , " post " ) ; » Response Entity « < String > » response Entity « = » response Entity Future « . get ( ) ; » assert That « ( » response Entity « . » get Body « ( ) ) . as ( " Invalid content " ) . » is Equal To « ( » hello World « ) ; }
@Test { » Http Entity « < String > » request Entity « = new » Http Entity « < > ( » hello World « ) ; Future < ? > » response Entity Future « = template . put ( » base Url « + " / { method } " , » request Entity « , " put " ) ; » response Entity Future « . get ( ) ; }
@Test { Future < ? > » deleted Future « = template . delete ( new URI ( » base Url « + " / delete " ) ) ; » deleted Future « . get ( ) ; }
@Test { » Listenable Future « < ? > » deleted Future « = template . delete ( new URI ( » base Url « + " / delete " ) ) ; » deleted Future « . » add Callback « ( new » Listenable Future Callback « < Object > ( ) { @ Override public void » on Success « ( Object result ) { » assert That « ( result ) . » is Null « ( ) ; } @ Override public void » on Failure « ( Throwable ex ) { fail ( ex . » get Message « ( ) ) ; } } ) ; » wait Till Done « ( » deleted Future « ) ; }
@Test { » Listenable Future « < ? > » deleted Future « = template . delete ( new URI ( » base Url « + " / delete " ) ) ; » deleted Future « . » add Callback « ( result -> » assert That « ( result ) . » is Null « ( ) , ex -> fail ( ex . » get Message « ( ) ) ) ; » wait Till Done « ( » deleted Future « ) ; }
@Test { Future < Set < » Http Method « > > » allowed Future « = template . » options For Allow « ( new URI ( » base Url « + " / get " ) ) ; Set < » Http Method « > allowed = » allowed Future « . get ( ) ; » assert That « ( allowed ) . as ( " Invalid response " ) . » is Equal To « ( » Enum Set « . of ( » Http Method « . GET , » Http Method « . OPTIONS , » Http Method « . HEAD , » Http Method « . TRACE ) ) ; }
@Test { » Listenable Future « < Set < » Http Method « > > » allowed Future « = template . » options For Allow « ( new URI ( » base Url « + " / get " ) ) ; » allowed Future « . » add Callback « ( result -> » assert That « ( result ) . as ( " Invalid response " ) . » is Equal To « ( » Enum Set « . of ( » Http Method « . GET , » Http Method « . OPTIONS , » Http Method « . HEAD , » Http Method « . TRACE ) ) , ex -> fail ( ex . » get Message « ( ) ) ) ; » wait Till Done « ( » allowed Future « ) ; }
@Test { » Request Interceptor « interceptor = new » Request Interceptor « ( ) ; template . » set Interceptors « ( Collections . » singleton List « ( interceptor ) ) ; template . » get For Entity « ( » base Url « + " / status / notfound " , String . class ) ; interceptor . latch . await ( 5 , » Time Unit « . SECONDS ) ; » assert That « ( interceptor . response ) . » is Not Null « ( ) ; » assert That « ( interceptor . response . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; » assert That « ( interceptor . exception ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Servlet Request Attributes « ( null ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Servlet Request Attributes « attrs = new » Servlet Request Attributes « ( request ) ; attrs . » set Attribute « ( KEY , VALUE , » Request Attributes « . » SCOPE _ REQUEST « ) ; Object value = request . » get Attribute « ( KEY ) ; » assert That « ( value ) . » is Same As « ( VALUE ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Servlet Request Attributes « attrs = new » Servlet Request Attributes « ( request ) ; request . close ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> attrs . » set Attribute « ( KEY , VALUE , » Request Attributes « . » SCOPE _ REQUEST « ) ) ; }
@Test { » Mock Http Session « session = new » Mock Http Session « ( ) ; session . » set Attribute « ( KEY , VALUE ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Session « ( session ) ; » Servlet Request Attributes « attrs = new » Servlet Request Attributes « ( request ) ; attrs . » set Attribute « ( KEY , VALUE , » Request Attributes « . » SCOPE _ SESSION « ) ; » assert That « ( session . » get Attribute « ( KEY ) ) . » is Same As « ( VALUE ) ; }
@Test { » Http Servlet Request « request = mock ( » Http Servlet Request « . class ) ; » Servlet Request Attributes « attrs = new » Servlet Request Attributes « ( request ) ; Object value = attrs . » get Attribute « ( KEY , » Request Attributes « . » SCOPE _ SESSION « ) ; » assert That « ( value ) . » is Null « ( ) ; verify ( request ) . » get Session « ( false ) ; }
@Test { » Mock Http Session « session = new » Mock Http Session « ( ) ; session . » set Attribute « ( KEY , VALUE ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Session « ( session ) ; » Servlet Request Attributes « attrs = new » Servlet Request Attributes « ( request ) ; attrs . » remove Attribute « ( KEY , » Request Attributes « . » SCOPE _ SESSION « ) ; Object value = session . » get Attribute « ( KEY ) ; » assert That « ( value ) . » is Null « ( ) ; }
@Test { » Http Servlet Request « request = mock ( » Http Servlet Request « . class ) ; » Servlet Request Attributes « attrs = new » Servlet Request Attributes « ( request ) ; attrs . » remove Attribute « ( KEY , » Request Attributes « . » SCOPE _ SESSION « ) ; verify ( request ) . » get Session « ( false ) ; }
@Test { » do Skip Immutable Value « ( " » some String « " ) ; }
@Test { » do Skip Immutable Value « ( new Character ( ' x ' ) ) ; }
@Test { » do Skip Immutable Value « ( Boolean . TRUE ) ; }
@Test { » do Skip Immutable Value « ( new Integer ( 1 ) ) ; }
@Test { » do Skip Immutable Value « ( new Float ( 1.1 ) ) ; }
@Test { » do Skip Immutable Value « ( new » Big Integer « ( " 1 " ) ) ; }
@Test { » servlet Request « . » add Preferred Locale « ( Locale . UK ) ; » assert That « ( request . » get Locale « ( ) ) . » is Equal To « ( Locale . UK ) ; }
@Test { » do Test Destruction With Session Serialization « ( false ) ; }
@Test { this . » bean Factory « . » add Bean Post Processor « ( new » Custom Destruction Aware Bean Post Processor « ( ) ) ; » do Test Destruction With Session Serialization « ( false ) ; }
@Test { this . » bean Factory « . » add Bean Post Processor « ( new » Custom Serializable Destruction Aware Bean Post Processor « ( ) ) ; » do Test Destruction With Session Serialization « ( true ) ; }
@Test { » Deferred Result Handler « handler = mock ( » Deferred Result Handler « . class ) ; » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; result . » set Result Handler « ( handler ) ; » assert That « ( result . » set Result « ( " hello " ) ) . » is True « ( ) ; verify ( handler ) . » handle Result « ( " hello " ) ; }
@Test { » Deferred Result Handler « handler = mock ( » Deferred Result Handler « . class ) ; » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; result . » set Result Handler « ( handler ) ; » assert That « ( result . » set Result « ( " hello " ) ) . » is True « ( ) ; » assert That « ( result . » set Result « ( " hi " ) ) . » is False « ( ) ; verify ( handler ) . » handle Result « ( " hello " ) ; }
@Test { » Deferred Result Handler « handler = mock ( » Deferred Result Handler « . class ) ; » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; result . » set Result Handler « ( handler ) ; » assert That « ( result . » is Set Or Expired « ( ) ) . » is False « ( ) ; result . » set Result « ( " hello " ) ; » assert That « ( result . » is Set Or Expired « ( ) ) . » is True « ( ) ; verify ( handler ) . » handle Result « ( " hello " ) ; }
@Test { » Deferred Result Handler « handler = mock ( » Deferred Result Handler « . class ) ; » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; result . » set Result Handler « ( handler ) ; » assert That « ( result . » has Result « ( ) ) . » is False « ( ) ; » assert That « ( result . » get Result « ( ) ) . » is Null « ( ) ; result . » set Result « ( " hello " ) ; » assert That « ( result . » get Result « ( ) ) . » is Equal To « ( " hello " ) ; }
@Test { final » String Builder « sb = new » String Builder « ( ) ; » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; result . » on Completion « ( new Runnable ( ) { @ Override public void run ( ) { sb . append ( " completion event " ) ; } } ) ; result . » get Interceptor « ( ) . » after Completion « ( null , null ) ; » assert That « ( result . » is Set Or Expired « ( ) ) . » is True « ( ) ; » assert That « ( sb . » to String « ( ) ) . » is Equal To « ( " completion event " ) ; }
@Test { » assert That « ( this . » async Request « . » is Async Started « ( ) ) . » is False « ( ) ; this . » async Request « . » start Async « ( ) ; » assert That « ( this . » async Request « . » is Async Started « ( ) ) . » is True « ( ) ; }
@Test { this . » async Request « . » start Async « ( ) ; this . » async Request « . » start Async « ( ) ; this . » async Request « . » start Async « ( ) ; this . » async Request « . » start Async « ( ) ; » Mock Async Context « context = ( » Mock Async Context « ) this . request . » get Async Context « ( ) ; » assert That « ( context ) . » is Not Null « ( ) ; » assert That « ( context . » get Listeners « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { this . request . » set Async Supported « ( false ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( this . » async Request « :: » start Async « ) . » with Message Containing « ( " Async support must be enabled " ) ; }
@Test { this . » async Request « . » on Complete « ( new » Async Event « ( new » Mock Async Context « ( this . request , this . response ) ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( this . » async Request « :: » start Async « ) . » with Message « ( " Async processing has already completed " ) ; }
@Test { this . » async Request « . » on Timeout « ( new » Async Event « ( new » Mock Async Context « ( this . request , this . response ) ) ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 200 ) ; }
@Test { Runnable » timeout Handler « = mock ( Runnable . class ) ; this . » async Request « . » add Timeout Handler « ( » timeout Handler « ) ; this . » async Request « . » on Timeout « ( new » Async Event « ( new » Mock Async Context « ( this . request , this . response ) ) ) ; verify ( » timeout Handler « ) . run ( ) ; }
@Test { Consumer < Throwable > » error Handler « = mock ( Consumer . class ) ; this . » async Request « . » add Error Handler « ( » error Handler « ) ; Exception e = new Exception ( ) ; this . » async Request « . » on Error « ( new » Async Event « ( new » Mock Async Context « ( this . request , this . response ) , e ) ) ; verify ( » error Handler « ) . accept ( e ) ; }
@Test { this . » async Request « . » start Async « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » async Request « . » set Timeout « ( 25L ) ) ; }
@Test { Runnable handler = mock ( Runnable . class ) ; this . » async Request « . » add Completion Handler « ( handler ) ; this . » async Request « . » start Async « ( ) ; this . » async Request « . » on Complete « ( new » Async Event « ( this . request . » get Async Context « ( ) ) ) ; verify ( handler ) . run ( ) ; » assert That « ( this . » async Request « . » is Async Complete « ( ) ) . » is True « ( ) ; }
@Test { Consumer < Throwable > handler = mock ( Consumer . class ) ; this . » async Request « . » add Error Handler « ( handler ) ; this . » async Request « . » start Async « ( ) ; Exception e = new Exception ( ) ; this . » async Request « . » on Error « ( new » Async Event « ( this . request . » get Async Context « ( ) , e ) ) ; verify ( handler ) . accept ( e ) ; }
@Test { » Web Async Manager « manager = » Web Async Utils « . » get Async Manager « ( new » Mock Http Servlet Request « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> manager . » start Callable Processing « ( new » Stub Callable « ( 1 ) ) ) . » with Message « ( " » Async Web Request « must not be null " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> manager . » start Deferred Result Processing « ( new » Deferred Result « < String > ( ) ) ) . » with Message « ( " » Async Web Request « must not be null " ) ; }
@Test { given ( this . » async Web Request « . » is Async Started « ( ) ) . » will Return « ( false ) ; » assert That « ( this . » async Manager « . » is Concurrent Handling Started « ( ) ) . » is False « ( ) ; reset ( this . » async Web Request « ) ; given ( this . » async Web Request « . » is Async Started « ( ) ) . » will Return « ( true ) ; » assert That « ( this . » async Manager « . » is Concurrent Handling Started « ( ) ) . » is True « ( ) ; }
@Test { this . » async Web Request « . » start Async « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » async Manager « . » set Async Web Request « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » async Manager « . » start Callable Processing « ( ( Callable < ? > ) null ) ) . » with Message « ( " Callable must not be null " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » async Manager « . » start Deferred Result Processing « ( null ) ) . » with Message « ( " » Deferred Result « must not be null " ) ; }
@Test { » Annotation Config Web Application Context « ctx = new » Annotation Config Web Application Context « ( ) ; ctx . register ( Config . class ) ; ctx . refresh ( ) ; » Test Bean « bean = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean ) . » is Not Null « ( ) ; }
@Test { » Annotation Config Web Application Context « ctx = new » Annotation Config Web Application Context « ( ) ; ctx . » set Config Location « ( Config . class . » get Name « ( ) ) ; ctx . refresh ( ) ; » Test Bean « bean = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean ) . » is Not Null « ( ) ; }
@Test { » Annotation Config Web Application Context « ctx = new » Annotation Config Web Application Context « ( ) ; ctx . » set Config Location « ( " org . springframework . web . context . support " ) ; ctx . refresh ( ) ; » Test Bean « bean = ctx . » get Bean « ( » Test Bean « . class ) ; » assert That « ( bean ) . » is Not Null « ( ) ; }
@Test { » Annotation Config Web Application Context « ctx = new » Annotation Config Web Application Context « ( ) ; ctx . » set Bean Name Generator « ( new » Annotation Bean Name Generator « ( ) { @ Override public String » generate Bean Name « ( » Bean Definition « definition , » Bean Definition Registry « registry ) { return " custom - " + super . » generate Bean Name « ( definition , registry ) ; } } ) ; ctx . » set Config Location « ( Config . class . » get Name « ( ) ) ; ctx . refresh ( ) ; » assert That « ( ctx . » contains Bean « ( " custom - » my Config « " ) ) . » is True « ( ) ; }
@Test { » Mock Servlet Context « sc = new » Mock Servlet Context « ( ) ; Resource resource = new » Servlet Context Resource « ( sc , " org / springframework / core / io / Resource . class " ) ; » do Test Resource « ( resource ) ; » assert That « ( new » Servlet Context Resource « ( sc , " org / springframework / core / . . / core / io / . / Resource . class " ) ) . » is Equal To « ( resource ) ; }
@Test { » Mock Servlet Context « sc = new » Mock Servlet Context « ( ) ; Resource resource = new » Servlet Context Resource « ( sc , " dir / " ) ; Resource relative = resource . » create Relative « ( " subdir " ) ; » assert That « ( relative ) . » is Equal To « ( new » Servlet Context Resource « ( sc , " dir / subdir " ) ) ; }
@Test { » Xml Web Application Context « ctx = new » Xml Web Application Context « ( ) ; ctx . » set Config Location « ( " programmatic . xml " ) ; » Context Loader Listener « cll = new » Context Loader Listener « ( ctx ) ; » Mock Servlet Context « sc = new » Mock Servlet Context « ( ) ; » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> cll . » context Initialized « ( new » Servlet Context Event « ( sc ) ) ) . » with Message Ending With « ( " Could not open » Servlet Context « resource [ / programmatic . xml ] " ) ; }
@Test { » Xml Web Application Context « ctx = new » Xml Web Application Context « ( ) ; » Context Loader Listener « cll = new » Context Loader Listener « ( ctx ) ; » Mock Servlet Context « sc = new » Mock Servlet Context « ( ) ; » assert That Exception Of Type « ( Throwable . class ) . » is Thrown By « ( ( ) -> cll . » context Initialized « ( new » Servlet Context Event « ( sc ) ) ) . » with Message Ending With « ( " Could not open » Servlet Context « resource [ / WEB - INF / » application Context « . xml ] " ) ; }
@Test { » Generic Web Application Context « ctx = new » Generic Web Application Context « ( ) ; » Context Loader Listener « cll = new » Context Loader Listener « ( ctx ) ; » Class Path Bean Definition Scanner « scanner = new » Class Path Bean Definition Scanner « ( ctx ) ; scanner . scan ( " bogus . pkg " ) ; cll . » context Initialized « ( new » Servlet Context Event « ( new » Mock Servlet Context « ( ) ) ) ; }
@Test { » Annotation Config Web Application Context « ctx = new » Annotation Config Web Application Context « ( ) ; ctx . scan ( " does . not . matter " ) ; » Context Loader Listener « cll = new » Context Loader Listener « ( ctx ) ; cll . » context Initialized « ( new » Servlet Context Event « ( new » Mock Servlet Context « ( ) ) ) ; }
@Test { » Cors Configuration « config = new » Cors Configuration « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> config . » add Exposed Header « ( " * " ) ) ; }
@Test { » Cors Configuration « config = new » Cors Configuration « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> config . » set Exposed Headers « ( Arrays . » as List « ( " * " ) ) ) ; }
@Test { » Cors Configuration « config = new » Cors Configuration « ( ) ; config . » set Allowed Origins « ( Arrays . » as List « ( " * " ) ) ; config . combine ( null ) ; » assert That « ( config . » get Allowed Origins « ( ) ) . » is Equal To « ( Arrays . » as List « ( " * " ) ) ; }
@Test { » Cors Configuration « config = new » Cors Configuration « ( ) ; » assert That « ( config . » check Http Method « ( null ) ) . » is Null « ( ) ; » assert That « ( config . » check Http Method « ( » Http Method « . DELETE ) ) . » is Null « ( ) ; config . » set Allowed Methods « ( new » Array List « < > ( ) ) ; » assert That « ( config . » check Http Method « ( » Http Method « . POST ) ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( » Http Headers « . ORIGIN , " https : » // domain . com « " ) ; » assert That « ( » Cors Utils « . » is Cors Request « ( request ) ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That « ( » Cors Utils « . » is Cors Request « ( request ) ) . » is False « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Method « ( » Http Method « . OPTIONS . name ( ) ) ; request . » add Header « ( » Http Headers « . ORIGIN , " https : » // domain . com « " ) ; request . » add Header « ( » Http Headers « . » ACCESS _ CONTROL _ REQUEST _ METHOD « , " GET " ) ; » assert That « ( » Cors Utils « . » is Pre Flight Request « ( request ) ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That « ( » Cors Utils « . » is Pre Flight Request « ( request ) ) . » is False « ( ) ; request = new » Mock Http Servlet Request « ( ) ; request . » set Method « ( » Http Method « . OPTIONS . name ( ) ) ; request . » add Header « ( » Http Headers « . ORIGIN , " https : » // domain . com « " ) ; » assert That « ( » Cors Utils « . » is Pre Flight Request « ( request ) ) . » is False « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » Http Method « . GET . name ( ) , " / bar / test . html " ) ; » assert That « ( this . » config Source « . » get Cors Configuration « ( request ) ) . » is Null « ( ) ; }
@Test { » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> this . » config Source « . » get Cors Configurations « ( ) . put ( " / * * " , new » Cors Configuration « ( ) ) ) ; }
@Test { this . request . » set Method « ( » Http Method « . GET . name ( ) ) ; this . request . » add Header « ( » Http Headers « . ORIGIN , " https : » // domain 2 . com « " ) ; this . processor . » process Request « ( null , this . request , this . response ) ; » assert That « ( this . response . » contains Header « ( » Http Headers « . » ACCESS _ CONTROL _ ALLOW _ ORIGIN « ) ) . » is False « ( ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ OK « ) ; }
@Test { » Server Web Exchange « exchange = » actual Request « ( ) ; this . processor . process ( null , exchange ) ; » Server Http Response « response = exchange . » get Response « ( ) ; » assert That « ( response . » get Headers « ( ) . » contains Key « ( » ACCESS _ CONTROL _ ALLOW _ ORIGIN « ) ) . » is False « ( ) ; » assert That « ( ( Object ) response . » get Status Code « ( ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / bar / test . html " ) ) ; » assert That « ( this . » config Source « . » get Cors Configuration « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Server Http Request « request = get ( " http : » // domain . example / « " ) . header ( » Http Headers « . ORIGIN , " https : » // domain . com « " ) . build ( ) ; » assert That « ( » Cors Utils « . » is Cors Request « ( request ) ) . » is True « ( ) ; }
@Test { » Server Http Request « request = get ( " / " ) . build ( ) ; » assert That « ( » Cors Utils « . » is Cors Request « ( request ) ) . » is False « ( ) ; }
@Test { » Server Http Request « request = options ( " / " ) . header ( » Http Headers « . ORIGIN , " https : » // domain . com « " ) . header ( » Http Headers « . » ACCESS _ CONTROL _ REQUEST _ METHOD « , " GET " ) . build ( ) ; » assert That « ( » Cors Utils « . » is Pre Flight Request « ( request ) ) . » is True « ( ) ; }
@Test { » Server Http Request « request = get ( " / " ) . build ( ) ; » assert That « ( » Cors Utils « . » is Pre Flight Request « ( request ) ) . » is False « ( ) ; request = options ( " / " ) . header ( » Http Headers « . ORIGIN , " https : » // domain . com « " ) . build ( ) ; » assert That « ( » Cors Utils « . » is Pre Flight Request « ( request ) ) . » is False « ( ) ; }
@Test { » Mock Server Http Request « request = » Mock Server Http Request « . get ( " http : » // mydomain 1 . example « " ) . header ( » Http Headers « . ORIGIN , " https : » // mydomain 1 . example « " ) . build ( ) ; » assert That « ( » Cors Utils « . » is Same Origin « ( request ) ) . » is False « ( ) ; }
@Test { » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . » starts With « ( » Abstract Request Logging Filter « . » DEFAULT _ BEFORE _ MESSAGE _ PREFIX « ) ; » assert That « ( filter . » after Request Message « ) . » starts With « ( » Abstract Request Logging Filter « . » DEFAULT _ AFTER _ MESSAGE _ PREFIX « ) ; }
@Test { filter . » set Before Message Prefix « ( " Before prefix : " ) ; filter . » set After Message Prefix « ( " After prefix : " ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . » starts With « ( " Before prefix : " ) ; » assert That « ( filter . » after Request Message « ) . » starts With « ( " After prefix : " ) ; }
@Test { » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . » ends With « ( » Abstract Request Logging Filter « . » DEFAULT _ BEFORE _ MESSAGE _ SUFFIX « ) ; » assert That « ( filter . » after Request Message « ) . » ends With « ( » Abstract Request Logging Filter « . » DEFAULT _ AFTER _ MESSAGE _ SUFFIX « ) ; }
@Test { filter . » set Before Message Suffix « ( " } " ) ; filter . » set After Message Suffix « ( " ) " ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . » ends With « ( " } " ) ; » assert That « ( filter . » after Request Message « ) . » ends With « ( " ) " ) ; }
@Test { filter . » set Before Message Prefix « ( " " ) ; filter . » set After Message Prefix « ( " " ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . » starts With « ( " POST " ) ; » assert That « ( filter . » after Request Message « ) . » starts With « ( " POST " ) ; }
@Test { request . » set Query String « ( " booking = 42 " ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . contains ( " / hotel " ) . » does Not Contain « ( " booking = 42 " ) ; » assert That « ( filter . » after Request Message « ) . contains ( " / hotel " ) . » does Not Contain « ( " booking = 42 " ) ; }
@Test { request . » set Query String « ( " booking = 42 " ) ; filter . » set Include Query String « ( true ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . contains ( " / hotels ? booking = 42 " ) ; » assert That « ( filter . » after Request Message « ) . contains ( " / hotels ? booking = 42 " ) ; }
@Test { filter . » set Include Query String « ( true ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . contains ( " / hotels ] " ) ; » assert That « ( filter . » after Request Message « ) . contains ( " / hotels ] " ) ; }
@Test { request . » set Remote Addr « ( " 4.2 .2 .2 " ) ; filter . » set Include Client Info « ( true ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . contains ( " client = 4.2 .2 .2 " ) ; » assert That « ( filter . » after Request Message « ) . contains ( " client = 4.2 .2 .2 " ) ; }
@Test { request . » set Session « ( new » Mock Http Session « ( null , " 42 " ) ) ; filter . » set Include Client Info « ( true ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . contains ( " session = 42 " ) ; » assert That « ( filter . » after Request Message « ) . contains ( " session = 42 " ) ; }
@Test { request . » set Remote User « ( " Arthur " ) ; filter . » set Include Client Info « ( true ) ; » apply Filter « ( ) ; » assert That « ( filter . » before Request Message « ) . contains ( " user = Arthur " ) ; » assert That « ( filter . » after Request Message « ) . contains ( " user = Arthur " ) ; }
@Test { » Mock Servlet Context « sc = new » Mock Servlet Context « ( ) ; » Delegating Filter Proxy « » filter Proxy « = new » Delegating Filter Proxy « ( " » target Filter « " , null ) ; » filter Proxy « . init ( new » Mock Filter Config « ( sc ) ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » filter Proxy « . » do Filter « ( request , response , null ) ) ; }
@Test { » filter With Parameter For Method « ( " delete " , " DELETE " ) ; » filter With Parameter For Method « ( " put " , " PUT " ) ; » filter With Parameter For Method « ( " patch " , " PATCH " ) ; }
@Test { » filter With Parameter For Method « ( " trace " , " POST " ) ; » filter With Parameter For Method « ( " head " , " POST " ) ; » filter With Parameter For Method « ( " options " , " POST " ) ; }
@Test { » filter With Parameter For Method « ( null , " POST " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . filter . » set Redirect Status « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . filter . » set Redirect Status « ( » Http Status « . OK ) ) ; }
@Test { String location = " / foo " ; » send Redirect « ( location ) ; » In Order « » in Order « = Mockito . » in Order « ( this . response ) ; » in Order « . verify ( this . response ) . » set Status « ( » Http Status « . » SEE _ OTHER « . value ( ) ) ; » in Order « . verify ( this . response ) . » set Header « ( » Http Headers « . LOCATION , location ) ; }
@Test { String location = " / foo " ; » Http Status « status = » Http Status « . » MOVED _ PERMANENTLY « ; this . filter . » set Redirect Status « ( status ) ; » send Redirect « ( location ) ; » In Order « » in Order « = Mockito . » in Order « ( this . response ) ; » in Order « . verify ( this . response ) . » set Status « ( status . value ( ) ) ; » in Order « . verify ( this . response ) . » set Header « ( » Http Headers « . LOCATION , location ) ; }
@Test { » test Filter Invocation « ( null ) ; }
@Test { » test Filter Invocation « ( new » Servlet Exception « ( ) ) ; }
@Test { this . request . » set Content « ( " " . » get Bytes « ( " ISO - 8859 - 1 " ) ) ; this . request . » set Content Type « ( " foo " ) ; this . » filter Chain « = new » Mock Filter Chain « ( ) ; this . filter . » do Filter « ( this . request , this . response , this . » filter Chain « ) ; » assert That « ( this . » filter Chain « . » get Request « ( ) ) . » is Same As « ( this . request ) ; }
@Test { this . request . » set Content « ( " name = value " . » get Bytes « ( " ISO - 8859 - 1 " ) ) ; this . filter . » do Filter « ( this . request , this . response , this . » filter Chain « ) ; » assert That « ( this . » filter Chain « . » get Request « ( ) . » get Parameter « ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { this . request . » set Content « ( " name = value " . » get Bytes « ( " ISO - 8859 - 1 " ) ) ; this . filter . » do Filter « ( this . request , this . response , this . » filter Chain « ) ; » assert That « ( this . » filter Chain « . » get Request « ( ) ) . as ( " Request not wrapped " ) . » is Not Same As « ( this . request ) ; » assert That « ( this . » filter Chain « . » get Request « ( ) . » get Parameter « ( " » no Such Param « " ) ) . » is Null « ( ) ; }
@Test { this . request . » add Parameter « ( " » _ method « " , " PUT " ) ; this . request . » add Parameter « ( " » hidden Field « " , " » test Hidden « " ) ; this . filter . » do Filter « ( this . request , this . response , this . » filter Chain « ) ; » assert That « ( this . » filter Chain « . » get Request « ( ) . » get Parameter Values « ( " » hidden Field « " ) ) . » is Equal To « ( new String [ ] { " » test Hidden « " } ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " " ) ; » assert That « ( » filter And Get Context Path « ( ) ) . » is Equal To « ( " " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / foo / bar / " ) ; » assert That « ( » filter And Get Context Path « ( ) ) . » is Equal To « ( " / foo / bar " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " » / foo / bar / baz /// « " ) ; » assert That « ( » filter And Get Context Path « ( ) ) . » is Equal To « ( " / foo / bar / baz " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / prefix " ) ; this . request . » set Context Path « ( " / mvc - showcase " ) ; String actual = » filter And Get Context Path « ( ) ; » assert That « ( actual ) . » is Equal To « ( " / prefix " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / prefix / " ) ; this . request . » set Context Path « ( " / mvc - showcase " ) ; String actual = » filter And Get Context Path « ( ) ; » assert That « ( actual ) . » is Equal To « ( " / prefix " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / " ) ; this . request . » set Context Path « ( " / app " ) ; this . request . » set Request URI « ( " / app / path " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; » assert That « ( actual . » get Context Path « ( ) ) . » is Equal To « ( " " ) ; » assert That « ( actual . » get Request URI « ( ) ) . » is Equal To « ( " / path " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / " ) ; this . request . » set Context Path « ( " / app " ) ; this . request . » set Request URI « ( " / app / path / " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; » assert That « ( actual . » get Context Path « ( ) ) . » is Equal To « ( " " ) ; » assert That « ( actual . » get Request URI « ( ) ) . » is Equal To « ( " / path / " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / " ) ; this . request . » set Context Path « ( " / app " ) ; this . request . » set Request URI « ( " / app " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; » assert That « ( actual . » get Context Path « ( ) ) . » is Equal To « ( " " ) ; » assert That « ( actual . » get Request URI « ( ) ) . » is Equal To « ( " / " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / " ) ; this . request . » set Context Path « ( " / app " ) ; this . request . » set Request URI « ( " / app / " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; » assert That « ( actual . » get Context Path « ( ) ) . » is Equal To « ( " " ) ; » assert That « ( actual . » get Request URI « ( ) ) . » is Equal To « ( " / " ) ; }
@Test { » test Should Filter « ( " Forwarded " ) ; » test Should Filter « ( » X _ FORWARDED _ HOST « ) ; » test Should Filter « ( » X _ FORWARDED _ PORT « ) ; » test Should Filter « ( » X _ FORWARDED _ PROTO « ) ; » test Should Filter « ( » X _ FORWARDED _ SSL « ) ; }
@Test { » assert That « ( this . filter . » should Not Filter « ( new » Mock Http Servlet Request « ( ) ) ) . » is True « ( ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / prefix " ) ; this . request . » set Request URI « ( " / mvc - showcase " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; » assert That « ( actual . » get Request URL « ( ) . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / prefix / mvc - showcase « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / prefix / " ) ; this . request . » set Request URI « ( " / mvc - showcase " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; » assert That « ( actual . » get Request URL « ( ) . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / prefix / mvc - showcase « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PREFIX « , " / prefix / " ) ; this . request . » set Request URI « ( " / mvc - showcase " ) ; » Http Servlet Request « actual = » filter And Get Wrapped Request « ( ) ; actual . » get Request URL « ( ) . append ( " ? key = value " ) ; » assert That « ( actual . » get Request URL « ( ) . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / prefix / mvc - showcase « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; String » redirected Url « = » send Redirect « ( " / foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " https : » // example . com / foo / bar « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; this . request . » set Context Path « ( " / context " ) ; String » redirected Url « = » send Redirect « ( " / context / foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " https : » // example . com / context / foo / bar « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; this . request . » set Request URI « ( " / parent / " ) ; String » redirected Url « = » send Redirect « ( " foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " https : » // example . com / parent / foo / bar « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; this . request . » set Request URI « ( " / context / a " ) ; String » redirected Url « = » send Redirect « ( " foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " https : » // example . com / context / foo / bar « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; this . request . » set Request URI « ( " / parent " ) ; String » redirected Url « = » send Redirect « ( " foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " https : » // example . com / foo / bar « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; String » redirected Url « = » send Redirect « ( " parent / . . / foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " https : » // example . com / foo / bar « " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; String location = " http : » // company . example / foo / bar « " ; String » redirected Url « = » send Redirect « ( location ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( location ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; String location = " » // other . info / foo / bar « " ; String » redirected Url « = » send Redirect « ( location ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( ( " https : " + location ) ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; String location = " » // other . info / parent / « .. » / foo / bar « " ; String » redirected Url « = » send Redirect « ( location ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( ( " https : " + location ) ) ; }
@Test { String » redirected Url « = » send Redirect « ( " / foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " / foo / bar " ) ; }
@Test { String » redirected Url « = » send Redirect « ( " . . / foo / bar " ) ; » assert That « ( » redirected Url « ) . » is Equal To « ( " . . / foo / bar " ) ; }
@Test { this . request . » add Header « ( » X _ FORWARDED _ PROTO « , " https " ) ; this . request . » add Header « ( » X _ FORWARDED _ HOST « , " example . com " ) ; this . request . » add Header « ( » X _ FORWARDED _ PORT « , " 443 " ) ; this . filter . » set Relative Redirects « ( true ) ; String location = » send Redirect « ( " / a " ) ; » assert That « ( location ) . » is Equal To « ( " / a " ) ; }
@Test { this . filter . » set Relative Redirects « ( true ) ; String location = » send Redirect « ( " / a " ) ; » assert That « ( location ) . » is Equal To « ( " / a " ) ; }
@Test { » init Error Dispatch « ( ) ; this . filter . » do Filter « ( this . request , new » Mock Http Servlet Response « ( ) , this . » filter Chain « ) ; » assert That « ( this . filter . » did Filter « ) . » is False « ( ) ; » assert That « ( this . filter . » did Filter Nested Error Dispatch « ) . » is False « ( ) ; }
@Test { » init Error Dispatch « ( ) ; this . request . » set Attribute « ( this . filter . » get Already Filtered Attribute Name « ( ) , Boolean . TRUE ) ; this . filter . » do Filter « ( this . request , new » Mock Http Servlet Response « ( ) , this . » filter Chain « ) ; » assert That « ( this . filter . » did Filter « ) . » is False « ( ) ; » assert That « ( this . filter . » did Filter Nested Error Dispatch « ) . » is False « ( ) ; }
@Test { this . filter . » set Should Not Filter Error Dispatch « ( false ) ; this . request . » set Attribute « ( this . filter . » get Already Filtered Attribute Name « ( ) , Boolean . TRUE ) ; » init Error Dispatch « ( ) ; this . filter . » do Filter « ( this . request , new » Mock Http Servlet Response « ( ) , this . » filter Chain « ) ; » assert That « ( this . filter . » did Filter « ) . » is False « ( ) ; » assert That « ( this . filter . » did Filter Nested Error Dispatch « ) . » is True « ( ) ; }
@Test { » post Form « ( " » _ method « = DELETE " ) . block ( Duration . ZERO ) ; » assert That « ( this . » filter Chain « . » get Http Method « ( ) ) . » is Equal To « ( » Http Method « . DELETE ) ; }
@Test { » post Form « ( " » _ method « = TRACE " ) . block ( Duration . ZERO ) ; » assert That « ( this . » filter Chain « . » get Http Method « ( ) ) . » is Equal To « ( » Http Method « . POST ) ; }
@Test { » post Form « ( " " ) . block ( Duration . ZERO ) ; » assert That « ( this . » filter Chain « . » get Http Method « ( ) ) . » is Equal To « ( » Http Method « . POST ) ; }
@Test { » post Form « ( " » _ method « = " ) . block ( Duration . ZERO ) ; » assert That « ( this . » filter Chain « . » get Http Method « ( ) ) . » is Equal To « ( » Http Method « . POST ) ; }
@Test { this . filter . » set Method Param Name « ( " » _ foo « " ) ; » post Form « ( " » _ foo « = DELETE " ) . block ( Duration . ZERO ) ; » assert That « ( this . » filter Chain « . » get Http Method « ( ) ) . » is Equal To « ( » Http Method « . DELETE ) ; }
@Test { » Step Verifier « . create ( » post Form « ( " » _ method « = INVALID " ) ) . » consume Error With « ( error -> { » assert That « ( error ) . » is Instance Of « ( » Illegal Argument Exception « . class ) ; » assert That « ( error . » get Message « ( ) ) . » is Equal To « ( " » Http Method « 'INVALID' not supported " ) ; } ) . verify ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . put ( " / " ) . header ( » Http Headers « . » CONTENT _ TYPE « , » Media Type « . » APPLICATION _ FORM _ URLENCODED _ VALUE « ) . body ( " » _ method « = DELETE " ) ) ; this . filter . filter ( exchange , this . » filter Chain « ) . block ( Duration . ZERO ) ; » assert That « ( this . » filter Chain « . » get Http Method « ( ) ) . » is Equal To « ( » Http Method « . PUT ) ; }
@Test { » My Service « service = new » My Service « ( ) ; » Http Handler « » http Handler « = » Web Http Handler Builder « . » web Handler « ( exchange -> service . service ( ) . then ( ) ) . filter ( new » Server Web Exchange Context Filter « ( ) ) . build ( ) ; » http Handler « . handle ( » Mock Server Http Request « . get ( " / path " ) . build ( ) , new » Mock Server Http Response « ( ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( service . » get Exchange « ( ) ) . » is Not Null « ( ) ; }
@Test { » Test Navigation Handler « » target Handler « = new » Test Navigation Handler « ( ) ; » bean Factory « . » add Bean « ( " » jsf Navigation Handler « " , » target Handler « ) ; » del Nav Handler « . » handle Navigation « ( » faces Context « , " » from Action « " , " » my View Id « " ) ; » assert That « ( » target Handler « . » last From Action « ) . » is Equal To « ( " » from Action « " ) ; » assert That « ( » target Handler « . » last Outcome « ) . » is Equal To « ( " » my View Id « " ) ; }
@Test { Predicate < Class < ? > > predicate = » Handler Type Predicate « . » for Annotation « ( Controller . class ) ; » assert That « ( predicate . test ( » Html Controller « . class ) ) . » is True « ( ) ; » assert That « ( predicate . test ( » Api Controller « . class ) ) . » is True « ( ) ; » assert That « ( predicate . test ( » Another Api Controller « . class ) ) . » is True « ( ) ; }
@Test { Predicate < Class < ? > > predicate = » Handler Type Predicate « . » for Annotation « ( Controller . class ) . and ( » Handler Type Predicate « . » for Assignable Type « ( Special . class ) ) ; » assert That « ( predicate . test ( » Html Controller « . class ) ) . » is False « ( ) ; » assert That « ( predicate . test ( » Api Controller « . class ) ) . » is False « ( ) ; » assert That « ( predicate . test ( » Another Api Controller « . class ) ) . » is True « ( ) ; }
@Test { String » bean Name « = " » my Bean « " ; » Bean Factory « » bean Factory « = mock ( » Bean Factory « . class ) ; given ( » bean Factory « . » contains Bean « ( » bean Name « ) ) . » will Return « ( true ) ; » Controller Advice Bean « » bean 1 « = new » Controller Advice Bean « ( » bean Name « , » bean Factory « ) ; » Controller Advice Bean « » bean 2 « = new » Controller Advice Bean « ( » bean Name « , » bean Factory « ) ; » assert Equals Hash Code And To String « ( » bean 1 « , » bean 2 « , » bean Name « ) ; }
@Test { String » to String « = " » bean Instance « " ; Object » bean Instance « = new Object ( ) { @ Override public String » to String « ( ) { return » to String « ; } } ; » Controller Advice Bean « » bean 1 « = new » Controller Advice Bean « ( » bean Instance « ) ; » Controller Advice Bean « » bean 2 « = new » Controller Advice Bean « ( » bean Instance « ) ; » assert Equals Hash Code And To String « ( » bean 1 « , » bean 2 « , » to String « ) ; }
@Test { » assert Order « ( » Simple Controller Advice « . class , Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { » assert Order « ( new » Simple Controller Advice « ( ) , Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { » assert Order « ( » Ordered Controller Advice « . class , 42 ) ; }
@Test { » assert Order « ( new » Ordered Controller Advice « ( ) , 42 ) ; }
@Test { » assert Order « ( » Order Annotation Controller Advice « . class , 100 ) ; » assert Order « ( » Priority Annotation Controller Advice « . class , 200 ) ; }
@Test { » assert Order « ( new » Order Annotation Controller Advice « ( ) , 100 ) ; » assert Order « ( new » Priority Annotation Controller Advice « ( ) , 200 ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Simple Controller Advice « ( ) ) ; » assert Applicable « ( " should match all " , bean , » Annotated Controller « . class ) ; » assert Applicable « ( " should match all " , bean , » Implementation Controller « . class ) ; » assert Applicable « ( " should match all " , bean , » Inheritance Controller « . class ) ; » assert Applicable « ( " should match all " , bean , String . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Base Package Support « ( ) ) ; » assert Applicable « ( " base package support " , bean , » Annotated Controller « . class ) ; » assert Applicable « ( " base package support " , bean , » Implementation Controller « . class ) ; » assert Applicable « ( " base package support " , bean , » Inheritance Controller « . class ) ; » assert Not Applicable « ( " bean not in package " , bean , String . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Base Package Value Support « ( ) ) ; » assert Applicable « ( " base package support " , bean , » Annotated Controller « . class ) ; » assert Applicable « ( " base package support " , bean , » Implementation Controller « . class ) ; » assert Applicable « ( " base package support " , bean , » Inheritance Controller « . class ) ; » assert Not Applicable « ( " bean not in package " , bean , String . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Annotation Support « ( ) ) ; » assert Applicable « ( " annotation support " , bean , » Annotated Controller « . class ) ; » assert Not Applicable « ( " this bean is not annotated " , bean , » Inheritance Controller « . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Marker Class Support « ( ) ) ; » assert Applicable « ( " base package class support " , bean , » Annotated Controller « . class ) ; » assert Applicable « ( " base package class support " , bean , » Implementation Controller « . class ) ; » assert Applicable « ( " base package class support " , bean , » Inheritance Controller « . class ) ; » assert Not Applicable « ( " bean not in package " , bean , String . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Should Not Match « ( ) ) ; » assert Not Applicable « ( " should not match " , bean , » Annotated Controller « . class ) ; » assert Not Applicable « ( " should not match " , bean , » Implementation Controller « . class ) ; » assert Not Applicable « ( " should not match " , bean , » Inheritance Controller « . class ) ; » assert Not Applicable « ( " should not match " , bean , String . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Assignable Types Support « ( ) ) ; » assert Applicable « ( " controller implements assignable " , bean , » Implementation Controller « . class ) ; » assert Applicable « ( " controller inherits assignable " , bean , » Inheritance Controller « . class ) ; » assert Not Applicable « ( " not assignable " , bean , » Annotated Controller « . class ) ; » assert Not Applicable « ( " not assignable " , bean , String . class ) ; }
@Test { » Controller Advice Bean « bean = new » Controller Advice Bean « ( new » Multiple Selectors Support « ( ) ) ; » assert Applicable « ( " controller implements assignable " , bean , » Implementation Controller « . class ) ; » assert Applicable « ( " controller is annotated " , bean , » Annotated Controller « . class ) ; » assert Not Applicable « ( " should not match " , bean , » Inheritance Controller « . class ) ; }
@Test { Class [ ] » expected Types « = { » Ordered Controller Advice « . class , » Priority Ordered Controller Advice « . class , » Order Annotation Controller Advice « . class , » Priority Annotation Controller Advice « . class , » Simple Controller Advice « . class } ; » Annotation Config Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; List < » Controller Advice Bean « > » advice Beans « = » Controller Advice Bean « . » find Annotated Beans « ( context ) ; » assert That « ( » advice Beans « ) . extracting ( » Controller Advice Bean « :: » get Bean Type « ) . » contains Exactly « ( » expected Types « ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( » param Named Cookie « ) ) . as ( " Cookie parameter not supported " ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Named Default Value String « ) ) . as ( " Cookie string parameter not supported " ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param String « ) ) . as ( " non - @ » Cookie Value « parameter supported " ) . » is False « ( ) ; }
@Test { Object result = resolver . » resolve Argument « ( » param Named Default Value String « , null , » web Request « , null ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( " bar " ) ; }
@Test { » assert That Exception Of Type « ( » Servlet Request Binding Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Named Cookie « , null , » web Request « , null ) ) ; }
@Test { » Web Data Binder Factory « factory = » create Factory « ( " » init Binder « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = factory . » create Binder « ( this . » web Request « , null , null ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Not Null « ( ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) [ 0 ] ) . » is Equal To « ( " id " ) ; }
@Test { » Conversion Service « » conversion Service « = new » Default Formatting Conversion Service « ( ) ; » binding Initializer « . » set Conversion Service « ( » conversion Service « ) ; » Web Data Binder Factory « factory = » create Factory « ( " » init Binder « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = factory . » create Binder « ( this . » web Request « , null , null ) ; » assert That « ( » data Binder « . » get Conversion Service « ( ) ) . » is Same As « ( » conversion Service « ) ; }
@Test { » Web Data Binder Factory « factory = » create Factory « ( " » init Binder With Attribute Name « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = factory . » create Binder « ( this . » web Request « , null , " foo " ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Not Null « ( ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) [ 0 ] ) . » is Equal To « ( " id " ) ; }
@Test { » Web Data Binder Factory « factory = » create Factory « ( " » init Binder With Attribute Name « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = factory . » create Binder « ( this . » web Request « , null , " » invalid Name « " ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Null « ( ) ; }
@Test { » Web Data Binder Factory « factory = » create Factory « ( " » init Binder With Attribute Name « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = factory . » create Binder « ( this . » web Request « , null , null ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Null « ( ) ; }
@Test { » Web Data Binder Factory « factory = » create Factory « ( " » init Binder Return Value « " , » Web Data Binder « . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> factory . » create Binder « ( this . » web Request « , null , " » invalid Name « " ) ) ; }
@Test { » assert That « ( this . processor . » supports Parameter « ( this . resolvable . » annot Not Present « ( ) . arg ( Map . class , String . class , Object . class ) ) ) . » is True « ( ) ; » assert That « ( this . processor . » supports Parameter « ( this . resolvable . » annot Present « ( » Request Body « . class ) . arg ( Map . class , String . class , Object . class ) ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . processor . » supports Return Type « ( this . resolvable . » return Type « ( ) ) ) . » is True « ( ) ; }
@Test { » Method Parameter « param = this . resolvable . » annot Not Present « ( ) . arg ( Map . class , String . class , Object . class ) ; » assert That « ( this . processor . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ) . » is Same As « ( this . » mav Container « . » get Model « ( ) ) ; }
@Test { » run Test « ( new » Tree Dependency Controller « ( ) ) ; » assert Invoked Before « ( " » get A « " , " » get B 1 « " , " » get B 2 « " , " » get C 1 « " , " » get C 2 « " , " » get C 3 « " , " » get C 4 « " ) ; » assert Invoked Before « ( " » get B 1 « " , " » get C 1 « " , " » get C 2 « " ) ; » assert Invoked Before « ( " » get B 2 « " , " » get C 3 « " , " » get C 4 « " ) ; }
@Test { » run Test « ( new » Unresolved Dependency Controller « ( ) ) ; » assert Invoked Before « ( " » get A « " , " » get C 1 « " , " » get C 2 « " , " » get C 3 « " , " » get C 4 « " ) ; }
@Test { » assert That « ( processor . » supports Parameter « ( » param Model « ) ) . » is True « ( ) ; }
@Test { » assert That « ( processor . » supports Return Type « ( » return Param Model « ) ) . » is True « ( ) ; }
@Test { » assert That « ( processor . » resolve Argument « ( » param Model « , » mav Container « , » web Request « , null ) ) . » is Same As « ( » mav Container « . » get Model « ( ) ) ; }
@Test { resolver . » supports Parameter « ( » param Errors « ) ; }
@Test { » Model And View Container « » mav Container « = new » Model And View Container « ( ) ; » mav Container « . » add All Attributes « ( » binding Result « . » get Model « ( ) ) ; » mav Container « . » add Attribute « ( " » ignore 1 « " , " » value 1 « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Errors « , » mav Container « , » web Request « , null ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Errors « , new » Model And View Container « ( ) , » web Request « , null ) ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( » param System Property « ) ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Context Path « ) ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Not Supported « ) ) . » is False « ( ) ; }
@Test { System . » set Property « ( " » system Property « " , " 22 " ) ; Object value = resolver . » resolve Argument « ( » param System Property « , null , » web Request « , null ) ; System . » clear Property « ( " » system Property « " ) ; » assert That « ( value ) . » is Equal To « ( " 22 " ) ; }
@Test { » web Request « . » get Native Request « ( » Mock Http Servlet Request « . class ) . » set Context Path « ( " / » context Path « " ) ; Object value = resolver . » resolve Argument « ( » param Context Path « , null , » web Request « , null ) ; » assert That « ( value ) . » is Equal To « ( " / » context Path « " ) ; }
@Test { » Model Factory « » model Factory « = » create Model Factory « ( " » model Attr « " , Model . class ) ; » Handler Method « » handler Method « = » create Handler Method « ( " handle " ) ; » model Factory « . » init Model « ( this . » web Request « , this . » mav Container « , » handler Method « ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " » model Attr « " ) ) . » is Equal To « ( Boolean . TRUE ) ; }
@Test { » Model Factory « » model Factory « = » create Model Factory « ( " » model Attr With Name « " ) ; » Handler Method « » handler Method « = » create Handler Method « ( " handle " ) ; » model Factory « . » init Model « ( this . » web Request « , this . » mav Container « , » handler Method « ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " name " ) ) . » is Equal To « ( Boolean . TRUE ) ; }
@Test { » Model Factory « » model Factory « = » create Model Factory « ( " » model Attr Convention « " ) ; » Handler Method « » handler Method « = » create Handler Method « ( " handle " ) ; » model Factory « . » init Model « ( this . » web Request « , this . » mav Container « , » handler Method « ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " boolean " ) ) . » is Equal To « ( Boolean . TRUE ) ; }
@Test { » Model Factory « » model Factory « = » create Model Factory « ( " » null Model Attr « " ) ; » Handler Method « » handler Method « = » create Handler Method « ( " handle " ) ; » model Factory « . » init Model « ( this . » web Request « , this . » mav Container « , » handler Method « ) ; » assert That « ( this . » mav Container « . » contains Attribute « ( " name " ) ) . » is True « ( ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " name " ) ) . » is Null « ( ) ; }
@Test { » Model Factory « » model Factory « = » create Model Factory « ( " » model Attr With Binding Disabled « " ) ; » Handler Method « » handler Method « = » create Handler Method « ( " handle " ) ; » model Factory « . » init Model « ( this . » web Request « , this . » mav Container « , » handler Method « ) ; » assert That « ( this . » mav Container « . » contains Attribute « ( " foo " ) ) . » is True « ( ) ; » assert That « ( this . » mav Container « . » is Binding Disabled « ( " foo " ) ) . » is True « ( ) ; }
@Test { String name = " foo " ; String value = " bar " ; Map < String , String > expected = Collections . » singleton Map « ( name , value ) ; request . » add Header « ( name , value ) ; Object result = resolver . » resolve Argument « ( » param Map « , null , » web Request « , null ) ; boolean condition = result instanceof Map ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( expected ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Return « ( 42 ) ; » assert That « ( adapter . » supports Parameter « ( parameter ) ) . as ( " Parameter not supported " ) . » is True « ( ) ; verify ( adaptee ) . » resolve Argument « ( parameter , » web Request « ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Return « ( » Web Argument Resolver « . UNRESOLVED ) ; » assert That « ( adapter . » supports Parameter « ( parameter ) ) . as ( " Parameter supported " ) . » is False « ( ) ; verify ( adaptee ) . » resolve Argument « ( parameter , » web Request « ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Return « ( " Foo " ) ; » assert That « ( adapter . » supports Parameter « ( parameter ) ) . as ( " Parameter supported " ) . » is False « ( ) ; verify ( adaptee ) . » resolve Argument « ( parameter , » web Request « ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Throw « ( new Exception ( ) ) ; » assert That « ( adapter . » supports Parameter « ( parameter ) ) . as ( " Parameter supported " ) . » is False « ( ) ; verify ( adaptee ) . » resolve Argument « ( parameter , » web Request « ) ; }
@Test { int expected = 42 ; given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Return « ( expected ) ; Object result = adapter . » resolve Argument « ( parameter , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( expected ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Return « ( » Web Argument Resolver « . UNRESOLVED ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> adapter . » resolve Argument « ( parameter , null , » web Request « , null ) ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Return « ( " Foo " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> adapter . » resolve Argument « ( parameter , null , » web Request « , null ) ) ; }
@Test { given ( adaptee . » resolve Argument « ( parameter , » web Request « ) ) . » will Throw « ( new Exception ( ) ) ; » assert That Exception Of Type « ( Exception . class ) . » is Thrown By « ( ( ) -> adapter . » resolve Argument « ( parameter , null , » web Request « , null ) ) ; }
@Test { processor = new » Model Attribute Method Processor « ( false ) ; » assert That « ( this . processor . » supports Return Type « ( » return Param Named Model Attr « ) ) . » is True « ( ) ; » assert That « ( this . processor . » supports Return Type « ( » return Param Non Simple Type « ) ) . » is False « ( ) ; }
@Test { processor = new » Model Attribute Method Processor « ( true ) ; » assert That « ( this . processor . » supports Return Type « ( » return Param Named Model Attr « ) ) . » is True « ( ) ; » assert That « ( this . processor . » supports Return Type « ( » return Param Non Simple Type « ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . processor . » is Bind Exception Required « ( null , this . » param Non Simple Type « ) ) . » is True « ( ) ; » assert That « ( this . processor . » is Bind Exception Required « ( null , this . » param Named Valid Model Attr « ) ) . » is False « ( ) ; }
@Test { » test Get Attribute From Model « ( " » attr Name « " , this . » param Named Valid Model Attr « ) ; » test Get Attribute From Model « ( " » test Bean « " , this . » param Model Attr « ) ; » test Get Attribute From Model « ( " » test Bean « " , this . » param Non Simple Type « ) ; }
@Test { » Web Data Binder « » data Binder « = new » Web Request Data Binder « ( null ) ; » Web Data Binder Factory « factory = mock ( » Web Data Binder Factory « . class ) ; given ( factory . » create Binder « ( any ( ) , » not Null « ( ) , eq ( " » attr Name « " ) ) ) . » will Return « ( » data Binder « ) ; this . processor . » resolve Argument « ( this . » param Named Valid Model Attr « , this . container , this . request , factory ) ; verify ( factory ) . » create Binder « ( any ( ) , » not Null « ( ) , eq ( " » attr Name « " ) ) ; }
@Test { this . processor . » handle Return Value « ( " expected " , this . » return Param Named Model Attr « , this . container , this . request ) ; » assert That « ( this . container . » get Model « ( ) . get ( " » model Attr Name « " ) ) . » is Equal To « ( " expected " ) ; }
@Test { » Test Bean « » test Bean « = new » Test Bean « ( " expected " ) ; this . processor . » handle Return Value « ( » test Bean « , this . » return Param Non Simple Type « , this . container , this . request ) ; » assert That « ( this . container . » get Model « ( ) . get ( " » test Bean « " ) ) . » is Same As « ( » test Bean « ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( » param Named Default Value String Header « ) ) . as ( " String parameter not supported " ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Named Value String Array « ) ) . as ( " String array parameter not supported " ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Named Value Map « ) ) . as ( " non - @ » Request Param « parameter supported " ) . » is False « ( ) ; }
@Test { String expected = " foo " ; » servlet Request « . » add Header « ( " name " , expected ) ; Object result = resolver . » resolve Argument « ( » param Named Default Value String Header « , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( expected ) ; }
@Test { String [ ] expected = new String [ ] { " foo " , " bar " } ; » servlet Request « . » add Header « ( " name " , expected ) ; Object result = resolver . » resolve Argument « ( » param Named Value String Array « , null , » web Request « , null ) ; » assert That « ( result ) . » is Instance Of « ( String [ ] . class ) ; » assert That « ( result ) . » is Equal To « ( expected ) ; }
@Test { Object result = resolver . » resolve Argument « ( » param Named Default Value String Header « , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { System . » set Property « ( " » system Property « " , " bar " ) ; try { Object result = resolver . » resolve Argument « ( » param System Property « , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { String expected = " foo " ; » servlet Request « . » add Header « ( " bar " , expected ) ; System . » set Property « ( " » system Property « " , " bar " ) ; try { Object result = resolver . » resolve Argument « ( » param Resolved Name With Expression « , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( expected ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { String expected = " foo " ; » servlet Request « . » add Header « ( " bar " , expected ) ; System . » set Property « ( " » system Property « " , " bar " ) ; try { Object result = resolver . » resolve Argument « ( » param Resolved Name With Placeholder « , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( expected ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { » servlet Request « . » set Context Path « ( " / bar " ) ; Object result = resolver . » resolve Argument « ( » param Context Path « , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( " / bar " ) ; }
@Test { » assert That Exception Of Type « ( » Servlet Request Binding Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Named Value String Array « , null , » web Request « , null ) ) ; }
@Test { UUID uuid = UUID . » random UUID « ( ) ; » servlet Request « . » add Header « ( " name " , uuid . » to String « ( ) ) ; » Configurable Web Binding Initializer « » binding Initializer « = new » Configurable Web Binding Initializer « ( ) ; » binding Initializer « . » set Conversion Service « ( new » Default Formatting Conversion Service « ( ) ) ; Object result = resolver . » resolve Argument « ( » param Uuid « , null , » web Request « , new » Default Data Binder Factory « ( » binding Initializer « ) ) ; » assert That « ( result ) . » is Equal To « ( uuid ) ; }
@Test { » servlet Request « . » add Header « ( " name " , " bogus - uuid " ) ; » Configurable Web Binding Initializer « » binding Initializer « = new » Configurable Web Binding Initializer « ( ) ; » binding Initializer « . » set Conversion Service « ( new » Default Formatting Conversion Service « ( ) ) ; » assert That Exception Of Type « ( » Method Argument Type Mismatch Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Uuid « , null , » web Request « , new » Default Data Binder Factory « ( » binding Initializer « ) ) ) ; }
@Test { » uuid Conversion With Empty Or Blank Value « ( " " ) ; }
@Test { » Exception Handler Method Resolver « resolver = new » Exception Handler Method Resolver « ( » Exception Controller « . class ) ; » IO Exception « exception = new » IO Exception « ( ) ; » assert That « ( resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle IO Exception « " ) ; }
@Test { » Exception Handler Method Resolver « resolver = new » Exception Handler Method Resolver « ( » Exception Controller « . class ) ; » Illegal Argument Exception « exception = new » Illegal Argument Exception « ( ) ; » assert That « ( resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle Illegal Argument Exception « " ) ; }
@Test { » Exception Handler Method Resolver « resolver = new » Exception Handler Method Resolver « ( » Exception Controller « . class ) ; » IO Exception « » io Exception « = new » File Not Found Exception « ( ) ; » assert That « ( resolver . » resolve Method « ( » io Exception « ) . » get Name « ( ) ) . » is Equal To « ( " » handle IO Exception « " ) ; » Socket Exception « » bind Exception « = new » Bind Exception « ( ) ; » assert That « ( resolver . » resolve Method « ( » bind Exception « ) . » get Name « ( ) ) . » is Equal To « ( " » handle Socket Exception « " ) ; }
@Test { » Exception Handler Method Resolver « resolver = new » Exception Handler Method Resolver « ( » Exception Controller « . class ) ; » Socket Exception « exception = new » Socket Exception « ( ) ; » assert That « ( resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle Socket Exception « " ) ; }
@Test { » Exception Handler Method Resolver « resolver = new » Exception Handler Method Resolver « ( » Exception Controller « . class ) ; Exception exception = new Exception ( ) ; » assert That « ( resolver . » resolve Method « ( exception ) ) . as ( " 1 st lookup " ) . » is Null « ( ) ; » assert That « ( resolver . » resolve Method « ( exception ) ) . as ( " 2 nd lookup from cache " ) . » is Null « ( ) ; }
@Test { » Exception Handler Method Resolver « resolver = new » Exception Handler Method Resolver « ( » Inherited Controller « . class ) ; » IO Exception « exception = new » IO Exception « ( ) ; » assert That « ( resolver . » resolve Method « ( exception ) . » get Name « ( ) ) . » is Equal To « ( " » handle IO Exception « " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Exception Handler Method Resolver « ( » Ambiguous Controller « . class ) ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> new » Exception Handler Method Resolver « ( » No Exception Controller « . class ) ) ; }
@Test { String expected = " foo " ; request . » add Parameter « ( " name " , expected ) ; » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( " bar " ) ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( expected ) ; }
@Test { String [ ] expected = new String [ ] { " foo " , " bar " } ; request . » add Parameter « ( " name " , expected ) ; » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( String [ ] . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; boolean condition = result instanceof String [ ] ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( String [ ] ) result ) . as ( " Invalid result " ) . » is Equal To « ( expected ) ; }
@Test { » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( » Multipart File « . class ) ; » assert That Exception Of Type « ( » Multipart Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( param , null , » web Request « , null ) ) ; }
@Test { request . » set Method « ( " POST " ) ; » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( » Multipart File « . class ) ; » assert That Exception Of Type « ( » Multipart Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( param , null , » web Request « , null ) ) ; }
@Test { request . » set Method « ( " POST " ) ; request . » set Content Type « ( " multipart / form - data " ) ; » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( » Multipart File « . class ) ; » assert That Exception Of Type « ( » Missing Servlet Request Part Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( param , null , » web Request « , null ) ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( " bar " ) ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( " bar " ) ; }
@Test { » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( String [ ] . class ) ; » assert That Exception Of Type « ( » Missing Servlet Request Parameter Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( param , null , » web Request « , null ) ) ; }
@Test { request . » set Parameter « ( " » string Not Annot « " , " » plain Value « " ) ; » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( " » plain Value « " ) ; }
@Test { » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { request . » add Parameter « ( " name " , " " ) ; » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( " bar " ) ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { request . » add Parameter « ( " » string Not Annot « " , " " ) ; » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( " " ) ; }
@Test { request . » add Parameter « ( " name " , " " ) ; » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( ) ) . arg ( String . class ) ; Object result = resolver . » resolve Argument « ( param , null , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( " " ) ; }
@Test { » Configurable Web Binding Initializer « initializer = new » Configurable Web Binding Initializer « ( ) ; initializer . » set Conversion Service « ( new » Default Conversion Service « ( ) ) ; » Web Data Binder Factory « » binder Factory « = new » Default Data Binder Factory « ( initializer ) ; » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( Optional . class , » Multipart File « . class ) ; Object actual = resolver . » resolve Argument « ( param , null , » web Request « , » binder Factory « ) ; » assert That « ( actual ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { this . » resolver Composite « . » add Resolver « ( new » Stub Argument Resolver « ( Integer . class ) ) ; » assert That « ( this . » resolver Composite « . » supports Parameter « ( » param Int « ) ) . » is True « ( ) ; » assert That « ( this . » resolver Composite « . » supports Parameter « ( » param Str « ) ) . » is False « ( ) ; }
@Test { this . » resolver Composite « . » add Resolver « ( new » Stub Argument Resolver « ( 55 ) ) ; Object » resolved Value « = this . » resolver Composite « . » resolve Argument « ( » param Int « , null , null , null ) ; » assert That « ( » resolved Value « ) . » is Equal To « ( 55 ) ; }
@Test { this . » resolver Composite « . » add Resolver « ( new » Stub Argument Resolver « ( 1 ) ) ; this . » resolver Composite « . » add Resolver « ( new » Stub Argument Resolver « ( 2 ) ) ; Object » resolved Value « = this . » resolver Composite « . » resolve Argument « ( » param Int « , null , null , null ) ; » assert That « ( » resolved Value « ) . as ( " Did » n ' t « use the first registered resolver " ) . » is Equal To « ( 1 ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » resolver Composite « . » resolve Argument « ( » param Str « , null , null , null ) ) ; }
@Test { this . » mav Container « . » add Attribute « ( " name " , " value " ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { this . » mav Container « . » add Attribute « ( " name " , " value " ) ; this . » mav Container « . » set Redirect Model Scenario « ( true ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { this . » mav Container « . » set Ignore Default Model On Redirect « ( true ) ; this . » mav Container « . » add Attribute « ( " name " , " value " ) ; this . » mav Container « . » set Redirect Model Scenario « ( true ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { this . » mav Container « . » set Ignore Default Model On Redirect « ( true ) ; this . » mav Container « . » set Redirect Model Scenario « ( true ) ; this . » mav Container « . » add Attribute « ( " name " , " value " ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . » mav Container « . » get Model « ( ) . get ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » get Invocable « ( Integer . class , String . class ) . » invoke For Request « ( request , null ) ) . » with Message Containing « ( " Could not resolve parameter [ 0 ] " ) ; }
@Test { Object value = » get Invocable « ( Integer . class , String . class ) . » invoke For Request « ( request , null , 99 , " value " ) ; » assert That « ( value ) . » is Not Null « ( ) ; » assert That « ( value . » get Class « ( ) ) . » is Equal To « ( String . class ) ; » assert That « ( value ) . » is Equal To « ( " 99 - value " ) ; }
@Test { this . composite . » add Resolver « ( new » Stub Argument Resolver « ( 1 ) ) ; this . composite . » add Resolver « ( new » Stub Argument Resolver « ( " » value 1 « " ) ) ; Object value = » get Invocable « ( Integer . class , String . class ) . » invoke For Request « ( request , null , 2 , " » value 2 « " ) ; » assert That « ( value ) . » is Equal To « ( " 2 - » value 2 « " ) ; }
@Test { this . composite . » add Resolver « ( new » Exception Raising Argument Resolver « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » get Invocable « ( Integer . class , String . class ) . » invoke For Request « ( request , null ) ) ; }
@Test { this . composite . » add Resolver « ( new » Stub Argument Resolver « ( double . class ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » get Invocable « ( double . class ) . » invoke For Request « ( this . request , null ) ) . » with Message Containing « ( " Illegal argument " ) ; }
@Test { » assert That « ( this . handlers . » supports Return Type « ( this . » integer Type « ) ) . » is True « ( ) ; » assert That « ( this . handlers . » supports Return Type « ( this . » string Type « ) ) . » is False « ( ) ; }
@Test { this . handlers . » handle Return Value « ( 55 , this . » integer Type « , this . » mav Container « , null ) ; verify ( this . » integer Handler « ) . » handle Return Value « ( 55 , this . » integer Type « , this . » mav Container « , null ) ; }
@Test { » Handler Method Return Value Handler « » another Integer Handler « = mock ( » Handler Method Return Value Handler « . class ) ; given ( » another Integer Handler « . » supports Return Type « ( this . » integer Type « ) ) . » will Return « ( true ) ; this . handlers . » handle Return Value « ( 55 , this . » integer Type « , this . » mav Container « , null ) ; verify ( this . » integer Handler « ) . » handle Return Value « ( 55 , this . » integer Type « , this . » mav Container « , null ) ; » verify No More Interactions « ( » another Integer Handler « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . handlers . » handle Return Value « ( " value " , this . » string Type « , null , null ) ) ; }
@Test { » do Test With Application Context « ( false ) ; }
@Test { » do Test With Application Context « ( true ) ; }
@Test { this . » multipart Params « . put ( " key " , new String [ ] { " p " } ) ; this . » query Params « . add ( " key " , " q " ) ; String [ ] values = » create Multipart Request « ( ) . » get Parameter Values « ( " key " ) ; » assert That « ( values ) . » is Equal To « ( new String [ ] { " p " , " q " } ) ; }
@Test { this . » mock Request « . » add File « ( new » Mock Multipart File « ( " part " , " " , " " , " content " . » get Bytes « ( " UTF - 8 " ) ) ) ; » Server Http Request « request = new » Request Part Servlet Server Http Request « ( this . » mock Request « , " part " ) ; this . » mock Request « . » set Method « ( " POST " ) ; » assert That « ( request . » get Method « ( ) ) . » is Equal To « ( » Http Method « . POST ) ; }
@Test { byte [ ] bytes = " content " . » get Bytes « ( " UTF - 8 " ) ; » Multipart File « part = new » Mock Multipart File « ( " part " , " " , " application / json " , bytes ) ; this . » mock Request « . » add File « ( part ) ; » Server Http Request « request = new » Request Part Servlet Server Http Request « ( this . » mock Request « , " part " ) ; byte [ ] result = » File Copy Utils « . » copy To Byte Array « ( request . » get Body « ( ) ) ; » assert That « ( result ) . » is Equal To « ( bytes ) ; }
@Test { String disposition = " form - data ; name = \" file \" ; filename = \" » my File « . txt \" " ; » Standard Multipart Http Servlet Request « request = » request With Part « ( " file " , disposition , " " ) ; » Multipart File « » multipart File « = request . » get File « ( " file " ) ; » assert That « ( » multipart File « ) . » is Not Null « ( ) ; » assert That « ( » multipart File « . » get Original Filename « ( ) ) . » is Equal To « ( " » my File « . txt " ) ; }
@Test { String » expected Value « = " Shumwere , shumhow , a shuck ish washing you . - Drunken Far Side " ; editor . » set Value « ( » expected Value « . » get Bytes « ( ) ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( » expected Value « ) ; }
@Test { String » expected Value « = " 'Green Wing' - classic British comedy " ; editor . » set Value « ( » expected Value « ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( » expected Value « ) ; }
@Test { final String » expected Value « = " 'Green Wing' - classic British comedy " ; Object object = new Object ( ) { @ Override public String » to String « ( ) { return » expected Value « ; } } ; editor . » set Value « ( object ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( » expected Value « ) ; }
@Test { editor . » set Value « ( null ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( " " ) ; }
@Test { String » expected Value « = " That is comforting to know " ; » Multipart File « file = mock ( » Multipart File « . class ) ; given ( file . » get Bytes « ( ) ) . » will Return « ( » expected Value « . » get Bytes « ( ) ) ; editor . » set Value « ( file ) ; » assert That « ( editor . » get As Text « ( ) ) . » is Equal To « ( » expected Value « ) ; }
@Test { » Multipart File « file = mock ( » Multipart File « . class ) ; given ( file . » get Bytes « ( ) ) . » will Throw « ( new » IO Exception « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> editor . » set Value « ( file ) ) ; }
@Test { String » e Tag « = " \" etagvalue \" " ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . » if None Match « ( " missingquotes " ) ) ; » assert That « ( exchange . » check Not Modified « ( » e Tag « ) ) . » is False « ( ) ; » assert That « ( exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Null « ( ) ; » assert That « ( exchange . » get Response « ( ) . » get Headers « ( ) . » get E Tag « ( ) ) . » is Equal To « ( » e Tag « ) ; }
@Test { String » e Tag « = " \" Foo \" " ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . » if None Match « ( " * " ) ) ; » assert That « ( exchange . » check Not Modified « ( » e Tag « ) ) . » is False « ( ) ; » assert That « ( exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Null « ( ) ; » assert That « ( exchange . » get Response « ( ) . » get Headers « ( ) . » get E Tag « ( ) ) . » is Equal To « ( » e Tag « ) ; }
@Test { » Server Web Exchange « exchange = » create Exchange « ( ) ; » assert That « ( exchange . » transform Url « ( " / foo " ) ) . » is Equal To « ( " / foo " ) ; }
@Test { » Server Web Exchange « exchange = » create Exchange « ( ) ; exchange . » add Url Transformer « ( s -> s + " ? nonce = 123 " ) ; » assert That « ( exchange . » transform Url « ( " / foo " ) ) . » is Equal To « ( " / foo ? nonce = 123 " ) ; }
@Test { » Server Web Exchange « exchange = » create Exchange « ( ) ; exchange . » add Url Transformer « ( s -> s + " ; p = abc " ) ; exchange . » add Url Transformer « ( s -> s + " ? q = 123 " ) ; » assert That « ( exchange . » transform Url « ( " / foo " ) ) . » is Equal To « ( " / foo ; p = abc ? q = 123 " ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . register ( » Forwarded Header Filter Config « . class ) ; context . refresh ( ) ; » Web Http Handler Builder « builder = » Web Http Handler Builder « . » application Context « ( context ) ; builder . filters ( filters -> » assert That « ( filters ) . » is Equal To « ( Collections . » empty List « ( ) ) ) ; » assert That « ( builder . » has Forwarded Header Transformer « ( ) ) . » is True « ( ) ; }
@Test { » Annotation Config Application Context « context = new » Annotation Config Application Context « ( ) ; context . register ( » No Filter Config « . class ) ; context . refresh ( ) ; » Web Http Handler Builder « builder = » Web Http Handler Builder « . » application Context « ( context ) ; » assert That « ( ( ( » Http Web Handler Adapter « ) builder . build ( ) ) . » get Application Context « ( ) ) . » is Same As « ( context ) ; » assert That « ( ( ( » Http Web Handler Adapter « ) builder . clone ( ) . build ( ) ) . » get Application Context « ( ) ) . » is Same As « ( context ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . add ( " Forwarded " , " host = 84.198 .58 .199 ; proto = https " ) ; » Server Http Request « request = this . » request Mutator « . apply ( » get Request « ( headers ) ) ; » assert That « ( request . » get URI « ( ) ) . » is Equal To « ( new URI ( " https : » // 84 . 198 . 58 . 199 / path « " ) ) ; » assert Forwarded Headers Removed « ( request ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . add ( " X - Forwarded - Prefix " , " / prefix " ) ; » Server Http Request « request = this . » request Mutator « . apply ( » get Request « ( headers ) ) ; » assert That « ( request . » get URI « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / prefix / path « " ) ) ; » assert That « ( request . » get Path « ( ) . value ( ) ) . » is Equal To « ( " / prefix / path " ) ; » assert Forwarded Headers Removed « ( request ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . add ( " X - Forwarded - Prefix " , " » / prefix //// « " ) ; » Server Http Request « request = this . » request Mutator « . apply ( » get Request « ( headers ) ) ; » assert That « ( request . » get URI « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / prefix / path « " ) ) ; » assert That « ( request . » get Path « ( ) . value ( ) ) . » is Equal To « ( " / prefix / path " ) ; » assert Forwarded Headers Removed « ( request ) ; }
@Test { » create Web Handler « ( new » Bad Request Exception Handler « ( ) ) . handle ( this . exchange ) . block ( ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « ) ; }
@Test { » create Web Handler « ( new » Unresolved Exception Handler « ( ) , new » Unresolved Exception Handler « ( ) , new » Bad Request Exception Handler « ( ) , new » Unresolved Exception Handler « ( ) ) . handle ( this . exchange ) . block ( ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « ) ; }
@Test { Mono < Void > mono = » create Web Handler « ( new » Unresolved Exception Handler « ( ) ) . handle ( this . exchange ) ; » Step Verifier « . create ( mono ) . » expect Error Message « ( " boo " ) . verify ( ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Null « ( ) ; }
@Test { new » Http Web Handler Adapter « ( » create Web Handler « ( new » Unresolved Exception Handler « ( ) ) ) . handle ( this . exchange . » get Request « ( ) , this . exchange . » get Response « ( ) ) . block ( ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » INTERNAL _ SERVER _ ERROR « ) ; }
@Test { » Stub Web Handler « » target Handler « = new » Stub Web Handler « ( ) ; new » Filtering Web Handler « ( » target Handler « , Collections . » empty List « ( ) ) . handle ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) . block ( Duration . ZERO ) ; » assert That « ( » target Handler « . invoked ( ) ) . » is True « ( ) ; }
@Test { » Async Filter « filter = new » Async Filter « ( ) ; » Stub Web Handler « » target Handler « = new » Stub Web Handler « ( ) ; new » Filtering Web Handler « ( » target Handler « , Collections . » singleton List « ( filter ) ) . handle ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( filter . invoked ( ) ) . » is True « ( ) ; » assert That « ( » target Handler « . invoked ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( CANADA ) ) . » get Locale « ( ) ) . » is Equal To « ( CANADA ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( US , CANADA ) ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; }
@Test { this . resolver . » set Supported Locales « ( Collections . » singleton List « ( CANADA ) ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( US , CANADA ) ) . » get Locale « ( ) ) . » is Equal To « ( CANADA ) ; }
@Test { this . resolver . » set Supported Locales « ( Collections . » singleton List « ( CANADA ) ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( US , UK ) ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; }
@Test { this . resolver . » set Supported Locales « ( Arrays . » as List « ( US , JAPAN ) ) ; this . resolver . » set Default Locale « ( JAPAN ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( KOREA ) ) . » get Locale « ( ) ) . » is Equal To « ( JAPAN ) ; }
@Test { this . resolver . » set Supported Locales « ( Collections . » singleton List « ( ENGLISH ) ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( GERMANY , US , UK ) ) . » get Locale « ( ) ) . » is Equal To « ( ENGLISH ) ; }
@Test { this . resolver . » set Supported Locales « ( Arrays . » as List « ( ENGLISH , UK ) ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( GERMANY , US , UK ) ) . » get Locale « ( ) ) . » is Equal To « ( UK ) ; }
@Test { this . resolver . » set Supported Locales « ( Arrays . » as List « ( GERMAN , US ) ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ( GERMANY , US , UK ) ) . » get Locale « ( ) ) . » is Equal To « ( GERMAN ) ; }
@Test { » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / " ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ) . » get Locale « ( ) ) . » is Null « ( ) ; }
@Test { this . resolver . » set Default Locale « ( US ) ; » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / " ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; }
@Test { » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / " ) . header ( » Http Headers « . » ACCEPT _ LANGUAGE « , " " ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ) . » get Locale « ( ) ) . » is Null « ( ) ; }
@Test { this . resolver . » set Default Locale « ( US ) ; » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / " ) . header ( » Http Headers « . » ACCEPT _ LANGUAGE « , " " ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; }
@Test { » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / " ) . header ( » Http Headers « . » ACCEPT _ LANGUAGE « , " » en _ US « " ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ) . » get Locale « ( ) ) . » is Null « ( ) ; }
@Test { this . resolver . » set Default Locale « ( US ) ; » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / " ) . header ( » Http Headers « . » ACCEPT _ LANGUAGE « , " » en _ US « " ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » assert That « ( this . resolver . » resolve Locale Context « ( exchange ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; }
@Test { » Fixed Locale Context Resolver « resolver = new » Fixed Locale Context Resolver « ( ) ; » assert That « ( resolver . » resolve Locale Context « ( exchange ( ) ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; » assert That « ( resolver . » resolve Locale Context « ( exchange ( CANADA ) ) . » get Locale « ( ) ) . » is Equal To « ( US ) ; }
@Test { » Fixed Locale Context Resolver « resolver = new » Fixed Locale Context Resolver « ( FRANCE ) ; » assert That « ( resolver . » resolve Locale Context « ( exchange ( ) ) . » get Locale « ( ) ) . » is Equal To « ( FRANCE ) ; » assert That « ( resolver . » resolve Locale Context « ( exchange ( CANADA ) ) . » get Locale « ( ) ) . » is Equal To « ( FRANCE ) ; }
@Test { » Time Zone « » time Zone « = » Time Zone « . » get Time Zone « ( » Zone Id « . of ( " UTC " ) ) ; » Fixed Locale Context Resolver « resolver = new » Fixed Locale Context Resolver « ( FRANCE , » time Zone « ) ; » Time Zone Aware Locale Context « context = ( » Time Zone Aware Locale Context « ) resolver . » resolve Locale Context « ( exchange ( ) ) ; » assert That « ( context . » get Locale « ( ) ) . » is Equal To « ( FRANCE ) ; » assert That « ( context . » get Time Zone « ( ) ) . » is Equal To « ( » time Zone « ) ; }
@Test { String » session Id « = this . » update Session « . » get Id « ( ) ; given ( this . » session Id Resolver « . » resolve Session Ids « ( this . exchange ) ) . » will Return « ( Collections . » singleton List « ( » session Id « ) ) ; » Web Session « actual = this . » session Manager « . » get Session « ( this . exchange ) . block ( ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual . » get Id « ( ) ) . » is Equal To « ( » session Id « ) ; }
@Test { » Web Session « session = this . store . » create Web Session « ( ) . block ( ) ; » assert That « ( session ) . » is Not Null « ( ) ; session . start ( ) ; » assert That « ( session . » is Started « ( ) ) . » is True « ( ) ; }
@Test { » Web Session « session = this . store . » create Web Session « ( ) . block ( ) ; » assert That « ( session ) . » is Not Null « ( ) ; session . start ( ) ; session . » get Attributes « ( ) . put ( " foo " , " bar " ) ; » assert That « ( session . » is Started « ( ) ) . » is True « ( ) ; }
@Test { Mono . defer ( ( ) -> this . store . » create Web Session « ( ) ) . » subscribe On « ( Schedulers . parallel ( ) ) . block ( ) ; }
@Test { » Int Stream « . range ( 0 , 10000 ) . » for Each « ( i -> » insert Session « ( ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( this :: » insert Session « ) . » with Message « ( " Max sessions limit reached : 10000 " ) ; }
@Test { this . » id Resolver « . » expire Session « ( this . exchange ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . get ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « ) ) . » is Equal To « ( Arrays . » as List « ( " " ) ) ; }
@Test { this . » id Resolver « . » expire Session « ( this . exchange ) ; this . » id Resolver « . » expire Session « ( this . exchange ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . get ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « ) ) . » is Equal To « ( Arrays . » as List « ( " " ) ) ; }
@Test { this . » id Resolver « . » set Session Id « ( this . exchange , " 123 " ) ; this . » id Resolver « . » expire Session « ( this . exchange ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . get ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « ) ) . » is Equal To « ( Arrays . » as List « ( " " ) ) ; }
@Test { String id = " 123 " ; this . » id Resolver « . » set Session Id « ( this . exchange , id ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . get ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « ) ) . » is Equal To « ( Arrays . » as List « ( id ) ) ; }
@Test { String id = " 123 " ; this . » id Resolver « . » set Session Id « ( this . exchange , " » overridden By Next Invocation « " ) ; this . » id Resolver « . » set Session Id « ( this . exchange , id ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . get ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « ) ) . » is Equal To « ( Arrays . » as List « ( id ) ) ; }
@Test { String » header Name « = " x - auth " ; String id = " 123 " ; this . » id Resolver « . » set Header Name « ( » header Name « ) ; this . » id Resolver « . » set Session Id « ( this . exchange , id ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . get ( » header Name « ) ) . » is Equal To « ( Arrays . » as List « ( id ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » id Resolver « . » set Session Id « ( this . exchange , ( String ) null ) ) ; }
@Test { List < String > ids = this . » id Resolver « . » resolve Session Ids « ( this . exchange ) ; » assert That « ( ids . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { String id = " 123 " ; this . exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path " ) . header ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « , id ) ) ; List < String > ids = this . » id Resolver « . » resolve Session Ids « ( this . exchange ) ; » assert That « ( ids ) . » is Equal To « ( Arrays . » as List « ( id ) ) ; }
@Test { String » id 1 « = " 123 " ; String » id 2 « = " abc " ; this . exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path " ) . header ( » Header Web Session Id Resolver « . » DEFAULT _ HEADER _ NAME « , » id 1 « , » id 2 « ) ) ; List < String > ids = this . » id Resolver « . » resolve Session Ids « ( this . exchange ) ; » assert That « ( ids ) . » is Equal To « ( Arrays . » as List « ( » id 1 « , » id 2 « ) ) ; }
@Test { » Mock Servlet Context « » servlet Context « = new » Mock Servlet Context « ( ) ; » servlet Context « . » set Init Parameter « ( " test . prop " , " bar " ) ; String resolved = » Servlet Context Property Utils « . » resolve Placeholders « ( " $ { test . prop : foo } " , » servlet Context « ) ; » assert That « ( resolved ) . » is Equal To « ( " bar " ) ; }
@Test { » Mock Servlet Context « » servlet Context « = new » Mock Servlet Context « ( ) ; System . » set Property « ( " test . prop " , " bar " ) ; try { String resolved = » Servlet Context Property Utils « . » resolve Placeholders « ( " $ { test . prop : foo } " , » servlet Context « ) ; » assert That « ( resolved ) . » is Equal To « ( " bar " ) ; } finally { System . » clear Property « ( " test . prop " ) ; } }
@Test { this . request . » set Method « ( " GET " ) ; this . request . » set Character Encoding « ( CHARSET ) ; this . request . » set Content « ( " Hello World " . » get Bytes « ( CHARSET ) ) ; » Content Caching Request Wrapper « wrapper = new » Content Caching Request Wrapper « ( this . request ) ; byte [ ] response = » File Copy Utils « . » copy To Byte Array « ( wrapper . » get Input Stream « ( ) ) ; » assert That « ( wrapper . » get Content As Byte Array « ( ) ) . » is Equal To « ( response ) ; }
@Test { String escaped = " & quot ; This is a quote & # 39 ; " ; String unescaped = » Html Utils « . » html Unescape « ( escaped ) ; » assert That « ( unescaped ) . » is Equal To « ( " \" This is a quote ' " ) ; }
@Test { » String Builder « sb = new » String Builder « ( ) ; sb . append ( ' ' ) ; sb . append ( ' ' ) ; String result = » Java Script Utils « . » java Script Escape « ( sb . » to String « ( ) ) ; » assert That « ( result ) . » is Equal To « ( " \\u2028 \\u2029 " ) ; }
@Test { » assert That « ( » Java Script Utils « . » java Script Escape « ( " < > " ) ) . » is Equal To « ( " \\u003C \\u003E " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » get Scope « ( null ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » has Ancestor Of Type « ( new » Tag Support « ( ) , String . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » has Ancestor Of Type « ( null , » Tag Support « . class ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » has Ancestor Of Type « ( new » Tag Support « ( ) , null ) ) ; }
@Test { Tag a = new » Tag A « ( ) ; Tag b = new » Tag B « ( ) ; Tag c = new » Tag C « ( ) ; a . » set Parent « ( b ) ; b . » set Parent « ( c ) ; » assert That « ( » Tag Utils « . » has Ancestor Of Type « ( a , » Tag C « . class ) ) . » is True « ( ) ; }
@Test { Tag a = new » Tag A « ( ) ; Tag b = new » Tag B « ( ) ; Tag » another B « = new » Tag B « ( ) ; a . » set Parent « ( b ) ; b . » set Parent « ( » another B « ) ; » assert That « ( » Tag Utils « . » has Ancestor Of Type « ( a , » Tag C « . class ) ) . » is False « ( ) ; }
@Test { » assert That « ( » Tag Utils « . » has Ancestor Of Type « ( new » Tag A « ( ) , » Tag C « . class ) ) . » is False « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » assert Has Ancestor Of Type « ( new » Tag A « ( ) , » Tag C « . class , null , " c " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » assert Has Ancestor Of Type « ( new » Tag A « ( ) , » Tag C « . class , " a " , null ) ) ; }
@Test { Tag a = new » Tag A « ( ) ; Tag b = new » Tag B « ( ) ; Tag » another B « = new » Tag B « ( ) ; a . » set Parent « ( b ) ; b . » set Parent « ( » another B « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Tag Utils « . » assert Has Ancestor Of Type « ( a , » Tag C « . class , " a " , " c " ) ) ; }
@Test { Tag a = new » Tag A « ( ) ; Tag b = new » Tag B « ( ) ; Tag c = new » Tag C « ( ) ; a . » set Parent « ( b ) ; b . » set Parent « ( c ) ; » Tag Utils « . » assert Has Ancestor Of Type « ( a , » Tag C « . class , " a " , " c " ) ; }
@Test { request . » set Context Path « ( " / petclinic " ) ; request . » set Request URI « ( " / petclinic / welcome . html " ) ; » assert That « ( helper . » get Path Within Application « ( request ) ) . as ( " Incorrect path returned " ) . » is Equal To « ( " / welcome . html " ) ; }
@Test { request . » set Context Path « ( " / petclinic " ) ; request . » set Request URI « ( " / petclinic " ) ; » assert That « ( helper . » get Path Within Application « ( request ) ) . as ( " Incorrect root path returned " ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Context Path « ( " / " ) ; request . » set Request URI « ( " / welcome . html " ) ; » assert That « ( helper . » get Path Within Application « ( request ) ) . as ( " Incorrect path returned " ) . » is Equal To « ( " / welcome . html " ) ; }
@Test { request . » set Context Path « ( " / petclinic " ) ; request . » set Servlet Path « ( " / main " ) ; request . » set Request URI « ( " / petclinic / main / welcome . html " ) ; » assert That « ( helper . » get Path Within Servlet Mapping « ( request ) ) . as ( " Incorrect path returned " ) . » is Equal To « ( " / welcome . html " ) ; }
@Test { helper . » set Always Use Full Path « ( true ) ; request . » set Context Path « ( " / petclinic " ) ; request . » set Servlet Path « ( " / main " ) ; request . » set Request URI « ( " / petclinic / main / welcome . html " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . as ( " Incorrect path returned " ) . » is Equal To « ( " / main / welcome . html " ) ; }
@Test { request . » set Context Path « ( " / SPR - 11101 " ) ; request . » set Servlet Path « ( " / » test _ url _ decoding « / a / b " ) ; request . » set Request URI « ( " / » test _ url _ decoding « / a % 2F b " ) ; helper . » set Url Decode « ( false ) ; String actual = helper . » get Path Within Servlet Mapping « ( request ) ; » assert That « ( actual ) . » is Equal To « ( " / » test _ url _ decoding « / a % 2F b " ) ; }
@Test { helper . » set Remove Semicolon Content « ( false ) ; request . » set Context Path « ( " / petclinic " ) ; request . » set Servlet Path « ( " / main " ) ; request . » set Request URI « ( " / petclinic ; a = b / main ; b = c / welcome . html ; c = d " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / welcome . html ; c = d " ) ; }
@Test { helper . » set Remove Semicolon Content « ( false ) ; request . » set Context Path « ( " / petclinic " ) ; request . » set Servlet Path « ( " / welcome . html " ) ; request . » set Request URI « ( " / petclinic ; a = b / welcome . html ; c = d " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / welcome . html ; c = d " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( null ) ; request . » set Servlet Path « ( " / " ) ; request . » set Request URI « ( " / test / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( null ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( null ) ; request . » set Servlet Path « ( " / foo / " ) ; request . » set Request URI « ( " / test / foo / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo / " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / " ) ; request . » set Servlet Path « ( " " ) ; request . » set Request URI « ( " / test / " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / " ) ; » tomcat Default Servlet Root « ( ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / foo " ) ; request . » set Servlet Path « ( " " ) ; request . » set Request URI « ( " / test / foo " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo " ) ; » tomcat Default Servlet File « ( ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / foo / " ) ; request . » set Servlet Path « ( " " ) ; request . » set Request URI « ( " / test / foo / " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo / " ) ; }
@Test { » Url Path Helper « . » websphere Compliance Flag « = true ; try { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / " ) ; » tomcat Default Servlet Folder « ( ) ; } finally { » Url Path Helper « . » websphere Compliance Flag « = false ; } }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / " ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( null ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / foo " ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo / foo " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / foo / " ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo / foo / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo / " ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( null ) ; request . » set Servlet Path « ( " / foo / " ) ; request . » set Request URI « ( " / test / foo / " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / " ) ; » tomcat Casual Servlet Root « ( ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( null ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo " ) ; » tomcat Casual Servlet Root With Missing Slash « ( ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / foo " ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo / foo " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / foo " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / foo " ) ; » tomcat Casual Servlet File « ( ) ; }
@Test { request . » set Context Path « ( " / test " ) ; request . » set Path Info « ( " / foo / " ) ; request . » set Servlet Path « ( " / foo " ) ; request . » set Request URI « ( " / test / foo / foo / " ) ; request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / foo / " ) ; » assert That « ( helper . » get Lookup Path For Request « ( request ) ) . » is Equal To « ( " / foo / " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / test / foo / foo / " ) ; » tomcat Casual Servlet Folder « ( ) ; }
@Test { request . » set Attribute « ( » Web Utils « . » FORWARD _ REQUEST _ URI _ ATTRIBUTE « , " / path " ) ; request . » set Request URI « ( " / forwarded " ) ; » assert That « ( helper . » get Originating Request Uri « ( request ) ) . » is Equal To « ( " / path " ) ; }
@Test { request . » set Attribute « ( » WEBSPHERE _ URI _ ATTRIBUTE « , " / path " ) ; request . » set Request URI « ( " / forwarded " ) ; » assert That « ( helper . » get Originating Request Uri « ( request ) ) . » is Equal To « ( " / path " ) ; }
@Test { request . » set Request URI « ( " / forwarded " ) ; » assert That « ( helper . » get Originating Request Uri « ( request ) ) . » is Equal To « ( " / forwarded " ) ; }
@Test { request . » set Query String « ( " forward = on " ) ; request . » set Attribute « ( » Web Utils « . » FORWARD _ REQUEST _ URI _ ATTRIBUTE « , " / path " ) ; request . » set Attribute « ( » Web Utils « . » FORWARD _ QUERY _ STRING _ ATTRIBUTE « , " original = on " ) ; » assert That « ( this . helper . » get Originating Query String « ( request ) ) . » is Equal To « ( " original = on " ) ; }
@Test { request . » set Query String « ( " forward = true " ) ; » assert That « ( this . helper . » get Originating Query String « ( request ) ) . » is Equal To « ( " forward = true " ) ; }
@Test { request . » set Query String « ( " forward = true " ) ; request . » set Attribute « ( » Web Utils « . » FORWARD _ REQUEST _ URI _ ATTRIBUTE « , " / path " ) ; » assert That « ( this . helper . » get Originating Query String « ( request ) ) . » is Null « ( ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( ) ; URI uri = factory . » uri String « ( " / foo / { id } " ) . build ( " a / b " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / foo / a % 2F b " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( ) ; URI uri = factory . builder ( ) . path ( " / foo / { id } " ) . build ( " a / b " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / foo / a % 2F b " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " https : » // foo . example / v 1 « ? » id = 123 « " ) ; URI uri = factory . » uri String « ( " / bar " ) . port ( 8080 ) . build ( ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " https : » // foo . example : 8080 / v 1 / bar « ? » id = 123 « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " https : » // foo . example / v 1 « ? » id = 123 « " ) ; URI uri = factory . » uri String « ( " https : » // example . com / 1 / 2 « " ) . build ( ) ; » assert That « ( uri . » to String « ( ) ) . as ( " Use of host should case » base Uri « to be completely ignored " ) . » is Equal To « ( " https : » // example . com / 1 / 2 « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " https : » // foo . example / v 1 « " ) ; URI uri = factory . builder ( ) . » replace Path « ( " / baz " ) . build ( ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " https : » // foo . example / baz « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " https : // { host } » / v 1 « " ) ; factory . » set Default Uri Variables « ( » singleton Map « ( " host " , " foo . example " ) ) ; URI uri = factory . » uri String « ( " / { id } " ) . build ( » singleton Map « ( " id " , " 123 " ) ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " https : » // foo . example / v 1 / 123 « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " https : // { host } » / v 1 « " ) ; factory . » set Default Uri Variables « ( » singleton Map « ( " host " , " spring . io " ) ) ; URI uri = factory . » uri String « ( " / bar " ) . build ( » singleton Map « ( " host " , " docs . spring . io " ) ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " https : » // docs . spring . io / v 1 / bar « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " https : // { host } » / v 1 « " ) ; factory . » set Default Uri Variables « ( » singleton Map « ( " host " , " foo . example " ) ) ; URI uri = factory . » uri String « ( " / bar " ) . build ( ) ; » assert That « ( uri . » to String « ( ) ) . as ( " Expected delegation to build ( Map ) method " ) . » is Equal To « ( " https : » // foo . example / v 1 / bar « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " / foo / { bar } " ) ; URI uri = factory . » uri String « ( " / baz / { id } " ) . build ( " a / b " , " c / d " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / foo / a % 2F b / baz / c % 2F d " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( " / foo / { bar } " ) ; factory . » set Encoding Mode « ( » Encoding Mode « . » URI _ COMPONENT « ) ; factory . » set Parse Path « ( false ) ; URI uri = factory . » uri String « ( " / baz / { id } " ) . build ( " a / b " , " c / d " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / foo / a / b / baz / c / d " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( ) ; URI uri = factory . expand ( " https : » // localhost : 8080 / spring / « " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " https : » // localhost : 8080 / spring / « " ) ; }
@Test { » Default Uri Builder Factory « factory = new » Default Uri Builder Factory « ( ) ; URI uri = factory . expand ( " » / foo ///////// bar « " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / foo / bar " ) ; }
@Test { » Uri Components « uri = » Uri Components Builder « . » from Path « ( " / hotel list / { city } specials " ) . » query Param « ( " q " , " { value } " ) . build ( ) . expand ( " Zürich " , " a + b " ) . encode ( ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / hotel % 20l ist / Z % » C 3 « % » B Crich « % 20 specials ? q = a + b " ) ; }
@Test { » Uri Components « uri = » Uri Components Builder « . » from Path « ( " / hotel list / { city } specials " ) . » query Param « ( " q " , " { value } " ) . encode ( ) . build ( ) . expand ( " Zürich " , " a + b " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / hotel % 20l ist / Z % » C 3 « % » B Crich « % 20 specials ? q = a % 2 Bb " ) ; }
@Test { » Uri Components « uri = » Uri Components Builder « . » from Path « ( " / hotel list / { city } specials " ) . » query Param « ( " q " , " { value } " ) . encode ( ) . » uri Variables « ( Collections . » singleton Map « ( " city " , " Zürich " ) ) . build ( ) ; » assert That « ( uri . expand ( " a + b " ) . » to String « ( ) ) . » is Equal To « ( " / hotel % 20l ist / Z % » C 3 « % » B Crich « % 20 specials ? q = a % 2 Bb " ) ; }
@Test { » Uri Components « uri = » Uri Components Builder « . » from Path « ( " / path " ) . » query Param « ( " q " , " { value } " ) . encode ( ) . build ( ) ; » assert That « ( uri . expand ( " » Java Class $ 1 « . class " ) . » to String « ( ) ) . » is Equal To « ( " / path ? q = » Java Class « % 241. class " ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / hotel « » list / Zürich « " ) . build ( ) ; » assert That « ( » uri Components « . encode ( ) . » to Uri « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / hotel « % » 20 list / Z « % » C 3 « % » B Crich « " ) ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / hotel « » list / Zürich « " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / hotel « % » 20 list / Zürich « " ) ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / hotel « % » 20 list / Z « % » C 3 « % » B Crich « " ) . build ( true ) ; » Uri Components « encoded = » uri Components « . encode ( ) ; » assert That « ( encoded . » to Uri « ( ) ) . » is Equal To « ( new URI ( " https : » // example . com / hotel « % » 20 list / Z « % » C 3 « % » B Crich « " ) ) ; }
@Test { String template = " / myurl / { name : [ a - z ] { 1 , 5 } } / show " ; » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( template ) . build ( ) ; » uri Components « = » uri Components « . expand ( Collections . » singleton Map « ( " name " , " test " ) ) ; » assert That « ( » uri Components « . » get Path « ( ) ) . » is Equal To « ( " / myurl / test / show " ) ; }
@Test { » assert That « ( » Uri Components Builder « . » from Uri String « ( " / myurl / ? q = { { { { " ) . encode ( ) . build ( ) . » to Uri String « ( ) ) . » is Equal To « ( " / myurl / ? q = % 7 B % 7 B % 7 B % 7 B " ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : // { host } / { path } # { fragment } " ) . build ( ) . expand ( " example . com " , " foo " , " bar " ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " https : » // example . com / foo « # bar " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » Uri Components Builder « . » from Path « ( " / { foo } " ) . build ( ) . encode ( ) . expand ( " bar " ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Uri Components Builder « . » from Path « ( " / { foo } " ) . build ( true ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Uri Components Builder « . » from Path « ( " / fo % 2 o " ) . build ( true ) ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / foo / « .. » / bar « " ) . build ( ) ; » assert That « ( » uri Components « . normalize ( ) . » to String « ( ) ) . » is Equal To « ( " https : » // example . com / bar « " ) ; }
@Test { String uri = " https : » // www . google . com / ig / calculator « ? » q = 1 USD = « ? EUR " ; » Uri Components « result = » Uri Components Builder « . » from Uri String « ( uri ) . build ( ) ; » assert That « ( result . » get Query « ( ) ) . » is Equal To « ( " q = 1 USD = ? EUR " ) ; » assert That « ( result . » get Query Params « ( ) . » get First « ( " q " ) ) . » is Equal To « ( " 1 USD = ? EUR " ) ; }
@Test { String » http Url « = " http : » // localhost : 8080 / test / print « ? » value = « % EA % » B 0 « % » 80 + « % EB % 82 % 98 " ; URI uri = » Uri Components Builder « . » from Http Url « ( » http Url « ) . build ( true ) . » to Uri « ( ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( » http Url « ) ; }
@Test { » assert That « ( » Uri Components Builder « . » from Http Url « ( " HTTP : » // www . google . com « " ) . build ( ) . » get Scheme « ( ) ) . » is Equal To « ( " http " ) ; » assert That « ( » Uri Components Builder « . » from Http Url « ( " HTTPS : » // www . google . com « " ) . build ( ) . » get Scheme « ( ) ) . » is Equal To « ( " https " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Uri Components Builder « . » from Http Url « ( " http : // [ » 1 abc : 2 abc : 3 abc « : » : 5 ABC : 6 abc : 8080 / resource « " ) . build ( ) . encode ( ) ) ; }
@Test { » Uri Components « before = » Uri Components Builder « . » from Path « ( " / foo / " ) . build ( ) ; » Uri Components « after = » Uri Components Builder « . » new Instance « ( ) . » uri Components « ( before ) . build ( ) ; » assert That « ( after . » get Path « ( ) ) . » is Equal To « ( " / foo / " ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » from Path « ( " / foo / bar " ) ; » Uri Components « result = builder . build ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / bar " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Arrays . » as List « ( " foo " , " bar " ) ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » new Instance « ( ) ; » Uri Components « result = builder . » path Segment « ( " foo " ) . » path Segment « ( " bar " ) . build ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / bar " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Arrays . » as List « ( " foo " , " bar " ) ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » from Path « ( " / foo / bar " ) . path ( " ba / z " ) ; » Uri Components « result = builder . build ( ) . encode ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / barba / z " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Arrays . » as List « ( " foo " , " barba " , " z " ) ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » from Path « ( " / foo / bar " ) . » path Segment « ( " ba / z " ) ; » Uri Components « result = builder . build ( ) . encode ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / bar / ba % 2F z " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Arrays . » as List « ( " foo " , " bar " , " ba % 2F z " ) ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » new Instance « ( ) . » path Segment « ( " foo " ) . » path Segment « ( " bar " ) ; » Uri Components « result = builder . build ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / bar " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Arrays . » as List « ( " foo " , " bar " ) ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » new Instance « ( ) . » path Segment « ( " foo " ) . path ( " / " ) ; » Uri Components « result = builder . build ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Collections . » singleton List « ( " foo " ) ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » new Instance « ( ) . » path Segment « ( " " , " foo " , " " , " bar " ) ; » Uri Components « result = builder . build ( ) ; » assert That « ( result . » get Path « ( ) ) . » is Equal To « ( " / foo / bar " ) ; » assert That « ( result . » get Path Segments « ( ) ) . » is Equal To « ( Arrays . » as List « ( " foo " , " bar " ) ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Path « ( " » / foo ///////// bar « " ) . build ( ) ; » assert That « ( » uri Components « . » get Path « ( ) ) . » is Equal To « ( " / foo / bar " ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » new Instance « ( ) ; » Uri Components « result = builder . » query Param « ( " baz " ) . build ( ) ; » assert That « ( result . » get Query « ( ) ) . » is Equal To « ( " baz " ) ; » Multi Value Map « < String , String > » expected Query Params « = new » Linked Multi Value Map « < > ( 2 ) ; » expected Query Params « . add ( " baz " , null ) ; » assert That « ( result . » get Query Params « ( ) ) . » is Equal To « ( » expected Query Params « ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / foo « ? » bar = baz « " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " https : » // example . com / foo « ? » bar = baz « " ) ; » assert That « ( » uri Components « . » get Query Params « ( ) . get ( " bar " ) . get ( 0 ) ) . » is Equal To « ( " baz " ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / foo « ? » bar = « " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " https : » // example . com / foo « ? » bar = « " ) ; » assert That « ( » uri Components « . » get Query Params « ( ) . get ( " bar " ) . get ( 0 ) ) . » is Equal To « ( " " ) ; }
@Test { » Uri Components « » uri Components « = » Uri Components Builder « . » from Uri String « ( " https : » // example . com / foo « ? bar " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " https : » // example . com / foo « ? bar " ) ; » assert That « ( » uri Components « . » get Query Params « ( ) . get ( " bar " ) . get ( 0 ) ) . » is Null « ( ) ; }
@Test { URI uri = new URI ( " urn : ietf : wg : oauth : 2.0 : oob " ) ; » Uri Components « result = » Uri Components Builder « . » from Uri « ( uri ) . host ( null ) . port ( - 1 ) . port ( null ) . » query Params « ( null ) . » replace Query « ( null ) . query ( null ) . build ( ) ; » assert That « ( result . » to Uri « ( ) ) . » is Equal To « ( uri ) ; }
@Test { » Uri Components « components = » Uri Components Builder « . » from Uri String « ( " » / example « # " ) . build ( ) ; » assert That « ( components . » get Fragment « ( ) ) . » is Null « ( ) ; » assert That « ( components . » to String « ( ) ) . » is Equal To « ( " / example " ) ; }
@Test { » Uri Components « components = » Uri Components Builder « . » from Uri String « ( " " ) . build ( ) ; » assert That « ( components . » to String « ( ) ) . » is Equal To « ( " " ) ; }
@Test { String uri = » Uri Components Builder « . » from Uri String « ( " http : » // localhost : 8081 « " ) . » uri Components « ( » Uri Components Builder « . » from Uri String « ( " / { path } ? sort = { sort } " ) . build ( ) ) . » query Param « ( " sort " , " » another _ value « " ) . build ( ) . » to String « ( ) ; » assert That « ( uri ) . » is Equal To « ( " http : » // localhost : 8081 / « { path } ? » sort = « { sort } & » sort = another _ value « " ) ; }
@Test { » assert That « ( » Uri Components Builder « . » from Uri String « ( " / path ? q = { asa } asa " ) . » to Uri String « ( ) ) . » is Equal To « ( " / path ? q = % 7 Basa % 7D asa " ) ; }
@Test { this . handler . » set Base Url « ( " http : » // localhost : 8080 « " ) ; URI actual = this . handler . expand ( " / myapiresource " ) ; » assert That « ( actual . » to String « ( ) ) . » is Equal To « ( " http : » // localhost : 8080 / myapiresource « " ) ; }
@Test { this . handler . » set Base Url « ( " http : » // localhost : 8080 / context « " ) ; URI actual = this . handler . expand ( " / myapiresource " ) ; » assert That « ( actual . » to String « ( ) ) . » is Equal To « ( " http : » // localhost : 8080 / context / myapiresource « " ) ; }
@Test { this . handler . » set Strict Encoding « ( false ) ; Map < String , String > vars = new » Hash Map « < > ( 2 ) ; vars . put ( " » user Id « " , " john ; doe " ) ; String template = " https : » // www . example . com / user / « { » user Id « } » / dashboard « " ; URI actual = this . handler . expand ( template , vars ) ; » assert That « ( actual . » to String « ( ) ) . » is Equal To « ( " https : » // www . example . com / user / john « ; » doe / dashboard « " ) ; }
@Test { this . handler . » set Strict Encoding « ( false ) ; String template = " https : » // www . example . com / user / « { » user Id « } » / dashboard « " ; URI actual = this . handler . expand ( template , " john ; doe " ) ; » assert That « ( actual . » to String « ( ) ) . » is Equal To « ( " https : » // www . example . com / user / john « ; » doe / dashboard « " ) ; }
@Test { this . handler . » set Strict Encoding « ( true ) ; Map < String , String > vars = new » Hash Map « < > ( 2 ) ; vars . put ( " » user Id « " , " john ; doe " ) ; String template = " https : » // www . example . com / user / « { » user Id « } » / dashboard « " ; URI actual = this . handler . expand ( template , vars ) ; » assert That « ( actual . » to String « ( ) ) . » is Equal To « ( " https : » // www . example . com / user / john « % » 3 Bdoe / dashboard « " ) ; }
@Test { this . handler . » set Strict Encoding « ( true ) ; String template = " https : » // www . example . com / user / « { » user Id « } » / dashboard « " ; URI actual = this . handler . expand ( template , " john ; doe " ) ; » assert That « ( actual . » to String « ( ) ) . » is Equal To « ( " https : » // www . example . com / user / john « % » 3 Bdoe / dashboard « " ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; List < String > » variable Names « = template . » get Variable Names « ( ) ; » assert That « ( » variable Names « ) . as ( " Invalid variable names " ) . » is Equal To « ( Arrays . » as List « ( " hotel " , " booking " ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; URI result = template . expand ( " 1 " , " 42 " ) ; » assert That « ( result ) . as ( " Invalid expanded template " ) . » is Equal To « ( new URI ( " / hotels / 1 / bookings / 42 " ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / sum ? numbers = { numbers } " ) ; URI result = template . expand ( new int [ ] { 1 , 2 , 3 } ) ; » assert That « ( result ) . » is Equal To « ( new URI ( " / sum ? numbers = 1 , 2 , 3 " ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> template . expand ( " 1 " ) ) ; }
@Test { Map < String , String > » uri Variables « = new » Hash Map « < > ( 2 ) ; » uri Variables « . put ( " booking " , " 42 " ) ; » uri Variables « . put ( " hotel " , " 1 " ) ; » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; URI result = template . expand ( » uri Variables « ) ; » assert That « ( result ) . as ( " Invalid expanded template " ) . » is Equal To « ( new URI ( " / hotels / 1 / bookings / 42 " ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / order / { c } / { c } / { c } " ) ; » assert That « ( template . » get Variable Names « ( ) ) . » is Equal To « ( Arrays . » as List « ( " c " , " c " , " c " ) ) ; URI result = template . expand ( Collections . » singleton Map « ( " c " , " cheeseburger " ) ) ; » assert That « ( result ) . » is Equal To « ( new URI ( " / order / cheeseburger / cheeseburger / cheeseburger " ) ) ; }
@Test { Map < String , Integer > » uri Variables « = new » Hash Map « < > ( 2 ) ; » uri Variables « . put ( " booking " , 42 ) ; » uri Variables « . put ( " hotel " , 1 ) ; » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; URI result = template . expand ( » uri Variables « ) ; » assert That « ( result ) . as ( " Invalid expanded template " ) . » is Equal To « ( new URI ( " / hotels / 1 / bookings / 42 " ) ) ; }
@Test { Map < String , String > » uri Variables « = Collections . » singleton Map « ( " hotel " , " Zürich " ) ; » Uri Template « template = new » Uri Template « ( " / hotel list / { hotel } " ) ; URI result = template . expand ( » uri Variables « ) ; » assert That « ( result ) . as ( " Invalid expanded template " ) . » is Equal To « ( new URI ( " / hotel % 20l ist / Z % » C 3 « % » B Crich « " ) ) ; }
@Test { Map < String , String > » uri Variables « = new » Hash Map « < > ( 2 ) ; » uri Variables « . put ( " booking " , " 42 " ) ; » uri Variables « . put ( " bar " , " 1 " ) ; » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> template . expand ( » uri Variables « ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / hotel list / { hotel } " ) ; URI result = template . expand ( " Zürich " ) ; » assert That « ( result ) . as ( " Invalid expanded template " ) . » is Equal To « ( new URI ( " / hotel % 20l ist / Z % » C 3 « % » B Crich « " ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " » / hotels / « { hotel : » \\ d + « } " ) ; » assert That « ( template . matches ( " / hotels / 42 " ) ) . as ( " » Uri Template « does not match " ) . » is True « ( ) ; » assert That « ( template . matches ( " / hotels / foo " ) ) . as ( " » Uri Template « matches " ) . » is False « ( ) ; }
@Test { Map < String , String > expected = new » Hash Map « < > ( 2 ) ; expected . put ( " booking " , " 42 " ) ; expected . put ( " hotel " , " 1 " ) ; » Uri Template « template = new » Uri Template « ( " / hotels / { hotel } / bookings / { booking } " ) ; Map < String , String > result = template . match ( " / hotels / 1 / bookings / 42 " ) ; » assert That « ( result ) . as ( " Invalid match " ) . » is Equal To « ( expected ) ; }
@Test { Map < String , String > expected = new » Hash Map « < > ( 2 ) ; expected . put ( " booking " , " 42 " ) ; expected . put ( " hotel " , " 1 " ) ; » Uri Template « template = new » Uri Template « ( " » / hotels / « { hotel : » \\ d « } » / bookings / « { booking : » \\ d + « } " ) ; Map < String , String > result = template . match ( " / hotels / 1 / bookings / 42 " ) ; » assert That « ( result ) . as ( " Invalid match " ) . » is Equal To « ( expected ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / site . { domain : co . [ a - z ] { 2 } } " ) ; Map < String , String > result = template . match ( " / site . co . eu " ) ; » assert That « ( result ) . as ( " Invalid match " ) . » is Equal To « ( Collections . » singleton Map « ( " domain " , " co . eu " ) ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / order / { c } / { c } / { c } " ) ; Map < String , String > result = template . match ( " / order / cheeseburger / cheeseburger / cheeseburger " ) ; Map < String , String > expected = Collections . » singleton Map « ( " c " , " cheeseburger " ) ; » assert That « ( result ) . as ( " Invalid match " ) . » is Equal To « ( expected ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / { foo } - { bar } " ) ; Map < String , String > result = template . match ( " / 12 - 34 " ) ; Map < String , String > expected = new » Hash Map « < > ( 2 ) ; expected . put ( " foo " , " 12 " ) ; expected . put ( " bar " , " 34 " ) ; » assert That « ( result ) . as ( " Invalid match " ) . » is Equal To « ( expected ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / account / { » account Id « } " ) ; » assert That « ( template . matches ( " / account / 15 / alias / 5 " ) ) . » is False « ( ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / search ? q = { query } " ) ; » assert That « ( template . matches ( " / search ? q = foo " ) ) . » is True « ( ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " » / search « # { fragment } " ) ; » assert That « ( template . matches ( " » / search « # foo " ) ) . » is True « ( ) ; template = new » Uri Template « ( " » / search « ? » query = « { query } # { fragment } " ) ; » assert That « ( template . matches ( " » / search « ? » query = foo « # bar " ) ) . » is True « ( ) ; }
@Test { » Uri Template « » uri Template « = new » Uri Template « ( " / test / " ) ; » assert That « ( » uri Template « . matches ( " / test / " ) ) . » is True « ( ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " / { a } " ) ; URI uri = template . expand ( " » $ replacement « " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " / » $ replacement « " ) ; }
@Test { » Uri Template « template = new » Uri Template « ( " http : » // localhost / query = « { query } " ) ; URI uri = template . expand ( " foo @ bar " ) ; » assert That « ( uri . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / query = foo « @ bar " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode Scheme « ( " foobar + - . " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar + - . " ) ; » assert That « ( » Uri Utils « . » encode Scheme « ( " foo bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo % 20 bar " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode User Info « ( " foobar : " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar : " ) ; » assert That « ( » Uri Utils « . » encode User Info « ( " foo bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo % 20 bar " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode Host « ( " foobar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar " ) ; » assert That « ( » Uri Utils « . » encode Host « ( " foo bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo % 20 bar " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode Port « ( " 80 " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " 80 " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode Path Segment « ( " foobar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar " ) ; » assert That « ( » Uri Utils « . » encode Path Segment « ( " / foo / bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " % 2F foo % 2F bar " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode Query Param « ( " foobar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar " ) ; » assert That « ( » Uri Utils « . » encode Query Param « ( " foo bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo % 20 bar " ) ; » assert That « ( » Uri Utils « . » encode Query Param « ( " foo & bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo % 26 bar " ) ; }
@Test { » assert That « ( » Uri Utils « . » encode Fragment « ( " foobar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar " ) ; » assert That « ( » Uri Utils « . » encode Fragment « ( " foo bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo % 20 bar " ) ; » assert That « ( » Uri Utils « . » encode Fragment « ( " foobar / " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foobar / " ) ; }
@Test { » assert That « ( » Uri Utils « . encode ( " foo " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " foo " ) ; » assert That « ( » Uri Utils « . encode ( " https : » // example . com / foo « bar " , CHARSET ) ) . as ( " Invalid encoded result " ) . » is Equal To « ( " https % 3 A % 2F % 2F example . com % 2F foo % 20 bar " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Uri Utils « . decode ( " foo % 2 " , CHARSET ) ) ; }
@Test { » check Structure « ( " / " ) ; » check Structure « ( " / foo " ) ; » check Structure « ( " foo " ) ; » check Structure « ( " foo / " ) ; » check Structure « ( " / foo / " ) ; » check Structure « ( " " ) ; }
@Test { » path Pattern « = » check Structure « ( " ? " ) ; » assert Path Elements « ( » path Pattern « , » Single Char Wildcarded Path Element « . class ) ; » check Structure « ( " / ? / " ) ; » check Structure « ( " / ? abc ? / " ) ; }
@Test { » path Pattern « = » check Structure « ( " / * * " ) ; » assert Path Elements « ( » path Pattern « , » Wildcard The Rest Path Element « . class ) ; » path Pattern « = » check Structure « ( " / * * acb " ) ; » assert Path Elements « ( » path Pattern « , » Separator Path Element « . class , » Regex Path Element « . class ) ; }
@Test { » path Pattern « = » check Structure « ( " { foo } " ) ; » assert That « ( » path Pattern « . » get Head Section « ( ) . » get Class « ( ) . » get Name « ( ) ) . » is Equal To « ( » Capture Variable Path Element « . class . » get Name « ( ) ) ; » check Structure « ( " / { foo } " ) ; » check Structure « ( " / { f } / " ) ; » check Structure « ( " / { foo } / { bar } / { wibble } " ) ; » check Structure « ( " / { mobile - number } " ) ; }
@Test { » path Pattern « = » check Structure « ( " { foo : ... } " ) ; » assert Path Elements « ( » path Pattern « , » Capture Variable Path Element « . class ) ; » path Pattern « = » check Structure « ( " { foo : [ 0 - 9 ] * } " ) ; » assert Path Elements « ( » path Pattern « , » Capture Variable Path Element « . class ) ; » check Error « ( " { foo : } " , 5 , » Pattern Message « . » MISSING _ REGEX _ CONSTRAINT « ) ; }
@Test { » Path Pattern Parser « parser = new » Path Pattern Parser « ( ) ; parser . » set Path Options « ( » Path Container « . Options . create ( ' . ' , false ) ) ; String » raw Pattern « = " first . second . { last } " ; » Path Pattern « pattern = parser . parse ( » raw Pattern « ) ; » assert That « ( pattern . » compute Pattern String « ( ) ) . » is Equal To « ( » raw Pattern « ) ; }
@Test { » check Extract Path Within Pattern « ( " / * * " , " // " , " " ) ; » check Extract Path Within Pattern « ( " / * * " , " / " , " " ) ; » check Extract Path Within Pattern « ( " / * * " , " " , " " ) ; » check Extract Path Within Pattern « ( " / * * " , " / foobar " , " foobar " ) ; }
@Test { » Path Pattern Parser « ppp = new » Path Pattern Parser « ( ) ; » Path Pattern « » path Pattern « = ppp . parse ( " / web / { id : foo ( bar ) ? } _ { goo } " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » match And Extract « ( » path Pattern « , " / web / » foobar _ goo « " ) ) . » with Message Containing « ( " The number of capturing groups in the pattern " ) ; }
@Test { » Test Path Combiner « » path Matcher « = new » Test Path Combiner « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » path Matcher « . combine ( " / * » . html « " , " / * » . txt « " ) ) ; }
@Test { » assert That « ( » Path Pattern « . » SPECIFICITY _ COMPARATOR « . compare ( null , null ) == 0 ) . » is True « ( ) ; » assert That « ( » Path Pattern « . » SPECIFICITY _ COMPARATOR « . compare ( parse ( " / abc " ) , null ) < 0 ) . » is True « ( ) ; » assert That « ( » Path Pattern « . » SPECIFICITY _ COMPARATOR « . compare ( null , parse ( " / abc " ) ) > 0 ) . » is True « ( ) ; }
@Test { » Path Pattern Parser « pp = new » Path Pattern Parser « ( ) ; pp . » set Case Sensitive « ( false ) ; » Path Pattern « p = pp . parse ( " / group / { » group Name « } / members " ) ; » assert Matches « ( p , " / group / sales / members " ) ; » assert Matches « ( p , " / Group / Sales / Members " ) ; » assert Matches « ( p , " / group / Sales / members " ) ; }
@Test { » Path Pattern Route Matcher « » route Matcher « = new » Path Pattern Route Matcher « ( ) ; » Route Matcher « . Route route = » route Matcher « . » parse Route « ( " projects . spring - framework " ) ; » assert That « ( » route Matcher « . match ( " projects . { name } " , route ) ) . » is True « ( ) ; }
@Test { » Path Pattern Parser « parser = new » Path Pattern Parser « ( ) ; parser . » set Path Options « ( » Path Container « . Options . create ( ' / ' , false ) ) ; » Path Pattern Route Matcher « » route Matcher « = new » Path Pattern Route Matcher « ( parser ) ; » Route Matcher « . Route route = » route Matcher « . » parse Route « ( " / projects / spring - framework " ) ; » assert That « ( » route Matcher « . match ( " / projects / { name } " , route ) ) . » is True « ( ) ; }
@Test { » Path Pattern Route Matcher « » route Matcher « = new » Path Pattern Route Matcher « ( ) ; » Route Matcher « . Route route = » route Matcher « . » parse Route « ( " projects . spring % 20f ramework ; p = 1 " ) ; » assert That « ( » route Matcher « . match ( " projects . spring % 20f ramework ; p = 1 " , route ) ) . » is True « ( ) ; }
@Test { » Path Pattern Route Matcher « » route Matcher « = new » Path Pattern Route Matcher « ( ) ; » Route Matcher « . Route route = » route Matcher « . » parse Route « ( " projects . spring % 2Ef ramework " ) ; Map < String , String > vars = » route Matcher « . » match And Extract « ( " projects . { project } " , route ) ; » assert That « ( vars ) . » contains Entry « ( " project " , " spring . framework " ) ; }
@Test { Throwable ex = new » Response Status Exception « ( » Http Status « . » BAD _ REQUEST « , " " ) ; this . handler . handle ( this . exchange , ex ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « ) ; }
@Test { Throwable ex = new Exception ( new » Response Status Exception « ( » Http Status « . » BAD _ REQUEST « , " " ) ) ; this . handler . handle ( this . exchange , ex ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « ) ; }
@Test { Throwable expected = new » Illegal State Exception « ( ) ; Mono < Void > mono = this . handler . handle ( this . exchange , expected ) ; » Step Verifier « . create ( mono ) . » consume Error With « ( actual -> » assert That « ( actual ) . » is Same As « ( expected ) ) . verify ( ) ; }
@Test { Throwable ex = new » Response Status Exception « ( » Http Status « . » INTERNAL _ SERVER _ ERROR « , " Oops " ) ; this . exchange . » get Response « ( ) . » set Status Code « ( » Http Status « . CREATED ) ; Mono < Void > mono = this . exchange . » get Response « ( ) . » set Complete « ( ) . then ( Mono . defer ( ( ) -> this . handler . handle ( this . exchange , ex ) ) ) ; » Step Verifier « . create ( mono ) . » consume Error With « ( actual -> » assert That « ( actual ) . » is Same As « ( ex ) ) . verify ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / error - signal " ) ) ; Mono < Void > publisher = this . » dispatcher Handler « . handle ( exchange ) ; » Step Verifier « . create ( publisher ) . » consume Error With « ( error -> » assert That « ( error ) . » is Same As « ( EXCEPTION ) ) . verify ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / raise - exception " ) ) ; Mono < Void > publisher = this . » dispatcher Handler « . handle ( exchange ) ; » Step Verifier « . create ( publisher ) . » consume Error With « ( error -> » assert That « ( error ) . » is Same As « ( EXCEPTION ) ) . verify ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / unknown - return - type " ) ) ; Mono < Void > publisher = this . » dispatcher Handler « . handle ( exchange ) ; » Step Verifier « . create ( publisher ) . » consume Error With « ( error -> » assert That « ( error ) . » is Instance Of « ( » Illegal State Exception « . class ) . » has Message Starting With « ( " No » Handler Result Handler « " ) ) . verify ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . post ( " / request - body " ) . accept ( » APPLICATION _ JSON « ) . body ( " body " ) ) ; Mono < Void > publisher = this . » dispatcher Handler « . handle ( exchange ) ; » Step Verifier « . create ( publisher ) . » consume Error With « ( error -> » assert That « ( error ) . » is Instance Of « ( » Not Acceptable Status Exception « . class ) ) . verify ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . post ( " / request - body " ) . body ( Mono . error ( EXCEPTION ) ) ) ; Mono < Void > publisher = this . » dispatcher Handler « . handle ( exchange ) ; » Step Verifier « . create ( publisher ) . » consume Error With « ( error -> » assert That « ( error ) . » is Same As « ( EXCEPTION ) ) . verify ( ) ; }
@Test { String header = " textplain ; q = 0.5 " ; » assert That Exception Of Type « ( » Not Acceptable Status Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Media Types « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) . header ( " accept " , header ) ) ) ) ; }
@Test { » Requested Content Type Resolver « resolver = new » Requested Content Type Resolver Builder « ( ) . build ( ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / flower " ) . accept ( » Media Type « . » IMAGE _ GIF « ) ) ; List < » Media Type « > » media Types « = resolver . » resolve Media Types « ( exchange ) ; » assert That « ( » media Types « ) . » is Equal To « ( Collections . » singleton List « ( » Media Type « . » IMAGE _ GIF « ) ) ; }
@Test { » Requested Content Type Resolver Builder « builder = new » Requested Content Type Resolver Builder « ( ) ; builder . » fixed Resolver « ( » Media Type « . » APPLICATION _ JSON « ) ; » Requested Content Type Resolver « resolver = builder . build ( ) ; List < » Media Type « > » media Types « = resolver . » resolve Media Types « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) . accept ( » Media Type « . ALL ) ) ) ; » assert That « ( » media Types « ) . » is Equal To « ( Collections . » singleton List « ( » Media Type « . » APPLICATION _ JSON « ) ) ; }
@Test { » Parameter Content Type Resolver « resolver = new » Parameter Content Type Resolver « ( Collections . » empty Map « ( ) ) ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; List < » Media Type « > » media Types « = resolver . » resolve Media Types « ( exchange ) ; » assert That « ( » media Types « ) . » is Equal To « ( » Requested Content Type Resolver « . » MEDIA _ TYPE _ ALL _ LIST « ) ; }
@Test { » Parameter Content Type Resolver « resolver = new » Parameter Content Type Resolver « ( Collections . » empty Map « ( ) ) ; » assert That Exception Of Type « ( » Not Acceptable Status Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Media Types « ( » create Exchange « ( " blah " ) ) ) ; }
@Test { » Server Web Exchange « exchange = » create Exchange « ( " xls " ) ; » Requested Content Type Resolver « resolver = new » Parameter Content Type Resolver « ( Collections . » empty Map « ( ) ) ; List < » Media Type « > » media Types « = resolver . » resolve Media Types « ( exchange ) ; » assert That « ( » media Types « ) . » is Equal To « ( Collections . » singleton List « ( new » Media Type « ( " application " , " vnd . ms - excel " ) ) ) ; }
@Test { » Server Web Exchange « exchange = » create Exchange « ( " » J So N « " ) ; Map < String , » Media Type « > mapping = Collections . » singleton Map « ( " json " , » Media Type « . » APPLICATION _ JSON « ) ; » Parameter Content Type Resolver « resolver = new » Parameter Content Type Resolver « ( mapping ) ; List < » Media Type « > » media Types « = resolver . » resolve Media Types « ( exchange ) ; » assert That « ( » media Types « ) . » is Equal To « ( Collections . » singleton List « ( » Media Type « . » APPLICATION _ JSON « ) ) ; }
@Test { » assert That « ( this . registry . » get Cors Configurations « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { this . registry . » add Mapping « ( " / foo " ) ; this . registry . » add Mapping « ( " / bar " ) ; » assert That « ( this . registry . » get Cors Configurations « ( ) . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » delegating Config « . » set Configurers « ( Collections . » singleton List « ( » web Flux Configurer « ) ) ; » delegating Config « . » request Mapping Handler Mapping « ( » delegating Config « . » web Flux Content Type Resolver « ( ) ) ; verify ( » web Flux Configurer « ) . » configure Content Type Resolver « ( any ( » Requested Content Type Resolver Builder « . class ) ) ; verify ( » web Flux Configurer « ) . » add Cors Mappings « ( any ( » Cors Registry « . class ) ) ; verify ( » web Flux Configurer « ) . » configure Path Matching « ( any ( » Path Match Configurer « . class ) ) ; }
@Test { » delegating Config « . » set Configurers « ( Collections . » singleton List « ( » web Flux Configurer « ) ) ; » delegating Config « . » response Body Result Handler « ( » delegating Config « . » web Flux Adapter Registry « ( ) , » delegating Config « . » server Codec Configurer « ( ) , » delegating Config « . » web Flux Content Type Resolver « ( ) ) ; verify ( » web Flux Configurer « ) . » configure Http Message Codecs « ( » codecs Configurer « . capture ( ) ) ; verify ( » web Flux Configurer « ) . » configure Content Type Resolver « ( any ( » Requested Content Type Resolver Builder « . class ) ) ; }
@Test { » delegating Config « . » set Configurers « ( Collections . » singleton List « ( » web Flux Configurer « ) ) ; » delegating Config « . » view Resolution Result Handler « ( » delegating Config « . » web Flux Adapter Registry « ( ) , » delegating Config « . » web Flux Content Type Resolver « ( ) ) ; verify ( » web Flux Configurer « ) . » configure View Resolvers « ( any ( » View Resolver Registry « . class ) ) ; }
@Test { this . registry = new » Resource Handler Registry « ( new » Generic Application Context « ( ) ) ; » assert That « ( ( Object ) this . registry . » get Handler Mapping « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( » get Handler « ( " » / resources / « * * " ) . » get Cache Control « ( ) ) . » is Null « ( ) ; this . registration . » set Cache Control « ( » Cache Control « . » no Cache « ( ) . » cache Private « ( ) ) ; » assert That « ( » get Handler « ( " » / resources / « * * " ) . » get Cache Control « ( ) . » get Header Value « ( ) ) . » is Equal To « ( » Cache Control « . » no Cache « ( ) . » cache Private « ( ) . » get Header Value « ( ) ) ; }
@Test { » assert That « ( this . registry . » get Handler Mapping « ( ) . » get Order « ( ) ) . » is Equal To « ( Integer . » MAX _ VALUE « - 1 ) ; this . registry . » set Order « ( 0 ) ; » assert That « ( this . registry . » get Handler Mapping « ( ) . » get Order « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . registry . » has Mapping For Pattern « ( " » / resources / « * * " ) ) . » is True « ( ) ; » assert That « ( this . registry . » has Mapping For Pattern « ( " / whatever " ) ) . » is False « ( ) ; }
@Test { » Application Context « context = » load Config « ( » Web Flux Config « . class ) ; String name = " » resource Url Provider « " ; » Resource Url Provider « » resource Url Provider « = context . » get Bean « ( name , » Resource Url Provider « . class ) ; » assert That « ( » resource Url Provider « ) . » is Not Null « ( ) ; }
@Test { » assert That « ( this . registry . » get Order « ( ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; }
@Test { » assert That « ( this . registry . » has Registrations « ( ) ) . » is False « ( ) ; this . registry . » free Marker « ( ) ; » assert That « ( this . registry . » has Registrations « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . registry . » get View Resolvers « ( ) ) . » is Not Null « ( ) ; » assert That « ( this . registry . » get View Resolvers « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; » assert That « ( this . registry . » has Registrations « ( ) ) . » is False « ( ) ; }
@Test { » Url Based View Resolver « » view Resolver « = new » Url Based View Resolver « ( ) ; this . registry . » view Resolver « ( » view Resolver « ) ; » assert That « ( this . registry . » get View Resolvers « ( ) . get ( 0 ) ) . » is Same As « ( » view Resolver « ) ; » assert That « ( this . registry . » get View Resolvers « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { View view = new » Http Message Writer View « ( new » Jackson 2 Json Encoder « ( ) ) ; this . registry . » default Views « ( view ) ; » assert That « ( this . registry . » get Default Views « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . registry . » get Default Views « ( ) . get ( 0 ) ) . » is Same As « ( view ) ; }
@Test { load ( context -> { } ) ; » Request Mapping Handler Mapping « » handler Mapping « = this . context . » get Bean « ( » Request Mapping Handler Mapping « . class ) ; » assert That « ( » handler Mapping « . » get Content Type Resolver « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Content Type Resolver « " ) ) ; }
@Test { load ( context -> { } ) ; » Response Entity Result Handler « » response Entity Result Handler « = this . context . » get Bean « ( » Response Entity Result Handler « . class ) ; » assert That « ( » response Entity Result Handler « . » get Adapter Registry « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Adapter Registry « " ) ) ; » assert That « ( » response Entity Result Handler « . » get Content Type Resolver « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Content Type Resolver « " ) ) ; }
@Test { load ( context -> { } ) ; » Response Body Result Handler « » response Body Result Handler « = this . context . » get Bean « ( » Response Body Result Handler « . class ) ; » assert That « ( » response Body Result Handler « . » get Adapter Registry « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Adapter Registry « " ) ) ; » assert That « ( » response Body Result Handler « . » get Content Type Resolver « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Content Type Resolver « " ) ) ; }
@Test { load ( context -> { } ) ; » View Resolution Result Handler « » view Resolution Result Handler « = this . context . » get Bean « ( » View Resolution Result Handler « . class ) ; » assert That « ( » view Resolution Result Handler « . » get Adapter Registry « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Adapter Registry « " ) ) ; » assert That « ( » view Resolution Result Handler « . » get Content Type Resolver « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » web Flux Content Type Resolver « " ) ) ; }
@Test { » Body Extractor « < Mono < Map < String , String > > , » Reactive Http Input Message « > extractor = » Body Extractors « . » to Mono « ( new » Parameterized Type Reference « < Map < String , String > > ( ) { } ) ; » Mock Server Http Request « request = » Mock Server Http Request « . post ( " / " ) . body ( Flux . empty ( ) ) ; Mono < Map < String , String > > result = extractor . extract ( request , this . context ) ; » Step Verifier « . create ( result ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Test Publisher « < » Data Buffer « > body = » Test Publisher « . create ( ) ; » Body Extractor « < Mono < Void > , » Reactive Http Input Message « > extractor = » Body Extractors « . » to Mono « ( Void . class ) ; » Mock Client Http Response « response = new » Mock Client Http Response « ( » Http Status « . OK ) ; response . » set Body « ( body . flux ( ) ) ; » Step Verifier « . create ( extractor . extract ( response , this . context ) ) . then ( ( ) -> { body . » assert Was Subscribed « ( ) ; body . complete ( ) ; } ) . » verify Complete « ( ) ; }
@Test { URI url = new URI ( " https : » // example . com « " ) ; » Client Request « . Builder builder = » Client Request « . create ( DELETE , url ) ; » assert That « ( builder . build ( ) . method ( ) ) . » is Equal To « ( DELETE ) ; builder . method ( OPTIONS ) ; » assert That « ( builder . build ( ) . method ( ) ) . » is Equal To « ( OPTIONS ) ; }
@Test { URI » url 1 « = new URI ( " https : » // example . com / foo « " ) ; URI » url 2 « = new URI ( " https : » // example . com / bar « " ) ; » Client Request « . Builder builder = » Client Request « . create ( DELETE , » url 1 « ) ; » assert That « ( builder . build ( ) . url ( ) ) . » is Equal To « ( » url 1 « ) ; builder . url ( » url 2 « ) ; » assert That « ( builder . build ( ) . url ( ) ) . » is Equal To « ( » url 2 « ) ; }
@Test { » Client Request « result = » Client Request « . create ( GET , URI . create ( " https : » // example . com « " ) ) . cookie ( " foo " , " bar " ) . build ( ) ; » assert That « ( result . cookies ( ) . » get First « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Client Response « other = » Client Response « . create ( 499 , » Exchange Strategies « . » with Defaults « ( ) ) . build ( ) ; » Client Response « result = » Client Response « . from ( other ) . build ( ) ; » assert That « ( result . » raw Status Code « ( ) ) . » is Equal To « ( 499 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( result :: » status Code « ) ; }
@Test { » Http Status « status = » Http Status « . CONTINUE ; given ( » mock Response « . » get Status Code « ( ) ) . » will Return « ( status ) ; » assert That « ( » default Client Response « . » status Code « ( ) ) . » is Equal To « ( status ) ; }
@Test { int status = 999 ; given ( » mock Response « . » get Raw Status Code « ( ) ) . » will Return « ( status ) ; » assert That « ( » default Client Response « . » raw Status Code « ( ) ) . » is Equal To « ( status ) ; }
@Test { » Response Cookie « cookie = » Response Cookie « . from ( " foo " , " bar " ) . build ( ) ; » Multi Value Map « < String , » Response Cookie « > cookies = new » Linked Multi Value Map « < > ( ) ; cookies . add ( " foo " , cookie ) ; given ( » mock Response « . » get Cookies « ( ) ) . » will Return « ( cookies ) ; » assert That « ( » default Client Response « . cookies ( ) ) . » is Same As « ( cookies ) ; }
@Test { this . builder . build ( ) . get ( ) . uri ( " / path " ) . exchange ( ) . block ( Duration . » of Seconds « ( 10 ) ) ; » Client Request « request = » verify And Get Request « ( ) ; » assert That « ( request . url ( ) . » to String « ( ) ) . » is Equal To « ( " / base / path " ) ; » assert That « ( request . headers ( ) ) . » is Equal To « ( new » Http Headers « ( ) ) ; » assert That « ( request . cookies ( ) ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; }
@Test { this . builder . build ( ) . get ( ) . uri ( builder -> builder . path ( " / path " ) . » query Param « ( " q " , " 12 " ) . build ( ) ) . exchange ( ) . block ( Duration . » of Seconds « ( 10 ) ) ; » Client Request « request = » verify And Get Request « ( ) ; » assert That « ( request . url ( ) . » to String « ( ) ) . » is Equal To « ( " / base / path ? q = 12 " ) ; }
@Test { this . builder . build ( ) . get ( ) . uri ( builder -> builder . » replace Path « ( " / path " ) . build ( ) ) . exchange ( ) . block ( Duration . » of Seconds « ( 10 ) ) ; » Client Request « request = » verify And Get Request « ( ) ; » assert That « ( request . url ( ) . » to String « ( ) ) . » is Equal To « ( " / path " ) ; }
@Test { Mono < Void > mono = Mono . empty ( ) ; » Web Client « client = this . builder . build ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> client . post ( ) . uri ( " https : » // example . com « " ) . » body Value « ( mono ) ) ; }
@Test { » Exchange Strategies « strategies = » Exchange Strategies « . empty ( ) . build ( ) ; » assert That « ( strategies . » message Readers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; » assert That « ( strategies . » message Writers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Exchange Strategies « strategies = » Exchange Strategies « . » with Defaults « ( ) ; » assert That « ( strategies . » message Readers « ( ) . » is Empty « ( ) ) . » is False « ( ) ; » assert That « ( strategies . » message Writers « ( ) . » is Empty « ( ) ) . » is False « ( ) ; }
@Test { » assert That « ( wrapper . response ( ) ) . » is Same As « ( » mock Response « ) ; }
@Test { » Http Status « status = » Http Status « . » BAD _ REQUEST « ; given ( » mock Response « . » status Code « ( ) ) . » will Return « ( status ) ; » assert That « ( wrapper . » status Code « ( ) ) . » is Same As « ( status ) ; }
@Test { int status = 999 ; given ( » mock Response « . » raw Status Code « ( ) ) . » will Return « ( status ) ; » assert That « ( wrapper . » raw Status Code « ( ) ) . » is Equal To « ( status ) ; }
@Test { » Client Response « . Headers headers = mock ( » Client Response « . Headers . class ) ; given ( » mock Response « . headers ( ) ) . » will Return « ( headers ) ; » assert That « ( wrapper . headers ( ) ) . » is Same As « ( headers ) ; }
@Test { » Multi Value Map « < String , » Response Cookie « > cookies = mock ( » Multi Value Map « . class ) ; given ( » mock Response « . cookies ( ) ) . » will Return « ( cookies ) ; » assert That « ( wrapper . cookies ( ) ) . » is Same As « ( cookies ) ; }
@Test { Mono < String > result = Mono . just ( " foo " ) ; » Body Extractor « < Mono < String > , » Reactive Http Input Message « > extractor = » Body Extractors « . » to Mono « ( String . class ) ; given ( » mock Response « . body ( extractor ) ) . » will Return « ( result ) ; » assert That « ( wrapper . body ( extractor ) ) . » is Same As « ( result ) ; }
@Test { Mono < String > result = Mono . just ( " foo " ) ; given ( » mock Response « . » body To Mono « ( String . class ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Mono « ( String . class ) ) . » is Same As « ( result ) ; }
@Test { Mono < String > result = Mono . just ( " foo " ) ; » Parameterized Type Reference « < String > reference = new » Parameterized Type Reference « < String > ( ) { } ; given ( » mock Response « . » body To Mono « ( reference ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Mono « ( reference ) ) . » is Same As « ( result ) ; }
@Test { Flux < String > result = Flux . just ( " foo " ) ; given ( » mock Response « . » body To Flux « ( String . class ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Flux « ( String . class ) ) . » is Same As « ( result ) ; }
@Test { Flux < String > result = Flux . just ( " foo " ) ; » Parameterized Type Reference « < String > reference = new » Parameterized Type Reference « < String > ( ) { } ; given ( » mock Response « . » body To Flux « ( reference ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Flux « ( reference ) ) . » is Same As « ( result ) ; }
@Test { Mono < » Response Entity « < String > > result = Mono . just ( new » Response Entity « < > ( " foo " , » Http Status « . OK ) ) ; given ( » mock Response « . » to Entity « ( String . class ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » to Entity « ( String . class ) ) . » is Same As « ( result ) ; }
@Test { Mono < » Response Entity « < String > > result = Mono . just ( new » Response Entity « < > ( " foo " , » Http Status « . OK ) ) ; » Parameterized Type Reference « < String > reference = new » Parameterized Type Reference « < String > ( ) { } ; given ( » mock Response « . » to Entity « ( reference ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » to Entity « ( reference ) ) . » is Same As « ( result ) ; }
@Test { Mono < » Response Entity « < List < String > > > result = Mono . just ( new » Response Entity « < > ( » singleton List « ( " foo " ) , » Http Status « . OK ) ) ; given ( » mock Response « . » to Entity List « ( String . class ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » to Entity List « ( String . class ) ) . » is Same As « ( result ) ; }
@Test { Mono < » Response Entity « < List < String > > > result = Mono . just ( new » Response Entity « < > ( » singleton List « ( " foo " ) , » Http Status « . OK ) ) ; » Parameterized Type Reference « < String > reference = new » Parameterized Type Reference « < String > ( ) { } ; given ( » mock Response « . » to Entity List « ( reference ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » to Entity List « ( reference ) ) . » is Same As « ( result ) ; }
@Test { » Request Predicate « predicate = new » Add Attribute Predicate « ( false , " predicate " , " baz " ) . negate ( ) ; boolean result = predicate . test ( this . request ) ; » assert That « ( result ) . » is True « ( ) ; » assert That « ( this . request . attributes ( ) . get ( " exchange " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( this . request . attributes ( ) . get ( " predicate " ) ) . » is Equal To « ( " baz " ) ; }
@Test { » Request Predicate « predicate = new » Add Attribute Predicate « ( true , " predicate " , " baz " ) . negate ( ) ; boolean result = predicate . test ( this . request ) ; » assert That « ( result ) . » is False « ( ) ; » assert That « ( this . request . attributes ( ) . get ( " exchange " ) ) . » is Equal To « ( " bar " ) ; » assert That « ( this . request . attributes ( ) . » contains Key « ( " baz " ) ) . » is False « ( ) ; }
@Test { » Request Predicate « predicate = request -> false ; » Request Predicate « negated = predicate . negate ( ) ; » Mock Server Request « » mock Request « = » Mock Server Request « . builder ( ) . build ( ) ; » assert That « ( negated . test ( » mock Request « ) ) . » is True « ( ) ; predicate = request -> true ; negated = predicate . negate ( ) ; » assert That « ( negated . test ( » mock Request « ) ) . » is False « ( ) ; }
@Test { String name = " foo " ; Mono < » Rendering Response « > result = » Rendering Response « . create ( name ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> name . equals ( response . name ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; Mono < » Rendering Response « > result = » Rendering Response « . create ( " foo " ) . headers ( headers ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> headers . equals ( response . headers ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Rendering Response « > result = » Rendering Response « . create ( " foo " ) . » model Attribute « ( " foo " , " bar " ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " bar " . equals ( response . model ( ) . get ( " foo " ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Rendering Response « > result = » Rendering Response « . create ( " foo " ) . » model Attribute « ( " bar " ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " bar " . equals ( response . model ( ) . get ( " string " ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Map < String , String > model = Collections . » singleton Map « ( " foo " , " bar " ) ; Mono < » Rendering Response « > result = » Rendering Response « . create ( " foo " ) . » model Attributes « ( model ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " bar " . equals ( response . model ( ) . get ( " foo " ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Set < String > model = Collections . singleton ( " bar " ) ; Mono < » Rendering Response « > result = » Rendering Response « . create ( " foo " ) . » model Attributes « ( model ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " bar " . equals ( response . model ( ) . get ( " string " ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . status ( » Http Status « . CREATED ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . CREATED . equals ( response . » status Code « ( ) ) && response . » raw Status Code « ( ) == 201 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . OK . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; Mono < » Server Response « > result = » Server Response « . created ( location ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . CREATED . equals ( response . » status Code « ( ) ) && location . equals ( response . headers ( ) . » get Location « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . accepted ( ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . ACCEPTED . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . » no Content « ( ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » NO _ CONTENT « . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; Mono < » Server Response « > result = » Server Response « . » see Other « ( location ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » SEE _ OTHER « . equals ( response . » status Code « ( ) ) && location . equals ( response . headers ( ) . » get Location « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; Mono < » Server Response « > result = » Server Response « . » temporary Redirect « ( location ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » TEMPORARY _ REDIRECT « . equals ( response . » status Code « ( ) ) && location . equals ( response . headers ( ) . » get Location « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; Mono < » Server Response « > result = » Server Response « . » permanent Redirect « ( location ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » PERMANENT _ REDIRECT « . equals ( response . » status Code « ( ) ) && location . equals ( response . headers ( ) . » get Location « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . » bad Request « ( ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » BAD _ REQUEST « . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . » not Found « ( ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » NOT _ FOUND « . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . » unprocessable Entity « ( ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . » UNPROCESSABLE _ ENTITY « . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . allow ( » Http Method « . GET ) . build ( ) ; Set < » Http Method « > expected = » Enum Set « . of ( » Http Method « . GET ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> expected . equals ( response . headers ( ) . » get Allow « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . » content Length « ( 42 ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> Long . » value Of « ( 42 ) . equals ( response . headers ( ) . » get Content Length « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Media Type « . » APPLICATION _ JSON « . equals ( response . headers ( ) . » get Content Type « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . » e Tag « ( " foo " ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " \" foo \" " . equals ( response . headers ( ) . » get E Tag « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Zoned Date Time « now = » Zoned Date Time « . now ( ) ; Mono < » Server Response « > result = » Server Response « . ok ( ) . » last Modified « ( now ) . build ( ) ; Long expected = now . » to Instant « ( ) . » to Epoch Milli « ( ) / 1000 ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> expected . equals ( response . headers ( ) . » get Last Modified « ( ) / 1000 ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . » cache Control « ( » Cache Control « . » no Cache « ( ) ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " no - cache " . equals ( response . headers ( ) . » get Cache Control « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < » Server Response « > result = » Server Response « . ok ( ) . » vary By « ( " foo " ) . build ( ) ; List < String > expected = Collections . » singleton List « ( " foo " ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> expected . equals ( response . headers ( ) . » get Vary « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Http Status « » status Code « = » Http Status « . ACCEPTED ; Mono < » Server Response « > result = » Server Response « . status ( » status Code « ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » status Code « . equals ( response . » status Code « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Http Headers « » new Headers « = new » Http Headers « ( ) ; » new Headers « . set ( " foo " , " bar " ) ; Mono < » Server Response « > result = » Server Response « . ok ( ) . headers ( headers -> headers . » add All « ( » new Headers « ) ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » new Headers « . equals ( response . headers ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Multi Value Map « < String , » Response Cookie « > » new Cookies « = new » Linked Multi Value Map « < > ( ) ; » new Cookies « . add ( " name " , » Response Cookie « . from ( " name " , " value " ) . build ( ) ) ; Mono < » Server Response « > result = » Server Response « . ok ( ) . cookies ( cookies -> cookies . » add All « ( » new Cookies « ) ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » new Cookies « . equals ( response . cookies ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Mono < Void > mono = Mono . empty ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » Server Response « . ok ( ) . » body Value « ( mono ) ) ; }
@Test { » Handler Strategies « strategies = » Handler Strategies « . empty ( ) . build ( ) ; » assert That « ( strategies . » message Readers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; » assert That « ( strategies . » message Writers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; » assert That « ( strategies . » view Resolvers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Handler Strategies « strategies = » Handler Strategies « . » with Defaults « ( ) ; » assert That « ( strategies . » message Readers « ( ) . » is Empty « ( ) ) . » is False « ( ) ; » assert That « ( strategies . » message Writers « ( ) . » is Empty « ( ) ) . » is False « ( ) ; » assert That « ( strategies . » view Resolvers « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Class Path Resource « location = new » Class Path Resource « ( " org / springframework / web / reactive / function / server / " ) ; » Path Resource Lookup Function « function = new » Path Resource Lookup Function « ( " » / resources / « * * " , location ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . uri ( new URI ( " http : » // localhost / resources / foo « " ) ) . build ( ) ; Mono < Resource > result = function . apply ( request ) ; » Step Verifier « . create ( result ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; » Entity Response « < String > response = » Entity Response « . » from Object « ( body ) . build ( ) . block ( ) ; » assert That « ( response . entity ( ) ) . » is Same As « ( body ) ; }
@Test { Flux < String > body = Flux . just ( " foo " , " bar " ) ; » Entity Response « < Flux < String > > response = » Entity Response « . » from Publisher « ( body , String . class ) . build ( ) . block ( ) ; » assert That « ( response . entity ( ) ) . » is Same As « ( body ) ; }
@Test { Flux < String > body = Flux . just ( " foo " , " bar " ) ; » Parameterized Type Reference « < String > » type Reference « = new » Parameterized Type Reference « < String > ( ) { } ; » Entity Response « < Flux < String > > response = » Entity Response « . » from Publisher « ( body , » type Reference « ) . build ( ) . block ( ) ; » assert That « ( response . entity ( ) ) . » is Same As « ( body ) ; }
@Test { Single < String > body = Single . just ( " foo " ) ; » Parameterized Type Reference « < String > » type Reference « = new » Parameterized Type Reference « < String > ( ) { } ; » Entity Response « < Single < String > > response = » Entity Response « . » from Producer « ( body , » type Reference « ) . build ( ) . block ( ) ; » assert That « ( response . entity ( ) ) . » is Same As « ( body ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . status ( » Http Status « . CREATED ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Http Status « . CREATED . equals ( response . » status Code « ( ) ) && response . » raw Status Code « ( ) == 201 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . allow ( » Http Method « . GET ) . build ( ) ; Set < » Http Method « > expected = » Enum Set « . of ( » Http Method « . GET ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> expected . equals ( response . headers ( ) . » get Allow « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . » content Length « ( 42 ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> Long . » value Of « ( 42 ) . equals ( response . headers ( ) . » get Content Length « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> » Media Type « . » APPLICATION _ JSON « . equals ( response . headers ( ) . » get Content Type « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . » e Tag « ( " foo " ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " \" foo \" " . equals ( response . headers ( ) . » get E Tag « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Zoned Date Time « now = » Zoned Date Time « . now ( ) ; String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . » last Modified « ( now ) . build ( ) ; Long expected = now . » to Instant « ( ) . » to Epoch Milli « ( ) / 1000 ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> expected . equals ( response . headers ( ) . » get Last Modified « ( ) / 1000 ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . » cache Control « ( » Cache Control « . » no Cache « ( ) ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> " no - cache " . equals ( response . headers ( ) . » get Cache Control « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . » vary By « ( " foo " ) . build ( ) ; List < String > expected = Collections . » singleton List « ( " foo " ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> expected . equals ( response . headers ( ) . » get Vary « ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String body = " foo " ; » Http Headers « headers = new » Http Headers « ( ) ; Mono < » Entity Response « < String > > result = » Entity Response « . » from Object « ( body ) . headers ( headers ) . build ( ) ; » Step Verifier « . create ( result ) . » expect Next Matches « ( response -> headers . equals ( response . headers ( ) ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Http Method « method = » Http Method « . HEAD ; » Default Server Request « request = new » Default Server Request « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . method ( method , " https : » // example . com « " ) ) , this . » message Readers « ) ; » assert That « ( request . method ( ) ) . » is Equal To « ( method ) ; }
@Test { URI uri = URI . create ( " https : » // example . com « " ) ; » Default Server Request « request = new » Default Server Request « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . method ( » Http Method « . GET , uri ) ) , this . » message Readers « ) ; » assert That « ( request . uri ( ) ) . » is Equal To « ( uri ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . method ( » Http Method « . GET , " https : » // example . com « " ) ) ; exchange . » get Attributes « ( ) . put ( " foo " , " bar " ) ; » Default Server Request « request = new » Default Server Request « ( exchange , » message Readers « ) ; » assert That « ( request . attribute ( " foo " ) ) . » is Equal To « ( Optional . of ( " bar " ) ) ; }
@Test { » Default Server Request « request = new » Default Server Request « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . method ( » Http Method « . GET , " https : » // example . com « ? » foo = bar « " ) ) , this . » message Readers « ) ; » assert That « ( request . » query Param « ( " foo " ) ) . » is Equal To « ( Optional . of ( " bar " ) ) ; }
@Test { » Default Server Request « request = new » Default Server Request « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . method ( » Http Method « . GET , " https : » // example . com « ? foo " ) ) , this . » message Readers « ) ; » assert That « ( request . » query Param « ( " foo " ) ) . » is Equal To « ( Optional . of ( " " ) ) ; }
@Test { » Default Server Request « request = new » Default Server Request « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . method ( » Http Method « . GET , " https : » // example . com « ? foo " ) ) , this . » message Readers « ) ; » assert That « ( request . » query Param « ( " bar " ) ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " https : » // example . com « " ) ) ; Map < String , String > » path Variables « = Collections . » singleton Map « ( " foo " , " bar " ) ; exchange . » get Attributes « ( ) . put ( » Router Functions « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » path Variables « ) ; » Default Server Request « request = new » Default Server Request « ( exchange , » message Readers « ) ; » assert That « ( request . » path Variables « ( ) ) . » is Equal To « ( » path Variables « ) ; }
@Test { » Request Predicate « predicate = » Request Predicates « . all ( ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; }
@Test { » Http Method « » http Method « = » Http Method « . GET ; » Request Predicate « predicate = » Request Predicates « . method ( » http Method « ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . method ( » http Method « ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; request = » Mock Server Request « . builder ( ) . method ( » Http Method « . POST ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { URI uri = URI . create ( " http : » // localhost / path « " ) ; » Request Predicate « predicate = » Request Predicates « . path ( " / p * " ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . uri ( uri ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; request = » Mock Server Request « . builder ( ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { URI uri = URI . create ( " http : » // localhost / path « " ) ; » Request Predicate « predicate = » Request Predicates « . path ( " p * " ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . uri ( uri ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; }
@Test { URI uri = URI . create ( " http : » // localhost / foo « % » 20 bar « " ) ; » Request Predicate « predicate = » Request Predicates « . path ( " / foo bar " ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . uri ( uri ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; request = » Mock Server Request « . builder ( ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { » Path Pattern Parser « parser = new » Path Pattern Parser « ( ) ; parser . » set Case Sensitive « ( false ) ; Function < String , » Request Predicate « > » path Predicates « = » Request Predicates « . » path Predicates « ( parser ) ; URI uri = URI . create ( " http : » // localhost / path « " ) ; » Request Predicate « predicate = » path Predicates « . apply ( " / P * " ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . uri ( uri ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; }
@Test { String name = " » My Header « " ; String value = " » My Value « " ; » Request Predicate « predicate = » Request Predicates « . headers ( headers -> headers . header ( name ) . equals ( Collections . » singleton List « ( value ) ) ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . header ( name , value ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; request = » Mock Server Request « . builder ( ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { » Media Type « json = » Media Type « . » APPLICATION _ JSON « ; » Request Predicate « predicate = » Request Predicates « . » content Type « ( json ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . header ( " Content - Type " , json . » to String « ( ) ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; request = » Mock Server Request « . builder ( ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { » Media Type « json = » Media Type « . » APPLICATION _ JSON « ; » Request Predicate « predicate = » Request Predicates « . accept ( json ) ; » Mock Server Request « request = » Mock Server Request « . builder ( ) . header ( " Accept " , json . » to String « ( ) ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; request = » Mock Server Request « . builder ( ) . header ( " Accept " , » Media Type « . » TEXT _ XML _ VALUE « ) . build ( ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { » Mock Server Request « request = » Mock Server Request « . builder ( ) . » query Param « ( " foo " , " bar " ) . build ( ) ; » Request Predicate « predicate = » Request Predicates « . » query Param « ( " foo " , s -> s . equals ( " bar " ) ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; predicate = » Request Predicates « . » query Param « ( " foo " , s -> s . equals ( " baz " ) ) ; » assert That « ( predicate . test ( request ) ) . » is False « ( ) ; }
@Test { List < » Media Type « > accept = Collections . » singleton List « ( » Media Type « . » APPLICATION _ JSON « ) ; given ( » mock Headers « . accept ( ) ) . » will Return « ( accept ) ; » assert That « ( wrapper . accept ( ) ) . » is Same As « ( accept ) ; }
@Test { List < Charset > » accept Charset « = Collections . » singleton List « ( » Standard Charsets « . » UTF _ 8 « ) ; given ( » mock Headers « . » accept Charset « ( ) ) . » will Return « ( » accept Charset « ) ; » assert That « ( wrapper . » accept Charset « ( ) ) . » is Same As « ( » accept Charset « ) ; }
@Test { » Optional Long « » content Length « = » Optional Long « . of ( 42L ) ; given ( » mock Headers « . » content Length « ( ) ) . » will Return « ( » content Length « ) ; » assert That « ( wrapper . » content Length « ( ) ) . » is Same As « ( » content Length « ) ; }
@Test { Optional < » Media Type « > » content Type « = Optional . of ( » Media Type « . » APPLICATION _ JSON « ) ; given ( » mock Headers « . » content Type « ( ) ) . » will Return « ( » content Type « ) ; » assert That « ( wrapper . » content Type « ( ) ) . » is Same As « ( » content Type « ) ; }
@Test { » Inet Socket Address « host = » Inet Socket Address « . » create Unresolved « ( " example . com " , 42 ) ; given ( » mock Headers « . host ( ) ) . » will Return « ( host ) ; » assert That « ( wrapper . host ( ) ) . » is Same As « ( host ) ; }
@Test { List < » Http Range « > range = Collections . » singleton List « ( » Http Range « . » create Byte Range « ( 42 ) ) ; given ( » mock Headers « . range ( ) ) . » will Return « ( range ) ; » assert That « ( wrapper . range ( ) ) . » is Same As « ( range ) ; }
@Test { String name = " foo " ; List < String > value = Collections . » singleton List « ( " bar " ) ; given ( » mock Headers « . header ( name ) ) . » will Return « ( value ) ; » assert That « ( wrapper . header ( name ) ) . » is Same As « ( value ) ; }
@Test { » Http Headers « » http Headers « = new » Http Headers « ( ) ; given ( » mock Headers « . » as Http Headers « ( ) ) . » will Return « ( » http Headers « ) ; » assert That « ( wrapper . » as Http Headers « ( ) ) . » is Same As « ( » http Headers « ) ; }
@Test { » assert That « ( wrapper . request ( ) ) . » is Same As « ( » mock Request « ) ; }
@Test { » Http Method « method = » Http Method « . POST ; given ( » mock Request « . method ( ) ) . » will Return « ( method ) ; » assert That « ( wrapper . method ( ) ) . » is Same As « ( method ) ; }
@Test { URI uri = URI . create ( " https : » // example . com « " ) ; given ( » mock Request « . uri ( ) ) . » will Return « ( uri ) ; » assert That « ( wrapper . uri ( ) ) . » is Same As « ( uri ) ; }
@Test { String path = " / foo / bar " ; given ( » mock Request « . path ( ) ) . » will Return « ( path ) ; » assert That « ( wrapper . path ( ) ) . » is Same As « ( path ) ; }
@Test { » Server Request « . Headers headers = mock ( » Server Request « . Headers . class ) ; given ( » mock Request « . headers ( ) ) . » will Return « ( headers ) ; » assert That « ( wrapper . headers ( ) ) . » is Same As « ( headers ) ; }
@Test { String name = " foo " ; String value = " bar " ; given ( » mock Request « . attribute ( name ) ) . » will Return « ( Optional . of ( value ) ) ; » assert That « ( wrapper . attribute ( name ) ) . » is Equal To « ( Optional . of ( value ) ) ; }
@Test { String name = " foo " ; String value = " bar " ; given ( » mock Request « . » query Param « ( name ) ) . » will Return « ( Optional . of ( value ) ) ; » assert That « ( wrapper . » query Param « ( name ) ) . » is Equal To « ( Optional . of ( value ) ) ; }
@Test { » Multi Value Map « < String , String > value = new » Linked Multi Value Map « < > ( ) ; value . add ( " foo " , " bar " ) ; given ( » mock Request « . » query Params « ( ) ) . » will Return « ( value ) ; » assert That « ( wrapper . » query Params « ( ) ) . » is Same As « ( value ) ; }
@Test { String name = " foo " ; String value = " bar " ; given ( » mock Request « . » path Variable « ( name ) ) . » will Return « ( value ) ; » assert That « ( wrapper . » path Variable « ( name ) ) . » is Equal To « ( value ) ; }
@Test { Map < String , String > » path Variables « = Collections . » singleton Map « ( " foo " , " bar " ) ; given ( » mock Request « . » path Variables « ( ) ) . » will Return « ( » path Variables « ) ; » assert That « ( wrapper . » path Variables « ( ) ) . » is Same As « ( » path Variables « ) ; }
@Test { » Multi Value Map « < String , » Http Cookie « > cookies = mock ( » Multi Value Map « . class ) ; given ( » mock Request « . cookies ( ) ) . » will Return « ( cookies ) ; » assert That « ( wrapper . cookies ( ) ) . » is Same As « ( cookies ) ; }
@Test { Mono < String > result = Mono . just ( " foo " ) ; » Body Extractor « < Mono < String > , » Reactive Http Input Message « > extractor = » Body Extractors « . » to Mono « ( String . class ) ; given ( » mock Request « . body ( extractor ) ) . » will Return « ( result ) ; » assert That « ( wrapper . body ( extractor ) ) . » is Same As « ( result ) ; }
@Test { Mono < String > result = Mono . just ( " foo " ) ; given ( » mock Request « . » body To Mono « ( String . class ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Mono « ( String . class ) ) . » is Same As « ( result ) ; }
@Test { Mono < String > result = Mono . just ( " foo " ) ; » Parameterized Type Reference « < String > reference = new » Parameterized Type Reference « < String > ( ) { } ; given ( » mock Request « . » body To Mono « ( reference ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Mono « ( reference ) ) . » is Same As « ( result ) ; }
@Test { Flux < String > result = Flux . just ( " foo " ) ; given ( » mock Request « . » body To Flux « ( String . class ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Flux « ( String . class ) ) . » is Same As « ( result ) ; }
@Test { Flux < String > result = Flux . just ( " foo " ) ; » Parameterized Type Reference « < String > reference = new » Parameterized Type Reference « < String > ( ) { } ; given ( » mock Request « . » body To Flux « ( reference ) ) . » will Return « ( result ) ; » assert That « ( wrapper . » body To Flux « ( reference ) ) . » is Same As « ( result ) ; }
@Test { » Router Function « < » Server Response « > » router Function « = request -> Mono . empty ( ) ; » Router Function Mapping « mapping = new » Router Function Mapping « ( » router Function « ) ; mapping . » set Message Readers « ( this . » codec Configurer « . » get Readers « ( ) ) ; Mono < Object > result = mapping . » get Handler « ( this . exchange ) ; » Step Verifier « . create ( result ) . » expect Complete « ( ) . verify ( ) ; }
@Test { Throwable ex = new » Custom Exception « ( ) ; this . handler . handle ( this . exchange , ex ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » I _ AM _ A _ TEAPOT « ) ; }
@Test { Throwable ex = new Exception ( new » Custom Exception « ( ) ) ; this . handler . handle ( this . exchange , ex ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » I _ AM _ A _ TEAPOT « ) ; }
@Test { String origin = " https : » // domain 2 . com « " ; » Server Web Exchange « exchange = » create Exchange « ( » Http Method « . GET , " / welcome . html " , origin ) ; Object actual = this . » handler Mapping « . » get Handler « ( exchange ) . block ( ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual ) . » is Same As « ( this . » welcome Controller « ) ; }
@Test { String origin = " https : » // domain 2 . com « " ; » Server Web Exchange « exchange = » create Exchange « ( » Http Method « . OPTIONS , " / welcome . html " , origin ) ; Object actual = this . » handler Mapping « . » get Handler « ( exchange ) . block ( ) ; » assert That « ( actual ) . » is Not Null « ( ) ; » assert That « ( actual ) . » is Not Same As « ( this . » welcome Controller « ) ; }
@Test { String file = " something / something . js " ; given ( this . chain . » resolve Url Path « ( file , this . locations ) ) . » will Return « ( Mono . empty ( ) ) ; String actual = this . resolver . » resolve Url Path « ( file , this . locations , this . chain ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Null « ( ) ; verify ( this . chain , times ( 1 ) ) . » resolve Url Path « ( file , this . locations ) ; verify ( this . chain , never ( ) ) . » resolve Url Path « ( null , this . locations ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / static / foo . css " ) ) ; Resource expected = » get Resource « ( " foo . css " ) ; Resource actual = this . transformer . transform ( exchange , expected , this . chain ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / static / error . appcache " ) ) ; Resource expected = » get Resource « ( " error . appcache " ) ; Resource actual = this . transformer . transform ( exchange , expected , this . chain ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { Resource expected = new » Class Path Resource « ( " test / bar . css " , » get Class « ( ) ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " " ) ) ; Resource actual = this . chain . » resolve Resource « ( exchange , " bar . css " , this . locations ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Not Same As « ( expected ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { Resource expected = Mockito . mock ( Resource . class ) ; this . cache . put ( » resource Key « ( " bar . css " ) , expected ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " " ) ) ; Resource actual = this . chain . » resolve Resource « ( exchange , " bar . css " , this . locations ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " " ) ) ; » assert That « ( this . chain . » resolve Resource « ( exchange , " invalid . css " , this . locations ) . block ( TIMEOUT ) ) . » is Null « ( ) ; }
@Test { String expected = " / foo . css " ; String actual = this . chain . » resolve Url Path « ( expected , this . locations ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { String expected = " cached - imaginary . css " ; this . cache . put ( » Caching Resource Resolver « . » RESOLVED _ URL _ PATH _ CACHE _ KEY _ PREFIX « + " imaginary . css " , expected ) ; String actual = this . chain . » resolve Url Path « ( " imaginary . css " , this . locations ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( this . chain . » resolve Url Path « ( " invalid . css " , this . locations ) . block ( TIMEOUT ) ) . » is Null « ( ) ; }
@Test { String file = " bar . css " ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( file ) ) ; Resource expected = this . chain . » resolve Resource « ( exchange , file , this . locations ) . block ( TIMEOUT ) ; String » cache Key « = » resource Key « ( file ) ; Object actual = this . cache . get ( » cache Key « ) . get ( ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { String hash = " 7f » be 76 cdac 6093784895 bb 4989203 e 5 a « " ; String path = " font - awesome / css / font - awesome . min - " + hash + " . css " ; » assert That « ( this . strategy . » extract Version « ( path ) ) . » is Equal To « ( hash ) ; » assert That « ( this . strategy . » extract Version « ( " foo / bar . css " ) ) . » is Null « ( ) ; }
@Test { String hash = " 7f » be 76 cdac 6093784895 bb 4989203 e 5 a « " ; String path = " font - awesome / css / font - awesome . min % s % s . css " ; » assert That « ( this . strategy . » remove Version « ( String . format ( path , " - " , hash ) , hash ) ) . » is Equal To « ( String . format ( path , " " , " " ) ) ; }
@Test { Resource expected = new » Class Path Resource « ( " test / bar . css " , » get Class « ( ) ) ; String hash = » Digest Utils « . » md 5 Digest As Hex « ( » File Copy Utils « . » copy To Byte Array « ( expected . » get Input Stream « ( ) ) ) ; » assert That « ( this . strategy . » get Resource Version « ( expected ) . block ( ) ) . » is Equal To « ( hash ) ; }
@Test { » assert That « ( this . strategy . » add Version « ( " test / bar . css " , " 123 " ) ) . » is Equal To « ( " test / bar - 123. css " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / static / foo . css " ) ) ; Resource expected = » get Resource « ( " foo . css " ) ; » Step Verifier « . create ( this . » transformer Chain « . transform ( exchange , expected ) ) . » consume Next With « ( resource -> » assert That « ( resource ) . » is Same As « ( expected ) ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / static / images / image . png " ) ) ; Resource expected = » get Resource « ( " images / image . png " ) ; » Step Verifier « . create ( this . » transformer Chain « . transform ( exchange , expected ) ) . » expect Next « ( expected ) . » expect Complete « ( ) . verify ( ) ; }
@Test { String file = " js / foo . js " ; Resource resolved = this . resolver . » resolve Resource « ( null , file , this . locations ) . block ( TIMEOUT ) ; » assert That « ( resolved . » get Description « ( ) ) . » is Equal To « ( » get Resource « ( file ) . » get Description « ( ) ) ; » assert That « ( resolved . » get Filename « ( ) ) . » is Equal To « ( » get Resource « ( file ) . » get Filename « ( ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Fixed Version Strategy « ( " " ) ) ; }
@Test { » assert That « ( this . strategy . » extract Version « ( VERSION + " / " + PATH ) ) . » is Equal To « ( VERSION ) ; » assert That « ( this . strategy . » extract Version « ( PATH ) ) . » is Null « ( ) ; }
@Test { » assert That « ( this . strategy . » remove Version « ( VERSION + " / " + PATH , VERSION ) ) . » is Equal To « ( ( " / " + PATH ) ) ; }
@Test { » assert That « ( this . strategy . » add Version « ( " / " + PATH , VERSION ) ) . » is Equal To « ( ( VERSION + " / " + PATH ) ) ; }
@Test { String » relative Path « = " . . / " + PATH ; » assert That « ( this . strategy . » add Version « ( » relative Path « , VERSION ) ) . » is Equal To « ( » relative Path « ) ; }
@Test { Resource resource = » get Resource « ( " main . css " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; String actual = this . transformer . » resolve Url Path « ( " bar . css " , exchange , resource , this . chain ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( " bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { Resource resource = » get Resource « ( " images / image . png " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; String actual = this . transformer . » resolve Url Path « ( " . . / bar . css " , exchange , resource , this . chain ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( " . . / bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / resources / main . css " ) ) ; String absolute = this . transformer . » to Absolute Path « ( " img / image . png " , exchange ) ; » assert That « ( absolute ) . » is Equal To « ( " / resources / img / image . png " ) ; absolute = this . transformer . » to Absolute Path « ( " / img / image . png " , exchange ) ; » assert That « ( absolute ) . » is Equal To « ( " / img / image . png " ) ; }
@Test { String expected = " / resources / foo . css " ; String actual = this . » url Provider « . » get For Uri String « ( expected , this . exchange ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » Annotation Config Web Application Context « context = new » Annotation Config Web Application Context « ( ) ; context . » set Servlet Context « ( new » Mock Servlet Context « ( ) ) ; context . register ( » Handler Mapping Configuration « . class ) ; context . refresh ( ) ; » assert That « ( context . » get Bean « ( » Resource Url Provider « . class ) . » get Handler Map « ( ) ) . » has Key Satisfying « ( » path Pattern String Of « ( " » / resources / « * * " ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . options ( " " ) ) ; » set Path Within Handler Mapping « ( exchange , " foo . css " ) ; this . handler . handle ( exchange ) . block ( TIMEOUT ) ; » assert That « ( exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Null « ( ) ; » assert That « ( exchange . » get Response « ( ) . » get Headers « ( ) . » get First « ( " Allow " ) ) . » is Equal To « ( " GET , HEAD , OPTIONS " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; » set Path Within Handler Mapping « ( exchange , " js / foo . js " ) ; this . handler . handle ( exchange ) . block ( TIMEOUT ) ; » assert That « ( exchange . » get Response « ( ) . » get Headers « ( ) . » get Content Type « ( ) ) . » is Equal To « ( » Media Type « . » parse Media Type « ( " application / javascript " ) ) ; » assert Response Body « ( exchange , " function foo ( ) { console . log ( \" hello world \" ) ; } " ) ; }
@Test { for ( » Http Method « method : » Http Method « . values ( ) ) { » test Resolve Path With Traversal « ( method ) ; } }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) . » if Modified Since « ( » resource Last Modified « ( " test / foo . css " ) ) ) ; » set Path Within Handler Mapping « ( exchange , " foo . css " ) ; this . handler . handle ( exchange ) . block ( TIMEOUT ) ; » assert That « ( exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ MODIFIED « ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; » set Path Within Handler Mapping « ( exchange , " js / " ) ; » Step Verifier « . create ( this . handler . handle ( exchange ) ) . » expect Error Satisfies « ( err -> { » assert That « ( err ) . » is Instance Of « ( » Response Status Exception « . class ) ; » assert That « ( ( ( » Response Status Exception « ) err ) . » get Status « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; } ) . verify ( TIMEOUT ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; » set Path Within Handler Mapping « ( exchange , " underscorejs / " ) ; » Step Verifier « . create ( this . handler . handle ( exchange ) ) . » expect Error Satisfies « ( err -> { » assert That « ( err ) . » is Instance Of « ( » Response Status Exception « . class ) ; » assert That « ( ( ( » Response Status Exception « ) err ) . » get Status « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; } ) . verify ( TIMEOUT ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; » set Path Within Handler Mapping « ( exchange , " " ) ; » Step Verifier « . create ( this . handler . handle ( exchange ) ) . » expect Error Satisfies « ( err -> { » assert That « ( err ) . » is Instance Of « ( » Response Status Exception « . class ) ; » assert That « ( ( ( » Response Status Exception « ) err ) . » get Status « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; } ) . verify ( TIMEOUT ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " " ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . handler . handle ( exchange ) . block ( TIMEOUT ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . post ( " " ) ) ; » set Path Within Handler Mapping « ( exchange , " foo . css " ) ; » assert That Exception Of Type « ( » Method Not Allowed Exception « . class ) . » is Thrown By « ( ( ) -> this . handler . handle ( exchange ) . block ( TIMEOUT ) ) ; }
@Test { for ( » Http Method « method : » Http Method « . values ( ) ) { » resource Not Found « ( method ) ; } }
@Test { String file = " missing . css " ; given ( this . chain . » resolve Resource « ( null , file , this . locations ) ) . » will Return « ( Mono . empty ( ) ) ; this . resolver . » set Strategy Map « ( Collections . » empty Map « ( ) ) ; Resource actual = this . resolver . » resolve Resource Internal « ( null , file , this . locations , this . chain ) . block ( Duration . » of Millis « ( 5000 ) ) ; » assert That « ( ( Object ) actual ) . » is Null « ( ) ; verify ( this . chain , times ( 1 ) ) . » resolve Resource « ( null , file , this . locations ) ; }
@Test { given ( this . chain . » resolve Url Path « ( " / foo . css " , this . locations ) ) . » will Return « ( Mono . just ( " / foo . css " ) ) ; String resolved = this . resolver . » resolve Url Path Internal « ( " / foo . css " , this . locations , this . chain ) . block ( Duration . » of Millis « ( 1000 ) ) ; » assert That « ( resolved ) . » is Equal To « ( " / foo . css " ) ; }
@Test { Resource location = new » Class Path Resource « ( " test / " , » Path Resource Resolver « . class ) ; String path = " bar . css " ; List < Resource > locations = » singleton List « ( location ) ; Resource actual = this . resolver . » resolve Resource « ( null , path , locations , null ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( location . » create Relative « ( path ) ) ; }
@Test { Resource location = new » Class Path Resource « ( " / " ) ; String path = " org / springframework / web / reactive / resource / test / bar . css " ; List < Resource > locations = » singleton List « ( location ) ; Resource actual = this . resolver . » resolve Resource « ( null , path , locations , null ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Not Null « ( ) ; }
@Test { Resource » classpath Location « = new » Class Path Resource « ( " test / " , » Path Resource Resolver « . class ) ; » test With Encoded Path « ( » classpath Location « ) ; » test With Encoded Path « ( new » File Url Resource « ( » classpath Location « . » get URL « ( ) ) ) ; }
@Test { » Url Resource « location = new » Url Resource « ( » get Class « ( ) . » get Resource « ( " . / test / " ) ) ; Resource resource = location . » create Relative « ( " test % file . txt " ) ; » assert That « ( this . resolver . » check Resource « ( resource , location ) ) . » is True « ( ) ; }
@Test { this . resolver . » set Allowed Locations « ( new » Class Path Resource « ( " test / " , » Path Resource Resolver « . class ) , new » Class Path Resource « ( " testalternatepath / " , » Path Resource Resolver « . class ) ) ; Resource location = » get Resource « ( " main . css " ) ; String actual = this . resolver . » resolve Url Path « ( " . . / testalternatepath / bar . css " , » singleton List « ( location ) , null ) . block ( TIMEOUT ) ; » assert That « ( actual ) . » is Equal To « ( " . . / testalternatepath / bar . css " ) ; }
@Test { String » location Url « = new » Url Resource « ( » get Class « ( ) . » get Resource « ( " . / test / " ) ) . » get URL « ( ) . » to External Form « ( ) ; Resource location = new » Url Resource « ( » location Url « . replace ( " / springframework " , " / . . / org / springframework " ) ) ; List < Resource > locations = » singleton List « ( location ) ; » assert That « ( this . resolver . » resolve Resource « ( null , " main . css " , locations , null ) . block ( TIMEOUT ) ) . » is Not Null « ( ) ; }
@Test { Resource resource = » get Resource « ( " main . css " ) ; » assert That « ( this . resolver . » check Resource « ( resource , resource ) ) . » is True « ( ) ; }
@Test { Resource » webjars Location « = new » Class Path Resource « ( " / META - INF / resources / webjars / " , » Path Resource Resolver « . class ) ; String path = this . resolver . » resolve Url Path Internal « ( " " , » singleton List « ( » webjars Location « ) , null ) . block ( TIMEOUT ) ; » assert That « ( path ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path " ) . header ( " Accept " , " text / plain ; q = 0.5 , application / json " ) ) ; List < » Media Type « > » media Types « = Arrays . » as List « ( » TEXT _ PLAIN « , » APPLICATION _ JSON « ) ; » Media Type « actual = this . » result Handler « . » select Media Type « ( exchange , ( ) -> » media Types « ) ; » assert That « ( actual ) . » is Equal To « ( » APPLICATION _ JSON « ) ; }
@Test { List < » Media Type « > producible = Collections . » singleton List « ( ALL ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path " ) ) ; » Media Type « actual = this . » result Handler « . » select Media Type « ( exchange , ( ) -> producible ) ; » assert That « ( actual ) . » is Equal To « ( » APPLICATION _ OCTET _ STREAM « ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path " ) . header ( " Accept " , " text / plain ; q = 0.5 " ) ) ; List < » Media Type « > » media Types « = Arrays . » as List « ( » APPLICATION _ JSON « , » TEXT _ PLAIN « ) ; » Media Type « actual = this . » result Handler « . » select Media Type « ( exchange , ( ) -> » media Types « ) ; » assert That « ( actual ) . » is Equal To « ( » TEXT _ PLAIN « ) ; }
@Test { » assert That Exception Of Type « ( » Pattern Parse Exception « . class ) . » is Thrown By « ( ( ) -> paths ( " / { foo " ) . build ( ) ) . » with Message Containing « ( " Expected close capture character after variable name } " ) ; }
@Test { » Request Mapping Info « actual = paths ( " foo " ) . build ( ) ; List < » Path Pattern « > patterns = new » Array List « < > ( actual . » get Patterns Condition « ( ) . » get Patterns « ( ) ) ; » assert That « ( patterns . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( patterns . get ( 0 ) . » get Pattern String « ( ) ) . » is Equal To « ( " / foo " ) ; }
@Test { » Composite Request Condition « » cond 1 « = new » Composite Request Condition « ( this . » param 1 « , this . » header 1 « ) ; » Composite Request Condition « » cond 2 « = new » Composite Request Condition « ( this . » param 2 « , this . » header 2 « ) ; » Composite Request Condition « » cond 3 « = new » Composite Request Condition « ( this . » param 3 « , this . » header 3 « ) ; » assert That « ( » cond 1 « . combine ( » cond 2 « ) ) . » is Equal To « ( » cond 3 « ) ; }
@Test { » Composite Request Condition « empty = new » Composite Request Condition « ( ) ; » Composite Request Condition « » not Empty « = new » Composite Request Condition « ( this . » param 1 « ) ; » assert That « ( empty . combine ( empty ) ) . » is Same As « ( empty ) ; » assert That « ( » not Empty « . combine ( empty ) ) . » is Same As « ( » not Empty « ) ; » assert That « ( empty . combine ( » not Empty « ) ) . » is Same As « ( » not Empty « ) ; }
@Test { » Composite Request Condition « » cond 1 « = new » Composite Request Condition « ( this . » param 1 « ) ; » Composite Request Condition « » cond 2 « = new » Composite Request Condition « ( this . » param 1 « , this . » header 1 « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » cond 1 « . combine ( » cond 2 « ) ) ; }
@Test { » Composite Request Condition « cond = new » Composite Request Condition « ( this . » param 1 « ) ; » assert That « ( cond . » get Matching Condition « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ) . » is Null « ( ) ; }
@Test { » Composite Request Condition « empty = new » Composite Request Condition « ( ) ; » assert That « ( empty . » get Matching Condition « ( » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ) . » is Same As « ( empty ) ; }
@Test { » Composite Request Condition « » cond 1 « = new » Composite Request Condition « ( this . » param 1 « ) ; » Composite Request Condition « » cond 2 « = new » Composite Request Condition « ( this . » param 1 « , this . » header 1 « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » cond 1 « . » compare To « ( » cond 2 « , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " text / plain " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " text / plain " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " ! text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " ! application / xml " ) ; » assert That « ( condition . » get Consumable Media Types « ( ) ) . » is Equal To « ( Collections . » empty Set « ( ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " text / plain " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " » text / « * " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " text / plain " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " , " application / xml " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " application / xml " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " 01 " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " 01 " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " ! text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Consumes Request Condition « » condition 1 « = new » Consumes Request Condition « ( " text / plain " ) ; » Consumes Request Condition « » condition 2 « = new » Consumes Request Condition « ( " application / xml " ) ; » Consumes Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; » assert That « ( result ) . » is Equal To « ( » condition 2 « ) ; }
@Test { » Consumes Request Condition « » condition 1 « = new » Consumes Request Condition « ( " text / plain " ) ; » Consumes Request Condition « » condition 2 « = new » Consumes Request Condition « ( ) ; » Consumes Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; » assert That « ( result ) . » is Equal To « ( » condition 1 « ) ; }
@Test { String [ ] consumes = new String [ ] { " text / plain " } ; String [ ] headers = new String [ ] { " foo = bar " , " content - type = application / xml , application / pdf " } ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( consumes , headers ) ; » assert Conditions « ( condition , " text / plain " , " application / xml " , " application / pdf " ) ; }
@Test { » Mock Server Web Exchange « exchange = » post Exchange « ( " text / plain " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " , " application / xml " ) ; » Consumes Request Condition « result = condition . » get Matching Condition « ( exchange ) ; » assert Conditions « ( result , " text / plain " ) ; condition = new » Consumes Request Condition « ( " application / xml " ) ; result = condition . » get Matching Condition « ( exchange ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " accept " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " bar " , " " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " ! accept " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " foo " , " bar " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo = bar " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " foo " , " bazz " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo = bar " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " foo " , " bar " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo = Bar " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " foo " , " baz " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo != bar " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " foo " , " bar " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo != bar " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) ) ; » Headers Request Condition « » condition 1 « = new » Headers Request Condition « ( " foo = a " ) ; » Headers Request Condition « » condition 2 « = new » Headers Request Condition « ( " foo " ) ; int result = » condition 1 « . » compare To « ( » condition 2 « , exchange ) ; » assert That « ( result < 0 ) . as ( " Invalid comparison result : " + result ) . » is True « ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) ) ; » Headers Request Condition « » condition 1 « = new » Headers Request Condition « ( " foo != a " ) ; » Headers Request Condition « » condition 2 « = new » Headers Request Condition « ( " foo " ) ; » assert That « ( » condition 1 « . » compare To « ( » condition 2 « , exchange ) ) . as ( " Negated match should not count as more specific " ) . » is Equal To « ( 0 ) ; }
@Test { » Headers Request Condition « » condition 1 « = new » Headers Request Condition « ( " foo = bar " ) ; » Headers Request Condition « » condition 2 « = new » Headers Request Condition « ( " foo = baz " ) ; » Headers Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; Collection < ? > conditions = result . » get Content « ( ) ; » assert That « ( conditions . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " foo " , " bar " ) ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo " ) ; » Headers Request Condition « result = condition . » get Matching Condition « ( exchange ) ; » assert That « ( result ) . » is Equal To « ( condition ) ; condition = new » Headers Request Condition « ( " bar " ) ; result = condition . » get Matching Condition « ( exchange ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Request Condition Holder « » params 1 « = new » Request Condition Holder « ( new » Params Request Condition « ( " » name 1 « " ) ) ; » Request Condition Holder « » params 2 « = new » Request Condition Holder « ( new » Params Request Condition « ( " » name 2 « " ) ) ; » Request Condition Holder « expected = new » Request Condition Holder « ( new » Params Request Condition « ( " » name 1 « " , " » name 2 « " ) ) ; » assert That « ( » params 1 « . combine ( » params 2 « ) ) . » is Equal To « ( expected ) ; }
@Test { » Request Condition Holder « empty = new » Request Condition Holder « ( null ) ; » Request Condition Holder « » not Empty « = new » Request Condition Holder « ( new » Params Request Condition « ( " name " ) ) ; » assert That « ( empty . combine ( empty ) ) . » is Same As « ( empty ) ; » assert That « ( » not Empty « . combine ( empty ) ) . » is Same As « ( » not Empty « ) ; » assert That « ( empty . combine ( » not Empty « ) ) . » is Same As « ( » not Empty « ) ; }
@Test { » Request Condition Holder « params = new » Request Condition Holder « ( new » Params Request Condition « ( " name " ) ) ; » Request Condition Holder « headers = new » Request Condition Holder « ( new » Headers Request Condition « ( " name " ) ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> params . combine ( headers ) ) ; }
@Test { » Request Methods Request Condition « rm = new » Request Methods Request Condition « ( » Request Method « . GET , » Request Method « . POST ) ; » Request Condition Holder « custom = new » Request Condition Holder « ( rm ) ; » Request Methods Request Condition « expected = new » Request Methods Request Condition « ( » Request Method « . GET ) ; » Request Condition Holder « holder = custom . » get Matching Condition « ( this . exchange ) ; » assert That « ( holder ) . » is Not Null « ( ) ; » assert That « ( holder . » get Condition « ( ) ) . » is Equal To « ( expected ) ; }
@Test { » Request Methods Request Condition « rm = new » Request Methods Request Condition « ( » Request Method « . POST ) ; » Request Condition Holder « custom = new » Request Condition Holder « ( rm ) ; » assert That « ( custom . » get Matching Condition « ( this . exchange ) ) . » is Null « ( ) ; }
@Test { » Request Condition Holder « empty = new » Request Condition Holder « ( null ) ; » assert That « ( empty . » get Matching Condition « ( this . exchange ) ) . » is Same As « ( empty ) ; }
@Test { » Request Condition Holder « » params 11 « = new » Request Condition Holder « ( new » Params Request Condition « ( " 1 " ) ) ; » Request Condition Holder « » params 12 « = new » Request Condition Holder « ( new » Params Request Condition « ( " 1 " , " 2 " ) ) ; » assert That « ( » params 11 « . » compare To « ( » params 12 « , this . exchange ) ) . » is Equal To « ( 1 ) ; » assert That « ( » params 12 « . » compare To « ( » params 11 « , this . exchange ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Request Condition Holder « params = new » Request Condition Holder « ( new » Params Request Condition « ( " name " ) ) ; » Request Condition Holder « headers = new » Request Condition Holder « ( new » Headers Request Condition « ( " name " ) ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> params . » compare To « ( headers , this . exchange ) ) ; }
@Test { » test Match « ( new » Request Methods Request Condition « ( GET ) , GET ) ; » test Match « ( new » Request Methods Request Condition « ( GET , POST ) , GET ) ; » test No Match « ( new » Request Methods Request Condition « ( GET ) , POST ) ; }
@Test { » test Match « ( new » Request Methods Request Condition « ( HEAD ) , HEAD ) ; » test Match « ( new » Request Methods Request Condition « ( GET ) , GET ) ; » test No Match « ( new » Request Methods Request Condition « ( POST ) , HEAD ) ; }
@Test { » Request Methods Request Condition « condition = new » Request Methods Request Condition « ( ) ; for ( » Request Method « method : » Request Method « . values ( ) ) { if ( method != OPTIONS ) { » Server Web Exchange « exchange = » get Exchange « ( method . name ( ) ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; } } » test No Match « ( condition , OPTIONS ) ; }
@Test { » Server Web Exchange « exchange = » get Exchange « ( " PROPFIND " ) ; » assert That « ( new » Request Methods Request Condition « ( ) . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; » assert That « ( new » Request Methods Request Condition « ( GET , POST ) . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Request Methods Request Condition « » condition 1 « = new » Request Methods Request Condition « ( GET ) ; » Request Methods Request Condition « » condition 2 « = new » Request Methods Request Condition « ( POST ) ; » Request Methods Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; » assert That « ( result . » get Content « ( ) . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " text / plain " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " text / plain " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " ! text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " ! application / xml " ) ; » assert That « ( condition . » get Producible Media Types « ( ) ) . » is Equal To « ( Collections . » empty Set « ( ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " text / plain " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " » text / « * " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " text / plain " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " , " application / xml " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " application / xml " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " bogus " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " bogus " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " ! text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " ! application / json " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " » text / html « , » application / xhtml + xml « , » application / xml « ; » q = 0 . 9 « , » image / webp « , » image / apng « , * / * ; » q = 0 . 8 « " ) ) ; » assert That « ( condition . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Produces Request Condition « » condition 1 « = new » Produces Request Condition « ( " text / plain " ) ; » Produces Request Condition « » condition 2 « = new » Produces Request Condition « ( " application / xml " ) ; » Produces Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; » assert That « ( result ) . » is Equal To « ( » condition 2 « ) ; }
@Test { » Produces Request Condition « » condition 1 « = new » Produces Request Condition « ( " text / plain " ) ; » Produces Request Condition « » condition 2 « = new » Produces Request Condition « ( ) ; » Produces Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; » assert That « ( result ) . » is Equal To « ( » condition 1 « ) ; }
@Test { String [ ] produces = new String [ ] { " text / plain " } ; String [ ] headers = new String [ ] { " foo = bar " , " accept = application / xml , application / pdf " } ; » Produces Request Condition « condition = new » Produces Request Condition « ( produces , headers ) ; » assert Conditions « ( condition , " text / plain " , " application / xml " , " application / pdf " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) . header ( " Accept " , " text / plain " ) ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " , " application / xml " ) ; » Produces Request Condition « result = condition . » get Matching Condition « ( exchange ) ; » assert Conditions « ( result , " text / plain " ) ; condition = new » Produces Request Condition « ( " application / xml " ) ; result = condition . » get Matching Condition « ( exchange ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Patterns Request Condition « c = » create Patterns Condition « ( " " ) ; » assert That « ( c . » get Patterns « ( ) . iterator ( ) . next ( ) . » get Pattern String « ( ) ) . as ( " Do not prepend empty patterns ( SPR - 8255 ) " ) . » is Equal To « ( " " ) ; }
@Test { » Patterns Request Condition « » c 1 « = new » Patterns Request Condition « ( ) ; » Patterns Request Condition « » c 2 « = new » Patterns Request Condition « ( ) ; » assert That « ( » c 1 « . combine ( » c 2 « ) ) . » is Equal To « ( » create Patterns Condition « ( ) ) ; }
@Test { » Patterns Request Condition « condition = » create Patterns Condition « ( " / foo " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / foo " ) ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( exchange ) ; » assert That « ( match ) . » is Not Null « ( ) ; }
@Test { » Patterns Request Condition « condition = » create Patterns Condition « ( " » / foo / « * " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / foo / bar " ) ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( exchange ) ; » assert That « ( match ) . » is Not Null « ( ) ; }
@Test { » Patterns Request Condition « condition = » create Patterns Condition « ( " / * / * " , " / foo / bar " , " » / foo / « * " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / foo / bar " ) ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( exchange ) ; » Patterns Request Condition « expected = » create Patterns Condition « ( " / foo / bar " , " » / foo / « * " , " / * / * " ) ; » assert That « ( match ) . » is Equal To « ( expected ) ; }
@Test { » Patterns Request Condition « condition = » create Patterns Condition « ( " / foo . jpg " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / foo . html " ) ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( exchange ) ; » assert That « ( match ) . » is Null « ( ) ; }
@Test { » Patterns Request Condition « » c 1 « = » create Patterns Condition « ( " / foo * " ) ; » Patterns Request Condition « » c 2 « = » create Patterns Condition « ( " / foo * " ) ; » assert That « ( » c 1 « . » compare To « ( » c 2 « , » Mock Server Web Exchange « . from ( get ( " / foo " ) ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » Patterns Request Condition « c = » create Patterns Condition « ( " / a " , " / b " ) ; » assert That « ( c . » get Patterns « ( ) . size ( ) ) . » is Equal To « ( 2 ) ; Iterator < » Path Pattern « > itr = c . » get Patterns « ( ) . iterator ( ) ; » assert That « ( itr . next ( ) . » get Pattern String « ( ) ) . » is Equal To « ( " / a " ) ; » assert That « ( itr . next ( ) . » get Pattern String « ( ) ) . » is Equal To « ( " / b " ) ; }
@Test { » Params Request Condition « condition = new » Params Request Condition « ( " foo " ) ; » assert That « ( condition . » get Matching Condition « ( » Mock Server Web Exchange « . from ( get ( " / path ? foo = " ) ) ) ) . » is Not Null « ( ) ; }
@Test { » Params Request Condition « condition = new » Params Request Condition « ( " foo " ) ; » assert That « ( condition . » get Matching Condition « ( » Mock Server Web Exchange « . from ( get ( " / path ? foo " ) ) ) ) . » is Not Null « ( ) ; }
@Test { » Params Request Condition « condition = new » Params Request Condition « ( " foo " ) ; » assert That « ( condition . » get Matching Condition « ( » Mock Server Web Exchange « . from ( get ( " / path ? bar = " ) ) ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) ) ; » assert That « ( new » Params Request Condition « ( " ! foo " ) . » get Matching Condition « ( exchange ) ) . » is Not Null « ( ) ; }
@Test { » Params Request Condition « condition = new » Params Request Condition « ( " foo = bar " ) ; » assert That « ( condition . » get Matching Condition « ( » Mock Server Web Exchange « . from ( get ( " / path ? foo = bar " ) ) ) ) . » is Not Null « ( ) ; }
@Test { » Params Request Condition « condition = new » Params Request Condition « ( " foo = bar " ) ; » assert That « ( condition . » get Matching Condition « ( » Mock Server Web Exchange « . from ( get ( " / path ? foo = bazz " ) ) ) ) . » is Null « ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) ) ; » Params Request Condition « » condition 1 « = new » Params Request Condition « ( " » response _ type « = code " ) ; » Params Request Condition « » condition 2 « = new » Params Request Condition « ( " » response _ type « " ) ; int result = » condition 1 « . » compare To « ( » condition 2 « , exchange ) ; » assert That « ( result < 0 ) . as ( " Invalid comparison result : " + result ) . » is True « ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / " ) ) ; » Params Request Condition « » condition 1 « = new » Params Request Condition « ( " » response _ type « != code " ) ; » Params Request Condition « » condition 2 « = new » Params Request Condition « ( " » response _ type « " ) ; » assert That « ( » condition 1 « . » compare To « ( » condition 2 « , exchange ) ) . as ( " Negated match should not count as more specific " ) . » is Equal To « ( 0 ) ; }
@Test { » Params Request Condition « » condition 1 « = new » Params Request Condition « ( " foo = bar " ) ; » Params Request Condition « » condition 2 « = new » Params Request Condition « ( " foo = baz " ) ; » Params Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; Collection < ? > conditions = result . » get Content « ( ) ; » assert That « ( conditions . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { this . mapping . » register Mapping « ( " foo " , this . handler , this . » method 1 « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . mapping . » register Mapping « ( " foo " , this . handler , this . » method 2 « ) ) ; }
@Test { String key = " foo " ; this . mapping . » register Mapping « ( key , this . handler , this . » method 1 « ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( key ) ) ; Mono < Object > result = this . mapping . » get Handler « ( exchange ) ; » assert That « ( ( ( » Handler Method « ) result . block ( ) ) . » get Method « ( ) ) . » is Equal To « ( this . » method 1 « ) ; }
@Test { this . mapping . » register Mapping « ( " / fo * " , this . handler , this . » method 1 « ) ; this . mapping . » register Mapping « ( " / f * " , this . handler , this . » method 2 « ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / foo " ) ) ; Mono < Object > result = this . mapping . » get Handler « ( exchange ) ; » assert That « ( ( ( » Handler Method « ) result . block ( ) ) . » get Method « ( ) ) . » is Equal To « ( this . » method 1 « ) ; }
@Test { this . mapping . » register Mapping « ( " / f ? o " , this . handler , this . » method 1 « ) ; this . mapping . » register Mapping « ( " / fo ? " , this . handler , this . » method 2 « ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / foo " ) ) ; Mono < Object > result = this . mapping . » get Handler « ( exchange ) ; » Step Verifier « . create ( result ) . » expect Error « ( » Illegal State Exception « . class ) . verify ( ) ; }
@Test { String » key 1 « = " / foo " ; String » key 2 « = " / foo * " ; this . mapping . » register Mapping « ( » key 1 « , this . handler , this . » method 1 « ) ; this . mapping . » register Mapping « ( » key 2 « , this . handler , this . » method 2 « ) ; » assert That « ( this . mapping . » get Mapping Registry « ( ) . » get Mappings « ( ) ) . » contains Keys « ( » key 1 « , » key 2 « ) ; }
@Test { this . resolvers . add ( » stub Resolver « ( " » value 1 « " ) ) ; Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( o -> o . » single Arg « ( null ) ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert Handler Result Value « ( mono , " success : » value 1 « " ) ; }
@Test { this . resolvers . add ( » stub Resolver « ( Mono . empty ( ) ) ) ; Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( o -> o . » single Arg « ( null ) ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert Handler Result Value « ( mono , " success : null " ) ; }
@Test { Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( » Test Controller « :: » no Args « ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert Handler Result Value « ( mono , " success " ) ; }
@Test { Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( o -> o . » single Arg « ( null ) ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( mono :: block ) . » with Message « ( " Could not resolve parameter [ 0 ] in " + method . » to Generic String « ( ) + " : No suitable resolver " ) ; }
@Test { Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( o -> o . » single Arg « ( null ) ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method , " » value 1 « " ) ; » assert Handler Result Value « ( mono , " success : » value 1 « " ) ; }
@Test { this . resolvers . add ( » stub Resolver « ( " » value 1 « " ) ) ; Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( o -> o . » single Arg « ( null ) ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method , " » value 2 « " ) ; » assert Handler Result Value « ( mono , " success : » value 2 « " ) ; }
@Test { this . resolvers . add ( » stub Resolver « ( Mono . error ( new » Unsupported Media Type Status Exception « ( " boo " ) ) ) ) ; Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( o -> o . » single Arg « ( null ) ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert That Exception Of Type « ( » Unsupported Media Type Status Exception « . class ) . » is Thrown By « ( mono :: block ) . » with Message « ( " 415 » UNSUPPORTED _ MEDIA _ TYPE « \" boo \" " ) ; }
@Test { Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( » Test Controller « :: » exception Method « ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( mono :: block ) . » with Message « ( " boo " ) ; }
@Test { Method method = » Resolvable Method « . on ( » Test Controller « . class ) . » mock Call « ( » Test Controller « :: created ) . method ( ) ; Mono < » Handler Result « > mono = invoke ( new » Test Controller « ( ) , method ) ; » assert Handler Result Value « ( mono , " created " ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Status Code « ( ) ) . » is Equal To « ( » Http Status « . CREATED ) ; }
@Test { Method expected = on ( » Test Controller « . class ) . annot ( » get Mapping « ( " / foo " ) . params ( ) ) . » resolve Method « ( ) ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / foo " ) ) ; » Handler Method « hm = ( » Handler Method « ) this . » handler Mapping « . » get Handler « ( exchange ) . block ( ) ; » assert That « ( hm . » get Method « ( ) ) . » is Equal To « ( expected ) ; }
@Test { Method expected = on ( » Test Controller « . class ) . annot ( » request Mapping « ( " / ba * " ) . method ( GET , HEAD ) ) . » resolve Method « ( ) ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / bar " ) ) ; » Handler Method « hm = ( » Handler Method « ) this . » handler Mapping « . » get Handler « ( exchange ) . block ( ) ; » assert That « ( hm . » get Method « ( ) ) . » is Equal To « ( expected ) ; }
@Test { Method expected = on ( » Test Controller « . class ) . annot ( » get Mapping « ( " / foo " ) . params ( " p " ) ) . » resolve Method « ( ) ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / foo ? p = anything " ) ) ; » Handler Method « hm = ( » Handler Method « ) this . » handler Mapping « . » get Handler « ( exchange ) . block ( ) ; » assert That « ( hm . » get Method « ( ) ) . » is Equal To « ( expected ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( post ( " / bar " ) ) ; Mono < Object > mono = this . » handler Mapping « . » get Handler « ( exchange ) ; » assert Error « ( mono , » Method Not Allowed Exception « . class , ex -> » assert That « ( ex . » get Supported Methods « ( ) ) . » is Equal To « ( » Enum Set « . of ( » Http Method « . GET , » Http Method « . HEAD ) ) ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / users " ) . accept ( » Media Type « . » APPLICATION _ XML « ) ) ; this . » handler Mapping « . » register Handler « ( new » User Controller « ( ) ) ; Mono < Object > mono = this . » handler Mapping « . » get Handler « ( exchange ) ; » Step Verifier « . create ( mono ) . » expect Error « ( » Not Acceptable Status Exception « . class ) . verify ( ) ; }
@Test { » test Http Media Type Not Supported Exception « ( " / person / 1 " ) ; » test Http Media Type Not Supported Exception « ( " / person / 1 / " ) ; » test Http Media Type Not Supported Exception « ( " / person / 1. json " ) ; }
@Test { » Mock Server Http Request « request = put ( " / person / 1 " ) . header ( " content - type " , " bogus " ) . build ( ) ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; Mono < Object > mono = this . » handler Mapping « . » get Handler « ( exchange ) ; » assert Error « ( mono , » Unsupported Media Type Status Exception « . class , ex -> » assert That « ( ex . » get Message « ( ) ) . » is Equal To « ( ( " 415 » UNSUPPORTED _ MEDIA _ TYPE « " + " \" Invalid mime type \" bogus \" : does not contain '/' \" " ) ) ) ; }
@Test { » test Media Type Not Acceptable « ( " / persons " ) ; » test Media Type Not Acceptable « ( " / persons / " ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " / params " ) ) ; Mono < Object > mono = this . » handler Mapping « . » get Handler « ( exchange ) ; » assert Error « ( mono , » Server Web Input Exception « . class , ex -> { » assert That « ( ex . » get Reason « ( ) ) . contains ( " [ foo = bar ] " ) ; » assert That « ( ex . » get Reason « ( ) ) . contains ( " [ bar = baz ] " ) ; } ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( get ( " " ) ) ; this . » handler Mapping « . » handle Match « ( paths ( ) . build ( ) , » handler Method « , exchange ) ; » Path Pattern « pattern = ( » Path Pattern « ) exchange . » get Attributes « ( ) . get ( » BEST _ MATCHING _ PATTERN _ ATTRIBUTE « ) ; » assert That « ( pattern . » get Pattern String « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » test Exception « ( new » Illegal Access Exception « ( ) , " » Second Controller Advice « : » Illegal Access Exception « " ) ; }
@Test { » test Exception « ( new » Illegal State Exception « ( ) , " » One Controller Advice « : » Illegal State Exception « " ) ; }
@Test { » test Exception « ( new » Array Index Out Of Bounds Exception « ( ) , " » Handler Method « : handle " ) ; }
@Test { » Assertion Error « error = new » Assertion Error « ( " argh " ) ; » test Exception « ( error , error . » to String « ( ) ) ; }
@Test { » Assertion Error « cause = new » Assertion Error « ( " argh " ) ; » Fatal Bean Exception « exception = new » Fatal Bean Exception « ( " wrapped " , cause ) ; » test Exception « ( exception , cause . » to String « ( ) ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » cookie Parameter « ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » cookie String Parameter « ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » string Parameter « ) ) . » is False « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » supports Parameter « ( this . » cookie Mono Parameter « ) ) . » with Message Starting With « ( " » Cookie Value Method Argument Resolver « does not support reactive type wrapper " ) ; }
@Test { » Http Cookie « expected = new » Http Cookie « ( " name " , " foo " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) . cookie ( expected ) ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » cookie Parameter « , this . » binding Context « , exchange ) ; » assert That « ( mono . block ( ) ) . » is Equal To « ( expected ) ; }
@Test { » Http Cookie « cookie = new » Http Cookie « ( " name " , " foo " ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) . cookie ( cookie ) ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » cookie String Parameter « , this . » binding Context « , exchange ) ; » assert That « ( mono . block ( ) ) . as ( " Invalid result " ) . » is Equal To « ( cookie . » get Value « ( ) ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; Object result = this . resolver . » resolve Argument « ( this . » cookie String Parameter « , this . » binding Context « , exchange ) . block ( ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; Mono < Object > mono = resolver . » resolve Argument « ( this . » cookie Parameter « , this . » binding Context « , exchange ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » param System Property « ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » param Not Supported « ) ) . » is False « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » supports Parameter « ( this . » param Also Not Supported « ) ) . » with Message Starting With « ( " » Expression Value Method Argument Resolver « does not support reactive type wrapper " ) ; }
@Test { System . » set Property « ( " » system Property « " , " 22 " ) ; try { Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param System Property « , new » Binding Context « ( ) , this . exchange ) ; Object value = mono . block ( ) ; » assert That « ( value ) . » is Equal To « ( 22 ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . » no Name « ( ) ) . arg ( Map . class , String . class , String . class ) ; @ » Suppress Warnings « ( " unchecked " ) Map < String , String > map = ( Map < String , String > ) this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) . block ( Duration . ZERO ) ; » assert That « ( map ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( new » Method Parameter « ( this . » handle Method « , 0 ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( new » Method Parameter « ( this . » handle Method « , 4 ) ) ) . » is False « ( ) ; }
@Test { » Method Parameter « param = » init Method Parameter « ( 1 ) ; Foo foo = new Foo ( ) ; given ( this . session . » get Attribute « ( " » special Foo « " ) ) . » will Return « ( foo ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) ; » assert That « ( mono . block ( ) ) . » is Same As « ( foo ) ; }
@Test { » Method Parameter « param = » init Method Parameter « ( 2 ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) ; » assert That « ( mono . block ( ) ) . » is Null « ( ) ; Foo foo = new Foo ( ) ; given ( this . session . » get Attribute « ( " foo " ) ) . » will Return « ( foo ) ; mono = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) ; » assert That « ( mono . block ( ) ) . » is Same As « ( foo ) ; }
@Test { » test Resolve Argument « ( this . resolvable . arg ( Model . class ) ) ; » test Resolve Argument « ( this . resolvable . » annot Not Present « ( ) . arg ( Map . class , String . class , Object . class ) ) ; » test Resolve Argument « ( this . resolvable . arg ( » Model Map « . class ) ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( » param Map « ) ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Named Map « ) ) . » is False « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Map No Annot « ) ) . » is False « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » supports Parameter « ( this . » param Mono Map « ) ) . » with Message Starting With « ( " » Path Variable Map Method Argument Resolver « does not support reactive type wrapper " ) ; }
@Test { Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param Map « , new » Binding Context « ( ) , this . exchange ) ; Object result = mono . block ( ) ; » assert That « ( result ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Principal . class ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Mono . class , Principal . class ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Single . class , Principal . class ) ) ) . » is True « ( ) ; }
@Test { this . » handler Mapping « . » set Embedded Value Resolver « ( value -> " / $ { pattern } / bar " . equals ( value ) ? " / foo / bar " : value ) ; String [ ] patterns = new String [ ] { " / foo " , " / $ { pattern } / bar " } ; String [ ] result = this . » handler Mapping « . » resolve Embedded Values In Patterns « ( patterns ) ; » assert That « ( result ) . » is Equal To « ( new String [ ] { " / foo " , " / foo / bar " } ) ; }
@Test { » Request Mapping Info « » request Mapping Info « = » assert Composed Annotation Mapping « ( » Request Method « . POST ) ; » Consumes Request Condition « condition = » request Mapping Info « . » get Consumes Condition « ( ) ; » assert That « ( condition . » get Consumable Media Types « ( ) ) . » is Equal To « ( Collections . singleton ( » Media Type « . » APPLICATION _ XML « ) ) ; }
@Test { » assert Composed Annotation Mapping « ( » Request Method « . GET ) ; }
@Test { » assert Composed Annotation Mapping « ( » Request Method « . POST ) ; }
@Test { » assert Composed Annotation Mapping « ( » Request Method « . PUT ) ; }
@Test { » assert Composed Annotation Mapping « ( » Request Method « . DELETE ) ; }
@Test { » assert Composed Annotation Mapping « ( » Request Method « . PATCH ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . name ( " " ) ) . arg ( Map . class ) ; Object result = resolve ( param , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path ? foo = bar " ) ) ) ; boolean condition = result instanceof Map ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( Collections . » singleton Map « ( " foo " , " bar " ) ) ; }
@Test { » assert That « ( this . » result Handler « . » get Order « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( » Web Session « . class ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Mono . class , » Web Session « . class ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » test Method « . arg ( Single . class , » Web Session « . class ) ) ) . » is True « ( ) ; }
@Test { » Method Parameter « parameter = this . » test Method « . arg ( » Binding Result « . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( parameter , this . » binding Context « , this . exchange ) . block ( Duration . » of Millis « ( 5000 ) ) ) . » with Message Containing « ( " An @ » Model Attribute « and an Errors / » Binding Result « argument " + " cannot both be declared with an async type wrapper . " ) ; }
@Test { » Method Parameter « parameter = this . » test Method « . arg ( Errors . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( parameter , this . » binding Context « , this . exchange ) . block ( Duration . » of Millis « ( 5000 ) ) ) . » with Message Containing « ( " An Errors / » Binding Result « argument is expected " + " immediately after the @ » Model Attribute « argument " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; » Binding Context « context = » create Binding Context « ( " » init Binder « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = context . » create Data Binder « ( exchange , null , null ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Not Null « ( ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) [ 0 ] ) . » is Equal To « ( " id " ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; » Binding Context « context = » create Binding Context « ( " » init Binder With Attribute Name « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = context . » create Data Binder « ( exchange , null , " » invalid Name « " ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; » Binding Context « context = » create Binding Context « ( " » init Binder With Attribute Name « " , » Web Data Binder « . class ) ; » Web Data Binder « » data Binder « = context . » create Data Binder « ( exchange , null , null ) ; » assert That « ( » data Binder « . » get Disallowed Fields « ( ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; » Binding Context « context = » create Binding Context « ( " » init Binder Return Value « " , » Web Data Binder « . class ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> context . » create Data Binder « ( exchange , null , " » invalid Name « " ) ) ; }
@Test { » get Variables For « ( " cars " ) . add ( " year " , " 2006 " ) ; » get Variables For « ( " bikes " ) . add ( " year " , " 2005 " ) ; » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . name ( " year " ) ) . arg ( int . class ) ; Object actual = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) . block ( Duration . ZERO ) ; » assert That « ( actual ) . » is Equal To « ( 2006 ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . name ( " year " ) ) . arg ( int . class ) ; Object actual = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) . block ( Duration . ZERO ) ; » assert That « ( actual ) . » is Equal To « ( 2013 ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . » no Name « ( ) ) . arg ( List . class , String . class ) ; » assert That Exception Of Type « ( » Server Web Input Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) . block ( Duration . ZERO ) ) ; }
@Test { » Multi Value Map « < String , String > params = » get Variables For « ( " cars " ) ; params . add ( " » another Year « " , " 2012 " ) ; » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . name ( " year " ) ) . arg ( int . class ) ; Object actual = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) . block ( Duration . ZERO ) ; » assert That « ( actual ) . » is Equal To « ( 2013 ) ; }
@Test { String body = " { \" bar \" : \" BARBAR \" , \" foo \" : \" FOOFOO \" } " ; » Resolvable Type « type = » for Class With Generics « ( Mono . class , » Test Bean « . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; Mono < Object > mono = » resolve Value « ( param , body ) ; » assert That « ( mono . block ( ) ) . » is Equal To « ( new » Test Bean « ( " FOOFOO " , " BARBAR " ) ) ; }
@Test { String body = " { \" bar \" : \" » b 1 « \" , \" foo \" : \" » f 1 « \" } " ; » Resolvable Type « type = » for Class With Generics « ( Single . class , » Test Bean « . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; Single < » Test Bean « > single = » resolve Value « ( param , body ) ; » assert That « ( single . » to Blocking « ( ) . value ( ) ) . » is Equal To « ( new » Test Bean « ( " » f 1 « " , " » b 1 « " ) ) ; }
@Test { String body = " { \" bar \" : \" » b 1 « \" , \" foo \" : \" » f 1 « \" } " ; » Resolvable Type « type = » for Class With Generics « ( io . reactivex . Single . class , » Test Bean « . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; io . reactivex . Single < » Test Bean « > single = » resolve Value « ( param , body ) ; » assert That « ( single . » blocking Get « ( ) ) . » is Equal To « ( new » Test Bean « ( " » f 1 « " , " » b 1 « " ) ) ; }
@Test { String body = " { \" bar \" : \" » b 1 « \" , \" foo \" : \" » f 1 « \" } " ; » Resolvable Type « type = » for Class With Generics « ( Maybe . class , » Test Bean « . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; Maybe < » Test Bean « > maybe = » resolve Value « ( param , body ) ; » assert That « ( maybe . » blocking Get « ( ) ) . » is Equal To « ( new » Test Bean « ( " » f 1 « " , " » b 1 « " ) ) ; }
@Test { String body = " { \" bar \" : \" » b 1 « \" , \" foo \" : \" » f 1 « \" } " ; » Resolvable Type « type = » for Class With Generics « ( » Completable Future « . class , » Test Bean « . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; » Completable Future « < ? > future = » resolve Value « ( param , body ) ; » assert That « ( future . get ( ) ) . » is Equal To « ( new » Test Bean « ( " » f 1 « " , " » b 1 « " ) ) ; }
@Test { String body = " { \" bar \" : \" » b 1 « \" , \" foo \" : \" » f 1 « \" } " ; » Method Parameter « param = this . » test Method « . arg ( » Test Bean « . class ) ; » Test Bean « value = » resolve Value « ( param , body ) ; » assert That « ( value ) . » is Equal To « ( new » Test Bean « ( " » f 1 « " , " » b 1 « " ) ) ; }
@Test { String body = " { \" bar \" : \" » b 1 « \" } " ; » Resolvable Type « type = » for Class With Generics « ( Mono . class , » Test Bean « . class ) ; » Method Parameter « param = this . » test Method « . arg ( type ) ; Mono < » Test Bean « > mono = » resolve Value « ( param , body ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { Method method = » Abstract Parameterized Controller « . class . » get Method « ( " » handle Dto « " , Identifiable . class ) ; » Handler Method « » handler Method « = new » Handler Method « ( new » Concrete Parameterized Controller « ( ) , method ) ; » Method Parameter « » method Param « = » handler Method « . » get Method Parameters « ( ) [ 0 ] ; » Simple Bean « » simple Bean « = » resolve Value « ( » method Param « , " { \" name \" : \" Jad \" } " ) ; » assert That « ( » simple Bean « . » get Name « ( ) ) . » is Equal To « ( " Jad " ) ; }
@Test { Resource body = new » Class Path Resource « ( " logo . png " , » get Class « ( ) ) ; » Method Parameter « type = on ( » Test Controller « . class ) . » resolve Return Type « ( Resource . class ) ; this . » result Handler « . » write Body « ( body , type , this . exchange ) . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . » get First « ( " Content - Type " ) ) . » is Equal To « ( " image / png " ) ; }
@Test { » Byte Array Output Stream « body = new » Byte Array Output Stream « ( ) ; » Method Parameter « type = on ( » Test Controller « . class ) . » resolve Return Type « ( » Output Stream « . class ) ; » Http Message Writer « < ? > writer = new » Encoder Http Message Writer « < > ( new » Byte Buffer Encoder « ( ) ) ; Mono < Void > mono = » init Result Handler « ( writer ) . » write Body « ( body , type , this . exchange ) ; » Step Verifier « . create ( mono ) . » expect Error « ( » Illegal State Exception « . class ) . verify ( ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » param Named String « ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » param String « ) ) . » is False « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . resolver . » supports Parameter « ( this . » param Mono « ) ) . » with Message Starting With « ( " » Path Variable Method Argument Resolver « does not support reactive type wrapper " ) ; }
@Test { » Binding Context « » binding Context « = new » Binding Context « ( ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param Named String « , » binding Context « , this . exchange ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Error Exception « . class ) . verify ( ) ; }
@Test { » Binding Context « » binding Context « = new » Binding Context « ( ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param Not Required « , » binding Context « , this . exchange ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Binding Context « » binding Context « = new » Binding Context « ( ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param Optional « , » binding Context « , this . exchange ) ; » Step Verifier « . create ( mono ) . » consume Next With « ( value -> { boolean condition = value instanceof Optional ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( ( ( Optional < ? > ) value ) . » is Present « ( ) ) . » is False « ( ) ; } ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Method Parameter « param ; param = this . » test Method « . annot ( » request Body « ( ) ) . arg ( Mono . class , String . class ) ; » assert That « ( this . resolver . » supports Parameter « ( param ) ) . » is True « ( ) ; param = this . » test Method « . » annot Not Present « ( » Request Body « . class ) . arg ( String . class ) ; » assert That « ( this . resolver . » supports Parameter « ( param ) ) . » is False « ( ) ; }
@Test { String body = " » line 1 « " ; » Method Parameter « param = this . » test Method « . annot ( » request Body « ( ) ) . arg ( String . class ) ; String value = » resolve Value « ( param , body ) ; » assert That « ( value ) . » is Equal To « ( body ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Body « ( ) ) . arg ( String . class ) ; » assert That Exception Of Type « ( » Server Web Input Exception « . class ) . » is Thrown By « ( ( ) -> » resolve Value With Empty Body « ( param ) ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Body « ( ) . » not Required « ( ) ) . arg ( String . class ) ; String body = » resolve Value With Empty Body « ( param ) ; » assert That « ( body ) . » is Null « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Body « ( ) . » not Required « ( ) ) . arg ( Map . class ) ; String body = » resolve Value With Empty Body « ( param ) ; » assert That « ( body ) . » is Null « ( ) ; }
@Test { Object controller = new » Test Controller « ( ) ; Method method ; method = on ( » Test Controller « . class ) . » annot Present « ( » Response Body « . class ) . » resolve Method « ( ) ; » test Supports « ( controller , method ) ; method = on ( » Test Controller « . class ) . » annot Not Present « ( » Response Body « . class ) . » resolve Method « ( " » do Work « " ) ; » Handler Result « » handler Result « = » get Handler Result « ( controller , method ) ; » assert That « ( this . » result Handler « . supports ( » handler Result « ) ) . » is False « ( ) ; }
@Test { » assert That « ( this . » result Handler « . » get Order « ( ) ) . » is Equal To « ( 100 ) ; }
@Test { » Invocable Handler Method « invocable = this . » method Resolver « . » get Exception Handler Method « ( new » Illegal State Exception « ( " reason " ) , this . » handler Method « ) ; » assert That « ( invocable ) . » is Not Null « ( ) ; » assert That « ( invocable . » get Bean Type « ( ) ) . » is Equal To « ( » Test Controller Advice « . class ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( String . class ) ; » Http Entity « < Object > entity = » resolve Value With Empty Body « ( type ) ; » assert That « ( entity . » get Body « ( ) ) . » is Null « ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( Mono . class , String . class ) ; » Http Entity « < Mono < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( entity . » get Body « ( ) ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( Flux . class , String . class ) ; » Http Entity « < Flux < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( entity . » get Body « ( ) ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( Single . class , String . class ) ; » Http Entity « < Single < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( » Rx Reactive Streams « . » to Publisher « ( entity . » get Body « ( ) ) ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( io . reactivex . Single . class , String . class ) ; » Http Entity « < io . reactivex . Single < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( entity . » get Body « ( ) . » to Flowable « ( ) ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( Maybe . class , String . class ) ; » Http Entity « < Maybe < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( entity . » get Body « ( ) . » to Flowable « ( ) ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( Observable . class , String . class ) ; » Http Entity « < Observable < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( » Rx Reactive Streams « . » to Publisher « ( entity . » get Body « ( ) ) ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( io . reactivex . Observable . class , String . class ) ; » Http Entity « < io . reactivex . Observable < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( entity . » get Body « ( ) . » to Flowable « ( » Backpressure Strategy « . BUFFER ) ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( Flowable . class , String . class ) ; » Http Entity « < Flowable < String > > entity = » resolve Value With Empty Body « ( type ) ; » Step Verifier « . create ( entity . » get Body « ( ) ) . » expect Next Count « ( 0 ) . » expect Complete « ( ) . verify ( ) ; }
@Test { » Resolvable Type « type = » http Entity Type « ( » Completable Future « . class , String . class ) ; » Http Entity « < » Completable Future « < String > > entity = » resolve Value With Empty Body « ( type ) ; entity . » get Body « ( ) . » when Complete « ( ( body , ex ) -> { » assert That « ( body ) . » is Null « ( ) ; » assert That « ( ex ) . » is Null « ( ) ; } ) ; }
@Test { » Server Web Exchange « exchange = » post Exchange « ( " » line 1 « " ) ; » Resolvable Type « type = » http Entity Type « ( String . class ) ; » Http Entity « < String > » http Entity « = » resolve Value « ( exchange , type ) ; » assert That « ( » http Entity « . » get Headers « ( ) ) . » is Equal To « ( exchange . » get Request « ( ) . » get Headers « ( ) ) ; » assert That « ( » http Entity « . » get Body « ( ) ) . » is Equal To « ( " » line 1 « " ) ; }
@Test { » Server Web Exchange « exchange = » post Exchange « ( " » line 1 « " ) ; » Resolvable Type « type = » http Entity Type « ( Mono . class , String . class ) ; » Http Entity « < Mono < String > > » http Entity « = » resolve Value « ( exchange , type ) ; » assert That « ( » http Entity « . » get Headers « ( ) ) . » is Equal To « ( exchange . » get Request « ( ) . » get Headers « ( ) ) ; » assert That « ( » http Entity « . » get Body « ( ) . block ( ) ) . » is Equal To « ( " » line 1 « " ) ; }
@Test { » Server Web Exchange « exchange = » post Exchange « ( " » line 1 « " ) ; » Resolvable Type « type = » http Entity Type « ( Maybe . class , String . class ) ; » Http Entity « < Maybe < String > > » http Entity « = » resolve Value « ( exchange , type ) ; » assert That « ( » http Entity « . » get Headers « ( ) ) . » is Equal To « ( exchange . » get Request « ( ) . » get Headers « ( ) ) ; » assert That « ( » http Entity « . » get Body « ( ) . » blocking Get « ( ) ) . » is Equal To « ( " » line 1 « " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Attribute « ( ) . name ( " » special Foo « " ) ) . arg ( ) ; Foo foo = new Foo ( ) ; this . exchange . » get Attributes « ( ) . put ( " » special Foo « " , foo ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , this . exchange ) ; » assert That « ( mono . block ( ) ) . » is Same As « ( foo ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) ) . arg ( Person . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; » body Builder « . part ( " name " , new Person ( " Jones " ) ) ; Person actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual . » get Name « ( ) ) . » is Equal To « ( " Jones " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( List . class , Person . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; List < Person > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual ) . » is Empty « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) ) . arg ( Mono . class , Person . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; » body Builder « . part ( " name " , new Person ( " Jones " ) ) ; Mono < Person > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual . block ( ) . » get Name « ( ) ) . » is Equal To « ( " Jones " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( Mono . class , Person . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; Mono < Person > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual . block ( ) ) . » is Null « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( Flux . class , Person . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; Flux < Person > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual . » collect List « ( ) . block ( ) ) . » is Empty « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( List . class , Part . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; List < Part > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual ) . » is Empty « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) ) . arg ( Mono . class , Part . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; » body Builder « . part ( " name " , new Person ( " Jones " ) ) ; Mono < Part > actual = » resolve Argument « ( param , » body Builder « ) ; Part part = actual . block ( ) ; » assert That « ( » part To Utf 8 String « ( part ) ) . » is Equal To « ( " { \" name \" : \" Jones \" } " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( Mono . class , Part . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; Mono < Part > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual . block ( ) ) . » is Null « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( Flux . class , Part . class ) ; » Multipart Body Builder « » body Builder « = new » Multipart Body Builder « ( ) ; Flux < Part > actual = » resolve Argument « ( param , » body Builder « ) ; » assert That « ( actual . » collect List « ( ) . block ( ) ) . » is Empty « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) ) . arg ( Person . class ) ; » Server Web Exchange « exchange = » create Exchange « ( new » Multipart Body Builder « ( ) ) ; Mono < Object > result = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , exchange ) ; » Step Verifier « . create ( result ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( Person . class ) ; » Server Web Exchange « exchange = » create Exchange « ( new » Multipart Body Builder « ( ) ) ; Mono < Object > result = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , exchange ) ; » Step Verifier « . create ( result ) . » verify Complete « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) ) . arg ( Part . class ) ; » Server Web Exchange « exchange = » create Exchange « ( new » Multipart Body Builder « ( ) ) ; Mono < Object > result = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , exchange ) ; » Step Verifier « . create ( result ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Part « ( ) . » not Required « ( ) ) . arg ( Part . class ) ; » Server Web Exchange « exchange = » create Exchange « ( new » Multipart Body Builder « ( ) ) ; Mono < Object > result = this . resolver . » resolve Argument « ( param , new » Binding Context « ( ) , exchange ) ; » Step Verifier « . create ( result ) . » verify Complete « ( ) ; }
@Test { » Reactive Adapter Registry « » adapter Registry « = » Reactive Adapter Registry « . » get Shared Instance « ( ) ; this . resolver = new » Request Param Method Argument Resolver « ( null , » adapter Registry « , false ) ; » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; » assert That « ( this . resolver . » supports Parameter « ( param ) ) . » is False « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( " bar " ) ) . arg ( String . class ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path ? name = foo " ) ) ; » assert That « ( resolve ( param , exchange ) ) . » is Equal To « ( " foo " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( " bar " ) ) . arg ( String . class ) ; » assert That « ( resolve ( param , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( ) ) . arg ( Integer . class ) ; » assert That « ( resolve ( param , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / ? » null Param « = " ) ) ) ) . » is Null « ( ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; » Method Parameter « param = this . » test Method « . » annot Present « ( » Request Param « . class ) . arg ( String [ ] . class ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( param , this . » bind Context « , exchange ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / path ? » string Not Annot « = » plain Value « " ) . build ( ) ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( request ) ; » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; Object result = resolve ( param , exchange ) ; » assert That « ( result ) . » is Equal To « ( " » plain Value « " ) ; }
@Test { » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; » assert That « ( resolve ( param , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ) . » is Null « ( ) ; }
@Test { » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path ? name = " ) ) ; » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) . » not Required « ( " bar " ) ) . arg ( String . class ) ; Object result = resolve ( param , exchange ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { » Method Parameter « param = this . » test Method « . » annot Not Present « ( » Request Param « . class ) . arg ( String . class ) ; » Mock Server Http Request « request = » Mock Server Http Request « . get ( " / path ? » string Not Annot « = " ) . build ( ) ; » assert That « ( resolve ( param , » Mock Server Web Exchange « . from ( request ) ) ) . » is Equal To « ( " " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » request Param « ( ) ) . arg ( String . class ) ; » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / path ? name = " ) ) ; » assert That « ( resolve ( param , exchange ) ) . » is Equal To « ( " " ) ; }
@Test { String expected = " foo " ; » Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) . header ( " name " , expected ) ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param Named Default Value String Header « , this . » binding Context « , exchange ) ; Object result = mono . block ( ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( expected ) ; }
@Test { » Mock Server Web Exchange « exchange = » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ; Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param Named Default Value String Header « , this . » binding Context « , exchange ) ; Object result = mono . block ( ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; }
@Test { System . » set Property « ( " » system Property « " , " bar " ) ; try { Mono < Object > mono = this . resolver . » resolve Argument « ( this . » param System Property « , this . » binding Context « , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ; Object result = mono . block ( ) ; boolean condition = result instanceof String ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( result ) . » is Equal To « ( " bar " ) ; } finally { System . » clear Property « ( " » system Property « " ) ; } }
@Test { Mono < Object > mono = resolver . » resolve Argument « ( this . » param Named Value String Array « , this . » binding Context « , » Mock Server Web Exchange « . from ( » Mock Server Http Request « . get ( " / " ) ) ) ; » Step Verifier « . create ( mono ) . » expect Next Count « ( 0 ) . » expect Error « ( » Server Web Input Exception « . class ) . verify ( ) ; }
@Test { » test Bind Foo « ( " foo " , this . » test Method « . » annot Present « ( » Model Attribute « . class ) . arg ( Foo . class ) , value -> { » assert That « ( value . » get Class « ( ) ) . » is Equal To « ( Foo . class ) ; return ( Foo ) value ; } ) ; }
@Test { » Method Parameter « parameter = this . » test Method « . » annot Not Present « ( » Model Attribute « . class ) . arg ( Foo . class ) ; » test Validation Error « ( parameter , Function . identity ( ) ) ; }
@Test { » Method Parameter « parameter = this . » test Method « . » annot Not Present « ( » Model Attribute « . class ) . arg ( Mono . class , Foo . class ) ; » test Validation Error « ( parameter , » resolved Argument Mono « -> { Object value = » resolved Argument Mono « . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( value ) . » is Not Null « ( ) ; boolean condition = value instanceof Mono ; » assert That « ( condition ) . » is True « ( ) ; return ( Mono < ? > ) value ; } ) ; }
@Test { » Method Parameter « parameter = this . » test Method « . » annot Present « ( » Model Attribute « . class ) . arg ( Single . class , Foo . class ) ; » test Validation Error « ( parameter , » resolved Argument Mono « -> { Object value = » resolved Argument Mono « . block ( Duration . » of Seconds « ( 5 ) ) ; » assert That « ( value ) . » is Not Null « ( ) ; boolean condition = value instanceof Single ; » assert That « ( condition ) . » is True « ( ) ; return Mono . from ( » Rx Reactive Streams « . » to Publisher « ( ( Single < ? > ) value ) ) ; } ) ; }
@Test { » test Bind Bar « ( this . » test Method « . » annot Not Present « ( » Model Attribute « . class ) . arg ( Bar . class ) ) ; }
@Test { » assert That « ( this . view . » get Supported Media Types « ( ) ) . » is Equal To « ( Arrays . » as List « ( » Media Type « . » APPLICATION _ JSON « , » Media Type « . » parse Media Type « ( " » application / « * » + json « " ) ) ) ; }
@Test { this . view . » set Model Keys « ( Collections . singleton ( " » foo 2 « " ) ) ; this . model . » add Attribute « ( " » foo 1 « " , Collections . singleton ( " » bar 1 « " ) ) ; this . model . » add Attribute « ( " » foo 2 « " , Collections . singleton ( " » bar 2 « " ) ) ; this . model . » add Attribute « ( " » foo 3 « " , Collections . singleton ( " » bar 3 « " ) ) ; » assert That « ( » do Render « ( ) ) . » is Equal To « ( " [ \" » bar 2 « \" ] " ) ; }
@Test { this . view . » set Model Keys « ( Collections . singleton ( " » foo 2 « " ) ) ; this . model . » add Attribute « ( " » foo 1 « " , " » bar 1 « " ) ; » assert That « ( » do Render « ( ) ) . » is Equal To « ( " " ) ; }
@Test { this . view = new » Http Message Writer View « ( new » Jaxb 2 Xml Encoder « ( ) ) ; this . view . » set Model Keys « ( new » Hash Set « < > ( Collections . » singleton List « ( " » foo 1 « " ) ) ) ; this . model . » add Attribute « ( " » foo 1 « " , " » bar 1 « " ) ; » assert That « ( » do Render « ( ) ) . » is Equal To « ( " " ) ; }
@Test { » Request Context « context = new » Request Context « ( this . exchange , this . model , this . » application Context « ) ; » assert That « ( context . » get Context Url « ( " bar " ) ) . » is Equal To « ( " / foo / bar " ) ; }
@Test { » Request Context « context = new » Request Context « ( this . exchange , this . model , this . » application Context « ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " foo " , " bar " ) ; map . put ( " spam " , " bucket " ) ; » assert That « ( context . » get Context Url « ( " { foo } ? spam = { spam } " , map ) ) . » is Equal To « ( " / foo / bar ? spam = bucket " ) ; }
@Test { » Request Context « context = new » Request Context « ( this . exchange , this . model , this . » application Context « ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " foo " , " bar baz " ) ; map . put ( " spam " , " & bucket = " ) ; » assert That « ( context . » get Context Url « ( " { foo } ? spam = { spam } " , map ) ) . » is Equal To « ( " / foo / bar % 20 baz ? spam = % 26 bucket % 3D " ) ; }
@Test { this . resolver . » set View Class « ( » Test View « . class ) ; this . resolver . » set View Names « ( " my * " ) ; Mono < View > mono = this . resolver . » resolve View Name « ( " my - view " , Locale . US ) ; » assert That « ( mono . block ( ) ) . » is Not Null « ( ) ; mono = this . resolver . » resolve View Name « ( " not - my - view " , Locale . US ) ; » assert That « ( mono . block ( ) ) . » is Null « ( ) ; }
@Test { » Test View Resolver « » resolver 1 « = new » Test View Resolver « ( " account " ) ; » Test View Resolver « » resolver 2 « = new » Test View Resolver « ( " profile " ) ; » resolver 1 « . » set Order « ( 2 ) ; » resolver 2 « . » set Order « ( 1 ) ; List < » View Resolver « > resolvers = » result Handler « ( » resolver 1 « , » resolver 2 « ) . » get View Resolvers « ( ) ; » assert That « ( resolvers ) . » is Equal To « ( Arrays . » as List « ( » resolver 2 « , » resolver 1 « ) ) ; }
@Test { » test Handle « ( " / account " , on ( Handler . class ) . » annot Not Present « ( » Model Attribute « . class ) . » resolve Return Type « ( String . class ) , " profile " , " profile : { id = 123 } " , new » Test View Resolver « ( " account " ) , new » Test View Resolver « ( " profile " ) ) ; }
@Test { » test Default View Name « ( null , on ( Handler . class ) . » annot Present « ( » Model Attribute « . class ) . » resolve Return Type « ( String . class ) ) ; » test Default View Name « ( Mono . empty ( ) , on ( Handler . class ) . » resolve Return Type « ( Mono . class , String . class ) ) ; » test Default View Name « ( Mono . empty ( ) , on ( Handler . class ) . » resolve Return Type « ( Mono . class , Void . class ) ) ; » test Default View Name « ( Completable . complete ( ) , on ( Handler . class ) . » resolve Return Type « ( Completable . class ) ) ; }
@Test { Rendering rendering = Rendering . view ( " abc " ) . build ( ) ; » assert That « ( rendering . view ( ) ) . » is Equal To « ( " abc " ) ; » assert That « ( rendering . » model Attributes « ( ) ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; » assert That « ( rendering . status ( ) ) . » is Null « ( ) ; » assert That « ( rendering . headers ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { Rendering rendering = Rendering . view ( " foo " ) . build ( ) ; » assert That « ( rendering . view ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { Foo foo = new Foo ( ) ; Rendering rendering = Rendering . view ( " foo " ) . » model Attribute « ( foo ) . build ( ) ; » assert That « ( rendering . » model Attributes « ( ) ) . » is Equal To « ( Collections . » singleton Map « ( " foo " , foo ) ) ; }
@Test { Foo foo = new Foo ( ) ; Bar bar = new Bar ( ) ; Rendering rendering = Rendering . view ( " foo " ) . » model Attributes « ( foo , bar ) . build ( ) ; Map < String , Object > map = new » Linked Hash Map « < > ( 2 ) ; map . put ( " foo " , foo ) ; map . put ( " bar " , bar ) ; » assert That « ( rendering . » model Attributes « ( ) ) . » is Equal To « ( map ) ; }
@Test { Map < String , Object > map = new » Linked Hash Map « < > ( ) ; map . put ( " foo " , new Foo ( ) ) ; map . put ( " bar " , new Bar ( ) ) ; Rendering rendering = Rendering . view ( " foo " ) . model ( map ) . build ( ) ; » assert That « ( rendering . » model Attributes « ( ) ) . » is Equal To « ( map ) ; }
@Test { Rendering rendering = Rendering . view ( " foo " ) . header ( " foo " , " bar " ) . build ( ) ; » assert That « ( rendering . headers ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( rendering . headers ( ) . get ( " foo " ) ) . » is Equal To « ( Collections . » singleton List « ( " bar " ) ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . add ( " foo " , " bar " ) ; Rendering rendering = Rendering . view ( " foo " ) . headers ( headers ) . build ( ) ; » assert That « ( rendering . headers ( ) ) . » is Equal To « ( headers ) ; }
@Test { Rendering rendering = Rendering . » redirect To « ( " foo " ) . » context Relative « ( false ) . build ( ) ; Object view = rendering . view ( ) ; » assert That « ( view . » get Class « ( ) ) . » is Equal To « ( » Redirect View « . class ) ; » assert That « ( ( ( » Redirect View « ) view ) . » is Context Relative « ( ) ) . » is False « ( ) ; }
@Test { Rendering rendering = Rendering . » redirect To « ( " foo " ) . » propagate Query « ( true ) . build ( ) ; Object view = rendering . view ( ) ; » assert That « ( view . » get Class « ( ) ) . » is Equal To « ( » Redirect View « . class ) ; » assert That « ( ( ( » Redirect View « ) view ) . » is Propagate Query « ( ) ) . » is True « ( ) ; }
@Test { » Redirect View « rv = new » Redirect View « ( null ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( rv :: » after Properties Set « ) ; }
@Test { String url = " / test . html " ; » Redirect View « view = new » Redirect View « ( url ) ; view . render ( new » Hash Map « < > ( ) , » Media Type « . » TEXT _ HTML « , this . exchange ) . block ( ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . » get Location « ( ) ) . » is Equal To « ( URI . create ( " / context / test . html " ) ) ; }
@Test { String url = " / test . html ? id = 1 " ; » Redirect View « view = new » Redirect View « ( url ) ; view . render ( new » Hash Map « < > ( ) , » Media Type « . » TEXT _ HTML « , this . exchange ) . block ( ) ; » assert That « ( this . exchange . » get Response « ( ) . » get Headers « ( ) . » get Location « ( ) ) . » is Equal To « ( URI . create ( " / context / test . html ? id = 1 " ) ) ; }
@Test { » free Marker Configurer « . » after Properties Set « ( ) ; Configuration cfg = » free Marker Configurer « . » get Configuration « ( ) ; » assert That « ( cfg . » get Default Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { » free Marker Configurer « . » set Config Location « ( new » File System Resource « ( " myprops . properties " ) ) ; Properties props = new Properties ( ) ; props . » set Property « ( " myprop " , " / mydir " ) ; » free Marker Configurer « . » set Freemarker Settings « ( props ) ; » assert That IO Exception « ( ) . » is Thrown By « ( » free Marker Configurer « :: » after Properties Set « ) ; }
@Test { » Free Marker View « view = new » Free Marker View « ( ) ; view . » set Application Context « ( this . context ) ; view . » set Url « ( " » anything But Null « " ) ; » assert That Exception Of Type « ( » Application Context Exception « . class ) . » is Thrown By « ( view :: » after Properties Set « ) . » with Message Containing « ( " Must define a single » Free Marker Config « bean " ) ; }
@Test { » Free Marker View « » free Marker View « = new » Free Marker View « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( » free Marker View « :: » after Properties Set « ) . » with Message Containing « ( " Property 'url' is required " ) ; }
@Test { » Free Marker View « view = new » Free Marker View « ( ) ; view . » set Configuration « ( this . » free Marker Config « ) ; view . » set Url « ( " test . ftl " ) ; » assert That « ( view . » check Resource Exists « ( Locale . US ) ) . » is True « ( ) ; }
@Test { » assert That « ( » get Macro Output « ( " NAME " ) ) . » contains Exactly « ( " Darren " ) ; }
@Test { » assert That « ( » get Macro Output « ( " AGE " ) ) . » contains Exactly « ( " 99 " ) ; }
@Test { » assert That « ( » get Macro Output « ( " MESSAGE " ) ) . » contains Exactly « ( " Howdy Mundo " ) ; }
@Test { » assert That « ( » get Macro Output « ( " DEFAULTMESSAGE " ) ) . » contains Exactly « ( " hi planet " ) ; }
@Test { » assert That « ( » get Macro Output « ( " MESSAGEARGS " ) ) . » contains Exactly « ( " Howdy [ World ] " ) ; }
@Test { » assert That « ( » get Macro Output « ( " MESSAGEARGSWITHDEFAULTMESSAGE " ) ) . » contains Exactly « ( " Hi " ) ; }
@Test { » assert That « ( » get Macro Output « ( " URL " ) ) . » contains Exactly « ( " / springtest / aftercontext . html " ) ; }
@Test { » assert That « ( » get Macro Output « ( " URLPARAMS " ) ) . » contains Exactly « ( " / springtest / aftercontext / bar ? spam = bucket " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 1 « " ) ) . » contains Exactly « ( " < input type = \" text \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 2 « " ) ) . » contains Exactly « ( " < input type = \" text \" id = \" name \" name = \" name \" value = \" Darren \" class = \" » my Css Class « \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 3 « " ) ) . » contains Exactly « ( " < textarea id = \" name \" name = \" name \" > Darren < / textarea > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 4 « " ) ) . » contains Exactly « ( " < textarea id = \" name \" name = \" name \" rows = 10 cols = 30 > Darren < / textarea > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 5 « " ) ) . » contains Exactly « ( " < select id = \" name \" name = \" name \" > " , " < option value = \" Rob & amp ; Harrop \" > Rob Harrop < / option > " , " < option value = \" John \" > John Doe < / option > " , " < option value = \" Fred \" > Fred Bloggs < / option > " , " < option value = \" Darren \" selected = \" selected \" > Darren Davison < / option > " , " < / select > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 14 « " ) ) . » contains Exactly « ( " < select id = \" name \" name = \" name \" > " , " < option value = \" Rob Harrop \" > Rob Harrop < / option > " , " < option value = \" Darren Davison \" > Darren Davison < / option > " , " < option value = \" John Doe \" > John Doe < / option > " , " < option value = \" Fred Bloggs \" > Fred Bloggs < / option > " , " < / select > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 6 « " ) ) . » contains Exactly « ( " < select multiple = \" multiple \" id = \" spouses \" name = \" spouses \" > " , " < option value = \" Rob & amp ; Harrop \" > Rob Harrop < / option > " , " < option value = \" John \" > John Doe < / option > " , " < option value = \" Fred \" selected = \" selected \" > Fred Bloggs < / option > " , " < option value = \" Darren \" > Darren Davison < / option > " , " < / select > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 15 « " ) ) . » contains Exactly « ( " < input type = \" hidden \" name = \" » _ name « \" value = \" on \" / > " , " < input type = \" checkbox \" id = \" name \" name = \" name \" / > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 16 « " ) ) . » contains Exactly « ( " < input type = \" hidden \" name = \" » _ jedi « \" value = \" on \" / > " , " < input type = \" checkbox \" id = \" jedi \" name = \" jedi \" checked = \" checked \" / > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 18 « " ) ) . » contains Exactly « ( " < input type = \" hidden \" name = \" » _ spouses « [ 0 ] . jedi \" value = \" on \" / > " , " < input type = \" checkbox \" id = \" » spouses 0 « . jedi \" name = \" spouses [ 0 ] . jedi \" checked = \" checked \" / > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 9 « " ) ) . » contains Exactly « ( " < input type = \" password \" id = \" name \" name = \" name \" value = \" \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 10 « " ) ) . » contains Exactly « ( " < input type = \" hidden \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 11 « " ) ) . » contains Exactly « ( " < input type = \" text \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 12 « " ) ) . » contains Exactly « ( " < input type = \" hidden \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 13 « " ) ) . » contains Exactly « ( " < input type = \" password \" id = \" name \" name = \" name \" value = \" \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 17 « " ) ) . » contains Exactly « ( " < input type = \" text \" id = \" » spouses 0 « . name \" name = \" spouses [ 0 ] . name \" value = \" Fred \" > " ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , " Foo " ) ; String url = " org / springframework / web / reactive / result / view / script / kotlin / template . kts " ; » Mock Server Http Response « response = render ( url , model , Locale . FRENCH , » Script Templating Configuration « . class ) ; » assert That « ( response . » get Body As String « ( ) . block ( ) ) . » is Equal To « ( " < html > < body > \n < p > Bonjour Foo < / p > \n < / body > < / html > " ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , " Foo " ) ; String url = " org / springframework / web / reactive / result / view / script / kotlin / template . kts " ; » Mock Server Http Response « response = render ( url , model , Locale . ENGLISH , » Script Templating Configuration « . class ) ; » assert That « ( response . » get Body As String « ( ) . block ( ) ) . » is Equal To « ( " < html > < body > \n < p > Hello Foo < / p > \n < / body > < / html > " ) ; }
@Test { String url = " org / springframework / web / reactive / result / view / script / nashorn / template . html " ; Class < ? > » config Class « = » Script Templating With Url Configuration « . class ; » Mock Server Http Response « response = render ( url , null , » config Class « ) ; » assert That « ( response . » get Body As String « ( ) . block ( ) ) . » is Equal To « ( ( " < html > < head > < title > Check url parameter < / title > < / head > < body > < p > " + url + " < / p > < / body > < / html > " ) ) ; }
@Test { » Script Template View Resolver « resolver = new » Script Template View Resolver « ( ) ; » assert That « ( resolver . » required View Class « ( ) ) . » is Equal To « ( » Script Template View « . class ) ; » Direct Field Accessor « » view Accessor « = new » Direct Field Accessor « ( resolver ) ; Class < ? > » view Class « = ( Class < ? > ) » view Accessor « . » get Property Value « ( " » view Class « " ) ; » assert That « ( » view Class « ) . » is Equal To « ( » Script Template View « . class ) ; }
@Test { this . context . refresh ( ) ; this . view . » set Resource Loader Path « ( " classpath : org / springframework / web / reactive / result / view / script / " ) ; this . view . » set Url « ( " missing . txt " ) ; this . view . » set Engine « ( mock ( » Invocable Script Engine « . class ) ) ; this . configurer . » set Render Function « ( " render " ) ; this . view . » set Application Context « ( this . context ) ; » assert That « ( this . view . » check Resource Exists « ( Locale . ENGLISH ) ) . » is False « ( ) ; }
@Test { » assert That Exception Of Type « ( » Application Context Exception « . class ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( new » Static Application Context « ( ) ) ) . » with Message Containing « ( " » Script Template Config « " ) ; }
@Test { this . view . » set Engine « ( mock ( » Script Engine « . class ) ) ; this . view . » set Application Context « ( this . context ) ; }
@Test { this . view . » set Engine « ( mock ( » Script Engine « . class ) ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . context ) ) ; }
@Test { this . view . » set Engine « ( mock ( » Invocable Script Engine « . class ) ) ; this . view . » set Engine Name « ( " test " ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . context ) ) . » with Message Containing « ( " You should define either 'engine' , 'engineSupplier' or 'engineName' . " ) ; }
@Test { » Script Engine « engine = mock ( » Invocable Script Engine « . class ) ; this . view . » set Engine Supplier « ( ( ) -> engine ) ; this . view . » set Engine « ( engine ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . context ) ) . » with Message Containing « ( " You should define either 'engine' , 'engineSupplier' or 'engineName' . " ) ; }
@Test { this . view . » set Engine Supplier « ( ( ) -> mock ( » Invocable Script Engine « . class ) ) ; this . view . » set Engine Name « ( " test " ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . context ) ) . » with Message Containing « ( " You should define either 'engine' , 'engineSupplier' or 'engineName' . " ) ; }
@Test { this . view . » set Engine « ( mock ( » Invocable Script Engine « . class ) ) ; this . view . » set Render Function « ( " render " ) ; this . view . » set Shared Engine « ( false ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . context ) ) . » with Message Containing « ( " » shared Engine « " ) ; }
@Test { » Mock Servlet Context « sc = new » Mock Servlet Context « ( " " ) ; sc . » add Init Parameter « ( » Context Loader « . » CONFIG _ LOCATION _ PARAM « , " / WEB - INF / » my Context « . xml " ) ; » Servlet Context Listener « listener = new » Context Loader Listener « ( ) ; » Servlet Context Event « event = new » Servlet Context Event « ( sc ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> listener . » context Initialized « ( event ) ) . » with Cause Instance Of « ( » File Not Found Exception « . class ) ; }
@Test { » Mock Servlet Context « sc = new » Mock Servlet Context « ( " " ) ; sc . » add Init Parameter « ( » Context Loader « . » CONTEXT _ CLASS _ PARAM « , " org . springframework . web . context . support . » Invalid Web Application Context « " ) ; » Servlet Context Listener « listener = new » Context Loader Listener « ( ) ; » Servlet Context Event « event = new » Servlet Context Event « ( sc ) ; » assert That Exception Of Type « ( » Application Context Exception « . class ) . » is Thrown By « ( ( ) -> listener . » context Initialized « ( event ) ) . » with Cause Instance Of « ( » Class Not Found Exception « . class ) ; }
@Test { » Mock Servlet Context « sc = new » Mock Servlet Context « ( " " ) ; » Servlet Context Listener « listener = new » Context Loader Listener « ( ) ; » Servlet Context Event « event = new » Servlet Context Event « ( sc ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> listener . » context Initialized « ( event ) ) . » with Cause Instance Of « ( » IO Exception « . class ) . satisfies ( ex -> » assert That « ( ex . » get Cause « ( ) ) . » has Message Containing « ( " / WEB - INF / » application Context « . xml " ) ) ; }
@Test { » Dispatcher Servlet « servlet = new » Dispatcher Servlet « ( ) ; servlet . » set Context Class « ( » Xml Web Application Context « . class ) ; » assert That Exception Of Type « ( » Bean Definition Store Exception « . class ) . » is Thrown By « ( ( ) -> servlet . init ( new » Mock Servlet Config « ( new » Mock Servlet Context « ( " " ) , " test " ) ) ) . » with Cause Instance Of « ( » IO Exception « . class ) . satisfies ( ex -> » assert That « ( ex . » get Cause « ( ) ) . » has Message Containing « ( " / WEB - INF / test - servlet . xml " ) ) ; }
@Test { » Servlet Context « » servlet Context « = null ; » Servlet Context Aware Processor « processor = new » Servlet Context Aware Processor « ( » servlet Context « ) ; » Servlet Context Aware Bean « bean = new » Servlet Context Aware Bean « ( ) ; » assert That « ( bean . » get Servlet Context « ( ) ) . » is Null « ( ) ; processor . » post Process Before Initialization « ( bean , " » test Bean « " ) ; » assert That « ( bean . » get Servlet Context « ( ) ) . » is Null « ( ) ; }
@Test { » Servlet Context « » servlet Context « = new » Mock Servlet Context « ( ) ; » Servlet Context Aware Processor « processor = new » Servlet Context Aware Processor « ( » servlet Context « ) ; » Servlet Config Aware Bean « bean = new » Servlet Config Aware Bean « ( ) ; » assert That « ( bean . » get Servlet Config « ( ) ) . » is Null « ( ) ; processor . » post Process Before Initialization « ( bean , " » test Bean « " ) ; » assert That « ( bean . » get Servlet Config « ( ) ) . » is Null « ( ) ; }
@Test { » Servlet Context « » servlet Context « = new » Mock Servlet Context « ( ) ; » Servlet Context Aware Processor « processor = new » Servlet Context Aware Processor « ( » servlet Context « , null ) ; » Servlet Config Aware Bean « bean = new » Servlet Config Aware Bean « ( ) ; » assert That « ( bean . » get Servlet Config « ( ) ) . » is Null « ( ) ; processor . » post Process Before Initialization « ( bean , " » test Bean « " ) ; » assert That « ( bean . » get Servlet Config « ( ) ) . » is Null « ( ) ; }
@Test { » Servlet Context « » servlet Context « = null ; » Servlet Context Aware Processor « processor = new » Servlet Context Aware Processor « ( » servlet Context « ) ; » Servlet Config Aware Bean « bean = new » Servlet Config Aware Bean « ( ) ; » assert That « ( bean . » get Servlet Config « ( ) ) . » is Null « ( ) ; processor . » post Process Before Initialization « ( bean , " » test Bean « " ) ; » assert That « ( bean . » get Servlet Config « ( ) ) . » is Null « ( ) ; }
@Test { » assert That « ( this . » application Context « . » get Bean Definition Count « ( ) == 14 ) . as ( " should have 14 beans , not " + this . » application Context « . » get Bean Definition Count « ( ) ) . » is True « ( ) ; }
@Test { » Static Application Context « ac = new » Static Application Context « ( ) ; ac . » register Bean Definition « ( " test " , new » Root Bean Definition « ( » Test Web Application Object « . class ) ) ; » Web Application Object Support « wao = ( » Web Application Object Support « ) ac . » get Bean « ( " test " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( wao :: » get Web Application Context « ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » get Servlet Context « ( ) , " GET " , " / invalid . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » simple Dispatcher Servlet « . service ( request , response ) ; » assert That « ( response . » get Forwarded Url « ( ) == null ) . as ( " Not forwarded " ) . » is True « ( ) ; » assert That « ( response . » get Status « ( ) == » Http Servlet Response « . » SC _ NOT _ FOUND « ) . as ( " correct error code " ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » get Servlet Context « ( ) , " GET " , " / locale . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » complex Dispatcher Servlet « . service ( request , response ) ; » Complex Web Application Context « . » Test Application Listener « listener = ( » Complex Web Application Context « . » Test Application Listener « ) » complex Dispatcher Servlet « . » get Web Application Context « ( ) . » get Bean « ( " » test Listener « " ) ; » assert That « ( listener . counter ) . » is Equal To « ( 1 ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » get Servlet Context « ( ) , " GET " , " / view . do " ) ; request . » add User Role « ( " » role 1 « " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » complex Dispatcher Servlet « . service ( request , response ) ; » assert That « ( " myform . jsp " . equals ( response . » get Forwarded Url « ( ) ) ) . as ( " forwarded to form " ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » get Servlet Context « ( ) , " GET " , " / view . do " ) ; request . » add User Role « ( " » role 1 « " ) ; request . » add Parameter « ( " » no View « " , " true " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » complex Dispatcher Servlet « . service ( request , response ) ; » assert That « ( response . » get Forwarded Url « ( ) == null ) . as ( " Not forwarded " ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » get Servlet Context « ( ) , " GET " , " / locale . do " ) ; request . » add Preferred Locale « ( Locale . CANADA ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » complex Dispatcher Servlet « . service ( request , response ) ; » assert That « ( response . » get Status « ( ) == » Http Servlet Response « . » SC _ FORBIDDEN « ) . as ( " Correct response " ) . » is True « ( ) ; }
@Test { » Http Headers « headers = new » Http Headers « ( ) ; headers . add ( " foo " , " bar " ) ; » No Handler Found Exception « ex = new » No Handler Found Exception « ( " GET " , " / foo " , headers ) ; » assert That « ( ! ex . » get Message « ( ) . contains ( " bar " ) ) . » is True « ( ) ; » assert That « ( ! ex . » to String « ( ) . contains ( " bar " ) ) . » is True « ( ) ; }
@Test { » Mock Servlet Context « » servlet Context « = new » Mock Servlet Context « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » servlet Context « , " GET " , " / noview . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » complex Dispatcher Servlet « . service ( request , response ) ; » assert That « ( response . » get Forwarded Url « ( ) ) . » is Equal To « ( " noview . jsp " ) ; }
@Test { » Mock Servlet Context « » servlet Context « = new » Mock Servlet Context « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( » servlet Context « , " GET " , " / noview / simple . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » complex Dispatcher Servlet « . service ( request , response ) ; » assert That « ( response . » get Forwarded Url « ( ) ) . » is Equal To « ( " noview / simple . jsp " ) ; }
@Test { » Dispatcher Servlet « servlet = new » Dispatcher Servlet « ( ) ; servlet . » set Context Class « ( » Simple Web Application Context « . class ) ; servlet . » set Context Initializers « ( new » Test Web Context Initializer « ( ) , new » Other Web Context Initializer « ( ) ) ; servlet . init ( » servlet Config « ) ; » assert That « ( » get Servlet Context « ( ) . » get Attribute « ( " initialized " ) ) . » is Equal To « ( " true " ) ; » assert That « ( » get Servlet Context « ( ) . » get Attribute « ( " » other Initialized « " ) ) . » is Equal To « ( " true " ) ; }
@Test { given ( this . » interceptor 1 « . » pre Handle « ( this . request , this . response , this . handler ) ) . » will Return « ( true ) ; given ( this . » interceptor 2 « . » pre Handle « ( this . request , this . response , this . handler ) ) . » will Return « ( false ) ; this . chain . » apply Pre Handle « ( request , response ) ; verify ( this . » interceptor 1 « ) . » after Completion « ( this . request , this . response , this . handler , null ) ; }
@Test { this . chain . » trigger After Completion « ( this . request , this . response , null ) ; » verify No Interactions « ( this . » interceptor 1 « , this . » interceptor 2 « , this . » interceptor 3 « ) ; }
@Test { » assert That « ( new » Flash Map « ( ) . » is Expired « ( ) ) . » is False « ( ) ; » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . » start Expiration Period « ( 0 ) ; Thread . sleep ( 100 ) ; » assert That « ( » flash Map « . » is Expired « ( ) ) . » is True « ( ) ; }
@Test { » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . » start Expiration Period « ( 10 ) ; Thread . sleep ( 100 ) ; » assert That « ( » flash Map « . » is Expired « ( ) ) . » is False « ( ) ; }
@Test { » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . » add Target Request Param « ( " " , " abc " ) ; » flash Map « . » add Target Request Param « ( null , " abc " ) ; » assert That « ( » flash Map « . » get Target Request Params « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Multi Value Map « < String , String > params = new » Linked Multi Value Map « < > ( ) ; params . add ( " " , " abc " ) ; params . add ( null , " " ) ; » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . » add Target Request Params « ( params ) ; » assert That « ( » flash Map « . » get Target Request Params « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » load Bean Definitions « ( " mvc - config - message - converters . xml " ) ; » verify Message Converters « ( this . » app Context « . » get Bean « ( » Request Mapping Handler Adapter « . class ) , true ) ; » verify Message Converters « ( this . » app Context « . » get Bean « ( » Exception Handler Exception Resolver « . class ) , true ) ; » verify Request Response Body Advice « ( this . » app Context « . » get Bean « ( » Request Mapping Handler Adapter « . class ) ) ; » verify Response Body Advice « ( this . » app Context « . » get Bean « ( » Exception Handler Exception Resolver « . class ) ) ; }
@Test { » load Bean Definitions « ( " mvc - config - message - converters - defaults - off . xml " ) ; » verify Message Converters « ( this . » app Context « . » get Bean « ( » Request Mapping Handler Adapter « . class ) , false ) ; » verify Message Converters « ( this . » app Context « . » get Bean « ( » Exception Handler Exception Resolver « . class ) , false ) ; }
@Test { » load Bean Definitions « ( " mvc - config - argument - resolvers . xml " ) ; » test Argument Resolvers « ( this . » app Context « . » get Bean « ( » Request Mapping Handler Adapter « . class ) ) ; » test Argument Resolvers « ( this . » app Context « . » get Bean « ( » Exception Handler Exception Resolver « . class ) ) ; }
@Test { » load Bean Definitions « ( " mvc - config - return - value - handlers . xml " ) ; » test Return Value Handlers « ( this . » app Context « . » get Bean « ( » Request Mapping Handler Adapter « . class ) ) ; » test Return Value Handlers « ( this . » app Context « . » get Bean « ( » Exception Handler Exception Resolver « . class ) ) ; }
@Test { » load Bean Definitions « ( " mvc - config . xml " ) ; » Bean Name Url Handler Mapping « mapping = this . » app Context « . » get Bean « ( » Bean Name Url Handler Mapping « . class ) ; » assert That « ( mapping ) . » is Not Null « ( ) ; » assert That « ( mapping . » get Order « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » do Test Custom Validator « ( " mvc - config - custom - validator . xml " ) ; }
@Test { this . configurer . » media Types « ( Collections . » singleton Map « ( " json " , » Media Type « . » APPLICATION _ JSON « ) ) ; » Content Negotiation Manager « manager = this . configurer . » build Content Negotiation Manager « ( ) ; this . » servlet Request « . » set Request URI « ( " / flower . json " ) ; » assert That « ( manager . » resolve Media Types « ( this . » web Request « ) . get ( 0 ) ) . » is Equal To « ( » Media Type « . » APPLICATION _ JSON « ) ; }
@Test { this . configurer . » ignore Accept Header « ( true ) ; » Content Negotiation Manager « manager = this . configurer . » build Content Negotiation Manager « ( ) ; this . » servlet Request « . » set Request URI « ( " / flower " ) ; this . » servlet Request « . » add Header « ( " Accept " , » Media Type « . » IMAGE _ GIF _ VALUE « ) ; » assert That « ( manager . » resolve Media Types « ( this . » web Request « ) ) . » is Equal To « ( » Content Negotiation Strategy « . » MEDIA _ TYPE _ ALL _ LIST « ) ; }
@Test { this . configurer . » default Content Type « ( » Media Type « . » APPLICATION _ JSON « ) ; » Content Negotiation Manager « manager = this . configurer . » build Content Negotiation Manager « ( ) ; » assert That « ( manager . » resolve Media Types « ( this . » web Request « ) . get ( 0 ) ) . » is Equal To « ( » Media Type « . » APPLICATION _ JSON « ) ; }
@Test { this . configurer . » default Content Type « ( » Media Type « . » APPLICATION _ JSON « , » Media Type « . ALL ) ; » Content Negotiation Manager « manager = this . configurer . » build Content Negotiation Manager « ( ) ; » assert That « ( manager . » resolve Media Types « ( this . » web Request « ) ) . » is Equal To « ( Arrays . » as List « ( » Media Type « . » APPLICATION _ JSON « , » Media Type « . ALL ) ) ; }
@Test { this . configurer . » default Content Type Strategy « ( new » Fixed Content Negotiation Strategy « ( » Media Type « . » APPLICATION _ JSON « ) ) ; » Content Negotiation Manager « manager = this . configurer . » build Content Negotiation Manager « ( ) ; » assert That « ( manager . » resolve Media Types « ( this . » web Request « ) . get ( 0 ) ) . » is Equal To « ( » Media Type « . » APPLICATION _ JSON « ) ; }
@Test { » assert That « ( configurer . » build Handler Mapping « ( ) ) . » is Null « ( ) ; }
@Test { load ( context -> { } ) ; » Request Mapping Handler Mapping « » handler Mapping « = this . context . » get Bean « ( » Request Mapping Handler Mapping « . class ) ; » assert That « ( » handler Mapping « . » get Content Negotiation Manager « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » mvc Content Negotiation Manager « " ) ) ; }
@Test { load ( context -> context . » register Bean « ( » Resource Handler Configuration « . class ) ) ; » Abstract Handler Mapping « » handler Mapping « = this . context . » get Bean « ( " » resource Handler Mapping « " , » Abstract Handler Mapping « . class ) ; » assert That « ( » handler Mapping « . » get Path Matcher « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » mvc Path Matcher « " ) ) ; » assert That « ( » handler Mapping « . » get Url Path Helper « ( ) ) . » is Same As « ( this . context . » get Bean « ( " » mvc Url Path Helper « " ) ) ; }
@Test { load ( » register Primary Bean « ( " » test Validator « " , Validator . class ) ) ; » Request Mapping Handler Adapter « » mapping Handler Adapter « = this . context . » get Bean « ( » Request Mapping Handler Adapter « . class ) ; » assert That « ( » mapping Handler Adapter « . » get Web Binding Initializer « ( ) ) . » has Field Or Property With Value « ( " validator " , this . context . » get Bean « ( " » mvc Validator « " ) ) ; » assert That « ( this . context . » get Beans Of Type « ( Validator . class ) ) . » contains Only Keys « ( " » mvc Validator « " , " » test Validator « " ) ; }
@Test { given ( » web Mvc Configurer « . » get Validator « ( ) ) . » will Return « ( new » Local Validator Factory Bean « ( ) ) ; » delegating Config « . » set Configurers « ( Collections . » singleton List « ( » web Mvc Configurer « ) ) ; » delegating Config « . » mvc Validator « ( ) ; verify ( » web Mvc Configurer « ) . » get Validator « ( ) ; }
@Test { given ( » web Mvc Configurer « . » get Message Codes Resolver « ( ) ) . » will Return « ( new » Default Message Codes Resolver « ( ) ) ; » delegating Config « . » set Configurers « ( Collections . » singleton List « ( » web Mvc Configurer « ) ) ; » delegating Config « . » get Message Codes Resolver « ( ) ; verify ( » web Mvc Configurer « ) . » get Message Codes Resolver « ( ) ; }
@Test { » assert That « ( this . registry . » get Order « ( ) ) . » is Equal To « ( Ordered . » LOWEST _ PRECEDENCE « ) ; this . registry . » enable Content Negotiation « ( ) ; » assert That « ( this . registry . » get Order « ( ) ) . » is Equal To « ( Ordered . » HIGHEST _ PRECEDENCE « ) ; }
@Test { » assert That « ( this . registry . » has Registrations « ( ) ) . » is False « ( ) ; this . registry . » enable Content Negotiation « ( ) ; » assert That « ( this . registry . » has Registrations « ( ) ) . » is True « ( ) ; }
@Test { » Internal Resource View Resolver « » view Resolver « = new » Internal Resource View Resolver « ( " / " , " . jsp " ) ; this . registry . » view Resolver « ( » view Resolver « ) ; » assert That « ( this . registry . » get View Resolvers « ( ) . get ( 0 ) ) . » is Same As « ( » view Resolver « ) ; }
@Test { this . registry . » bean Name « ( ) ; » assert That « ( this . registry . » get View Resolvers « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( registry . » get View Resolvers « ( ) . get ( 0 ) . » get Class « ( ) ) . » is Equal To « ( » Bean Name View Resolver « . class ) ; }
@Test { this . registry . jsp ( ) ; » Internal Resource View Resolver « resolver = » check And Get Resolver « ( » Internal Resource View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " / WEB - INF / " , " suffix " , " . jsp " ) ; }
@Test { this . registry . jsp ( " / " , " . jsp " ) ; » Internal Resource View Resolver « resolver = » check And Get Resolver « ( » Internal Resource View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " / " , " suffix " , " . jsp " ) ; }
@Test { this . registry . tiles ( ) ; » check And Get Resolver « ( » Tiles View Resolver « . class ) ; }
@Test { this . registry . » free Marker « ( ) . prefix ( " / " ) . suffix ( " . fmt " ) . cache ( false ) ; » Free Marker View Resolver « resolver = » check And Get Resolver « ( » Free Marker View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " / " , " suffix " , " . fmt " , " » cache Limit « " , 0 ) ; }
@Test { this . registry . » free Marker « ( ) ; » Free Marker View Resolver « resolver = » check And Get Resolver « ( » Free Marker View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " " , " suffix " , " . ftl " ) ; }
@Test { this . registry . groovy ( ) . prefix ( " / " ) . suffix ( " . groovy " ) . cache ( true ) ; » Groovy Markup View Resolver « resolver = » check And Get Resolver « ( » Groovy Markup View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " / " , " suffix " , " . groovy " , " » cache Limit « " , 1024 ) ; }
@Test { this . registry . groovy ( ) ; » Groovy Markup View Resolver « resolver = » check And Get Resolver « ( » Groovy Markup View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " " , " suffix " , " . tpl " ) ; }
@Test { this . registry . » script Template « ( ) . prefix ( " / " ) . suffix ( " . html " ) . cache ( true ) ; » Script Template View Resolver « resolver = » check And Get Resolver « ( » Script Template View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " / " , " suffix " , " . html " , " » cache Limit « " , 1024 ) ; }
@Test { this . registry . » script Template « ( ) ; » Script Template View Resolver « resolver = » check And Get Resolver « ( » Script Template View Resolver « . class ) ; » check Property Values « ( resolver , " prefix " , " " , " suffix " , " " ) ; }
@Test { » Mapping Jackson 2 Json View « view = new » Mapping Jackson 2 Json View « ( ) ; this . registry . » enable Content Negotiation « ( view ) ; » Content Negotiating View Resolver « resolver = » check And Get Resolver « ( » Content Negotiating View Resolver « . class ) ; » assert That « ( resolver . » get Default Views « ( ) ) . » is Equal To « ( Arrays . » as List « ( view ) ) ; » assert That « ( this . registry . » get Order « ( ) ) . » is Equal To « ( Ordered . » HIGHEST _ PRECEDENCE « ) ; }
@Test { List < » Handler Exception Resolver « > resolvers = ( ( » Handler Exception Resolver Composite « ) this . config . » handler Exception Resolver « ( null ) ) . » get Exception Resolvers « ( ) ; » assert That « ( resolvers . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( resolvers . get ( 0 ) . » get Class « ( ) ) . » is Equal To « ( » Response Status Exception Resolver « . class ) ; » assert That « ( resolvers . get ( 1 ) . » get Class « ( ) ) . » is Equal To « ( » Simple Mapping Exception Resolver « . class ) ; }
@Test { Map < String , » Cors Configuration « > configs = this . config . » get Cors Configurations « ( ) ; » assert That « ( configs . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( configs . get ( " » / resources / « * * " ) . » get Allowed Origins « ( ) . get ( 0 ) ) . » is Equal To « ( " * " ) ; }
@Test { » Mock Http Servlet Response « response = » run Test « ( » Free Marker Web Config « . class ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " < html > < body > Hello World ! < / body > < / html > " ) ; }
@Test { » Mock Http Servlet Response « response = » run Test « ( » Tiles Web Config « . class ) ; » assert That « ( response . » get Forwarded Url « ( ) ) . » is Equal To « ( " / WEB - INF / index . jsp " ) ; }
@Test { » Mock Http Servlet Response « response = » run Test « ( » Groovy Markup Web Config « . class ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " < html > < body > Hello World ! < / body > < / html > " ) ; }
@Test { » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> » run Test « ( » Invalid Free Marker Web Config « . class ) ) . » with Message Containing « ( " In addition to a » Free Marker « view resolver " ) ; }
@Test { » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> » run Test « ( » Invalid Tiles Web Config « . class ) ) . » with Message Containing « ( " In addition to a Tiles view resolver " ) ; }
@Test { » assert That Exception Of Type « ( » Runtime Exception « . class ) . » is Thrown By « ( ( ) -> » run Test « ( » Invalid Groovy Markup Web Config « . class ) ) . » with Message Containing « ( " In addition to a Groovy markup view resolver " ) ; }
@Test { » Mock Http Servlet Response « response = » run Test « ( » Existing View Resolver Config « . class ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " < html > < body > Hello World ! < / body > < / html > " ) ; }
@Test { » Application Context « context = » init Context « ( » Web Config « . class ) ; » Composite Uri Components Contributor « » uri Components Contributor « = context . » get Bean « ( » Mvc Uri Components Builder « . » MVC _ URI _ COMPONENTS _ CONTRIBUTOR _ BEAN _ NAME « , » Composite Uri Components Contributor « . class ) ; » assert That « ( » uri Components Contributor « ) . » is Not Null « ( ) ; }
@Test { » Application Context « context = » init Context « ( » Web Config « . class ) ; » Url Path Helper « » url Path Helper « = context . » get Bean « ( » Url Path Helper « . class ) ; » Path Matcher « » path Matcher « = context . » get Bean « ( » Path Matcher « . class ) ; » assert That « ( » url Path Helper « ) . » is Not Null « ( ) ; » assert That « ( » path Matcher « ) . » is Not Null « ( ) ; » assert That « ( » path Matcher « . » get Class « ( ) ) . » is Equal To « ( » Ant Path Matcher « . class ) ; }
@Test { this . registry = new » Resource Handler Registry « ( new » Generic Web Application Context « ( ) , new » Mock Servlet Context « ( ) ) ; » assert That « ( ( Object ) this . registry . » get Handler Mapping « ( ) ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Method « ( " GET " ) ; request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " / » test Stylesheet « . css " ) ; » Resource Http Request Handler « handler = » get Handler « ( " » / resources / « * * " ) ; handler . » handle Request « ( request , this . response ) ; » assert That « ( this . response . » get Content As String « ( ) ) . » is Equal To « ( " test stylesheet content " ) ; }
@Test { » assert That « ( » get Handler « ( " » / resources / « * * " ) . » get Cache Seconds « ( ) ) . » is Equal To « ( - 1 ) ; this . registration . » set Cache Period « ( 0 ) ; » assert That « ( » get Handler « ( " » / resources / « * * " ) . » get Cache Seconds « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( registry . » get Handler Mapping « ( ) . » get Order « ( ) ) . » is Equal To « ( Integer . » MAX _ VALUE « - 1 ) ; registry . » set Order « ( 0 ) ; » assert That « ( registry . » get Handler Mapping « ( ) . » get Order « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert That « ( this . registry . » build Handler Mapping « ( ) ) . » is Null « ( ) ; }
@Test { this . registry . » add View Controller « ( " / path " ) ; » Parameterizable View Controller « controller = » get Controller « ( " / path " ) ; » assert That « ( controller . » get View Name « ( ) ) . » is Null « ( ) ; » assert That « ( controller . » get Status Code « ( ) ) . » is Null « ( ) ; » assert That « ( controller . » is Status Only « ( ) ) . » is False « ( ) ; » assert That « ( controller . » get Application Context « ( ) ) . » is Not Null « ( ) ; }
@Test { this . registry . » add View Controller « ( " / path " ) ; » Simple Url Handler Mapping « » handler Mapping « = this . registry . » build Handler Mapping « ( ) ; » assert That « ( » handler Mapping « . » get Order « ( ) ) . » is Equal To « ( 1 ) ; this . registry . » set Order « ( 2 ) ; » handler Mapping « = this . registry . » build Handler Mapping « ( ) ; » assert That « ( » handler Mapping « . » get Order « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { this . registry . » add Interceptor « ( this . » interceptor 1 « ) ; List < » Handler Interceptor « > interceptors = » get Interceptors For Path « ( null ) ; » assert That « ( interceptors ) . » is Equal To « ( Arrays . » as List « ( this . » interceptor 1 « ) ) ; }
@Test { this . registry . » add Interceptor « ( this . » interceptor 1 « ) ; this . registry . » add Interceptor « ( this . » interceptor 2 « ) ; List < » Handler Interceptor « > interceptors = » get Interceptors For Path « ( null ) ; » assert That « ( interceptors ) . » is Equal To « ( Arrays . » as List « ( this . » interceptor 1 « , this . » interceptor 2 « ) ) ; }
@Test { this . registry . » add Web Request Interceptor « ( this . » web Interceptor 1 « ) ; List < » Handler Interceptor « > interceptors = » get Interceptors For Path « ( null ) ; » assert That « ( interceptors . size ( ) ) . » is Equal To « ( 1 ) ; » verify Web Interceptor « ( interceptors . get ( 0 ) , this . » web Interceptor 1 « ) ; }
@Test { this . registry . » add Web Request Interceptor « ( this . » web Interceptor 1 « ) ; this . registry . » add Web Request Interceptor « ( this . » web Interceptor 2 « ) ; List < » Handler Interceptor « > interceptors = » get Interceptors For Path « ( null ) ; » assert That « ( interceptors . size ( ) ) . » is Equal To « ( 2 ) ; » verify Web Interceptor « ( interceptors . get ( 0 ) , this . » web Interceptor 1 « ) ; » verify Web Interceptor « ( interceptors . get ( 1 ) , this . » web Interceptor 2 « ) ; }
@Test { » Path Matcher « » path Matcher « = Mockito . mock ( » Path Matcher « . class ) ; this . registry . » add Interceptor « ( » interceptor 1 « ) . » add Path Patterns « ( " » / path 1 / « * * " ) . » path Matcher « ( » path Matcher « ) ; » Mapped Interceptor « » mapped Interceptor « = ( » Mapped Interceptor « ) this . registry . » get Interceptors « ( ) . get ( 0 ) ; » assert That « ( » mapped Interceptor « . » get Path Matcher « ( ) ) . » is Same As « ( » path Matcher « ) ; }
@Test { this . registry . » add Interceptor « ( this . » interceptor 1 « ) . order ( 0 ) ; this . registry . » add Interceptor « ( this . » interceptor 2 « ) . order ( 0 ) ; List < Object > interceptors = this . registry . » get Interceptors « ( ) ; » assert That « ( interceptors . size ( ) ) . » is Equal To « ( 2 ) ; » assert That « ( interceptors . get ( 0 ) ) . » is Same As « ( this . » interceptor 1 « ) ; » assert That « ( interceptors . get ( 1 ) ) . » is Same As « ( this . » interceptor 2 « ) ; }
@Test { String name = " foo " ; » Rendering Response « result = » Rendering Response « . create ( name ) . build ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mav = result . » write To « ( request , response , » EMPTY _ CONTEXT « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( name ) ; }
@Test { » Rendering Response « result = » Rendering Response « . create ( " foo " ) . » model Attribute « ( " foo " , " bar " ) . build ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mav = result . » write To « ( request , response , » EMPTY _ CONTEXT « ) ; » assert That « ( mav ) . » is Not Null « ( ) ; » assert That « ( mav . » get Model « ( ) . get ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Rendering Response « result = » Rendering Response « . create ( " foo " ) . » model Attribute « ( " bar " ) . build ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mav = result . » write To « ( request , response , » EMPTY _ CONTEXT « ) ; » assert That « ( mav ) . » is Not Null « ( ) ; » assert That « ( mav . » get Model « ( ) . get ( " string " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Rendering Response « result = » Rendering Response « . create ( " foo " ) . » model Attributes « ( " bar " ) . build ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mav = result . » write To « ( request , response , » EMPTY _ CONTEXT « ) ; » assert That « ( mav ) . » is Not Null « ( ) ; » assert That « ( mav . » get Model « ( ) . get ( " string " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Request Predicate « » predicate 1 « = request -> true ; » Request Predicate « » predicate 2 « = request -> true ; » Request Predicate « » predicate 3 « = request -> false ; » assert That « ( » predicate 1 « . and ( » predicate 2 « ) . test ( request ) ) . » is True « ( ) ; » assert That « ( » predicate 2 « . and ( » predicate 1 « ) . test ( request ) ) . » is True « ( ) ; » assert That « ( » predicate 1 « . and ( » predicate 3 « ) . test ( request ) ) . » is False « ( ) ; }
@Test { » Request Predicate « predicate = request -> false ; » Request Predicate « negated = predicate . negate ( ) ; » assert That « ( negated . test ( request ) ) . » is True « ( ) ; predicate = request -> true ; negated = predicate . negate ( ) ; » assert That « ( negated . test ( request ) ) . » is False « ( ) ; }
@Test { » Request Predicate « » predicate 1 « = request -> true ; » Request Predicate « » predicate 2 « = request -> false ; » Request Predicate « » predicate 3 « = request -> false ; » assert That « ( » predicate 1 « . or ( » predicate 2 « ) . test ( request ) ) . » is True « ( ) ; » assert That « ( » predicate 2 « . or ( » predicate 1 « ) . test ( request ) ) . » is True « ( ) ; » assert That « ( » predicate 2 « . or ( » predicate 3 « ) . test ( request ) ) . » is False « ( ) ; }
@Test { » Request Predicate « predicate = » Request Predicates « . all ( ) ; » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( ) ; » Server Request « request = new » Default Server Request « ( » servlet Request « , » empty List « ( ) ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / path " ) ; » Server Request « request = new » Default Server Request « ( » servlet Request « , » empty List « ( ) ) ; » Request Predicate « predicate = » Request Predicates « . path ( " p * " ) ; » assert That « ( predicate . test ( request ) ) . » is True « ( ) ; }
@Test { String body = " foo " ; » Entity Response « < String > response = » Entity Response « . » from Object « ( body ) . build ( ) ; » assert That « ( response . entity ( ) ) . » is Same As « ( body ) ; }
@Test { String body = " foo " ; » Entity Response « < String > response = » Entity Response « . » from Object « ( body , new » Parameterized Type Reference « < String > ( ) { } ) . build ( ) ; » assert That « ( response . entity ( ) ) . » is Same As « ( body ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . status ( » Http Status « . CREATED ) . build ( ) ; » assert That « ( result . » status Code « ( ) ) . » is Equal To « ( » Http Status « . CREATED ) ; » assert That « ( result . » raw Status Code « ( ) ) . » is Equal To « ( 201 ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . allow ( » Http Method « . GET ) . build ( ) ; Set < » Http Method « > expected = » Enum Set « . of ( » Http Method « . GET ) ; » assert That « ( result . headers ( ) . » get Allow « ( ) ) . » is Equal To « ( expected ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . » content Length « ( 42 ) . build ( ) ; » assert That « ( result . headers ( ) . » get Content Length « ( ) ) . » is Equal To « ( 42 ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . build ( ) ; » assert That « ( result . headers ( ) . » get Content Type « ( ) ) . » is Equal To « ( » Media Type « . » APPLICATION _ JSON « ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . » e Tag « ( " foo " ) . build ( ) ; » assert That « ( result . headers ( ) . » get E Tag « ( ) ) . » is Equal To « ( " \" foo \" " ) ; }
@Test { » Zoned Date Time « now = » Zoned Date Time « . now ( ) ; String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . » last Modified « ( now ) . build ( ) ; long expected = now . » to Instant « ( ) . » to Epoch Milli « ( ) / 1000 ; » assert That « ( result . headers ( ) . » get Last Modified « ( ) / 1000 ) . » is Equal To « ( expected ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . » cache Control « ( » Cache Control « . » no Cache « ( ) ) . build ( ) ; » assert That « ( result . headers ( ) . » get Cache Control « ( ) ) . » is Equal To « ( " no - cache " ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . » vary By « ( " foo " ) . build ( ) ; List < String > expected = Collections . » singleton List « ( " foo " ) ; » assert That « ( result . headers ( ) . » get Vary « ( ) ) . » is Equal To « ( expected ) ; }
@Test { String body = " foo " ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . header ( " foo " , " bar " ) . build ( ) ; » assert That « ( result . headers ( ) . » get First « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { String body = " foo " ; » Http Headers « headers = new » Http Headers « ( ) ; headers . set ( " foo " , " bar " ) ; » Entity Response « < String > result = » Entity Response « . » from Object « ( body ) . headers ( h -> h . » add All « ( headers ) ) . build ( ) ; » assert That « ( result . headers ( ) ) . » is Equal To « ( headers ) ; }
@Test { Cookie cookie = new Cookie ( " name " , " value " ) ; » Entity Response « < String > result = » Entity Response « . » from Object « ( " foo " ) . cookie ( cookie ) . build ( ) ; » assert That « ( result . cookies ( ) . get ( " name " ) . contains ( cookie ) ) . » is True « ( ) ; }
@Test { » Multi Value Map « < String , Cookie > » new Cookies « = new » Linked Multi Value Map « < > ( ) ; » new Cookies « . add ( " name " , new Cookie ( " name " , " value " ) ) ; » Entity Response « < String > result = » Entity Response « . » from Object « ( " foo " ) . cookies ( cookies -> cookies . » add All « ( » new Cookies « ) ) . build ( ) ; » assert That « ( result . cookies ( ) ) . » is Equal To « ( » new Cookies « ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " HEAD " , " / " ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . method ( ) ) . » is Equal To « ( » Http Method « . HEAD ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Server Name « ( " example . com " ) ; » servlet Request « . » set Scheme « ( " https " ) ; » servlet Request « . » set Server Port « ( 443 ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . uri ( ) ) . » is Equal To « ( URI . create ( " https : » // example . com / « " ) ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Attribute « ( " foo " , " bar " ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . attribute ( " foo " ) ) . » is Equal To « ( Optional . of ( " bar " ) ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Parameter « ( " foo " , " bar " ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . param ( " foo " ) ) . » is Equal To « ( Optional . of ( " bar " ) ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Parameter « ( " foo " , " " ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . param ( " foo " ) ) . » is Equal To « ( Optional . of ( " " ) ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Parameter « ( " foo " , " " ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . param ( " bar " ) ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; Map < String , String > » path Variables « = Collections . » singleton Map « ( " foo " , " bar " ) ; » servlet Request « . » set Attribute « ( » Router Functions « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » path Variables « ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . » path Variable « ( " foo " ) ) . » is Equal To « ( " bar " ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; Map < String , String > » path Variables « = Collections . » singleton Map « ( " foo " , " bar " ) ; » servlet Request « . » set Attribute « ( » Router Functions « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » path Variables « ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> request . » path Variable « ( " baz " ) ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; Map < String , String > » path Variables « = Collections . » singleton Map « ( " foo " , " bar " ) ; » servlet Request « . » set Attribute « ( » Router Functions « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » path Variables « ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . » path Variables « ( ) ) . » is Equal To « ( » path Variables « ) ; }
@Test { Cookie cookie = new Cookie ( " foo " , " bar " ) ; » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Cookies « ( cookie ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » Multi Value Map « < String , Cookie > expected = new » Linked Multi Value Map « < > ( ) ; expected . add ( " foo " , cookie ) ; » assert That « ( request . cookies ( ) ) . » is Equal To « ( expected ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » servlet Request « . » set Content Type « ( » Media Type « . » TEXT _ PLAIN _ VALUE « ) ; » servlet Request « . » set Content « ( " foo " . » get Bytes « ( » UTF _ 8 « ) ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; String result = request . body ( String . class ) ; » assert That « ( result ) . » is Equal To « ( " foo " ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » Mock Http Session « session = new » Mock Http Session « ( ) ; » servlet Request « . » set Session « ( session ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . session ( ) ) . » is Equal To « ( session ) ; }
@Test { » Mock Http Servlet Request « » servlet Request « = new » Mock Http Servlet Request « ( " GET " , " / " ) ; Principal principal = new Principal ( ) { @ Override public String » get Name « ( ) { return " foo " ; } } ; » servlet Request « . » set User Principal « ( principal ) ; » Default Server Request « request = new » Default Server Request « ( » servlet Request « , this . » message Converters « ) ; » assert That « ( request . principal ( ) . get ( ) ) . » is Equal To « ( principal ) ; }
@Test { » Server Response « response = » Server Response « . status ( » Http Status « . CREATED ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . CREATED ) ; » assert That « ( response . » raw Status Code « ( ) ) . » is Equal To « ( 201 ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . OK ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; » Server Response « response = » Server Response « . created ( location ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . CREATED ) ; » assert That « ( response . headers ( ) . » get Location « ( ) ) . » is Equal To « ( location ) ; }
@Test { » Server Response « response = » Server Response « . accepted ( ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . ACCEPTED ) ; }
@Test { » Server Response « response = » Server Response « . » no Content « ( ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » NO _ CONTENT « ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; » Server Response « response = » Server Response « . » see Other « ( location ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » SEE _ OTHER « ) ; » assert That « ( response . headers ( ) . » get Location « ( ) ) . » is Equal To « ( location ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; » Server Response « response = » Server Response « . » temporary Redirect « ( location ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » TEMPORARY _ REDIRECT « ) ; » assert That « ( response . headers ( ) . » get Location « ( ) ) . » is Equal To « ( location ) ; }
@Test { URI location = URI . create ( " https : » // example . com « " ) ; » Server Response « response = » Server Response « . » permanent Redirect « ( location ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » PERMANENT _ REDIRECT « ) ; » assert That « ( response . headers ( ) . » get Location « ( ) ) . » is Equal To « ( location ) ; }
@Test { » Server Response « response = » Server Response « . » bad Request « ( ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « ) ; }
@Test { » Server Response « response = » Server Response « . » not Found « ( ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » NOT _ FOUND « ) ; }
@Test { » Server Response « response = » Server Response « . » unprocessable Entity « ( ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » Http Status « . » UNPROCESSABLE _ ENTITY « ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . allow ( » Http Method « . GET ) . build ( ) ; » assert That « ( response . headers ( ) . » get Allow « ( ) ) . » is Equal To « ( » Enum Set « . of ( » Http Method « . GET ) ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . » content Length « ( 42 ) . build ( ) ; » assert That « ( response . headers ( ) . » get Content Length « ( ) ) . » is Equal To « ( 42L ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . » content Type « ( » Media Type « . » APPLICATION _ JSON « ) . build ( ) ; » assert That « ( response . headers ( ) . » get Content Type « ( ) ) . » is Equal To « ( » Media Type « . » APPLICATION _ JSON « ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . » e Tag « ( " foo " ) . build ( ) ; » assert That « ( response . headers ( ) . » get E Tag « ( ) ) . » is Equal To « ( " \" foo \" " ) ; }
@Test { » Zoned Date Time « now = » Zoned Date Time « . now ( ) ; » Server Response « response = » Server Response « . ok ( ) . » last Modified « ( now ) . build ( ) ; long expected = now . » to Instant « ( ) . » to Epoch Milli « ( ) / 1000 ; » assert That « ( response . headers ( ) . » get Last Modified « ( ) / 1000 ) . » is Equal To « ( expected ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . » cache Control « ( » Cache Control « . » no Cache « ( ) ) . build ( ) ; » assert That « ( response . headers ( ) . » get Cache Control « ( ) ) . » is Equal To « ( " no - cache " ) ; }
@Test { » Server Response « response = » Server Response « . ok ( ) . » vary By « ( " foo " ) . build ( ) ; List < String > expected = Collections . » singleton List « ( " foo " ) ; » assert That « ( response . headers ( ) . » get Vary « ( ) ) . » is Equal To « ( expected ) ; }
@Test { » Http Status « » status Code « = » Http Status « . ACCEPTED ; » Server Response « response = » Server Response « . status ( » status Code « ) . build ( ) ; » assert That « ( response . » status Code « ( ) ) . » is Equal To « ( » status Code « ) ; }
@Test { » Http Headers « » new Headers « = new » Http Headers « ( ) ; » new Headers « . set ( " foo " , " bar " ) ; » Server Response « response = » Server Response « . ok ( ) . headers ( headers -> headers . » add All « ( » new Headers « ) ) . build ( ) ; » assert That « ( response . headers ( ) ) . » is Equal To « ( » new Headers « ) ; }
@Test { » Multi Value Map « < String , Cookie > » new Cookies « = new » Linked Multi Value Map « < > ( ) ; » new Cookies « . add ( " name " , new Cookie ( " name " , " value " ) ) ; » Server Response « response = » Server Response « . ok ( ) . cookies ( cookies -> cookies . » add All « ( » new Cookies « ) ) . build ( ) ; » assert That « ( response . cookies ( ) ) . » is Equal To « ( » new Cookies « ) ; }
@Test { » check Mappings « ( " » url Mapping « " ) ; }
@Test { » check Mappings « ( " » url Mapping With Props « " ) ; }
@Test { String key = " foo " ; this . mapping . » register Mapping « ( key , this . handler , this . » method 1 « ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , key ) ; » Handler Method « result = this . mapping . » get Handler Internal « ( request ) ; » assert That « ( result . » get Method « ( ) ) . » is Equal To « ( » method 1 « ) ; » assert That « ( request . » get Attribute « ( » Handler Mapping « . » BEST _ MATCHING _ HANDLER _ ATTRIBUTE « ) ) . » is Equal To « ( result ) ; }
@Test { this . mapping . » register Mapping « ( " / f ? o " , this . handler , this . » method 1 « ) ; this . mapping . » register Mapping « ( " / fo ? " , this . handler , this . » method 2 « ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . mapping . » get Handler Internal « ( new » Mock Http Servlet Request « ( " GET " , " / foo " ) ) ) ; }
@Test { Object bean = wac . » get Bean « ( " » star Controller « " ) ; » Mock Http Servlet Request « req = new » Mock Http Servlet Request « ( " GET " , " / goggog . html " ) ; » Handler Execution Chain « hec = » get Handler « ( req ) ; » assert That « ( hec != null && hec . » get Handler « ( ) == bean ) . as ( " Handler is correct bean " ) . » is True « ( ) ; }
@Test { » Handler Mapping « hm = ( » Handler Mapping « ) wac . » get Bean « ( " » handler Mapping « " ) ; » do Test Requests With Sub Paths « ( hm ) ; }
@Test { » Bean Name Url Handler Mapping « hm = new » Bean Name Url Handler Mapping « ( ) ; hm . » set Detect Handlers In Ancestor Contexts « ( true ) ; hm . » set Application Context « ( new » Static Application Context « ( wac ) ) ; » do Test Requests With Sub Paths « ( hm ) ; }
@Test { » Bean Name Url Handler Mapping « hm = ( » Bean Name Url Handler Mapping « ) wac . » get Bean « ( " » handler Mapping « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> hm . » register Handler « ( " / mypath / welcome . html " , new Object ( ) ) ) ; }
@Test { » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( null , null , this . interceptor ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo " , » path Matcher « ) ) . » is True « ( ) ; }
@Test { » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " » / foo / « * " } , this . interceptor ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo / bar " , » path Matcher « ) ) . » is True « ( ) ; » assert That « ( » mapped Interceptor « . matches ( " / bar / foo " , » path Matcher « ) ) . » is False « ( ) ; }
@Test { » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " » / foo « * / * " } , this . interceptor ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo ; q = 1 / bar ; s = 2 " , » path Matcher « ) ) . » is True « ( ) ; }
@Test { » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( null , new String [ ] { " » / admin / « * * " } , this . interceptor ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo " , » path Matcher « ) ) . » is True « ( ) ; » assert That « ( » mapped Interceptor « . matches ( " / admin / foo " , » path Matcher « ) ) . » is False « ( ) ; }
@Test { » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " / * * " } , new String [ ] { " » / admin / « * * " } , this . interceptor ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo " , » path Matcher « ) ) . » is True « ( ) ; » assert That « ( » mapped Interceptor « . matches ( " / admin / foo " , » path Matcher « ) ) . » is False « ( ) ; }
@Test { » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " / foo / [ 0 - 9 ] * " } , this . interceptor ) ; » mapped Interceptor « . » set Path Matcher « ( new » Test Path Matcher « ( ) ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo / 123 " , » path Matcher « ) ) . » is True « ( ) ; » assert That « ( » mapped Interceptor « . matches ( " / foo / bar " , » path Matcher « ) ) . » is False « ( ) ; }
@Test { » Handler Interceptor « interceptor = mock ( » Handler Interceptor « . class ) ; » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " / * * " } , interceptor ) ; » mapped Interceptor « . » pre Handle « ( mock ( » Http Servlet Request « . class ) , mock ( » Http Servlet Response « . class ) , null ) ; then ( interceptor ) . should ( ) . » pre Handle « ( any ( » Http Servlet Request « . class ) , any ( » Http Servlet Response « . class ) , any ( ) ) ; }
@Test { » Handler Interceptor « interceptor = mock ( » Handler Interceptor « . class ) ; » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " / * * " } , interceptor ) ; » mapped Interceptor « . » post Handle « ( mock ( » Http Servlet Request « . class ) , mock ( » Http Servlet Response « . class ) , null , mock ( » Model And View « . class ) ) ; then ( interceptor ) . should ( ) . » post Handle « ( any ( ) , any ( ) , any ( ) , any ( ) ) ; }
@Test { » Handler Interceptor « interceptor = mock ( » Handler Interceptor « . class ) ; » Mapped Interceptor « » mapped Interceptor « = new » Mapped Interceptor « ( new String [ ] { " / * * " } , interceptor ) ; » mapped Interceptor « . » after Completion « ( mock ( » Http Servlet Request « . class ) , mock ( » Http Servlet Response « . class ) , null , mock ( Exception . class ) ) ; then ( interceptor ) . should ( ) . » after Completion « ( any ( ) , any ( ) , any ( ) , any ( ) ) ; }
@Test { » Static Web Application Context « cxt = new » Static Web Application Context « ( ) ; cxt . » register Singleton « ( " » hm 1 « " , » Test Handler Mapping « . class ) ; cxt . refresh ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » get Introspector « ( cxt ) . » get Matchable Handler Mapping « ( request ) ) ; }
@Test { » exception Resolver « . » set Order « ( 2 ) ; » assert That « ( » exception Resolver « . » get Order « ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " default - view " ) ; » assert That « ( mav . » get Model « ( ) . get ( » Simple Mapping Exception Resolver « . » DEFAULT _ EXCEPTION _ ATTRIBUTE « ) ) . » is Equal To « ( » generic Exception « ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » exception Resolver « . » set Mapped Handlers « ( Collections . singleton ( » handler 1 « ) ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 2 « , » generic Exception « ) ; » assert That « ( mav ) . » is Null « ( ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » exception Resolver « . » set Mapped Handler Classes « ( String . class ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 2 « , » generic Exception « ) ; » assert That « ( mav ) . » is Null « ( ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » exception Resolver « . » set Exception Attribute « ( null ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " default - view " ) ; » assert That « ( mav . » get Model « ( ) . get ( » Simple Mapping Exception Resolver « . » DEFAULT _ EXCEPTION _ ATTRIBUTE « ) ) . » is Null « ( ) ; }
@Test { » exception Resolver « . » set Exception Mappings « ( null ) ; » exception Resolver « . » set Default Error View « ( " default - view " ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " default - view " ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ OK « ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » exception Resolver « . » set Default Status Code « ( » Http Servlet Response « . » SC _ BAD _ REQUEST « ) ; » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ BAD _ REQUEST « ) ; }
@Test { » exception Resolver « . » set Default Error View « ( " default - view " ) ; » exception Resolver « . » set Default Status Code « ( » Http Servlet Response « . » SC _ BAD _ REQUEST « ) ; request . » set Attribute « ( » Web Utils « . » INCLUDE _ REQUEST _ URI _ ATTRIBUTE « , " some path " ) ; » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ OK « ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " Exception " , " error " ) ; » exception Resolver « . » set Warn Log Category « ( " » HANDLER _ EXCEPTION « " ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " java . lang . Exception " , " error " ) ; » exception Resolver « . » set Mapped Handlers « ( Collections . singleton ( » handler 1 « ) ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " java . lang . Exception " , " error " ) ; » exception Resolver « . » set Mapped Handler Classes « ( String . class ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " java . lang . Exception " , " error " ) ; » exception Resolver « . » set Mapped Handler Classes « ( Comparable . class ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " Exception " , " error " ) ; » exception Resolver « . » set Mapped Handlers « ( Collections . singleton ( » handler 1 « ) ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 2 « , » generic Exception « ) ; » assert That « ( mav ) . » is Null « ( ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " Exception " , " error " ) ; » exception Resolver « . » set Mapped Handler Classes « ( String . class ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 2 « , » generic Exception « ) ; » assert That « ( mav ) . » is Null « ( ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " Exception " , " error " ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » exception Resolver « . » set Excluded Exceptions « ( » Illegal Argument Exception « . class ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , new » Illegal Argument Exception « ( ) ) ; » assert That « ( mav ) . » is Null « ( ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " » Some Foo Throwable « " , " error " ) ; » exception Resolver « . » set Warn Log Category « ( " » HANDLER _ EXCEPTION « " ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav ) . » is Null « ( ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " java . lang . Exception " , " error " ) ; props . » set Property « ( " » Another Exception « " , " another - error " ) ; » exception Resolver « . » set Mapped Handlers « ( Collections . singleton ( » handler 1 « ) ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { Properties props = new Properties ( ) ; props . » set Property « ( " Exception " , " error " ) ; props . » set Property « ( " » Another Exception « " , " another - error " ) ; » exception Resolver « . » set Mapped Handlers « ( Collections . singleton ( » handler 1 « ) ) ; » exception Resolver « . » set Exception Mappings « ( props ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , » handler 1 « , » generic Exception « ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( " error " ) ; }
@Test { » do Test « ( new » Accept Header Locale Resolver « ( ) , false ) ; }
@Test { » do Test « ( new » Fixed Locale Resolver « ( Locale . UK ) , false ) ; }
@Test { » do Test « ( new » Cookie Locale Resolver « ( ) , true ) ; }
@Test { » do Test « ( new » Session Locale Resolver « ( ) , true ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » get Session « ( ) . » set Attribute « ( » Session Locale Resolver « . » LOCALE _ SESSION _ ATTRIBUTE _ NAME « , Locale . GERMAN ) ; » Session Locale Resolver « resolver = new » Session Locale Resolver « ( ) ; » assert That « ( resolver . » resolve Locale « ( request ) ) . » is Equal To « ( Locale . GERMAN ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Preferred Locale « ( Locale . TAIWAN ) ; » Session Locale Resolver « resolver = new » Session Locale Resolver « ( ) ; » assert That « ( resolver . » resolve Locale « ( request ) ) . » is Equal To « ( request . » get Locale « ( ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Preferred Locale « ( Locale . TAIWAN ) ; » Session Locale Resolver « resolver = new » Session Locale Resolver « ( ) ; resolver . » set Default Locale « ( Locale . GERMAN ) ; » assert That « ( resolver . » resolve Locale « ( request ) ) . » is Equal To « ( Locale . GERMAN ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; Cookie cookie = new Cookie ( " » Language Koekje « " , " nl " ) ; request . » set Cookies « ( cookie ) ; » Cookie Locale Resolver « resolver = new » Cookie Locale Resolver « ( ) ; resolver . » set Cookie Name « ( " » Language Koekje « " ) ; Locale loc = resolver . » resolve Locale « ( request ) ; » assert That « ( loc . » get Language « ( ) ) . » is Equal To « ( " nl " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; Cookie cookie = new Cookie ( " » Language Koekje « " , " ++ GMT + 1 " ) ; request . » set Cookies « ( cookie ) ; » Cookie Locale Resolver « resolver = new » Cookie Locale Resolver « ( ) ; resolver . » set Cookie Name « ( " » Language Koekje « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> resolver . » resolve Locale Context « ( request ) ) . » with Message Containing « ( " » Language Koekje « " ) . » with Message Containing « ( " ++ GMT + 1 " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; Cookie cookie = new Cookie ( " » Language Koekje « " , " nl X - MT " ) ; request . » set Cookies « ( cookie ) ; » Cookie Locale Resolver « resolver = new » Cookie Locale Resolver « ( ) ; resolver . » set Cookie Name « ( " » Language Koekje « " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> resolver . » resolve Locale Context « ( request ) ) . » with Message Containing « ( " » Language Koekje « " ) . » with Message Containing « ( " nl X - MT " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Preferred Locale « ( Locale . TAIWAN ) ; » Cookie Locale Resolver « resolver = new » Cookie Locale Resolver « ( ) ; Locale loc = resolver . » resolve Locale « ( request ) ; » assert That « ( loc ) . » is Equal To « ( request . » get Locale « ( ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Preferred Locale « ( Locale . TAIWAN ) ; » Cookie Locale Resolver « resolver = new » Cookie Locale Resolver « ( ) ; resolver . » set Default Locale « ( Locale . GERMAN ) ; Locale loc = resolver . » resolve Locale « ( request ) ; » assert That « ( loc ) . » is Equal To « ( Locale . GERMAN ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Preferred Locale « ( Locale . TAIWAN ) ; Cookie cookie = new Cookie ( » Cookie Locale Resolver « . » DEFAULT _ COOKIE _ NAME « , " " ) ; request . » set Cookies « ( cookie ) ; » Cookie Locale Resolver « resolver = new » Cookie Locale Resolver « ( ) ; Locale loc = resolver . » resolve Locale « ( request ) ; » assert That « ( loc ) . » is Equal To « ( request . » get Locale « ( ) ) ; }
@Test { » assert That « ( this . resolver . » resolve Locale « ( request ( CANADA ) ) ) . » is Equal To « ( CANADA ) ; » assert That « ( this . resolver . » resolve Locale « ( request ( US , CANADA ) ) ) . » is Equal To « ( US ) ; }
@Test { this . resolver . » set Supported Locales « ( Collections . » singleton List « ( CANADA ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ( US , CANADA ) ) ) . » is Equal To « ( CANADA ) ; }
@Test { this . resolver . » set Supported Locales « ( Collections . » singleton List « ( CANADA ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ( US , UK ) ) ) . » is Equal To « ( US ) ; }
@Test { this . resolver . » set Supported Locales « ( Collections . » singleton List « ( ENGLISH ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ( GERMANY , US , UK ) ) ) . » is Equal To « ( ENGLISH ) ; }
@Test { this . resolver . » set Supported Locales « ( Arrays . » as List « ( ENGLISH , UK ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ( GERMANY , US , UK ) ) ) . » is Equal To « ( UK ) ; }
@Test { this . resolver . » set Supported Locales « ( Arrays . » as List « ( GERMAN , US ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ( GERMANY , US , UK ) ) ) . » is Equal To « ( GERMAN ) ; }
@Test { this . resolver . » set Supported Locales « ( Arrays . » as List « ( US , JAPAN ) ) ; this . resolver . » set Default Locale « ( Locale . JAPAN ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " Accept - Language " , KOREA . » to Language Tag « ( ) ) ; request . » set Preferred Locales « ( Collections . » singleton List « ( KOREA ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ) ) . » is Equal To « ( Locale . JAPAN ) ; }
@Test { this . resolver . » set Default Locale « ( JAPANESE ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That « ( this . resolver . » resolve Locale « ( request ) ) . » is Equal To « ( JAPANESE ) ; request . » add Header « ( " Accept - Language " , US . » to Language Tag « ( ) ) ; request . » set Preferred Locales « ( Collections . » singleton List « ( US ) ) ; » assert That « ( this . resolver . » resolve Locale « ( request ) ) . » is Equal To « ( US ) ; }
@Test { » Servlet Forwarding Controller « sfc = new » Servlet Forwarding Controller « ( ) ; sfc . » set Servlet Name « ( " action " ) ; » do Test Servlet Forwarding Controller « ( sfc , false ) ; }
@Test { » Servlet Forwarding Controller « sfc = new » Servlet Forwarding Controller « ( ) ; sfc . » set Servlet Name « ( " action " ) ; » do Test Servlet Forwarding Controller « ( sfc , true ) ; }
@Test { » Servlet Forwarding Controller « sfc = new » Servlet Forwarding Controller « ( ) ; sfc . » set Bean Name « ( " action " ) ; » do Test Servlet Forwarding Controller « ( sfc , false ) ; }
@Test { String » view Name « = " » test View « " ; this . controller . » set View Name « ( » view Name « ) ; » Model And View « mav = this . controller . » handle Request « ( this . request , new » Mock Http Servlet Response « ( ) ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Equal To « ( » view Name « ) ; » assert That « ( mav . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Model And View « mav = this . controller . » handle Request « ( this . request , new » Mock Http Servlet Response « ( ) ) ; » assert That « ( mav . » get View Name « ( ) ) . » is Null « ( ) ; » assert That « ( mav . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { this . request . » set Attribute « ( » Dispatcher Servlet « . » INPUT _ FLASH _ MAP _ ATTRIBUTE « , new » Model Map « ( " name " , " value " ) ) ; » Model And View « mav = this . controller . » handle Request « ( this . request , new » Mock Http Servlet Response « ( ) ) ; » assert That « ( mav . » get Model « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( mav . » get Model « ( ) . get ( " name " ) ) . » is Equal To « ( " value " ) ; }
@Test { this . request . » set Method « ( » Http Method « . OPTIONS . name ( ) ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mav = this . controller . » handle Request « ( this . request , response ) ; » assert That « ( mav ) . » is Null « ( ) ; » assert That « ( response . » get Header « ( " Allow " ) ) . » is Equal To « ( " GET , HEAD , OPTIONS " ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / index " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mv = ctrl . » handle Request « ( request , response ) ; » assert That « ( mv . » get View Name « ( ) ) . » is Equal To « ( " index " ) ; » assert That « ( mv . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / index . html " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mv = ctrl . » handle Request « ( request , response ) ; » assert That « ( mv . » get View Name « ( ) ) . » is Equal To « ( " index " ) ; » assert That « ( mv . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / index ; a = A ; b = B " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mv = ctrl . » handle Request « ( request , response ) ; » assert That « ( mv . » get View Name « ( ) ) . » is Equal To « ( " index " ) ; » assert That « ( mv . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / docs / cvs / commit . html " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mv = ctrl . » handle Request « ( request , response ) ; » assert That « ( mv . » get View Name « ( ) ) . » is Equal To « ( " docs / cvs / commit " ) ; » assert That « ( mv . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; ctrl . » set Prefix « ( null ) ; » assert That « ( ctrl . » get Prefix « ( ) ) . as ( " For » set Prefix « ( . . ) with null , the empty string must be used instead . " ) . » is Not Null « ( ) ; » assert That « ( ctrl . » get Prefix « ( ) ) . as ( " For » set Prefix « ( . . ) with null , the empty string must be used instead . " ) . » is Equal To « ( " " ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; ctrl . » set Suffix « ( null ) ; » assert That « ( ctrl . » get Suffix « ( ) ) . as ( " For » set Prefix « ( . . ) with null , the empty string must be used instead . " ) . » is Not Null « ( ) ; » assert That « ( ctrl . » get Suffix « ( ) ) . as ( " For » set Prefix « ( . . ) with null , the empty string must be used instead . " ) . » is Equal To « ( " " ) ; }
@Test { » Url Filename View Controller « ctrl = new » Url Filename View Controller « ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / products / view . html " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » Model And View « mv = ctrl . » handle Request « ( request , response ) ; » assert That « ( mv . » get View Name « ( ) ) . » is Equal To « ( " products / view " ) ; » assert That « ( mv . » get Model « ( ) . » is Empty « ( ) ) . » is True « ( ) ; }
@Test { » Web Content Interceptor « interceptor = new » Web Content Interceptor « ( ) ; interceptor . » set Cache Seconds « ( 10 ) ; interceptor . » pre Handle « ( request , response , null ) ; Iterable < String > » cache Control Headers « = response . » get Headers « ( " Cache - Control " ) ; » assert That « ( » cache Control Headers « ) . contains ( " max - age = 10 " ) ; }
@Test { » Web Content Interceptor « interceptor = new » Web Content Interceptor « ( ) ; interceptor . » set Cache Seconds « ( 0 ) ; interceptor . » pre Handle « ( request , response , null ) ; Iterable < String > » cache Control Headers « = response . » get Headers « ( " Cache - Control " ) ; » assert That « ( » cache Control Headers « ) . contains ( " no - store " ) ; }
@Test { » Web Content Interceptor « interceptor = new » Web Content Interceptor « ( ) ; interceptor . » set Cache Seconds « ( - 1 ) ; interceptor . » pre Handle « ( request , response , null ) ; Iterable < String > » expires Headers « = response . » get Headers « ( " Expires " ) ; » assert That « ( » expires Headers « ) . » is Empty « ( ) ; Iterable < String > » cache Control Headers « = response . » get Headers « ( " Cache - Control " ) ; » assert That « ( » cache Control Headers « ) . » is Empty « ( ) ; }
@Test { » Web Content Interceptor « interceptor = new » Web Content Interceptor « ( ) ; interceptor . » set Cache Seconds « ( 10 ) ; response . » set Header « ( " Pragma " , " no - cache " ) ; response . » set Header « ( " Expires " , " 0 " ) ; interceptor . » pre Handle « ( request , response , null ) ; » assert That « ( response . » get Header « ( " Pragma " ) ) . » is Equal To « ( " " ) ; » assert That « ( response . » get Header « ( " Expires " ) ) . » is Equal To « ( " " ) ; }
@Test { » Web Content Interceptor « interceptor = new » Web Content Interceptor « ( ) ; interceptor . » set Cache Seconds « ( 10 ) ; interceptor . » set Always Must Revalidate « ( true ) ; response . » set Header « ( " Pragma " , " no - cache " ) ; response . » set Header « ( " Expires " , " 0 " ) ; interceptor . » pre Handle « ( request , response , null ) ; » assert That « ( response . » get Header « ( " Pragma " ) ) . » is Equal To « ( " " ) ; » assert That « ( response . » get Header « ( " Expires " ) ) . » is Equal To « ( " " ) ; }
@Test { » Web Content Interceptor « interceptor = new » Web Content Interceptor « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> interceptor . » set Path Matcher « ( null ) ) ; }
@Test { » init Servlet « ( » Type Level Impl « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / test " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; servlet . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » do It « " ) ; }
@Test { » init Servlet « ( » Method Level Impl « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / test " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; servlet . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » do It « " ) ; }
@Test { » init Servlet « ( » Type And Method Level Impl « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / hotels / bookings " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; servlet . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » do It « " ) ; }
@Test { » Status Code Exception « ex = new » Status Code Exception « ( ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert Resolved « ( mav , 400 , null ) ; }
@Test { » Status Code From Composed Response Status Exception « ex = new » Status Code From Composed Response Status Exception « ( ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert Resolved « ( mav , 400 , null ) ; }
@Test { » Status Code And Reason Exception « ex = new » Status Code And Reason Exception « ( ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert Resolved « ( mav , 410 , " You suck ! " ) ; }
@Test { Exception ex = new Exception ( ) ; » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert That « ( mav ) . as ( " » Model And View « returned " ) . » is Null « ( ) ; }
@Test { Exception cause = new » Status Code And Reason Message Exception « ( ) ; » Type Mismatch Exception « ex = new » Type Mismatch Exception « ( " value " , » I Test Bean « . class , cause ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert Resolved « ( mav , 410 , " gone . reason " ) ; }
@Test { » Response Status Exception « ex = new » Response Status Exception « ( » Http Status « . » BAD _ REQUEST « ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert Resolved « ( mav , 400 , null ) ; }
@Test { » Response Status Exception « ex = new » Response Status Exception « ( » Http Status « . » BAD _ REQUEST « , " The reason " ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert Resolved « ( mav , 400 , " The reason " ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " accept " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " Accept " , " " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " foo " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " bar " , " " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " ! accept " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " foo = bar " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " foo " , " bar " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " foo = bar " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " foo " , " bazz " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " foo = Bar " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " foo " , " bar " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " foo != bar " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " foo " , " baz " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Headers Request Condition « condition = new » Headers Request Condition « ( " foo != bar " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " foo " , " bar " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Headers Request Condition « » condition 1 « = new » Headers Request Condition « ( " foo != a " ) ; » Headers Request Condition « » condition 2 « = new » Headers Request Condition « ( " foo " ) ; » assert That « ( » condition 1 « . » compare To « ( » condition 2 « , request ) ) . as ( " Negated match should not count as more specific " ) . » is Equal To « ( 0 ) ; }
@Test { » Headers Request Condition « » condition 1 « = new » Headers Request Condition « ( " foo = bar " ) ; » Headers Request Condition « » condition 2 « = new » Headers Request Condition « ( " foo = baz " ) ; » Headers Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; Collection < » Header Expression « > conditions = result . » get Content « ( ) ; » assert That « ( conditions . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " foo " , " bar " ) ; » Headers Request Condition « condition = new » Headers Request Condition « ( " foo " ) ; » Headers Request Condition « result = condition . » get Matching Condition « ( request ) ; » assert That « ( result ) . » is Equal To « ( condition ) ; condition = new » Headers Request Condition « ( " bar " ) ; result = condition . » get Matching Condition « ( request ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Request Methods Request Condition « condition = new » Request Methods Request Condition « ( ) ; for ( » Request Method « method : » Request Method « . values ( ) ) { if ( method != OPTIONS ) { » Http Servlet Request « request = new » Mock Http Servlet Request « ( method . name ( ) , " " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; } } » test No Match « ( condition , OPTIONS ) ; }
@Test { » Http Servlet Request « request = new » Mock Http Servlet Request « ( " PROPFIND " , " " ) ; » assert That « ( new » Request Methods Request Condition « ( ) . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; » assert That « ( new » Request Methods Request Condition « ( GET , POST ) . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " OPTIONS " , " / path " ) ; request . » set Dispatcher Type « ( » Dispatcher Type « . ERROR ) ; » Request Methods Request Condition « condition = new » Request Methods Request Condition « ( ) ; » Request Methods Request Condition « result = condition . » get Matching Condition « ( request ) ; » assert That « ( result ) . » is Not Null « ( ) ; » assert That « ( result ) . » is Same As « ( condition ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " ! text / plain " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " » text / « * " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " , " application / xml " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " application / xml " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " 01 " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Consumes Request Condition « condition = new » Consumes Request Condition « ( " ! text / plain " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " 01 " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Content Type « ( " text / plain " ) ; » Consumes Request Condition « condition = new » Consumes Request Condition « ( " text / plain " , " application / xml " ) ; » Consumes Request Condition « result = condition . » get Matching Condition « ( request ) ; » assert Conditions « ( result , " text / plain " ) ; condition = new » Consumes Request Condition « ( " application / xml " ) ; result = condition . » get Matching Condition « ( request ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Patterns Request Condition « c = new » Patterns Request Condition « ( " foo " ) ; » assert That « ( c . » get Patterns « ( ) . iterator ( ) . next ( ) ) . » is Equal To « ( " / foo " ) ; }
@Test { » Patterns Request Condition « c = new » Patterns Request Condition « ( " " ) ; » assert That « ( c . » get Patterns « ( ) . iterator ( ) . next ( ) ) . as ( " Do not prepend empty patterns ( SPR - 8255 ) " ) . » is Equal To « ( " " ) ; }
@Test { » Patterns Request Condition « » c 1 « = new » Patterns Request Condition « ( ) ; » Patterns Request Condition « » c 2 « = new » Patterns Request Condition « ( ) ; » assert That « ( » c 1 « . combine ( » c 2 « ) ) . » is Equal To « ( new » Patterns Request Condition « ( " " ) ) ; }
@Test { » Patterns Request Condition « condition = new » Patterns Request Condition « ( " / foo " ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( new » Mock Http Servlet Request « ( " GET " , " / foo " ) ) ; » assert That « ( match ) . » is Not Null « ( ) ; }
@Test { » Patterns Request Condition « condition = new » Patterns Request Condition « ( " » / foo / « * " ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( new » Mock Http Servlet Request « ( " GET " , " / foo / bar " ) ) ; » assert That « ( match ) . » is Not Null « ( ) ; }
@Test { » Patterns Request Condition « condition = new » Patterns Request Condition « ( " / * * " , " / foo / bar " , " » / foo / « * " ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( new » Mock Http Servlet Request « ( " GET " , " / foo / bar " ) ) ; » Patterns Request Condition « expected = new » Patterns Request Condition « ( " / foo / bar " , " » / foo / « * " , " / * * " ) ; » assert That « ( match ) . » is Equal To « ( expected ) ; }
@Test { » Patterns Request Condition « condition = new » Patterns Request Condition « ( " / foo . jpg " ) ; » Patterns Request Condition « match = condition . » get Matching Condition « ( new » Mock Http Servlet Request « ( " GET " , " / foo . html " ) ) ; » assert That « ( match ) . » is Null « ( ) ; }
@Test { » Patterns Request Condition « » c 1 « = new » Patterns Request Condition « ( " / foo * " ) ; » Patterns Request Condition « » c 2 « = new » Patterns Request Condition « ( " / foo * " ) ; » assert That « ( » c 1 « . » compare To « ( » c 2 « , new » Mock Http Servlet Request « ( " GET " , " / foo " ) ) ) . » is Equal To « ( 0 ) ; }
@Test { » Patterns Request Condition « » c 1 « = new » Patterns Request Condition « ( " / fo * " ) ; » Patterns Request Condition « » c 2 « = new » Patterns Request Condition « ( " / foo " ) ; » assert That « ( » c 1 « . » compare To « ( » c 2 « , new » Mock Http Servlet Request « ( " GET " , " / foo " ) ) ) . » is Equal To « ( 1 ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » Composite Request Condition « cond = new » Composite Request Condition « ( this . » param 1 « ) ; » assert That « ( cond . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Composite Request Condition « empty = new » Composite Request Condition « ( ) ; » assert That « ( empty . » get Matching Condition « ( new » Mock Http Servlet Request « ( ) ) ) . » is Same As « ( empty ) ; }
@Test { » Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Composite Request Condition « » cond 1 « = new » Composite Request Condition « ( this . » param 1 « ) ; » Composite Request Condition « » cond 3 « = new » Composite Request Condition « ( this . » param 3 « ) ; » assert That « ( » cond 1 « . » compare To « ( » cond 3 « , request ) ) . » is Equal To « ( 1 ) ; » assert That « ( » cond 3 « . » compare To « ( » cond 1 « , request ) ) . » is Equal To « ( - 1 ) ; }
@Test { » Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Composite Request Condition « empty = new » Composite Request Condition « ( ) ; » Composite Request Condition « » not Empty « = new » Composite Request Condition « ( this . » param 1 « ) ; » assert That « ( empty . » compare To « ( empty , request ) ) . » is Equal To « ( 0 ) ; » assert That « ( » not Empty « . » compare To « ( empty , request ) ) . » is Equal To « ( - 1 ) ; » assert That « ( empty . » compare To « ( » not Empty « , request ) ) . » is Equal To « ( 1 ) ; }
@Test { » Composite Request Condition « » cond 1 « = new » Composite Request Condition « ( this . » param 1 « ) ; » Composite Request Condition « » cond 2 « = new » Composite Request Condition « ( this . » param 1 « , this . » header 1 « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> » cond 1 « . » compare To « ( » cond 2 « , new » Mock Http Servlet Request « ( ) ) ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " ) ; » Http Servlet Request « request = » create Request « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " ! text / plain " ) ; » Http Servlet Request « request = » create Request « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " ! text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( new » Mock Http Servlet Request « ( ) ) ) . » is Not Null « ( ) ; » assert That « ( condition . » get Producible Media Types « ( ) ) . » is Equal To « ( Collections . » empty Set « ( ) ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " » text / « * " ) ; » Http Servlet Request « request = » create Request « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " , " application / xml " ) ; » Http Servlet Request « request = » create Request « ( " text / plain " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " ) ; » Http Servlet Request « request = » create Request « ( " application / xml " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " ) ; » Http Servlet Request « request = » create Request « ( " bogus " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " ! text / plain " ) ; » Http Servlet Request « request = » create Request « ( " bogus " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { String [ ] produces = { " text / plain " } ; String [ ] headers = { } ; » Produces Request Condition « condition = new » Produces Request Condition « ( produces , headers ) ; » Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo . txt " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Produces Request Condition « condition = new » Produces Request Condition « ( " ! application / json " ) ; » Http Servlet Request « request = » create Request « ( " » text / html « , » application / xhtml + xml « , » application / xml « ; » q = 0 . 9 « , » image / webp « , » image / apng « , * / * ; » q = 0 . 8 « " ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Http Servlet Request « request = » create Request « ( " * / * ; » q = 0 . 9 « " ) ; » Produces Request Condition « » condition 1 « = new » Produces Request Condition « ( ) ; » Produces Request Condition « » condition 2 « = new » Produces Request Condition « ( " application / json " ) ; » assert That « ( » condition 1 « . » compare To « ( » condition 2 « , request ) < 0 ) . » is True « ( ) ; » assert That « ( » condition 2 « . » compare To « ( » condition 1 « , request ) > 0 ) . » is True « ( ) ; }
@Test { » Http Servlet Request « request = » create Request « ( " text / plain " ) ; » Produces Request Condition « condition = new » Produces Request Condition « ( " text / plain " , " application / xml " ) ; » Produces Request Condition « result = condition . » get Matching Condition « ( request ) ; » assert Conditions « ( result , " text / plain " ) ; condition = new » Produces Request Condition « ( " application / xml " ) ; result = condition . » get Matching Condition « ( request ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » Request Methods Request Condition « rm = new » Request Methods Request Condition « ( » Request Method « . POST ) ; » Request Condition Holder « custom = new » Request Condition Holder « ( rm ) ; » assert That « ( custom . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Request Condition Holder « empty = new » Request Condition Holder « ( null ) ; » assert That « ( empty . » get Matching Condition « ( new » Mock Http Servlet Request « ( ) ) ) . » is Same As « ( empty ) ; }
@Test { » Request Condition Holder « params = new » Request Condition Holder « ( new » Params Request Condition « ( " name " ) ) ; » Request Condition Holder « headers = new » Request Condition Holder « ( new » Headers Request Condition « ( " name " ) ) ; » assert That Exception Of Type « ( » Class Cast Exception « . class ) . » is Thrown By « ( ( ) -> params . » compare To « ( headers , new » Mock Http Servlet Request « ( ) ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Parameter « ( " foo " , " " ) ; » assert That « ( new » Params Request Condition « ( " foo " ) . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Parameter « ( " foo " , ( String ) null ) ; » assert That « ( new » Params Request Condition « ( " foo " ) . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Header « ( " bar " , " " ) ; » assert That « ( new » Params Request Condition « ( " foo " ) . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Params Request Condition « condition = new » Params Request Condition « ( " ! foo " ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That « ( condition . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Parameter « ( " foo " , " bar " ) ; » assert That « ( new » Params Request Condition « ( " foo = bar " ) . » get Matching Condition « ( request ) ) . » is Not Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » add Parameter « ( " foo " , " bazz " ) ; » assert That « ( new » Params Request Condition « ( " foo = bar " ) . » get Matching Condition « ( request ) ) . » is Null « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Params Request Condition « » condition 1 « = new » Params Request Condition « ( " » response _ type « = code " ) ; » Params Request Condition « » condition 2 « = new » Params Request Condition « ( " » response _ type « " ) ; int result = » condition 1 « . » compare To « ( » condition 2 « , request ) ; » assert That « ( result < 0 ) . as ( " Invalid comparison result : " + result ) . » is True « ( ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Params Request Condition « » condition 1 « = new » Params Request Condition « ( " » response _ type « != code " ) ; » Params Request Condition « » condition 2 « = new » Params Request Condition « ( " » response _ type « " ) ; » assert That « ( » condition 1 « . » compare To « ( » condition 2 « , request ) ) . as ( " Negated match should not count as more specific " ) . » is Equal To « ( 0 ) ; }
@Test { » Params Request Condition « » condition 1 « = new » Params Request Condition « ( " foo = bar " ) ; » Params Request Condition « » condition 2 « = new » Params Request Condition « ( " foo = baz " ) ; » Params Request Condition « result = » condition 1 « . combine ( » condition 2 « ) ; Collection < » Param Expression « > conditions = result . » get Content « ( ) ; » assert That « ( conditions . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { String [ ] patterns = { " » / foo / « * " , " / foo " , " » / bar / « * " , " / bar " } ; » Request Mapping Info « info = » Request Mapping Info « . paths ( patterns ) . build ( ) ; Set < String > actual = this . » handler Mapping « . » get Mapping Path Patterns « ( info ) ; » assert That « ( actual ) . » is Equal To « ( new » Hash Set « < > ( Arrays . » as List « ( patterns ) ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo " ) ; » Handler Method « » handler Method « = » get Handler « ( request ) ; » assert That « ( » handler Method « . » get Method « ( ) ) . » is Equal To « ( this . » foo Method « . » get Method « ( ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / bar " ) ; » Handler Method « » handler Method « = » get Handler « ( request ) ; » assert That « ( » handler Method « . » get Method « ( ) ) . » is Equal To « ( this . » bar Method « . » get Method « ( ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo " ) ; request . » set Parameter « ( " p " , " anything " ) ; » Handler Method « » handler Method « = » get Handler « ( request ) ; » assert That « ( » handler Method « . » get Method « ( ) ) . » is Equal To « ( this . » foo Param Method « . » get Method « ( ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " POST " , " / bar " ) ; » assert That Exception Of Type « ( » Http Request Method Not Supported Exception « . class ) . » is Thrown By « ( ( ) -> this . » handler Mapping « . » get Handler « ( request ) ) . satisfies ( ex -> » assert That « ( ex . » get Supported Methods « ( ) ) . » contains Exactly « ( " GET " , " HEAD " ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / users " ) ; request . » add Header « ( " Accept " , " application / xml " ) ; this . » handler Mapping « . » register Handler « ( new » User Controller « ( ) ) ; » assert That Exception Of Type « ( » Http Media Type Not Acceptable Exception « . class ) . » is Thrown By « ( ( ) -> this . » handler Mapping « . » get Handler « ( request ) ) ; }
@Test { » test Http Options « ( " / foo " , " GET , HEAD , OPTIONS " ) ; » test Http Options « ( " / person / 1 " , " PUT , OPTIONS " ) ; » test Http Options « ( " / persons " , " GET , HEAD , POST , PUT , PATCH , DELETE , OPTIONS " ) ; » test Http Options « ( " / something " , " PUT , POST " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " PUT " , " / person / 1 " ) ; request . » set Content Type « ( " bogus " ) ; » assert That Exception Of Type « ( » Http Media Type Not Supported Exception « . class ) . » is Thrown By « ( ( ) -> this . » handler Mapping « . » get Handler « ( request ) ) . » with Message « ( " Invalid mime type \" bogus \" : does not contain '/' " ) ; }
@Test { » test Http Media Type Not Acceptable Exception « ( " / persons " ) ; » test Http Media Type Not Acceptable Exception « ( " / persons / " ) ; » test Http Media Type Not Acceptable Exception « ( " / persons . json " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / params " ) ; » assert That Exception Of Type « ( » Unsatisfied Servlet Request Parameter Exception « . class ) . » is Thrown By « ( ( ) -> this . » handler Mapping « . » get Handler « ( request ) ) . satisfies ( ex -> » assert That « ( ex . » get Param Condition Groups « ( ) . stream ( ) . map ( group -> group [ 0 ] ) ) . » contains Exactly In Any Order « ( " foo = bar " , " bar = baz " ) ) ; }
@Test { » Request Mapping Info « key = » Request Mapping Info « . paths ( " / { » path 1 « } / 2 " , " / * * " ) . build ( ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / 1 / 2 " ) ; this . » handler Mapping « . » handle Match « ( key , " / 1 / 2 " , request ) ; » assert That « ( request . » get Attribute « ( » Handler Mapping « . » BEST _ MATCHING _ PATTERN _ ATTRIBUTE « ) ) . » is Equal To « ( " / { » path 1 « } / 2 " ) ; }
@Test { String path = " " ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , path ) ; this . » handler Mapping « . » handle Match « ( » Request Mapping Info « . paths ( ) . build ( ) , path , request ) ; » assert That « ( request . » get Attribute « ( » Handler Mapping « . » BEST _ MATCHING _ PATTERN _ ATTRIBUTE « ) ) . » is Equal To « ( path ) ; }
@Test { Method method = » Class Utils « . » get Method « ( » Test Controller « . class , " handle " ) ; » Handler Method « » handler Method « = new » Handler Method « ( new » Test Controller « ( ) , method ) ; » Request Mapping Info « rmi = new » Request Mapping Info « ( " foo " , null , null , null , null , null , null , null ) ; » Handler Method Mapping Naming Strategy « < » Request Mapping Info « > strategy = new » Request Mapping Info Handler Method Mapping Naming Strategy « ( ) ; » assert That « ( strategy . » get Name « ( » handler Method « , rmi ) ) . » is Equal To « ( " foo " ) ; }
@Test { Method method = » Class Utils « . » get Method « ( » Test Controller « . class , " handle " ) ; » Handler Method « » handler Method « = new » Handler Method « ( new » Test Controller « ( ) , method ) ; » Request Mapping Info « rmi = new » Request Mapping Info « ( null , null , null , null , null , null , null , null ) ; » Handler Method Mapping Naming Strategy « < » Request Mapping Info « > strategy = new » Request Mapping Info Handler Method Mapping Naming Strategy « ( ) ; » assert That « ( strategy . » get Name « ( » handler Method « , rmi ) ) . » is Equal To « ( " TC # handle " ) ; }
@Test { this . » handler Mapping « . » register Handler « ( new » Method Level Controller « ( ) ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / no " ) ; » Handler Execution Chain « chain = this . » handler Mapping « . » get Handler « ( request ) ; » assert That « ( » get Cors Configuration « ( chain , false ) ) . » is Null « ( ) ; }
@Test { this . » handler Mapping « . » register Handler « ( new » Method Level Controller « ( ) ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " OPTIONS " , " / no " ) ; request . » add Header « ( » Http Headers « . » ACCESS _ CONTROL _ REQUEST _ METHOD « , " GET " ) ; » Handler Execution Chain « chain = this . » handler Mapping « . » get Handler « ( request ) ; » assert That « ( chain . » get Handler « ( ) . » to String « ( ) ) . » is Equal To « ( » options Handler « ) ; }
@Test { this . » handler Mapping « . » register Handler « ( new » Method Level Controller « ( ) ) ; this . request . » set Request URI « ( " / no " ) ; » Handler Execution Chain « chain = this . » handler Mapping « . » get Handler « ( request ) ; » assert That « ( » get Cors Configuration « ( chain , false ) ) . » is Null « ( ) ; }
@Test { this . » handler Mapping « . » register Handler « ( new » Method Level Controller « ( ) ) ; this . request . » set Method « ( " POST " ) ; this . request . » set Request URI « ( " / no " ) ; » Handler Execution Chain « chain = this . » handler Mapping « . » get Handler « ( request ) ; » assert That « ( » get Cors Configuration « ( chain , false ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » handler Mapping « . » register Handler « ( new » Method Level Controller With Bogus Allow Credentials Value « ( ) ) ) . » with Message Containing « ( " @ » Cross Origin « » ' s « » allow Credentials « " ) . » with Message Containing « ( " current value is [ bogus ] " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " OPTIONS " , " / default " ) ; request . » add Header « ( » Http Headers « . ORIGIN , " https : » // domain 2 . com « " ) ; » assert That « ( this . » handler Mapping « . » get Handler « ( request ) ) . » is Null « ( ) ; }
@Test { » assert That « ( this . handler . » supports Return Type « ( on ( » Test Controller « . class ) . » resolve Return Type « ( String . class ) ) ) . » is False « ( ) ; }
@Test { » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; » Illegal State Exception « ex = new » Illegal State Exception « ( ) ; » test Handle « ( result , » Deferred Result « . class , ( ) -> result . » set Error Result « ( ex ) , ex ) ; }
@Test { » Settable Listenable Future « < String > future = new » Settable Listenable Future « < > ( ) ; » test Handle « ( future , » Listenable Future « . class , ( ) -> future . set ( " foo " ) , " foo " ) ; }
@Test { » Completable Future « < String > future = new » Completable Future « < > ( ) ; » test Handle « ( future , » Completable Future « . class , ( ) -> future . complete ( " foo " ) , " foo " ) ; }
@Test { » Deferred Result « < String > result = new » Deferred Result « < > ( ) ; » test Handle « ( result , » Deferred Result « . class , ( ) -> result . » set Result « ( " foo " ) , " foo " ) ; }
@Test { » Settable Listenable Future « < String > future = new » Settable Listenable Future « < > ( ) ; » Illegal State Exception « ex = new » Illegal State Exception « ( ) ; » test Handle « ( future , » Listenable Future « . class , ( ) -> future . » set Exception « ( ex ) , ex ) ; }
@Test { » Completable Future « < String > future = new » Completable Future « < > ( ) ; » Illegal State Exception « ex = new » Illegal State Exception « ( ) ; » test Handle « ( future , » Completable Future « . class , ( ) -> future . » complete Exceptionally « ( ex ) , ex ) ; }
@Test { » Test Bean « target = new » Test Bean « ( ) ; » Web Data Binder « binder = new » Extended Servlet Request Data Binder « ( target , " " ) ; ( ( » Servlet Request Data Binder « ) binder ) . bind ( request ) ; » assert That « ( target . » get Name « ( ) ) . » is Equal To « ( null ) ; » assert That « ( target . » get Age « ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » get Variables For « ( " cars " ) . add ( " year " , " 2006 " ) ; » get Variables For « ( " bikes " ) . add ( " year " , " 2005 " ) ; » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . name ( " year " ) ) . arg ( int . class ) ; » assert That « ( this . resolver . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ) . » is Equal To « ( " 2006 " ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . name ( " year " ) ) . arg ( int . class ) ; » assert That « ( resolver . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ) . » is Equal To « ( " 2013 " ) ; }
@Test { » get Variables For « ( " » var 1 « " ) . add ( " colors " , " red " ) ; » get Variables For « ( " » var 2 « " ) . add ( " colors " , " green " ) ; » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . » no Name « ( ) ) . arg ( List . class , String . class ) ; » assert That Exception Of Type « ( » Servlet Request Binding Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . » no Name « ( ) ) . arg ( List . class , String . class ) ; » assert That Exception Of Type « ( » Servlet Request Binding Exception « . class ) . » is Thrown By « ( ( ) -> this . resolver . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ) ; }
@Test { » Multi Value Map « < String , String > params = » get Variables For « ( " cars " ) ; params . add ( " » another Year « " , " 2012 " ) ; » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . name ( " year " ) ) . arg ( int . class ) ; » assert That « ( this . resolver . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ) . » is Equal To « ( " 2013 " ) ; }
@Test { » assert That « ( handler . » supports Return Type « ( » return Param Model And View « ) ) . » is True « ( ) ; » assert That « ( handler . » supports Return Type « ( » get Return Value Param « ( " » view Name « " ) ) ) . » is False « ( ) ; }
@Test { » Model And View « mav = new » Model And View « ( " » view Name « " , " » attr Name « " , " » attr Value « " ) ; handler . » handle Return Value « ( mav , » return Param Model And View « , » mav Container « , » web Request « ) ; » assert That « ( » mav Container « . » get View « ( ) ) . » is Equal To « ( " » view Name « " ) ; » assert That « ( » mav Container « . » get Model « ( ) . get ( " » attr Name « " ) ) . » is Equal To « ( " » attr Value « " ) ; }
@Test { » Model And View « mav = new » Model And View « ( new » Redirect View « ( ) , " » attr Name « " , " » attr Value « " ) ; handler . » handle Return Value « ( mav , » return Param Model And View « , » mav Container « , » web Request « ) ; » assert That « ( » mav Container « . » get View « ( ) . » get Class « ( ) ) . » is Equal To « ( » Redirect View « . class ) ; » assert That « ( » mav Container « . » get Model « ( ) . get ( " » attr Name « " ) ) . » is Equal To « ( " » attr Value « " ) ; }
@Test { handler . » handle Return Value « ( null , » return Param Model And View « , » mav Container « , » web Request « ) ; » assert That « ( » mav Container « . » is Request Handled « ( ) ) . » is True « ( ) ; }
@Test { » Method Parameter « » return Type « = new » Method Parameter « ( » get Class « ( ) . » get Declared Method « ( " » int Return Value « " ) , - 1 ) ; » mav Resolvers « . add ( new » Test Model And View Resolver « ( » Test Bean « . class ) ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> handler . » handle Return Value « ( 99 , » return Type « , » mav Container « , request ) ) ; }
@Test { » Method Parameter « » return Type « = new » Method Parameter « ( » get Class « ( ) . » get Declared Method « ( " » int Return Value « " ) , - 1 ) ; » assert That Exception Of Type « ( » Unsupported Operation Exception « . class ) . » is Thrown By « ( ( ) -> handler . » handle Return Value « ( 55 , » return Type « , » mav Container « , request ) ) ; }
@Test { » Method Parameter « » return Type « = new » Method Parameter « ( » get Class « ( ) . » get Declared Method « ( " » test Bean Return Value « " ) , - 1 ) ; handler . » handle Return Value « ( new » Test Bean « ( ) , » return Type « , » mav Container « , request ) ; » assert That « ( » mav Container « . » contains Attribute « ( " » test Bean « " ) ) . » is True « ( ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( » param Map « ) ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Named Map « ) ) . » is False « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param Map No Annot « ) ) . » is False « ( ) ; }
@Test { Map < String , String > » uri Template Vars « = new » Hash Map « < > ( ) ; » uri Template Vars « . put ( " » name 1 « " , " » value 1 « " ) ; » uri Template Vars « . put ( " » name 2 « " , " » value 2 « " ) ; request . » set Attribute « ( » Handler Mapping « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » uri Template Vars « ) ; Object result = resolver . » resolve Argument « ( » param Map « , » mav Container « , » web Request « , null ) ; » assert That « ( result ) . » is Equal To « ( » uri Template Vars « ) ; }
@Test { Map < String , String > map = ( Map < String , String > ) resolver . » resolve Argument « ( » param Map « , » mav Container « , » web Request « , null ) ; » assert That « ( map ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; }
@Test { » assert That « ( resolver . » supports Parameter « ( » param Named String « ) ) . as ( " Parameter with @ » Path Variable « annotation " ) . » is True « ( ) ; » assert That « ( resolver . » supports Parameter « ( » param String « ) ) . as ( " Parameter without @ » Path Variable « annotation " ) . » is False « ( ) ; }
@Test { » assert That Exception Of Type « ( » Missing Path Variable Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Named String « , » mav Container « , » web Request « , null ) ) ; }
@Test { » assert That « ( resolver . » resolve Argument « ( » param Not Required « , » mav Container « , » web Request « , null ) ) . » is Null « ( ) ; }
@Test { » Configurable Web Binding Initializer « initializer = new » Configurable Web Binding Initializer « ( ) ; initializer . » set Conversion Service « ( new » Default Conversion Service « ( ) ) ; » Web Data Binder Factory « » binder Factory « = new » Default Data Binder Factory « ( initializer ) ; » assert That « ( resolver . » resolve Argument « ( » param Optional « , » mav Container « , » web Request « , » binder Factory « ) ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » Handler Method « » handler Method « = » handler Method « ( " » handle And Complete Session « " , » Session Status « . class ) ; » handler Adapter « . handle ( request , response , » handler Method « ) ; » assert That « ( request . » get Session « ( ) . » get Attribute Names « ( ) . » has More Elements « ( ) ) . » is False « ( ) ; }
@Test { » Handler Method « » handler Method « = » handler Method « ( new » Simple Controller « ( ) , " handle " ) ; this . » handler Adapter « . » set Cache Seconds « ( 100 ) ; this . » handler Adapter « . » after Properties Set « ( ) ; this . » handler Adapter « . handle ( this . request , this . response , » handler Method « ) ; » assert That « ( response . » get Header « ( " Cache - Control " ) . contains ( " max - age " ) ) . » is True « ( ) ; }
@Test { » Session Attribute Controller « handler = new » Session Attribute Controller « ( ) ; this . » handler Adapter « . » set Cache Seconds « ( 100 ) ; this . » handler Adapter « . » after Properties Set « ( ) ; this . » handler Adapter « . handle ( this . request , this . response , » handler Method « ( handler , " handle " ) ) ; » assert That « ( this . response . » get Header « ( " Cache - Control " ) ) . » is Equal To « ( " no - store " ) ; }
@Test { » Handler Method Argument Resolver « resolver = new » Servlet Request Method Argument Resolver « ( ) ; this . » handler Adapter « . » set Custom Argument Resolvers « ( Collections . » singleton List « ( resolver ) ) ; this . » handler Adapter « . » after Properties Set « ( ) ; » assert That « ( this . » handler Adapter « . » get Argument Resolvers « ( ) . contains ( resolver ) ) . » is True « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « + 1 , » INIT _ BINDER _ RESOLVER _ COUNT « + 1 , » HANDLER _ COUNT « ) ; }
@Test { » Handler Method Argument Resolver « resolver = new » Servlet Request Method Argument Resolver « ( ) ; this . » handler Adapter « . » set Argument Resolvers « ( Collections . » singleton List « ( resolver ) ) ; this . » handler Adapter « . » after Properties Set « ( ) ; » assert Method Processor Count « ( 1 , » INIT _ BINDER _ RESOLVER _ COUNT « , » HANDLER _ COUNT « ) ; }
@Test { » Handler Method Argument Resolver « resolver = new » Servlet Request Method Argument Resolver « ( ) ; this . » handler Adapter « . » set Init Binder Argument Resolvers « ( Collections . » singleton List « ( resolver ) ) ; this . » handler Adapter « . » after Properties Set « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « , 1 , » HANDLER _ COUNT « ) ; }
@Test { » Handler Method Return Value Handler « handler = new » View Name Method Return Value Handler « ( ) ; this . » handler Adapter « . » set Custom Return Value Handlers « ( Collections . » singleton List « ( handler ) ) ; this . » handler Adapter « . » after Properties Set « ( ) ; » assert That « ( this . » handler Adapter « . » get Return Value Handlers « ( ) . contains ( handler ) ) . » is True « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « , » INIT _ BINDER _ RESOLVER _ COUNT « , » HANDLER _ COUNT « + 1 ) ; }
@Test { » Handler Method Return Value Handler « handler = new » Model Method Processor « ( ) ; this . » handler Adapter « . » set Return Value Handlers « ( Collections . » singleton List « ( handler ) ) ; this . » handler Adapter « . » after Properties Set « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « , » INIT _ BINDER _ RESOLVER _ COUNT « , 1 ) ; }
@Test { » test Create « ( » base Url « + " / commons - resolver / test " , " Jason " ) ; » test Create « ( » base Url « + " / commons - resolver / test " , " Arjen " ) ; }
@Test { » test Create « ( » base Url « + " / standard - resolver / test " , " Jason " ) ; » test Create « ( » base Url « + " / standard - resolver / test " , " Arjen " ) ; }
@Test { Object » advice Bean « = new » Controller Advice Bean « ( new » My Controller Advice « ( ) ) ; » Request Response Body Advice Chain « chain = new » Request Response Body Advice Chain « ( Collections . » singleton List « ( » advice Bean « ) ) ; String actual = ( String ) chain . » before Body Write « ( this . body , this . » return Type « , this . » content Type « , this . » converter Type « , this . request , this . response ) ; » assert That « ( actual ) . » is Equal To « ( " body - » My Controller Advice « " ) ; }
@Test { Object » advice Bean « = new » Controller Advice Bean « ( new » Targeted Controller Advice « ( ) ) ; » Request Response Body Advice Chain « chain = new » Request Response Body Advice Chain « ( Collections . » singleton List « ( » advice Bean « ) ) ; String actual = ( String ) chain . » before Body Write « ( this . body , this . » return Type « , this . » content Type « , this . » converter Type « , this . request , this . response ) ; » assert That « ( actual ) . » is Equal To « ( this . body ) ; }
@Test { » assert That « ( this . handler . » is Reactive Type « ( Mono . class ) ) . » is True « ( ) ; » assert That « ( this . handler . » is Reactive Type « ( Single . class ) ) . » is True « ( ) ; » assert That « ( this . handler . » is Reactive Type « ( io . reactivex . Single . class ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . handler . » is Reactive Type « ( String . class ) ) . » is False « ( ) ; }
@Test { » Mono Processor « < String > » mono Empty « = » Mono Processor « . create ( ) ; » test Deferred Result Subscriber « ( » mono Empty « , Mono . class , » for Class « ( String . class ) , » mono Empty « :: » on Complete « , null ) ; }
@Test { this . » servlet Request « . » add Header « ( " Accept " , " text / event - stream " ) ; » test Sse Response « ( true ) ; Set < » Media Type « > types = Collections . singleton ( » Media Type « . » TEXT _ EVENT _ STREAM « ) ; this . » servlet Request « . » set Attribute « ( » Handler Mapping « . » PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE « , types ) ; » test Sse Response « ( true ) ; » test Sse Response « ( false ) ; }
@Test { Cookie expected = new Cookie ( " name " , " foo " ) ; request . » set Cookies « ( expected ) ; Cookie result = ( Cookie ) resolver . » resolve Argument « ( » cookie Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( expected ) ; }
@Test { Cookie cookie = new Cookie ( " name " , " foo " ) ; request . » set Cookies « ( cookie ) ; String result = ( String ) resolver . » resolve Argument « ( » cookie String Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( cookie . » get Value « ( ) ) ; }
@Test { Map < String , String > » uri Template Vars « = new » Hash Map « < > ( ) ; » uri Template Vars « . put ( " » test Bean 1 « " , " Patty " ) ; request . » set Attribute « ( » Handler Mapping « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » uri Template Vars « ) ; » Test Bean « » test Bean « = ( » Test Bean « ) processor . » resolve Argument « ( » test Bean Model Attr « , » mav Container « , » web Request « , » binder Factory « ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " Patty " ) ; }
@Test { Map < String , String > » uri Template Vars « = new » Hash Map « < > ( ) ; » uri Template Vars « . put ( " » test Bean 2 « " , " Patty " ) ; request . » set Attribute « ( » Handler Mapping « . » URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE « , » uri Template Vars « ) ; » Test Bean Without String Constructor « » test Bean « = ( » Test Bean Without String Constructor « ) processor . » resolve Argument « ( » test Bean Without String Constructor Model Attr « , » mav Container « , » web Request « , » binder Factory « ) ; » assert That « ( » test Bean « ) . » is Not Null « ( ) ; }
@Test { request . » add Parameter « ( " » test Bean 1 « " , " Patty " ) ; » Test Bean « » test Bean « = ( » Test Bean « ) processor . » resolve Argument « ( » test Bean Model Attr « , » mav Container « , » web Request « , » binder Factory « ) ; » assert That « ( » test Bean « . » get Name « ( ) ) . » is Equal To « ( " Patty " ) ; }
@Test { request . » add Parameter « ( " » test Bean 2 « " , " Patty " ) ; » Test Bean Without String Constructor « » test Bean « = ( » Test Bean Without String Constructor « ) processor . » resolve Argument « ( » test Bean Without String Constructor Model Attr « , » mav Container « , » web Request « , » binder Factory « ) ; » assert That « ( » test Bean « ) . » is Not Null « ( ) ; }
@Test { request . » add Parameter « ( " » test Bean 3 « " , " Patty " ) ; Optional < » Test Bean « > » test Bean « = ( Optional < » Test Bean « > ) processor . » resolve Argument « ( » test Bean With Optional Model Attr « , » mav Container « , » web Request « , » binder Factory « ) ; » assert That « ( » test Bean « . get ( ) . » get Name « ( ) ) . » is Equal To « ( " Patty " ) ; }
@Test { » Method Parameter « » servlet Response Parameter « = new » Method Parameter « ( method , 0 ) ; » assert That « ( resolver . » supports Parameter « ( » servlet Response Parameter « ) ) . as ( " » Servlet Response « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » servlet Response Parameter « , » mav Container « , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » servlet Response « ) ; » assert That « ( » mav Container « . » is Request Handled « ( ) ) . » is True « ( ) ; }
@Test { » Method Parameter « » servlet Response Parameter « = new » Method Parameter « ( method , 0 ) ; » assert That « ( resolver . » supports Parameter « ( » servlet Response Parameter « ) ) . as ( " » Servlet Response « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » servlet Response Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » servlet Response « ) ; }
@Test { » Method Parameter « » writer Parameter « = new » Method Parameter « ( method , 2 ) ; » assert That « ( resolver . » supports Parameter « ( » writer Parameter « ) ) . as ( " Writer not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » writer Parameter « , » mav Container « , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » servlet Response « . » get Writer « ( ) ) ; » assert That « ( » mav Container « . » is Request Handled « ( ) ) . » is True « ( ) ; }
@Test { » assert That « ( this . handler . » supports Return Type « ( this . param ) ) . » is True « ( ) ; }
@Test { this . handler . » handle Return Value « ( " » test View « " , this . param , this . » mav Container « , this . » web Request « ) ; » assert That « ( this . » mav Container « . » get View Name « ( ) ) . » is Equal To « ( " » test View « " ) ; }
@Test { » Model Map « » redirect Model « = new » Redirect Attributes Model Map « ( ) ; this . » mav Container « . » set Redirect Model « ( » redirect Model « ) ; this . handler . » handle Return Value « ( " redirect : » test View « " , this . param , this . » mav Container « , this . » web Request « ) ; » assert That « ( this . » mav Container « . » get View Name « ( ) ) . » is Equal To « ( " redirect : » test View « " ) ; » assert That « ( this . » mav Container « . » get Model « ( ) ) . » is Same As « ( » redirect Model « ) ; }
@Test { » init Servlet With Controllers « ( » Simple Uri Template Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / 42 " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test - 42 - 7 " ) ; }
@Test { » init Servlet With Controllers « ( » Ambiguous Uri Template Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / hotels / new " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " specific " ) ; }
@Test { » init Servlet With Controllers « ( » Simple Uri Template Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / 42 ; jsessionid = » c 0 o 7 fszeb 1 « ; q = 24. xml " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test - 42 - 24 " ) ; }
@Test { » init Servlet With Controllers « ( » Simple Uri Template Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo . xml " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid response status code " ) . » is Equal To « ( » Http Servlet Response « . » SC _ BAD _ REQUEST « ) ; }
@Test { » init Servlet With Controllers « ( » Explicit Sub Path Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / hotels / 42 " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test - 42 " ) ; }
@Test { » init Servlet With Controllers « ( » Implicit Sub Path Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / hotels / 42 " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test - 42 " ) ; }
@Test { » init Servlet With Controllers « ( » Menu Tree Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / book / menu / type / » M 5 « " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » M 5 « " ) ; }
@Test { » init Servlet With Controllers « ( » Variable Names Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / test / foo . json " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " foo - foo " ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( new » Method Parameter « ( this . » handle Method « , 0 ) ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( new » Method Parameter « ( this . » handle Method « , - 1 ) ) ) . » is False « ( ) ; }
@Test { » Method Parameter « param = » init Method Parameter « ( 0 ) ; » assert That Exception Of Type « ( » Servlet Request Binding Exception « . class ) . » is Thrown By « ( ( ) -> » test Resolve Argument « ( param ) ) . » with Message Starting With « ( " Missing " ) ; Foo foo = new Foo ( ) ; this . » web Request « . » set Attribute « ( " foo " , foo , » get Scope « ( ) ) ; » assert That « ( » test Resolve Argument « ( param ) ) . » is Same As « ( foo ) ; }
@Test { » Method Parameter « param = » init Method Parameter « ( 1 ) ; Foo foo = new Foo ( ) ; this . » web Request « . » set Attribute « ( " » special Foo « " , foo , » get Scope « ( ) ) ; » assert That « ( » test Resolve Argument « ( param ) ) . » is Same As « ( foo ) ; }
@Test { » Method Parameter « param = » init Method Parameter « ( 2 ) ; » assert That « ( » test Resolve Argument « ( param ) ) . » is Null « ( ) ; Foo foo = new Foo ( ) ; this . » web Request « . » set Attribute « ( " foo " , foo , » get Scope « ( ) ) ; » assert That « ( » test Resolve Argument « ( param ) ) . » is Same As « ( foo ) ; }
@Test { this . » servlet Request « . » set Content « ( new byte [ 0 ] ) ; this . » servlet Request « . » set Content Type « ( " text / plain " ) ; List < » Http Message Converter « < ? > > converters = new » Array List « < > ( ) ; converters . add ( new » String Http Message Converter « ( ) ) ; » Request Response Body Method Processor « processor = new » Request Response Body Method Processor « ( converters ) ; » assert That Exception Of Type « ( » Http Message Not Readable Exception « . class ) . » is Thrown By « ( ( ) -> processor . » resolve Argument « ( » param String « , container , request , factory ) ) ; }
@Test { Method method = » get Class « ( ) . » get Declared Method « ( " » handle And Return Output Stream « " ) ; » Method Parameter « » return Type « = new » Method Parameter « ( method , - 1 ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> { » Request Response Body Method Processor « processor = new » Request Response Body Method Processor « ( new » Array List « < > ( ) ) ; processor . » write With Message Converters « ( new » Byte Array Output Stream « ( ) , » return Type « , this . request ) ; } ) ; }
@Test { Method method = » Response Body Controller « . class . » get Method « ( " handle " ) ; » Method Parameter « » return Type « = new » Method Parameter « ( method , - 1 ) ; List < » Http Message Converter « < ? > > converters = new » Array List « < > ( ) ; converters . add ( new » String Http Message Converter « ( ) ) ; » Request Response Body Method Processor « processor = new » Request Response Body Method Processor « ( converters ) ; » assert That « ( processor . » supports Return Type « ( » return Type « ) ) . as ( " Failed to recognize type - level @ » Response Body « " ) . » is True « ( ) ; }
@Test { Method method = » Test Rest Controller « . class . » get Method « ( " handle " ) ; » Method Parameter « » return Type « = new » Method Parameter « ( method , - 1 ) ; List < » Http Message Converter « < ? > > converters = new » Array List « < > ( ) ; converters . add ( new » String Http Message Converter « ( ) ) ; » Request Response Body Method Processor « processor = new » Request Response Body Method Processor « ( converters ) ; » assert That « ( processor . » supports Return Type « ( » return Type « ) ) . as ( " Failed to recognize type - level @ » Rest Controller « " ) . » is True « ( ) ; }
@Test { Object handler = null ; this . resolver . » after Properties Set « ( ) ; » Model And View « mav = this . resolver . » resolve Exception « ( this . request , this . response , handler , null ) ; » assert That « ( mav ) . as ( " Exception can be resolved only if there is a » Handler Method « " ) . » is Null « ( ) ; }
@Test { » Handler Method Argument Resolver « resolver = new » Servlet Request Method Argument Resolver « ( ) ; this . resolver . » set Custom Argument Resolvers « ( Collections . » singleton List « ( resolver ) ) ; this . resolver . » after Properties Set « ( ) ; » assert That « ( this . resolver . » get Argument Resolvers « ( ) . » get Resolvers « ( ) . contains ( resolver ) ) . » is True « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « + 1 , » HANDLER _ COUNT « ) ; }
@Test { » Handler Method Argument Resolver « resolver = new » Servlet Request Method Argument Resolver « ( ) ; this . resolver . » set Argument Resolvers « ( Collections . » singleton List « ( resolver ) ) ; this . resolver . » after Properties Set « ( ) ; » assert Method Processor Count « ( 1 , » HANDLER _ COUNT « ) ; }
@Test { » Handler Method Return Value Handler « handler = new » View Name Method Return Value Handler « ( ) ; this . resolver . » set Custom Return Value Handlers « ( Collections . » singleton List « ( handler ) ) ; this . resolver . » after Properties Set « ( ) ; » assert That « ( this . resolver . » get Return Value Handlers « ( ) . » get Handlers « ( ) . contains ( handler ) ) . » is True « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « , » HANDLER _ COUNT « + 1 ) ; }
@Test { » Handler Method Return Value Handler « handler = new » Model Method Processor « ( ) ; this . resolver . » set Return Value Handlers « ( Collections . » singleton List « ( handler ) ) ; this . resolver . » after Properties Set « ( ) ; » assert Method Processor Count « ( » RESOLVER _ COUNT « , 1 ) ; }
@Test { Exception npe = new » Null Pointer Exception « ( ) ; » Handler Method « » handler Method « = new » Handler Method « ( new » Io Exception Controller « ( ) , " handle " ) ; this . resolver . » after Properties Set « ( ) ; » Model And View « mav = this . resolver . » resolve Exception « ( this . request , this . response , » handler Method « , npe ) ; » assert That « ( mav ) . as ( " NPE should not have been handled " ) . » is Null « ( ) ; }
@Test { » Method Parameter « param = this . » test Method « . annot ( » matrix Attribute « ( ) . » no Name « ( ) ) . arg ( Map . class , String . class , String . class ) ; @ » Suppress Warnings « ( " unchecked " ) Map < String , String > map = ( Map < String , String > ) this . resolver . » resolve Argument « ( param , this . » mav Container « , this . » web Request « , null ) ; » assert That « ( map ) . » is Equal To « ( Collections . » empty Map « ( ) ) ; }
@Test { » Method Parameter « » return Type « = » return Type « ( » Test Controller « . class , " » handle Response Entity « " ) ; » Response Entity « < ? > emitter = » Response Entity « . » no Content « ( ) . build ( ) ; this . handler . » handle Return Value « ( emitter , » return Type « , this . » mav Container « , this . » web Request « ) ; » assert That « ( this . request . » is Async Started « ( ) ) . » is False « ( ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 204 ) ; }
@Test { » Response Entity « < ? > emitter = » Response Entity « . » no Content « ( ) . header ( " foo " , " bar " ) . build ( ) ; » Method Parameter « » return Type « = » return Type « ( » Test Controller « . class , " » handle Response Entity « " ) ; this . handler . » handle Return Value « ( emitter , » return Type « , this . » mav Container « , this . » web Request « ) ; » assert That « ( this . response . » get Headers « ( " foo " ) ) . » is Equal To « ( Collections . » singleton List « ( " bar " ) ) ; }
@Test { this . emitter . send ( " foo " , » Media Type « . » TEXT _ PLAIN « ) ; this . emitter . send ( " foo " , » Media Type « . » TEXT _ PLAIN « ) ; this . emitter . complete ( ) ; » verify No More Interactions « ( this . handler ) ; this . emitter . initialize ( this . handler ) ; verify ( this . handler , times ( 2 ) ) . send ( " foo " , » Media Type « . » TEXT _ PLAIN « ) ; verify ( this . handler ) . complete ( ) ; » verify No More Interactions « ( this . handler ) ; }
@Test { this . emitter . complete ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . emitter . send ( " foo " ) ) ; }
@Test { Runnable runnable = mock ( Runnable . class ) ; this . emitter . » on Timeout « ( runnable ) ; this . emitter . initialize ( this . handler ) ; » Argument Captor « < Runnable > captor = » Argument Captor « . » for Class « ( Runnable . class ) ; verify ( this . handler ) . » on Timeout « ( captor . capture ( ) ) ; verify ( this . handler ) . » on Completion « ( any ( ) ) ; » assert That « ( captor . » get Value « ( ) ) . » is Not Null « ( ) ; captor . » get Value « ( ) . run ( ) ; verify ( runnable ) . run ( ) ; }
@Test { this . emitter . initialize ( this . handler ) ; » Argument Captor « < Runnable > captor = » Argument Captor « . » for Class « ( Runnable . class ) ; verify ( this . handler ) . » on Timeout « ( captor . capture ( ) ) ; verify ( this . handler ) . » on Completion « ( any ( ) ) ; Runnable runnable = mock ( Runnable . class ) ; this . emitter . » on Timeout « ( runnable ) ; » assert That « ( captor . » get Value « ( ) ) . » is Not Null « ( ) ; captor . » get Value « ( ) . run ( ) ; verify ( runnable ) . run ( ) ; }
@Test { Runnable runnable = mock ( Runnable . class ) ; this . emitter . » on Completion « ( runnable ) ; this . emitter . initialize ( this . handler ) ; » Argument Captor « < Runnable > captor = » Argument Captor « . » for Class « ( Runnable . class ) ; verify ( this . handler ) . » on Timeout « ( any ( ) ) ; verify ( this . handler ) . » on Completion « ( captor . capture ( ) ) ; » assert That « ( captor . » get Value « ( ) ) . » is Not Null « ( ) ; captor . » get Value « ( ) . run ( ) ; verify ( runnable ) . run ( ) ; }
@Test { this . emitter . initialize ( this . handler ) ; » Argument Captor « < Runnable > captor = » Argument Captor « . » for Class « ( Runnable . class ) ; verify ( this . handler ) . » on Timeout « ( any ( ) ) ; verify ( this . handler ) . » on Completion « ( captor . capture ( ) ) ; Runnable runnable = mock ( Runnable . class ) ; this . emitter . » on Completion « ( runnable ) ; » assert That « ( captor . » get Value « ( ) ) . » is Not Null « ( ) ; captor . » get Value « ( ) . run ( ) ; verify ( runnable ) . run ( ) ; }
@Test { » init Servlet With Controllers « ( » Controller With Empty Value Mapping « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo " ) ; request . » set Context Path « ( " / foo " ) ; request . » set Servlet Path « ( " " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » init Servlet With Controllers « ( » Controller With Error Thrown « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo " ) ; request . » set Context Path « ( " / foo " ) ; request . » set Servlet Path « ( " " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test " ) ; }
@Test { » init Servlet With Controllers « ( » Custom Annotation Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / » my Path « . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid response status code " ) . » is Equal To « ( » Http Servlet Response « . » SC _ OK « ) ; }
@Test { » init Servlet With Controllers « ( » Required Param Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / » my Path « . do " ) ; request . » add Parameter « ( " id " , " foo " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid response status code " ) . » is Equal To « ( » Http Servlet Response « . » SC _ BAD _ REQUEST « ) ; }
@Test { » init Servlet With Controllers « ( » Optional Param Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / » my Path « . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " null - false - null " ) ; }
@Test { » init Servlet With Controllers « ( » Default Value Param Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / » my Path « . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " foo -- bar " ) ; }
@Test { » do Test Adapted Handle Methods « ( » My Adapted Controller « . class ) ; }
@Test { » do Test Adapted Handle Methods « ( » My Adapted Controller 2 « . class ) ; }
@Test { » do Test Adapted Handle Methods « ( » My Adapted Controller 3 « . class ) ; }
@Test { » init Servlet With Controllers « ( » My Null Command Controller « . class ) ; » get Servlet « ( ) . init ( new » Mock Servlet Config « ( ) ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / » my Path « " ) ; request . » set User Principal « ( new » Other Principal « ( ) ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » my View « " ) ; }
@Test { » assert That Thrown By « ( ( ) -> » init Servlet With Controllers « ( » Child Controller « . class ) ) . » is Instance Of « ( » Bean Creation Exception « . class ) . » has Cause Instance Of « ( » Illegal State Exception « . class ) . » has Message Containing « ( " Ambiguous mapping " ) ; }
@Test { » init Servlet With Controllers « ( » Path Ordering Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / dir / » my Path 1 « . do " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » method 1 « " ) ; }
@Test { » init Servlet With Controllers « ( » Response Body Void Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / something " ) ; request . » add Header « ( " Accept " , " text * " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 200 ) ; }
@Test { » init Servlet With Controllers « ( » Binding Cookie Value Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / test " ) ; request . » set Cookies « ( new Cookie ( " date " , " 2008 - 11 - 18 " ) ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test - 2008 " ) ; }
@Test { » init Servlet With Controllers « ( » Ambiguous Path And Request Method Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / bug / EXISTING " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 200 ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " Pattern " ) ; }
@Test { » init Servlet With Controllers « ( » Test Controller Impl « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / method " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; }
@Test { » init Servlet With Controllers « ( » Article Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / method " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; }
@Test { » init Servlet With Controllers « ( » My Abstract Controller Impl « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / handle " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " handle " ) ; }
@Test { » init Servlet With Controllers « ( » Trailing Slash Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo / " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " » template Path « " ) ; }
@Test { » init Servlet With Controllers « ( » Custom Map Editor Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / handle " ) ; request . » add Parameter « ( " map " , " bar " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " test - { foo = bar } " ) ; }
@Test { » init Servlet With Controllers « ( » Multipart Controller « . class ) ; » Mock Multipart Http Servlet Request « request = new » Mock Multipart Http Servlet Request « ( ) ; request . » set Request URI « ( " / » single String « " ) ; request . » add File « ( new » Mock Multipart File « ( " content " , " Juergen " . » get Bytes « ( ) ) ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " Juergen " ) ; }
@Test { » init Servlet With Controllers « ( » Multipart Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Request URI « ( " / » single String « " ) ; request . » set Method « ( " POST " ) ; request . » add Parameter « ( " content " , " Juergen " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " Juergen " ) ; }
@Test { » init Servlet With Controllers « ( » Multipart Controller « . class ) ; » Mock Multipart Http Servlet Request « request = new » Mock Multipart Http Servlet Request « ( ) ; request . » set Request URI « ( " / » string Array « " ) ; request . » add File « ( new » Mock Multipart File « ( " content " , " Juergen " . » get Bytes « ( ) ) ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " Juergen " ) ; }
@Test { » init Servlet With Controllers « ( » Multipart Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Request URI « ( " / » string Array « " ) ; request . » set Method « ( " POST " ) ; request . » add Parameter « ( " content " , " Juergen " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " Juergen " ) ; }
@Test { » init Servlet With Controllers « ( » No Path Get And M 2 Post Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / » t 1 « / » m 2 « " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 405 ) ; }
@Test { » init Servlet With Controllers « ( » This Will Actually Run « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " Hello World ! " ) ; }
@Test { » init Servlet With Controllers « ( » Model And View Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / path " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 422 ) ; » assert That « ( response . » get Forwarded Url « ( ) ) . » is Equal To « ( " view " ) ; }
@Test { » init Servlet With Controllers « ( » Model And View Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / exception " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 422 ) ; » assert That « ( response . » get Forwarded Url « ( ) ) . » is Equal To « ( " view " ) ; }
@Test { » init Servlet With Controllers « ( » Response Entity Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " HEAD " , " / stores " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 200 ) ; » assert That « ( response . » get Header « ( " » h 1 « " ) ) . » is Equal To « ( " » v 1 « " ) ; }
@Test { » init Servlet With Controllers « ( » Validated Data Class Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / bind " ) ; request . » add Parameter « ( " » param 1 « " , " » value 1 « " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " 1 : » value 1 « - null - null " ) ; }
@Test { » init Servlet With Controllers « ( » Validated Data Class Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / bind " ) ; request . » add Parameter « ( " » param 2 « " , " x " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " 2 : null - x - null " ) ; }
@Test { » init Servlet With Controllers « ( » Date Class Controller « . class ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / bind " ) ; request . » add Parameter « ( " date " , " 2010 - 01 - 01 " ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » get Servlet « ( ) . service ( request , response ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " 2010 - 01 - 01 " ) ; }
@Test { » Uri Components « » uri Components « = » from Controller « ( » Person Controller Impl « . class ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / people " ) ; }
@Test { » Uri Components « » uri Components « = » from Controller « ( » Persons Addresses Controller « . class ) . » build And Expand « ( 15 ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / people / 15 / addresses " ) ; }
@Test { » Uri Components « » uri Components « = » from Controller « ( » Person Controller Impl « . class ) . » path Segment « ( " something " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / people / something " ) ; }
@Test { » Uri Components « » uri Components « = » from Controller « ( » Invalid Controller « . class ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / persons « " ) ; }
@Test { » Uri Components « » uri Components « = » from Controller « ( » Unmapped Controller « . class ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / « " ) ; }
@Test { » Uri Components Builder « builder = » Uri Components Builder « . » from Uri String « ( " https : » // example . org : 9090 / base « " ) ; » Uri Components « » uri Components « = » from Controller « ( builder , » Person Controller Impl « . class ) . build ( ) ; » assert That « ( » uri Components « . » to String « ( ) ) . » is Equal To « ( " https : » // example . org : 9090 / base / people « " ) ; » assert That « ( builder . » to Uri String « ( ) ) . » is Equal To « ( " https : » // example . org : 9090 / base « " ) ; }
@Test { this . request . » set Scheme « ( " https " ) ; this . request . » add Header « ( " X - Forwarded - Host " , " » something Different « " ) ; » adapt Request From Forwarded Headers « ( ) ; » Uri Components « » uri Components « = » from Controller « ( » Person Controller Impl « . class ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » starts With « ( " https : » // something Different « " ) ; }
@Test { this . request . » set Scheme « ( " https " ) ; request . » add Header « ( " X - Forwarded - Host " , " foobar : 8088 " ) ; » adapt Request From Forwarded Headers « ( ) ; » Uri Components « » uri Components « = » from Controller « ( » Person Controller Impl « . class ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » starts With « ( " https : » // foobar : 8088 « " ) ; }
@Test { this . request . » set Scheme « ( " https " ) ; this . request . » add Header « ( " X - Forwarded - Host " , " barfoo : 8888 , localhost : 8088 " ) ; » adapt Request From Forwarded Headers « ( ) ; » Uri Components « » uri Components « = » from Controller « ( » Person Controller Impl « . class ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » starts With « ( " https : » // barfoo : 8888 « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Controller With Methods « . class , " » method With Path Variable « " , " 1 " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / something / 1 / foo « " ) ; }
@Test { this . request . » set Context Path « ( " / myapp " ) ; » Uri Components « » uri Components « = » from Method Name « ( » Persons Addresses Controller « . class , " » get Addresses For Country « " , " DE " ) . » build And Expand « ( " 1 " ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / myapp / people / 1 / addresses / DE « " ) ; }
@Test { » Date Time « now = » Date Time « . now ( ) ; » Uri Components « » uri Components « = » from Method Name « ( » Controller With Methods « . class , " » method With Two Path Variables « " , 1 , now ) . build ( ) ; » assert That « ( » uri Components « . » get Path « ( ) ) . » is Equal To « ( " / something / 1 / foo / " + » ISO Date Time Format « . date ( ) . print ( now ) ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Person Crud Controller « . class , " get " , ( long ) 42 ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / 42 « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » User Contact Controller « . class , " » show Create « " , 123 ) . build ( ) ; » assert That « ( » uri Components « . » get Path « ( ) ) . » is Equal To « ( " / user / 123 / contacts / create " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Unmapped Controller « . class , " » unmapped Method « " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Controller With Methods « . class , " » method With Optional Param « " , new Object [ ] { null } ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / something / optional - param « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Controller With Methods « . class , " » method With Optional Named Param « " , Optional . of ( " foo " ) ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / something / optional - param - with - name « ? » search = foo « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Meta Annotation Controller « . class , " » handle Input « " ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / input « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Call « ( on ( » Controller With Methods « . class ) . » my Method « ( null ) ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » starts With « ( " http : » // localhost « " ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / something / else " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Call « ( on ( » Extended Controller « . class ) . » my Method « ( null ) ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » starts With « ( " http : » // localhost « " ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / extended / else " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Call « ( on ( » Persons Addresses Controller « . class ) . » get Addresses For Country « ( " DE " ) ) . » build And Expand « ( 15 ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / people / 15 / addresses / DE " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Call « ( on ( » Controller With Methods « . class ) . » method With Path Variable « ( " 1 " ) ) . build ( ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » starts With « ( " http : » // localhost « " ) ; » assert That « ( » uri Components « . » to Uri String « ( ) ) . » ends With « ( " / something / 1 / foo " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Call « ( on ( » Booking Controller With Model And View « . class ) . » get Booking « ( 21L ) ) . » build And Expand « ( 42 ) ; » assert That « ( » uri Components « . encode ( ) . » to Uri « ( ) . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / hotels / 42 / bookings / 21 « " ) ; }
@Test { » Uri Components « » uri Components « = » from Method Call « ( on ( » Booking Controller With Object « . class ) . » get Booking « ( 21L ) ) . » build And Expand « ( 42 ) ; » assert That « ( » uri Components « . encode ( ) . » to Uri « ( ) . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / hotels / 42 / bookings / 21 « " ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> { » Uri Components « » uri Components « = » from Method Call « ( on ( » Booking Controller With String « . class ) . » get Booking « ( 21L ) ) . » build And Expand « ( 42 ) ; » uri Components « . encode ( ) . » to Uri « ( ) . » to String « ( ) ; } ) ; }
@Test { » Uri Components « » uri Components « = » from Method Name « ( » Booking Controller With String « . class , " » get Booking « " , 21L ) . » build And Expand « ( 42 ) ; » assert That « ( » uri Components « . encode ( ) . » to Uri « ( ) . » to String « ( ) ) . » is Equal To « ( " http : » // localhost / hotels / 42 / bookings / 21 « " ) ; }
@Test { » init Web Application Context « ( » Web Config « . class ) ; this . request . » set Server Name « ( " example . org " ) ; this . request . » set Server Port « ( 9999 ) ; this . request . » set Context Path « ( " / base " ) ; String » mapping Name « = " PAC # » get Addresses For Country « " ; String url = » from Mapping Name « ( » mapping Name « ) . arg ( 0 , " DE " ) . » build And Expand « ( 123 ) ; » assert That « ( url ) . » is Equal To « ( " / base / people / 123 / addresses / DE " ) ; }
@Test { » init Web Application Context « ( » Path Prefix Web Config « . class ) ; this . request . » set Scheme « ( " https " ) ; this . request . » set Server Name « ( " example . org " ) ; this . request . » set Server Port « ( 9999 ) ; this . request . » set Context Path « ( " / base " ) ; » assert That « ( » from Controller « ( » Persons Addresses Controller « . class ) . » build And Expand « ( " 123 " ) . » to String « ( ) ) . » is Equal To « ( " https : » // example . org : 9999 / base / api / people / 123 / addresses « " ) ; }
@Test { List < String > supported = Arrays . » as List « ( " POST " , " DELETE " ) ; Exception ex = new » Http Request Method Not Supported Exception « ( " GET " , supported ) ; » Response Entity « < Object > » response Entity « = » test Exception « ( ex ) ; » assert That « ( » response Entity « . » get Headers « ( ) . » get Allow « ( ) ) . » is Equal To « ( » Enum Set « . of ( » Http Method « . POST , » Http Method « . DELETE ) ) ; }
@Test { List < » Media Type « > acceptable = Arrays . » as List « ( » Media Type « . » APPLICATION _ ATOM _ XML « , » Media Type « . » APPLICATION _ XML « ) ; Exception ex = new » Http Media Type Not Supported Exception « ( » Media Type « . » APPLICATION _ JSON « , acceptable ) ; » Response Entity « < Object > » response Entity « = » test Exception « ( ex ) ; » assert That « ( » response Entity « . » get Headers « ( ) . » get Accept « ( ) ) . » is Equal To « ( acceptable ) ; }
@Test { Exception ex = new » Http Media Type Not Acceptable Exception « ( " " ) ; » test Exception « ( ex ) ; }
@Test { Method method = » get Class « ( ) . » get Declared Method « ( " handle " , String . class ) ; » Method Parameter « parameter = new » Method Parameter « ( method , 0 ) ; Exception ex = new » Missing Path Variable Exception « ( " param " , parameter ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Missing Servlet Request Parameter Exception « ( " param " , " type " ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Servlet Request Binding Exception « ( " message " ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Conversion Not Supported Exception « ( new Object ( ) , Object . class , null ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Type Mismatch Exception « ( " foo " , String . class ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Http Message Not Readable Exception « ( " message " ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Http Message Not Writable Exception « ( " " ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = mock ( » Method Argument Not Valid Exception « . class ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Missing Servlet Request Part Exception « ( " » part Name « " ) ; » test Exception « ( ex ) ; }
@Test { Exception ex = new » Bind Exception « ( new Object ( ) , " name " ) ; » test Exception « ( ex ) ; }
@Test { » Servlet Server Http Request « req = new » Servlet Server Http Request « ( new » Mock Http Servlet Request « ( " GET " , " / resource " ) ) ; Exception ex = new » No Handler Found Exception « ( req . » get Method « ( ) . » to String « ( ) , req . » get Servlet Request « ( ) . » get Request URI « ( ) , req . » get Headers « ( ) ) ; » test Exception « ( ex ) ; }
@Test { » test Exception « ( new » Async Request Timeout Exception « ( ) ) ; }
@Test { » assert That « ( this . handler . » supports Return Type « ( » create Return Value Param « ( " view " ) ) ) . » is True « ( ) ; }
@Test { » Internal Resource View « view = new » Internal Resource View « ( " » test View « " ) ; this . handler . » handle Return Value « ( view , » create Return Value Param « ( " view " ) , this . » mav Container « , this . » web Request « ) ; » assert That « ( this . » mav Container « . » get View « ( ) ) . » is Same As « ( view ) ; }
@Test { » assert That « ( processor . » supports Parameter « ( » param Request Body String « ) ) . as ( " » Request Body « parameter not supported " ) . » is True « ( ) ; » assert That « ( processor . » supports Parameter « ( » param Int « ) ) . as ( " non - » Request Body « parameter supported " ) . » is False « ( ) ; }
@Test { » assert That « ( processor . » supports Return Type « ( » return Type String « ) ) . as ( " » Response Body « return type not supported " ) . » is True « ( ) ; » assert That « ( processor . » supports Return Type « ( » return Type Int « ) ) . as ( " non - » Response Body « return type supported " ) . » is False « ( ) ; }
@Test { » test Resolve Argument With Validation « ( new » Simple Bean « ( " name " ) ) ; }
@Test { » servlet Request « . » set Content « ( " payload " . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » will Return « ( false ) ; » assert That Exception Of Type « ( » Http Media Type Not Supported Exception « . class ) . » is Thrown By « ( ( ) -> processor . » resolve Argument « ( » param Request Body String « , » mav Container « , » web Request « , null ) ) ; }
@Test { this . » servlet Request « . » set Content Type « ( " bad " ) ; » servlet Request « . » set Content « ( " payload " . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) ; » assert That Exception Of Type « ( » Http Media Type Not Supported Exception « . class ) . » is Thrown By « ( ( ) -> processor . » resolve Argument « ( » param Request Body String « , » mav Container « , » web Request « , null ) ) ; }
@Test { » servlet Request « . » set Method « ( " GET " ) ; » servlet Request « . » set Content « ( new byte [ 0 ] ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » will Return « ( false ) ; » assert That « ( processor . » resolve Argument « ( » param String Not Required « , » mav Container « , » web Request « , new » Validating Binder Factory « ( ) ) ) . » is Null « ( ) ; }
@Test { » servlet Request « . » set Content Type « ( " text / plain " ) ; » servlet Request « . » set Content « ( new byte [ 0 ] ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » TEXT _ PLAIN « ) ) . » will Return « ( true ) ; » assert That « ( processor . » resolve Argument « ( » param String Not Required « , » mav Container « , » web Request « , new » Validating Binder Factory « ( ) ) ) . » is Null « ( ) ; }
@Test { » servlet Request « . » set Content « ( new byte [ 0 ] ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » TEXT _ PLAIN « ) ) . » will Return « ( true ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » will Return « ( false ) ; » assert That « ( processor . » resolve Argument « ( » param String Not Required « , » mav Container « , » web Request « , new » Validating Binder Factory « ( ) ) ) . » is Null « ( ) ; }
@Test { » servlet Request « . » set Content Type « ( " text / plain " ) ; » servlet Request « . » set Content « ( new byte [ 0 ] ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » TEXT _ PLAIN « ) ) . » will Return « ( true ) ; » assert That « ( processor . » resolve Argument « ( » param Optional String « , » mav Container « , » web Request « , new » Validating Binder Factory « ( ) ) ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » servlet Request « . » set Content « ( new byte [ 0 ] ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » TEXT _ PLAIN « ) ) . » will Return « ( true ) ; given ( » string Message Converter « . » can Read « ( String . class , » Media Type « . » APPLICATION _ OCTET _ STREAM « ) ) . » will Return « ( false ) ; » assert That « ( processor . » resolve Argument « ( » param Optional String « , » mav Container « , » web Request « , new » Validating Binder Factory « ( ) ) ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { Object actual = resolver . » resolve Argument « ( » param Multipart File « , null , » web Request « , null ) ; » assert That « ( actual ) . » is Same As « ( » multipart File 1 « ) ; }
@Test { Object actual = resolver . » resolve Argument « ( » param Multipart File List « , null , » web Request « , null ) ; boolean condition = actual instanceof List ; » assert That « ( condition ) . » is True « ( ) ; » assert That « ( actual ) . » is Equal To « ( Arrays . » as List « ( » multipart File 1 « , » multipart File 2 « ) ) ; }
@Test { » test Resolve Argument « ( new » Simple Bean « ( " foo " ) , » param Request Part « ) ; }
@Test { » test Resolve Argument « ( new » Simple Bean « ( " foo " ) , » param Named Request Part « ) ; }
@Test { » test Resolve Argument « ( null , » param Named Request Part « ) ; }
@Test { » test Resolve Argument « ( new » Simple Bean « ( " foo " ) , » param Valid Request Part « ) ; }
@Test { » assert That Exception Of Type « ( » Missing Servlet Request Part Exception « . class ) . » is Thrown By « ( ( ) -> » test Resolve Argument « ( null , » param Valid Request Part « ) ) . satisfies ( ex -> » assert That « ( ex . » get Request Part Name « ( ) ) . » is Equal To « ( " » request Part « " ) ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » assert That Exception Of Type « ( » Multipart Exception « . class ) . » is Thrown By « ( ( ) -> resolver . » resolve Argument « ( » param Multipart File « , new » Model And View Container « ( ) , new » Servlet Web Request « ( request ) , null ) ) ; }
@Test { this . » multipart Request « . » set Method « ( " PUT " ) ; Object » actual Value « = resolver . » resolve Argument « ( » param Multipart File « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . » is Same As « ( » multipart File 1 « ) ; }
@Test { » web Request « = new » Servlet Web Request « ( new » Mock Http Servlet Request « ( ) ) ; Object » actual Value « = resolver . » resolve Argument « ( » optional Multipart File « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; » actual Value « = resolver . » resolve Argument « ( » optional Multipart File « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » web Request « = new » Servlet Web Request « ( new » Mock Http Servlet Request « ( ) ) ; Object » actual Value « = resolver . » resolve Argument « ( » optional Part « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; » actual Value « = resolver . » resolve Argument « ( » optional Part « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » web Request « = new » Servlet Web Request « ( new » Mock Http Servlet Request « ( ) ) ; Object » actual Value « = resolver . » resolve Argument « ( » optional Part List « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; » actual Value « = resolver . » resolve Argument « ( » optional Part List « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » web Request « = new » Servlet Web Request « ( new » Mock Http Servlet Request « ( ) ) ; Object » actual Value « = resolver . » resolve Argument « ( » optional Request Part « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; » actual Value « = resolver . » resolve Argument « ( » optional Request Part « , null , » web Request « , null ) ; » assert That « ( » actual Value « ) . as ( " Invalid argument value " ) . » is Equal To « ( Optional . empty ( ) ) ; }
@Test { » Servlet Invocable Handler Method « » handler Method « = » get Handler Method « ( new Handler ( ) , " » response Status « " ) ; » handler Method « . » invoke And Handle « ( this . » web Request « , this . » mav Container « ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « . value ( ) ) ; » assert That « ( this . » mav Container « . » is Request Handled « ( ) ) . as ( " Null return value + @ » Response Status « should result in 'request handled' " ) . » is True « ( ) ; }
@Test { » Servlet Invocable Handler Method « » handler Method « = » get Handler Method « ( new Handler ( ) , " » composed Response Status « " ) ; » handler Method « . » invoke And Handle « ( this . » web Request « , this . » mav Container « ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « . value ( ) ) ; » assert That « ( this . » mav Container « . » is Request Handled « ( ) ) . as ( " Null return value + @ » Composed Response Status « should result in 'request handled' " ) . » is True « ( ) ; }
@Test { » Servlet Invocable Handler Method « » handler Method « = » get Handler Method « ( new » Response Status Handler « ( ) , " handle " ) ; » handler Method « . » invoke And Handle « ( this . » web Request « , this . » mav Container « ) ; » assert That « ( this . » mav Container « . » is Request Handled « ( ) ) . » is True « ( ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( » Http Status « . » BAD _ REQUEST « . value ( ) ) ; }
@Test { this . » argument Resolvers « . » add Resolver « ( new » Servlet Response Method Argument Resolver « ( ) ) ; » Servlet Invocable Handler Method « » handler Method « = » get Handler Method « ( new Handler ( ) , " » http Servlet Response « " , » Http Servlet Response « . class ) ; » handler Method « . » invoke And Handle « ( this . » web Request « , this . » mav Container « ) ; » assert That « ( this . » mav Container « . » is Request Handled « ( ) ) . as ( " Null return value + » Http Servlet Response « arg should result in 'request handled' " ) . » is True « ( ) ; }
@Test { this . » return Value Handlers « . » add Handler « ( new » Exception Raising Return Value Handler « ( ) ) ; » Servlet Invocable Handler Method « » handler Method « = » get Handler Method « ( new Handler ( ) , " handle " ) ; » assert That Exception Of Type « ( » Http Message Not Writable Exception « . class ) . » is Thrown By « ( ( ) -> » handler Method « . » invoke And Handle « ( this . » web Request « , this . » mav Container « ) ) ; }
@Test { » wrap Concurrent Result _ Response Body « ( new » Method Level Response Body Handler « ( ) , " bar " , String . class ) ; }
@Test { » wrap Concurrent Result _ Response Body « ( new » Method Level Response Body Handler « ( ) , null , String . class ) ; }
@Test { » wrap Concurrent Result _ Response Body « ( new » Type Level Response Body Handler « ( ) , " bar " , String . class ) ; }
@Test { » wrap Concurrent Result _ Response Body « ( new » Type Level Response Body Handler « ( ) , null , String . class ) ; }
@Test { » wrap Concurrent Result _ Response Body « ( new » Deferred Result Subclass Handler « ( ) , " bar " , String . class ) ; }
@Test { » wrap Concurrent Result _ Response Body « ( new » Deferred Result Subclass Handler « ( ) , null , » Custom Deferred Result « . class ) ; }
@Test { this . » return Value Handlers « . » add Handler « ( new » Http Entity Method Processor « ( this . converters ) ) ; » Servlet Invocable Handler Method « » handler Method « = » get Handler Method « ( new » Response Entity Handler « ( ) , " » handle Raw Type « " ) ; » handler Method « . » invoke And Handle « ( this . » web Request « , this . » mav Container « ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 200 ) ; » assert That « ( this . response . » get Content As String « ( ) ) . » is Equal To « ( " " ) ; }
@Test { Principal principal = ( ) -> " Foo " ; » servlet Request « . » set User Principal « ( principal ) ; » Method Parameter « » principal Parameter « = new » Method Parameter « ( method , 3 ) ; » assert That « ( resolver . » supports Parameter « ( » principal Parameter « ) ) . as ( " Principal not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » principal Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( principal ) ; }
@Test { » Method Parameter « » principal Parameter « = new » Method Parameter « ( method , 3 ) ; » assert That « ( resolver . » supports Parameter « ( » principal Parameter « ) ) . as ( " Principal not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » principal Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Null « ( ) ; }
@Test { Locale locale = Locale . ENGLISH ; » servlet Request « . » add Preferred Locale « ( locale ) ; » Method Parameter « » locale Parameter « = new » Method Parameter « ( method , 4 ) ; » assert That « ( resolver . » supports Parameter « ( » locale Parameter « ) ) . as ( " Locale not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » locale Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( locale ) ; }
@Test { Locale locale = Locale . ENGLISH ; » servlet Request « . » set Attribute « ( » Dispatcher Servlet « . » LOCALE _ RESOLVER _ ATTRIBUTE « , new » Fixed Locale Resolver « ( locale ) ) ; » Method Parameter « » locale Parameter « = new » Method Parameter « ( method , 4 ) ; » assert That « ( resolver . » supports Parameter « ( » locale Parameter « ) ) . as ( " Locale not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » locale Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( locale ) ; }
@Test { » Method Parameter « » time Zone Parameter « = new » Method Parameter « ( method , 8 ) ; » assert That « ( resolver . » supports Parameter « ( » time Zone Parameter « ) ) . as ( " » Time Zone « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » time Zone Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( » Time Zone « . » get Default « ( ) ) ; }
@Test { » Method Parameter « » zone Id Parameter « = new » Method Parameter « ( method , 9 ) ; » assert That « ( resolver . » supports Parameter « ( » zone Id Parameter « ) ) . as ( " » Zone Id « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » zone Id Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Equal To « ( » Zone Id « . » system Default « ( ) ) ; }
@Test { » Method Parameter « » input Stream Parameter « = new » Method Parameter « ( method , 5 ) ; » assert That « ( resolver . » supports Parameter « ( » input Stream Parameter « ) ) . as ( " » Input Stream « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » input Stream Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » web Request « . » get Request « ( ) . » get Input Stream « ( ) ) ; }
@Test { » Method Parameter « » reader Parameter « = new » Method Parameter « ( method , 6 ) ; » assert That « ( resolver . » supports Parameter « ( » reader Parameter « ) ) . as ( " Reader not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » reader Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » web Request « . » get Request « ( ) . » get Reader « ( ) ) ; }
@Test { » Method Parameter « » web Request Parameter « = new » Method Parameter « ( method , 7 ) ; » assert That « ( resolver . » supports Parameter « ( » web Request Parameter « ) ) . as ( " » Web Request « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » web Request Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » web Request « ) ; }
@Test { » Method Parameter « » http Method Parameter « = new » Method Parameter « ( method , 10 ) ; » assert That « ( resolver . » supports Parameter « ( » http Method Parameter « ) ) . as ( " » Http Method « not supported " ) . » is True « ( ) ; Object result = resolver . » resolve Argument « ( » http Method Parameter « , null , » web Request « , null ) ; » assert That « ( result ) . as ( " Invalid result " ) . » is Same As « ( » Http Method « . » value Of « ( » web Request « . » get Request « ( ) . » get Method « ( ) ) ) ; }
@Test { » assert That « ( this . resolver . » supports Parameter « ( this . » builder Param « ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » servlet Builder Param « ) ) . » is True « ( ) ; » assert That « ( this . resolver . » supports Parameter « ( this . » int Param « ) ) . » is False « ( ) ; }
@Test { this . emitter . send ( " foo " ) ; this . handler . » assert Sent Object Count « ( 3 ) ; this . handler . » assert Object « ( 0 , " data : " , » TEXT _ PLAIN _ UTF 8 « ) ; this . handler . » assert Object « ( 1 , " foo " ) ; this . handler . » assert Object « ( 2 , " \n \n " , » TEXT _ PLAIN _ UTF 8 « ) ; }
@Test { this . emitter . send ( " foo " , » Media Type « . » TEXT _ PLAIN « ) ; this . handler . » assert Sent Object Count « ( 3 ) ; this . handler . » assert Object « ( 0 , " data : " , » TEXT _ PLAIN _ UTF 8 « ) ; this . handler . » assert Object « ( 1 , " foo " , » Media Type « . » TEXT _ PLAIN « ) ; this . handler . » assert Object « ( 2 , " \n \n " , » TEXT _ PLAIN _ UTF 8 « ) ; }
@Test { this . emitter . send ( event ( ) ) ; this . handler . » assert Sent Object Count « ( 0 ) ; }
@Test { this . emitter . send ( event ( ) . data ( " foo " ) ) ; this . handler . » assert Sent Object Count « ( 3 ) ; this . handler . » assert Object « ( 0 , " data : " , » TEXT _ PLAIN _ UTF 8 « ) ; this . handler . » assert Object « ( 1 , " foo " ) ; this . handler . » assert Object « ( 2 , " \n \n " , » TEXT _ PLAIN _ UTF 8 « ) ; }
@Test { this . emitter . send ( event ( ) . comment ( " blah " ) . name ( " test " ) . » reconnect Time « ( 5000L ) . id ( " 1 " ) . data ( " foo " ) ) ; this . handler . » assert Sent Object Count « ( 3 ) ; this . handler . » assert Object « ( 0 , " : blah \n event : test \n retry : 5000 \n id : 1 \n data : " , » TEXT _ PLAIN _ UTF 8 « ) ; this . handler . » assert Object « ( 1 , " foo " ) ; this . handler . » assert Object « ( 2 , " \n \n " , » TEXT _ PLAIN _ UTF 8 « ) ; }
@Test { » servlet Request « . » set Method « ( " POST " ) ; » servlet Request « . » set Content « ( " some content " . » get Bytes « ( » Standard Charsets « . » UTF _ 8 « ) ) ; » assert That Exception Of Type « ( » Http Media Type Not Supported Exception « . class ) . » is Thrown By « ( ( ) -> processor . » resolve Argument « ( » param Http Entity « , » mav Container « , » web Request « , null ) ) ; }
@Test { » Response Entity « < String > » return Value « = new » Response Entity « < > ( " Body " , » Http Status « . ACCEPTED ) ; » servlet Request « . » add Header « ( " Accept " , " 01 " ) ; » assert That Exception Of Type « ( » Http Media Type Not Acceptable Exception « . class ) . » is Thrown By « ( ( ) -> processor . » handle Return Value « ( » return Value « , » return Type Response Entity « , » mav Container « , » web Request « ) ) ; }
@Test { » servlet Request « . » set Method « ( " PUT " ) ; String » etag Value « = " \" some - etag \" " ; » Response Entity « < String > » return Value « = » Response Entity « . ok ( ) . header ( » Http Headers « . ETAG , » etag Value « ) . body ( " body " ) ; » init String Message Conversion « ( » TEXT _ PLAIN « ) ; processor . » handle Return Value « ( » return Value « , » return Type Response Entity « , » mav Container « , » web Request « ) ; » assert Conditional Response « ( » Http Status « . OK , " body " , » etag Value « , - 1 ) ; }
@Test { String [ ] » entity Values « = { " Accept - Language " , " User - Agent " } ; String [ ] » existing Values « = { } ; String [ ] expected = { " Accept - Language , User - Agent " } ; » test Vary Header « ( » entity Values « , » existing Values « , expected ) ; }
@Test { String [ ] » entity Values « = { " Accept - Language " } ; String [ ] » existing Values « = { " * " } ; String [ ] expected = { " * " } ; » test Vary Header « ( » entity Values « , » existing Values « , expected ) ; }
@Test { String [ ] » entity Values « = { " Accept - Language " , " User - Agent " } ; String [ ] » existing Values « = { " Accept - Encoding " , " Accept - Language " } ; String [ ] expected = { " Accept - Encoding " , " Accept - Language " , " User - Agent " } ; » test Vary Header « ( » entity Values « , » existing Values « , expected ) ; }
@Test { String [ ] » entity Values « = { " Accept - Language " , " User - Agent " } ; String [ ] » existing Values « = { " Accept - Encoding , Accept - Language " } ; String [ ] expected = { " Accept - Encoding , Accept - Language " , " User - Agent " } ; » test Vary Header « ( » entity Values « , » existing Values « , expected ) ; }
@Test { » Model And View « » model And View « = this . controller . » handle Request « ( this . request , this . response ) ; » assert That « ( » model And View « . » get View Name « ( ) ) . » is Null « ( ) ; }
@Test { this . controller . » set View Name « ( " view " ) ; » Model And View « » model And View « = this . controller . » handle Request « ( this . request , this . response ) ; » assert That « ( » model And View « . » get View Name « ( ) ) . » is Equal To « ( " view " ) ; }
@Test { this . controller . » set View Name « ( " view " ) ; this . controller . » set Status Code « ( » Http Status « . » NOT _ FOUND « ) ; » Model And View « » model And View « = this . controller . » handle Request « ( this . request , this . response ) ; » assert That « ( » model And View « . » get View Name « ( ) ) . » is Equal To « ( " view " ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { this . controller . » set Status Code « ( » Http Status « . » NO _ CONTENT « ) ; » Model And View « » model And View « = this . controller . » handle Request « ( this . request , this . response ) ; » assert That « ( » model And View « ) . » is Null « ( ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 204 ) ; }
@Test { » Redirect View « view = new » Redirect View « ( " / foo " ) ; this . controller . » set View « ( view ) ; » Model And View « » model And View « = this . controller . » handle Request « ( this . request , this . response ) ; » assert That « ( » model And View « . » get View « ( ) ) . » is Same As « ( view ) ; }
@Test { this . controller . » set Status Code « ( » Http Status « . » NOT _ FOUND « ) ; this . controller . » set Status Only « ( true ) ; » Model And View « » model And View « = this . controller . » handle Request « ( this . request , this . response ) ; » assert That « ( » model And View « ) . » is Null « ( ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { » Type Mismatch Exception « ex = new » Type Mismatch Exception « ( " foo " , String . class ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert That « ( mav ) . as ( " No » Model And View « returned " ) . » is Not Null « ( ) ; » assert That « ( mav . » is Empty « ( ) ) . as ( " No Empty » Model And View « returned " ) . » is True « ( ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( 400 ) ; }
@Test { » Http Message Not Readable Exception « ex = new » Http Message Not Readable Exception « ( " foo " ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert That « ( mav ) . as ( " No » Model And View « returned " ) . » is Not Null « ( ) ; » assert That « ( mav . » is Empty « ( ) ) . as ( " No Empty » Model And View « returned " ) . » is True « ( ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( 400 ) ; }
@Test { » Http Message Not Writable Exception « ex = new » Http Message Not Writable Exception « ( " foo " ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert That « ( mav ) . as ( " No » Model And View « returned " ) . » is Not Null « ( ) ; » assert That « ( mav . » is Empty « ( ) ) . as ( " No Empty » Model And View « returned " ) . » is True « ( ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( 500 ) ; }
@Test { » Bind Exception « ex = new » Bind Exception « ( new Object ( ) , " name " ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert That « ( mav ) . as ( " No » Model And View « returned " ) . » is Not Null « ( ) ; » assert That « ( mav . » is Empty « ( ) ) . as ( " No Empty » Model And View « returned " ) . » is True « ( ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( 400 ) ; }
@Test { Exception ex = new » Async Request Timeout Exception « ( ) ; » Model And View « mav = » exception Resolver « . » resolve Exception « ( request , response , null , ex ) ; » assert That « ( mav ) . as ( " No » Model And View « returned " ) . » is Not Null « ( ) ; » assert That « ( mav . » is Empty « ( ) ) . as ( " No Empty » Model And View « returned " ) . » is True « ( ) ; » assert That « ( response . » get Status « ( ) ) . as ( " Invalid status code " ) . » is Equal To « ( 503 ) ; }
@Test { this . » redirect Attributes « . » add Attribute « ( " speed " , 65 ) ; » assert That « ( this . » redirect Attributes « . get ( " speed " ) ) . » is Equal To « ( " 65 " ) ; }
@Test { String » attr Name « = " person " ; » Redirect Attributes Model Map « model = new » Redirect Attributes Model Map « ( ) ; model . » add Attribute « ( » attr Name « , new » Test Bean « ( " Fred " ) ) ; » assert That « ( model . get ( » attr Name « ) ) . as ( " » to String « ( ) should have been used " ) . » is Equal To « ( " Fred " ) ; }
@Test { this . » redirect Attributes « . » add Attribute « ( new » Test Bean « ( " Fred " ) ) ; » assert That « ( this . » redirect Attributes « . get ( " » test Bean « " ) ) . » is Equal To « ( " Fred " ) ; }
@Test { this . » redirect Attributes « . » add All Attributes « ( Arrays . » as List « ( new » Test Bean « ( " Fred " ) , new Integer ( 5 ) ) ) ; » assert That « ( this . » redirect Attributes « . get ( " » test Bean « " ) ) . » is Equal To « ( " Fred " ) ; » assert That « ( this . » redirect Attributes « . get ( " integer " ) ) . » is Equal To « ( " 5 " ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " person " , new » Test Bean « ( " Fred " ) ) ; map . put ( " age " , 33 ) ; this . » redirect Attributes « . » add All Attributes « ( map ) ; » assert That « ( this . » redirect Attributes « . get ( " person " ) ) . » is Equal To « ( " Fred " ) ; » assert That « ( this . » redirect Attributes « . get ( " age " ) ) . » is Equal To « ( " 33 " ) ; }
@Test { this . » redirect Attributes « . put ( " » test Bean « " , new » Test Bean « ( " Fred " ) ) ; » assert That « ( this . » redirect Attributes « . get ( " » test Bean « " ) ) . » is Equal To « ( " Fred " ) ; }
@Test { Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " person " , new » Test Bean « ( " Fred " ) ) ; map . put ( " age " , 33 ) ; this . » redirect Attributes « . » put All « ( map ) ; » assert That « ( this . » redirect Attributes « . get ( " person " ) ) . » is Equal To « ( " Fred " ) ; » assert That « ( this . » redirect Attributes « . get ( " age " ) ) . » is Equal To « ( " 33 " ) ; }
@Test { this . request = new » Mock Http Servlet Request « ( " GET " , " / static / foo . css " ) ; Resource resource = » get Resource « ( " foo . css " ) ; Resource result = this . transformer . transform ( this . request , resource , this . chain ) ; » assert That « ( result ) . » is Equal To « ( resource ) ; }
@Test { this . request = new » Mock Http Servlet Request « ( " GET " , " / static / error . appcache " ) ; Resource resource = » get Resource « ( " error . appcache " ) ; Resource result = this . transformer . transform ( this . request , resource , this . chain ) ; » assert That « ( result ) . » is Equal To « ( resource ) ; }
@Test { Resource expected = new » Class Path Resource « ( " test / bar . css " , » get Class « ( ) ) ; Resource actual = this . chain . » resolve Resource « ( null , " bar . css " , this . locations ) ; » assert That « ( actual ) . » is Not Same As « ( expected ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { Resource expected = Mockito . mock ( Resource . class ) ; this . cache . put ( » resource Key « ( " bar . css " ) , expected ) ; Resource actual = this . chain . » resolve Resource « ( null , " bar . css " , this . locations ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { » assert That « ( this . chain . » resolve Resource « ( null , " invalid . css " , this . locations ) ) . » is Null « ( ) ; }
@Test { String expected = " / foo . css " ; String actual = this . chain . » resolve Url Path « ( expected , this . locations ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { String expected = " cached - imaginary . css " ; this . cache . put ( » Caching Resource Resolver « . » RESOLVED _ URL _ PATH _ CACHE _ KEY _ PREFIX « + " imaginary . css " , expected ) ; String actual = this . chain . » resolve Url Path « ( " imaginary . css " , this . locations ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { » assert That « ( this . chain . » resolve Url Path « ( " invalid . css " , this . locations ) ) . » is Null « ( ) ; }
@Test { String file = " bar . css " ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , file ) ; Resource expected = this . chain . » resolve Resource « ( request , file , this . locations ) ; String » cache Key « = » resource Key « ( file ) ; Object actual = this . cache . get ( » cache Key « ) . get ( ) ; » assert That « ( actual ) . » is Equal To « ( expected ) ; }
@Test { String file = " js / foo . js " ; Resource resolved = this . resolver . » resolve Resource « ( null , file , this . locations ) ; » assert That « ( resolved . » get Description « ( ) ) . » is Equal To « ( » get Resource « ( file ) . » get Description « ( ) ) ; » assert That « ( resolved . » get Filename « ( ) ) . » is Equal To « ( » get Resource « ( file ) . » get Filename « ( ) ) ; }
@Test { this . request . » set Method « ( " OPTIONS " ) ; this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " foo . css " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 200 ) ; » assert That « ( this . response . » get Header « ( " Allow " ) ) . » is Equal To « ( " GET , HEAD , OPTIONS " ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " js / foo . js " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Content Type « ( ) ) . » is Equal To « ( " text / javascript " ) ; » assert That « ( this . response . » get Content As String « ( ) ) . » is Equal To « ( " function foo ( ) { console . log ( \" hello world \" ) ; } " ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " js / baz . js " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Content Type « ( ) ) . » is Equal To « ( " text / javascript " ) ; » assert That « ( this . response . » get Content As String « ( ) ) . » is Equal To « ( " function foo ( ) { console . log ( \" hello world \" ) ; } " ) ; }
@Test { for ( » Http Method « method : » Http Method « . values ( ) ) { this . request = new » Mock Http Servlet Request « ( " GET " , " " ) ; this . response = new » Mock Http Servlet Response « ( ) ; » test Resolve Path With Traversal « ( method ) ; } }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " / % foo % / bar . txt " ) ; this . response = new » Mock Http Servlet Response « ( ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " foo . css " ) ; this . request . » add Header « ( " If - Modified - Since " , » resource Last Modified « ( " test / foo . css " ) ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( » Http Servlet Response « . » SC _ NOT _ MODIFIED « ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " js / " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " underscorejs / " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . handler . » handle Request « ( this . request , this . response ) ) ; }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " foo . css " ) ; this . request . » set Method « ( " POST " ) ; » assert That Exception Of Type « ( » Http Request Method Not Supported Exception « . class ) . » is Thrown By « ( ( ) -> this . handler . » handle Request « ( this . request , this . response ) ) ; }
@Test { for ( » Http Method « method : » Http Method « . values ( ) ) { this . request = new » Mock Http Servlet Request « ( " GET " , " " ) ; this . response = new » Mock Http Servlet Response « ( ) ; » resource Not Found « ( method ) ; } }
@Test { this . request . » set Attribute « ( » Handler Mapping « . » PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE « , " foo . css " ) ; this . response . » set Header « ( " Cache - Control " , " no - store " ) ; this . handler . » handle Request « ( this . request , this . response ) ; » assert That « ( this . response . » get Header « ( " Cache - Control " ) ) . » is Equal To « ( " max - age = 3600 " ) ; }
@Test { this . request . » set Request URI « ( " / myapp / index " ) ; this . request . » set Servlet Path « ( " / index " ) ; this . » filter Chain « . » do Filter « ( this . request , this . response ) ; » assert That « ( » resolve Public Resource Url Path « ( " / myapp / resources / foo . css " ) ) . » is Equal To « ( " / myapp / resources / foo - » e 36 d 2 e 05253 c 6 c 7085 a 91522 ce 43 a 0 b 4 « . css " ) ; }
@Test { this . request . » set Request URI « ( " / myapp / myservlet / index " ) ; this . request . » set Servlet Path « ( " / myservlet " ) ; this . » filter Chain « . » do Filter « ( this . request , this . response ) ; » assert That « ( » resolve Public Resource Url Path « ( " / myapp / myservlet / resources / foo . css " ) ) . » is Equal To « ( " / myapp / myservlet / resources / foo - » e 36 d 2 e 05253 c 6 c 7085 a 91522 ce 43 a 0 b 4 « . css " ) ; }
@Test { this . request . » set Request URI « ( " / myapp / myservlet / index " ) ; this . request . » set Servlet Path « ( " / myservlet " ) ; this . » filter Chain « . » do Filter « ( this . request , this . response ) ; » assert That « ( » resolve Public Resource Url Path « ( " / myapp / myservlet / index " ) ) . » is Equal To « ( " / myapp / myservlet / index " ) ; }
@Test { String url = this . » url Provider « . » get For Lookup Path « ( " / resources / foo . css " ) ; » assert That « ( url ) . » is Equal To « ( " / resources / foo . css " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; request . » set Context Path « ( " / contextpath - longer - than - request - path " ) ; request . » set Request URI « ( " / contextpath - longer - than - request - path / style . css " ) ; String url = " / resources / foo . css " ; String » resolved Url « = this . » url Provider « . » get For Request Url « ( request , url ) ; » assert That « ( ( Object ) » resolved Url « ) . » is Null « ( ) ; }
@Test { » Annotation Config Web Application Context « context = new » Annotation Config Web Application Context « ( ) ; context . » set Servlet Context « ( new » Mock Servlet Context « ( ) ) ; context . register ( » Handler Mapping Configuration « . class ) ; context . refresh ( ) ; » Resource Url Provider « » url Provider Bean « = context . » get Bean « ( » Resource Url Provider « . class ) ; » assert That « ( » url Provider Bean « . » get Handler Map « ( ) ) . » contains Key « ( " » / resources / « * * " ) ; » assert That « ( » url Provider Bean « . » is Autodetect « ( ) ) . » is False « ( ) ; }
@Test { String file = " missing . css " ; given ( this . chain . » resolve Resource « ( null , file , this . locations ) ) . » will Return « ( null ) ; this . resolver . » set Strategy Map « ( Collections . » empty Map « ( ) ) ; Resource actual = this . resolver . » resolve Resource Internal « ( null , file , this . locations , this . chain ) ; » assert That « ( ( Object ) actual ) . » is Null « ( ) ; verify ( this . chain , times ( 1 ) ) . » resolve Resource « ( null , file , this . locations ) ; }
@Test { given ( this . chain . » resolve Url Path « ( " / foo . css " , this . locations ) ) . » will Return « ( " / foo . css " ) ; String resolved = this . resolver . » resolve Url Path Internal « ( " / foo . css " , this . locations , this . chain ) ; » assert That « ( resolved ) . » is Equal To « ( " / foo . css " ) ; }
@Test { this . locations = Collections . » singleton List « ( new » Class Path Resource « ( " / META - INF / resources / webjars / " , » get Class « ( ) ) ) ; String file = " / foo / 2.3 / foo . txt " ; given ( this . chain . » resolve Url Path « ( file , this . locations ) ) . » will Return « ( file ) ; String actual = this . resolver . » resolve Url Path « ( file , this . locations , this . chain ) ; » assert That « ( actual ) . » is Equal To « ( file ) ; verify ( this . chain , times ( 1 ) ) . » resolve Url Path « ( file , this . locations ) ; }
@Test { String file = " something / something . js " ; given ( this . chain . » resolve Url Path « ( file , this . locations ) ) . » will Return « ( null ) ; String actual = this . resolver . » resolve Url Path « ( file , this . locations , this . chain ) ; » assert That « ( actual ) . » is Null « ( ) ; verify ( this . chain , times ( 1 ) ) . » resolve Url Path « ( file , this . locations ) ; verify ( this . chain , never ( ) ) . » resolve Url Path « ( null , this . locations ) ; }
@Test { String file = " something / something . js " ; given ( this . chain . » resolve Url Path « ( file , this . locations ) ) . » will Return « ( null ) ; Resource actual = this . resolver . » resolve Resource « ( this . request , file , this . locations , this . chain ) ; » assert That « ( actual ) . » is Null « ( ) ; verify ( this . chain , times ( 1 ) ) . » resolve Resource « ( this . request , file , this . locations ) ; verify ( this . chain , never ( ) ) . » resolve Resource « ( this . request , null , this . locations ) ; }
@Test { » test Encode Url « ( new » Mock Http Servlet Request « ( " GET " , " / " ) , " / resources / bar . css " , " / resources / bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / context / foo " ) ; request . » set Context Path « ( " / context " ) ; » test Encode Url « ( request , " / context / resources / bar . css " , " / context / resources / bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / context " ) ; request . » set Context Path « ( " / context " ) ; » test Encode Url « ( request , " / context / resources / bar . css " , " / context / resources / bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / context / " ) ; request . » set Context Path « ( " / context " ) ; » test Encode Url « ( request , " / context / resources / bar . css " , " / context / resources / bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / context / foo " ) ; request . » set Context Path « ( " / context " ) ; » test Encode Url « ( request , " ? foo = 1 " , " ? foo = 1 " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / foo " ) ; request . » set Context Path « ( " / " ) ; » test Encode Url « ( request , " » / resources / bar . css « ? » foo = bar « & » url = https « : » // example . org « " , " » / resources / bar - 11 e 16 cf 79 faee 7 ac 698 c 805 cf 28248 d 2 . css « ? » foo = bar « & » url = https « : » // example . org « " ) ; }
@Test { » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( " GET " , " / context - path / index " ) ; request . » set Context Path « ( " / context - path " ) ; request . » set Servlet Path « ( " " ) ; » test Encode Url « ( request , " index ? key = value " , " index ? key = value " ) ; }
@Test { Resource resource = » get Resource « ( " main . css " ) ; String actual = this . transformer . » resolve Url Path « ( " bar . css " , this . request , resource , this . » transformer Chain « ) ; » assert That « ( actual ) . » is Equal To « ( " bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { Resource resource = » get Resource « ( " images / image . png " ) ; String actual = this . transformer . » resolve Url Path « ( " . . / bar . css " , this . request , resource , this . » transformer Chain « ) ; » assert That « ( actual ) . » is Equal To « ( " . . / bar - 11e16 » cf 79 faee 7 ac 698 c 805 cf 28248 d 2 « . css " ) ; }
@Test { String absolute = this . transformer . » to Absolute Path « ( " img / image . png " , new » Mock Http Servlet Request « ( " GET " , " / resources / style . css " ) ) ; » assert That « ( absolute ) . » is Equal To « ( " / resources / img / image . png " ) ; absolute = this . transformer . » to Absolute Path « ( " / img / image . png " , new » Mock Http Servlet Request « ( " GET " , " / resources / style . css " ) ) ; » assert That « ( absolute ) . » is Equal To « ( " / img / image . png " ) ; }
@Test { Resource location = new » Class Path Resource « ( " test / " , » Path Resource Resolver « . class ) ; String » request Path « = " bar . css " ; Resource actual = this . resolver . » resolve Resource « ( null , » request Path « , Collections . » singleton List « ( location ) , null ) ; » assert That « ( actual ) . » is Equal To « ( location . » create Relative « ( » request Path « ) ) ; }
@Test { Resource location = new » Class Path Resource « ( " / " ) ; String » request Path « = " org / springframework / web / servlet / resource / test / bar . css " ; Resource actual = this . resolver . » resolve Resource « ( null , » request Path « , Collections . » singleton List « ( location ) , null ) ; » assert That « ( actual ) . » is Not Null « ( ) ; }
@Test { this . resolver . » set Allowed Locations « ( new » Class Path Resource « ( " test / " , » Path Resource Resolver « . class ) , new » Class Path Resource « ( " testalternatepath / " , » Path Resource Resolver « . class ) ) ; Resource location = » get Resource « ( " main . css " ) ; List < Resource > locations = Collections . » singleton List « ( location ) ; String actual = this . resolver . » resolve Url Path « ( " . . / testalternatepath / bar . css " , locations , null ) ; » assert That « ( actual ) . » is Equal To « ( " . . / testalternatepath / bar . css " ) ; }
@Test { String » location Url « = new » Url Resource « ( » get Class « ( ) . » get Resource « ( " . / test / " ) ) . » get URL « ( ) . » to External Form « ( ) ; Resource location = new » Url Resource « ( » location Url « . replace ( " / springframework " , " / . . / org / springframework " ) ) ; » assert That « ( this . resolver . » resolve Resource « ( null , " main . css " , Collections . » singleton List « ( location ) , null ) ) . » is Not Null « ( ) ; }
@Test { Resource » webjars Location « = new » Class Path Resource « ( " / META - INF / resources / webjars / " , » Path Resource Resolver « . class ) ; String path = this . resolver . » resolve Url Path Internal « ( " " , Collections . » singleton List « ( » webjars Location « ) , null ) ; » assert That « ( path ) . » is Null « ( ) ; }
@Test { String hash = " 7f » be 76 cdac 6093784895 bb 4989203 e 5 a « " ; String path = " font - awesome / css / font - awesome . min - " + hash + " . css " ; » assert That « ( this . » version Strategy « . » extract Version « ( path ) ) . » is Equal To « ( hash ) ; » assert That « ( this . » version Strategy « . » extract Version « ( " foo / bar . css " ) ) . » is Null « ( ) ; }
@Test { String hash = " 7f » be 76 cdac 6093784895 bb 4989203 e 5 a « " ; String file = " font - awesome / css / font - awesome . min % s % s . css " ; » assert That « ( this . » version Strategy « . » remove Version « ( String . format ( file , " - " , hash ) , hash ) ) . » is Equal To « ( String . format ( file , " " , " " ) ) ; }
@Test { Resource expected = new » Class Path Resource « ( " test / bar . css " , » get Class « ( ) ) ; String hash = » Digest Utils « . » md 5 Digest As Hex « ( » File Copy Utils « . » copy To Byte Array « ( expected . » get Input Stream « ( ) ) ) ; » assert That « ( this . » version Strategy « . » get Resource Version « ( expected ) ) . » is Equal To « ( hash ) ; }
@Test { » assert That « ( this . » version Strategy « . » add Version « ( " test / bar . css " , " 123 " ) ) . » is Equal To « ( " test / bar - 123. css " ) ; }
@Test { this . request = new » Mock Http Servlet Request « ( " GET " , " / static / foo . css " ) ; Resource expected = » get Resource « ( " foo . css " ) ; Resource actual = this . » transformer Chain « . transform ( this . request , expected ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { this . request = new » Mock Http Servlet Request « ( " GET " , " / static / images / image . png " ) ; Resource expected = » get Resource « ( " images / image . png " ) ; Resource actual = this . » transformer Chain « . transform ( this . request , expected ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { initializer = new » My Annotation Config Dispatcher Servlet Initializer « ( ) { @ Override protected Filter [ ] » get Servlet Filters « ( ) { return null ; } } ; initializer . » on Startup « ( » servlet Context « ) ; » assert That « ( » filter Registrations « . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Flash Map « » flash Map « = new » Flash Map « ( ) ; this . » flash Map Manager « . » save Output Flash Map « ( » flash Map « , this . request , this . response ) ; List < » Flash Map « > » all Maps « = this . » flash Map Manager « . » get Flash Maps « ( ) ; » assert That « ( » all Maps « ) . » is Null « ( ) ; }
@Test { » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . put ( " key " , " value " ) ; » flash Map « . » set Target Request Path « ( " / once % 20 upon % 20 a % 20 time " ) ; this . » flash Map Manager « . » save Output Flash Map « ( » flash Map « , this . request , this . response ) ; » assert That « ( » flash Map « . » get Target Request Path « ( ) ) . » is Equal To « ( " / once upon a time " ) ; }
@Test { » Flash Map « » flash Map « = new » Flash Map « ( ) ; » flash Map « . put ( " key " , " value " ) ; » flash Map « . » set Target Request Path « ( " " ) ; this . » flash Map Manager « . » save Output Flash Map « ( » flash Map « , this . request , this . response ) ; » assert That « ( » flash Map « . » get Target Request Path « ( ) ) . » is Equal To « ( " " ) ; }
@Test { request . » set Context Path « ( " foo / " ) ; » Request Context « context = new » Request Context « ( request , response , » servlet Context « , model ) ; » assert That « ( context . » get Context Url « ( " bar " ) ) . » is Equal To « ( " foo / bar " ) ; }
@Test { request . » set Context Path « ( " foo / " ) ; » Request Context « context = new » Request Context « ( request , response , » servlet Context « , model ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " foo " , " bar " ) ; map . put ( " spam " , " bucket " ) ; » assert That « ( context . » get Context Url « ( " { foo } ? spam = { spam } " , map ) ) . » is Equal To « ( " foo / bar ? spam = bucket " ) ; }
@Test { request . » set Context Path « ( " foo / " ) ; » Request Context « context = new » Request Context « ( request , response , » servlet Context « , model ) ; Map < String , Object > map = new » Hash Map « < > ( ) ; map . put ( " foo " , " bar baz " ) ; map . put ( " spam " , " & bucket = " ) ; » assert That « ( context . » get Context Url « ( " { foo } ? spam = { spam } " , map ) ) . » is Equal To « ( " foo / bar % 20 baz ? spam = % 26 bucket % 3D " ) ; }
@Test { » Web Content Generator « generator = new » Test Web Content Generator « ( true ) ; » assert That « ( generator . » get Allow Header « ( ) ) . » is Equal To « ( " GET , HEAD , POST , OPTIONS " ) ; }
@Test { » Web Content Generator « generator = new » Test Web Content Generator « ( false ) ; » assert That « ( generator . » get Allow Header « ( ) ) . » is Equal To « ( " GET , HEAD , POST , PUT , PATCH , DELETE , OPTIONS " ) ; }
@Test { » Web Content Generator « generator = new » Test Web Content Generator « ( " POST " ) ; » assert That « ( generator . » get Allow Header « ( ) ) . » is Equal To « ( " POST , OPTIONS " ) ; }
@Test { » Web Content Generator « generator = new » Test Web Content Generator « ( ) ; generator . » set Supported Methods « ( " POST " ) ; » assert That « ( generator . » get Allow Header « ( ) ) . » is Equal To « ( " POST , OPTIONS " ) ; }
@Test { » Web Content Generator « generator = new » Test Web Content Generator « ( ) ; generator . » set Supported Methods « ( ) ; » assert That « ( generator . » get Allow Header « ( ) ) . as ( " Effectively \" no restriction \" on supported methods " ) . » is Equal To « ( " GET , HEAD , POST , PUT , PATCH , DELETE , OPTIONS " ) ; }
@Test { » Web Content Generator « generator = new » Test Web Content Generator « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; generator . » prepare Response « ( response ) ; » assert That « ( response . » get Header « ( " Vary " ) ) . » is Null « ( ) ; }
@Test { String [ ] » configured Values « = { " Accept - Language " , " User - Agent " } ; String [ ] » response Values « = { } ; String [ ] expected = { " Accept - Language " , " User - Agent " } ; » test Vary Header « ( » configured Values « , » response Values « , expected ) ; }
@Test { String [ ] » configured Values « = { " Accept - Language " } ; String [ ] » response Values « = { " * " } ; String [ ] expected = { " * " } ; » test Vary Header « ( » configured Values « , » response Values « , expected ) ; }
@Test { String [ ] » configured Values « = { " Accept - Language " , " User - Agent " } ; String [ ] » response Values « = { " Accept - Encoding " , " Accept - Language " } ; String [ ] expected = { " Accept - Encoding " , " Accept - Language " , " User - Agent " } ; » test Vary Header « ( » configured Values « , » response Values « , expected ) ; }
@Test { String [ ] » configured Values « = { " Accept - Language " , " User - Agent " } ; String [ ] » response Values « = { " Accept - Encoding , Accept - Language " } ; String [ ] expected = { " Accept - Encoding , Accept - Language " , " User - Agent " } ; » test Vary Header « ( » configured Values « , » response Values « , expected ) ; }
@Test { this . request . » set Request URI « ( " / mvc - showcase / data / param " ) ; this . request . » set Query String « ( " foo = 123 " ) ; String result = » Servlet Uri Components Builder « . » from Request « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / mvc - showcase / data / param « ? » foo = 123 « " ) ; }
@Test { this . request . » set Request URI « ( " / mvc - showcase / data / foo % 20 bar " ) ; String result = » Servlet Uri Components Builder « . » from Request « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / mvc - showcase / data / foo « % » 20 bar « " ) ; }
@Test { this . request . » set Server Port « ( 8080 ) ; String result = » Servlet Uri Components Builder « . » from Request « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost : 8080 / mvc - showcase « " ) ; }
@Test { this . request . » set Scheme « ( " https " ) ; this . request . » set Server Port « ( 9043 ) ; String result = » Servlet Uri Components Builder « . » from Request « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " https : » // localhost : 9043 / mvc - showcase « " ) ; }
@Test { this . request . » set Request URI « ( " / mvc - showcase / data / param " ) ; this . request . » set Query String « ( " foo = 123 " ) ; String result = » Servlet Uri Components Builder « . » from Request Uri « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / mvc - showcase / data / param « " ) ; }
@Test { this . request . » add Header « ( " X - Forwarded - Prefix " , " / " ) ; this . request . » set Context Path « ( " / mvc - showcase " ) ; this . request . » set Request URI « ( " / mvc - showcase / bar " ) ; » Http Servlet Request « » request To Use « = » adapt From Forwarded Headers « ( this . request ) ; » Uri Components « result = » Servlet Uri Components Builder « . » from Request « ( » request To Use « ) . build ( ) ; » assert That « ( result . » to Uri String « ( ) ) . » is Equal To « ( " http : » // localhost / bar « " ) ; }
@Test { this . request . » set Request URI « ( " / mvc - showcase / data / param " ) ; this . request . » set Query String « ( " foo = 123 " ) ; String result = » Servlet Uri Components Builder « . » from Context Path « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / mvc - showcase « " ) ; }
@Test { this . request . » add Header « ( " X - Forwarded - Prefix " , " / prefix " ) ; this . request . » set Context Path « ( " / mvc - showcase " ) ; this . request . » set Request URI « ( " / mvc - showcase / simple " ) ; » Http Servlet Request « » request To Use « = » adapt From Forwarded Headers « ( this . request ) ; String result = » Servlet Uri Components Builder « . » from Context Path « ( » request To Use « ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / prefix « " ) ; }
@Test { this . request . » set Request URI « ( " / mvc - showcase / app / simple " ) ; this . request . » set Servlet Path « ( " / app " ) ; this . request . » set Query String « ( " foo = 123 " ) ; String result = » Servlet Uri Components Builder « . » from Servlet Mapping « ( this . request ) . build ( ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / mvc - showcase / app « " ) ; }
@Test { this . request . » set Request URI « ( " / rest / books / 6. json " ) ; » Servlet Uri Components Builder « builder = » Servlet Uri Components Builder « . » from Request Uri « ( this . request ) ; String extension = builder . » remove Path Extension « ( ) ; String result = builder . path ( " / pages / 1. { ext } " ) . » build And Expand « ( extension ) . » to Uri String « ( ) ; » assert That « ( result ) . » is Equal To « ( " http : » // localhost / rest / books / 6 / pages / 1 . json « " ) ; }
@Test { this . request . » set Request URI « ( " / rest / books / 6 " ) ; » Servlet Uri Components Builder « builder = » Servlet Uri Components Builder « . » from Request Uri « ( this . request ) ; » assert That « ( builder . » remove Path Extension « ( ) ) . » is Null « ( ) ; }
@Test { tag . » set Value « ( " » value 1 « " ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Argument « ( ) ) . » is Equal To « ( " » value 1 « " ) ; }
@Test { int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Argument « ( ) ) . » is Null « ( ) ; }
@Test { tag . » set Value « ( null ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Argument « ( ) ) . » is Null « ( ) ; }
@Test { tag . » set Body Content « ( new » Mock Body Content « ( " » value 2 « " , new » Mock Http Servlet Response « ( ) ) ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Argument « ( ) ) . » is Equal To « ( " » value 2 « " ) ; }
@Test { tag . » set Expression « ( " bean . method ( ) " ) ; int action = tag . » do Start Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ BODY _ INCLUDE « ) ; action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( ( ( » Mock Http Servlet Response « ) context . » get Response « ( ) ) . » get Content As String « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { tag . » set Expression « ( " bean . null " ) ; int action = tag . » do Start Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ BODY _ INCLUDE « ) ; action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( ( ( » Mock Http Servlet Response « ) context . » get Response « ( ) ) . » get Content As String « ( ) ) . » is Equal To « ( " " ) ; }
@Test { tag . » set Expression « ( " bean . formattable " ) ; tag . » set Var « ( " foo " ) ; int action = tag . » do Start Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ BODY _ INCLUDE « ) ; action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( context . » get Attribute « ( " foo " ) ) . » is Equal To « ( new » Big Decimal « ( " .25 " ) ) ; }
@Test { tag . » set Expression « ( " bean . bean " ) ; tag . » set Var « ( " foo " ) ; int action = tag . » do Start Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ BODY _ INCLUDE « ) ; action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( context . » get Attribute « ( " foo " ) ) . » is Equal To « ( " not the bean object " ) ; }
@Test { tag . » set Expression « ( " bean . map . key " ) ; int action = tag . » do Start Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ BODY _ INCLUDE « ) ; action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( ( ( » Mock Http Servlet Response « ) context . » get Response « ( ) ) . » get Content As String « ( ) ) . » is Equal To « ( " value " ) ; }
@Test { » assert That « ( param . » get Name « ( ) ) . » is Null « ( ) ; » assert That « ( param . » get Value « ( ) ) . » is Null « ( ) ; }
@Test { tag . » set Name « ( " name " ) ; tag . » set Value « ( " value " ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Param « ( ) . » get Name « ( ) ) . » is Equal To « ( " name " ) ; » assert That « ( parent . » get Param « ( ) . » get Value « ( ) ) . » is Equal To « ( " value " ) ; }
@Test { tag . » set Name « ( " name " ) ; tag . » set Body Content « ( new » Mock Body Content « ( " value " , new » Mock Http Servlet Response « ( ) ) ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Param « ( ) . » get Name « ( ) ) . » is Equal To « ( " name " ) ; » assert That « ( parent . » get Param « ( ) . » get Value « ( ) ) . » is Equal To « ( " value " ) ; }
@Test { tag . » set Name « ( " name " ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Param « ( ) . » get Name « ( ) ) . » is Equal To « ( " name " ) ; » assert That « ( parent . » get Param « ( ) . » get Value « ( ) ) . » is Null « ( ) ; }
@Test { tag . » set Name « ( " name " ) ; tag . » set Value « ( null ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; » assert That « ( parent . » get Param « ( ) . » get Name « ( ) ) . » is Equal To « ( " name " ) ; » assert That « ( parent . » get Param « ( ) . » get Value « ( ) ) . » is Null « ( ) ; }
@Test { tag . » set Name « ( " name " ) ; tag . » set Value « ( " value " ) ; tag . » set Parent « ( null ) ; » assert That Exception Of Type « ( » Jsp Exception « . class ) . » is Thrown By « ( tag :: » do End Tag « ) ; }
@Test { » Page Context « pc = » create Page Context « ( ) ; » Bind Tag « tag = new » Bind Tag « ( ) ; tag . » set Page Context « ( pc ) ; tag . » set Path « ( " tb " ) ; » assert That Exception Of Type « ( » Jsp Exception « . class ) . » is Thrown By « ( tag :: » do Start Tag « ) ; }
@Test { » Page Context « pc = » create Page Context « ( ) ; » Bind Errors Tag « tag = new » Bind Errors Tag « ( ) ; tag . » set Page Context « ( pc ) ; tag . » set Name « ( " tb " ) ; » assert That « ( tag . » do Start Tag « ( ) == Tag . » SKIP _ BODY « ) . as ( " Correct » do Start Tag « return value " ) . » is True « ( ) ; }
@Test { » assert That « ( tag ) . » is Instance Of « ( » Param Aware « . class ) ; }
@Test { int action = tag . » do Start Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ BODY _ INCLUDE « ) ; }
@Test { tag . » set Value « ( " url / path " ) ; tag . » do Start Tag « ( ) ; int action = tag . » do End Tag « ( ) ; » assert That « ( action ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; }
@Test { tag . » set Value « ( " url / path " ) ; tag . » set Var « ( " var " ) ; tag . » do Start Tag « ( ) ; tag . » do End Tag « ( ) ; » assert That « ( context . » get Attribute « ( " var " , » Page Context « . » PAGE _ SCOPE « ) ) . » is Equal To « ( " url / path " ) ; }
@Test { tag . » set Value « ( " url / path " ) ; tag . » set Var « ( " var " ) ; tag . » set Scope « ( " request " ) ; tag . » do Start Tag « ( ) ; tag . » do End Tag « ( ) ; » assert That « ( context . » get Attribute « ( " var " , » Page Context « . » REQUEST _ SCOPE « ) ) . » is Equal To « ( " url / path " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( " name " ) ; param . » set Value « ( " value " ) ; params . add ( param ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " ? name = value " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( " name " ) ; param . » set Value « ( " value " ) ; params . add ( param ) ; String » query String « = tag . » create Query String « ( params , » used Params « , false ) ; » assert That « ( » query String « ) . » is Equal To « ( " & name = value " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( " name " ) ; param . » set Value « ( " " ) ; params . add ( param ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " ? name = " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( " name " ) ; param . » set Value « ( null ) ; params . add ( param ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " ? name " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( " name " ) ; param . » set Value « ( " value " ) ; params . add ( param ) ; » used Params « . add ( " name " ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( null ) ; param . » set Value « ( " value " ) ; params . add ( param ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; Param param = new Param ( ) ; param . » set Name « ( " " ) ; param . » set Value « ( " value " ) ; params . add ( param ) ; String » query String « = tag . » create Query String « ( params , » used Params « , true ) ; » assert That « ( » query String « ) . » is Equal To « ( " " ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; String uri = tag . » replace Uri Template Params « ( " url / path " , params , » used Params « ) ; » assert That « ( uri ) . » is Equal To « ( " url / path " ) ; » assert That « ( » used Params « . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { List < Param > params = new » Linked List « < > ( ) ; Set < String > » used Params « = new » Hash Set « < > ( ) ; String uri = tag . » replace Uri Template Params « ( " url / { path } " , params , » used Params « ) ; » assert That « ( uri ) . » is Equal To « ( " url / { path } " ) ; » assert That « ( » used Params « . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { tag . » set Value « ( " https : » // www . springframework . org / « " ) ; tag . » do Start Tag « ( ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " https : » // www . springframework . org / « " ) ; }
@Test { tag . » set Value « ( " url / path " ) ; tag . » do Start Tag « ( ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " url / path " ) ; }
@Test { ( ( » Mock Http Servlet Request « ) context . » get Request « ( ) ) . » set Context Path « ( " / app - context " ) ; tag . » set Value « ( " / url / path " ) ; tag . » do Start Tag « ( ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " / app - context / url / path " ) ; }
@Test { ( ( » Mock Http Servlet Request « ) context . » get Request « ( ) ) . » set Context Path « ( " / app - context " ) ; tag . » set Value « ( " / url / path " ) ; tag . » set Context « ( " some - other - context " ) ; tag . » do Start Tag « ( ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " / some - other - context / url / path " ) ; }
@Test { ( ( » Mock Http Servlet Request « ) context . » get Request « ( ) ) . » set Context Path « ( " / app - context " ) ; tag . » set Value « ( " / url / path " ) ; tag . » set Context « ( " / some - other - context " ) ; tag . » do Start Tag « ( ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " / some - other - context / url / path " ) ; }
@Test { ( ( » Mock Http Servlet Request « ) context . » get Request « ( ) ) . » set Context Path « ( " / app - context " ) ; tag . » set Value « ( " / url / path " ) ; tag . » set Context « ( " / " ) ; tag . » do Start Tag « ( ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " / url / path " ) ; }
@Test { tag . » set Value « ( " url / path ? foo = bar " ) ; tag . » do Start Tag « ( ) ; Param param = new Param ( ) ; param . » set Name « ( " name " ) ; param . » set Value « ( " value " ) ; tag . » add Param « ( param ) ; String uri = tag . » create Url « ( ) ; » assert That « ( uri ) . » is Equal To « ( " url / path ? foo = bar & name = value " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; » assert That « ( this . tag . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , » get Type « ( ) ) ; » assert Value Attribute « ( output , " Rob " ) ; }
@Test { » Bind Tag « » bind Tag « = new » Bind Tag « ( ) ; » bind Tag « . » set Path « ( " name " ) ; » bind Tag « . » set Page Context « ( » get Page Context « ( ) ) ; » bind Tag « . » do Start Tag « ( ) ; » Bind Status « » bind Status « = ( » Bind Status « ) » get Page Context « ( ) . » find Attribute « ( » Bind Tag « . » STATUS _ VARIABLE _ NAME « ) ; » assert That « ( » bind Status « . » get Value « ( ) ) . » is Equal To « ( " Rob " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; this . tag . » set Disabled « ( false ) ; this . tag . » do Start Tag « ( ) ; String output = » get Output « ( ) ; » assert Attribute Not Present « ( output , " disabled " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; this . tag . » set Readonly « ( true ) ; » assert That « ( this . tag . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , » get Type « ( ) ) ; » assert Contains Attribute « ( output , " readonly " , " readonly " ) ; » assert Value Attribute « ( output , " Rob " ) ; }
@Test { this . tag . » set Path « ( " » my Float « " ) ; this . tag . » set Dynamic Attribute « ( null , " type " , " number " ) ; » assert That « ( this . tag . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , " number " ) ; » assert Value Attribute « ( output , " 12.34 " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . tag . » set Dynamic Attribute « ( null , " type " , " radio " ) ) . » with Message « ( " Attribute type = \" radio \" is not allowed " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . tag . » set Dynamic Attribute « ( null , " type " , " checkbox " ) ) . » with Message « ( " Attribute type = \" checkbox \" is not allowed " ) ; }
@Test { this . » get Tag « ( ) . » set Path « ( " name " ) ; » assert That « ( this . » get Tag « ( ) . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , » get Type « ( ) ) ; » assert Value Attribute « ( output , " " ) ; }
@Test { this . » get Tag « ( ) . » set Path « ( " name " ) ; this . » get Password Tag « ( ) . » set Show Password « ( true ) ; » assert That « ( this . » get Tag « ( ) . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , » get Type « ( ) ) ; » assert Value Attribute « ( output , " Rob " ) ; }
@Test { this . » get Tag « ( ) . » set Path « ( " name " ) ; this . » get Password Tag « ( ) . » set Show Password « ( false ) ; » assert That « ( this . » get Tag « ( ) . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , » get Type « ( ) ) ; » assert Value Attribute « ( output , " " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » get Tag « ( ) . » set Dynamic Attribute « ( null , " type " , " email " ) ) . » with Message « ( " Attribute type = \" email \" is not allowed " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . tag . » set Dynamic Attribute « ( null , " type " , " email " ) ) . » with Message « ( " Attribute type = \" email \" is not allowed " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; » assert That Illegal Argument Exception « ( ) . as ( " null value when binding to a non - boolean " ) . » is Thrown By « ( this . tag :: » do Start Tag « ) ; }
@Test { » Int Stream « . » range Closed « ( 1 , 5 ) . » for Each « ( i -> » assert Next Id « ( ) ) ; }
@Test { this . writer . » start Tag « ( " br " ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < br / > " ) ; }
@Test { this . writer . » start Tag « ( " input " ) ; this . writer . » write Attribute « ( " type " , " text " ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < input type = \" text \" / > " ) ; }
@Test { this . writer . » start Tag « ( " textarea " ) ; this . writer . » append Value « ( " foobar " ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < textarea > foobar < / textarea > " ) ; }
@Test { this . writer . » start Tag « ( " textarea " ) ; this . writer . » write Attribute « ( " width " , " 10 " ) ; this . writer . » write Attribute « ( " height " , " 20 " ) ; this . writer . » append Value « ( " foobar " ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < textarea width = \" 10 \" height = \" 20 \" > foobar < / textarea > " ) ; }
@Test { this . writer . » start Tag « ( " span " ) ; this . writer . » write Attribute « ( " style " , " foo " ) ; this . writer . » start Tag « ( " strong " ) ; this . writer . » append Value « ( " Rob Harrop " ) ; this . writer . » end Tag « ( ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < span style = \" foo \" > < strong > Rob Harrop < / strong > < / span > " ) ; }
@Test { this . writer . » start Tag « ( " span " ) ; this . writer . » force Block « ( ) ; this . data . write ( " Rob Harrop " ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < span > Rob Harrop < / span > " ) ; }
@Test { this . writer . » start Tag « ( " span " ) ; this . writer . » append Value « ( " Rob " ) ; this . writer . » append Value « ( " Harrop " ) ; this . writer . » end Tag « ( ) ; » assert That « ( this . data . » to String « ( ) ) . » is Equal To « ( " < span > Rob Harrop < / span > " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; this . tag . » set Readonly « ( true ) ; » assert That « ( this . tag . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Contains Attribute « ( output , " name " , " name " ) ; » assert Contains Attribute « ( output , " readonly " , " readonly " ) ; » assert Block Tag Contains « ( output , " Rob " ) ; }
@Test { String onselect = " » do Select « ( ) " ; this . tag . » set Path « ( " spouse . name " ) ; this . tag . » set Onselect « ( onselect ) ; » assert That « ( this . tag . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Contains Attribute « ( output , " name " , " spouse . name " ) ; » assert Contains Attribute « ( output , " onselect " , onselect ) ; » assert Attribute Not Present « ( output , " readonly " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; this . tag . » set Readonly « ( true ) ; » assert That « ( this . tag . » do Start Tag « ( ) ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Block Tag Contains « ( output , " \r \n Rob " ) ; }
@Test { this . tag . » set Disabled « ( true ) ; this . tag . » do Start Tag « ( ) ; this . tag . » do End Tag « ( ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " disabled " , " disabled " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; » assert That Illegal Argument Exception « ( ) . as ( " null value binding to a non - boolean " ) . » is Thrown By « ( this . tag :: » do Start Tag « ) ; }
@Test { Errors errors = new » Bean Property Binding Result « ( new » Test Bean « ( ) , " » COMMAND _ NAME « " ) ; » expose Binding Result « ( errors ) ; int result = this . tag . » do Start Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; result = this . tag . » do End Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; String output = » get Output « ( ) ; » assert That « ( output . length ( ) ) . » is Equal To « ( 0 ) ; }
@Test { int result = this . tag . » do Start Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; result = this . tag . » do End Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » EVAL _ PAGE « ) ; String output = » get Output « ( ) ; » assert That « ( output . length ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » assert When No Errors Existing Messages In Scope Are Not Clobbered « ( » Page Context « . » APPLICATION _ SCOPE « ) ; }
@Test { » assert When No Errors Existing Messages In Scope Are Not Clobbered « ( » Page Context « . » SESSION _ SCOPE « ) ; }
@Test { » assert When No Errors Existing Messages In Scope Are Not Clobbered « ( » Page Context « . » PAGE _ SCOPE « ) ; }
@Test { » assert When No Errors Existing Messages In Scope Are Not Clobbered « ( » Page Context « . » REQUEST _ SCOPE « ) ; }
@Test { this . tag . » set Path « ( " name " ) ; int result = this . tag . » do Start Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Contains Attribute « ( output , " type " , " hidden " ) ; » assert Contains Attribute « ( output , " value " , " Sally Greenwood " ) ; » assert Attribute Not Present « ( output , " disabled " ) ; }
@Test { this . tag . » set Disabled « ( false ) ; this . tag . » do Start Tag « ( ) ; this . tag . » do End Tag « ( ) ; String output = » get Output « ( ) ; » assert Tag Opened « ( output ) ; » assert Tag Closed « ( output ) ; » assert Attribute Not Present « ( output , " disabled " ) ; }
@Test { this . tag . » set Path « ( " country " ) ; this . tag . » set Items « ( null ) ; this . tag . » set Item Value « ( " » iso Code « " ) ; this . tag . » set Item Label « ( " name " ) ; int result = this . tag . » do Start Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; String output = » get Output « ( ) ; » assert That « ( output ) . » is Equal To « ( " < select id = \" country \" name = \" country \" > < / select > " ) ; }
@Test { this . tag . » set Path « ( " country " ) ; this . tag . » set Items « ( Country . » get Countries « ( ) ) ; » assert List « ( true ) ; }
@Test { » Test Bean « tb = » get Test Bean « ( ) ; tb . » set Country « ( " AT " ) ; this . tag . » set Path « ( " country " ) ; this . tag . » set Items « ( Country . » get Countries « ( ) ) ; » assert List « ( false ) ; }
@Test { » Test Bean « tb = » get Test Bean « ( ) ; tb . » set Country « ( null ) ; this . tag . » set Path « ( " country " ) ; this . tag . » set Items « ( Country . » get Countries « ( ) ) ; » assert List « ( false ) ; }
@Test { this . tag . » set Path « ( " country " ) ; this . tag . » set Items « ( Country . » get Countries « ( ) ) ; this . tag . » set Item Value « ( " » iso Code « " ) ; int result = this . tag . » do Start Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; » validate Output « ( » get Output « ( ) , true ) ; }
@Test { this . tag . » set Path « ( " sex " ) ; this . tag . » set Items « ( » get Sexes « ( ) ) ; int result = this . tag . » do Start Tag « ( ) ; » assert That « ( result ) . » is Equal To « ( Tag . » SKIP _ BODY « ) ; }
@Test { this . tag . » set Path « ( " country " ) ; this . tag . » set Items « ( new » Test Bean « ( ) ) ; this . tag . » set Item Value « ( " » iso Code « " ) ; » assert That Exception Of Type « ( » Jsp Exception « . class ) . as ( " use a non - Collection typed value as the value of 'items' " ) . » is Thrown By « ( this . tag :: » do Start Tag « ) . » with Message Containing « ( " items " ) . » with Message Containing « ( " org . springframework . beans . testfixture . beans . » Test Bean « " ) ; }
@Test { this . tag . » set Path « ( " name " ) ; this . tag . » set Items « ( » get Names « ( ) ) ; » assert String Array « ( ) ; }
@Test { tag . » set Model Attribute « ( null ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( tag :: » do Start Tag « ) ; }
@Test { this . tag . » set Method « ( " get " ) ; this . tag . » do Start Tag « ( ) ; this . tag . » do End Tag « ( ) ; this . tag . » do Finally « ( ) ; String output = » get Output « ( ) ; String » form Output « = » get Form Tag « ( output ) ; String » input Output « = » get Input Tag « ( output ) ; » assert Contains Attribute « ( » form Output « , " method " , " get " ) ; » assert That « ( » input Output « ) . » is Equal To « ( " " ) ; }
@Test { this . tag . » set Method « ( " post " ) ; this . tag . » do Start Tag « ( ) ; this . tag . » do End Tag « ( ) ; this . tag . » do Finally « ( ) ; String output = » get Output « ( ) ; String » form Output « = » get Form Tag « ( output ) ; String » input Output « = » get Input Tag « ( output ) ; » assert Contains Attribute « ( » form Output « , " method " , " post " ) ; » assert That « ( » input Output « ) . » is Equal To « ( " " ) ; }
@Test { this . request . » set Request URI « ( " / a b c " ) ; request . » set Query String « ( " " ) ; this . tag . » do Start Tag « ( ) ; this . tag . » do End Tag « ( ) ; this . tag . » do Finally « ( ) ; String output = » get Output « ( ) ; String » form Output « = » get Form Tag « ( output ) ; » assert Contains Attribute « ( » form Output « , " action " , " / a % 20 b % 20 c " ) ; }
@Test { this . tag . » set Parent « ( null ) ; this . tag . » set Value « ( " foo " ) ; this . tag . » set Label « ( " Foo " ) ; » assert That Illegal State Exception « ( ) . as ( " not be able to use < option > tag without exposed context " ) . » is Thrown By « ( tag :: » do Start Tag « ) ; }
@Test { tag . » set Parent « ( null ) ; tag . » set Value « ( " foo " ) ; » assert That Illegal State Exception « ( ) . as ( " when not nested within a < select / > tag " ) . » is Thrown By « ( tag :: » do Start Tag « ) ; }
@Test { » internal Test « ( new » Fixed Theme Resolver « ( ) , false , » Abstract Theme Resolver « . » ORIGINAL _ DEFAULT _ THEME _ NAME « ) ; }
@Test { » internal Test « ( new » Cookie Theme Resolver « ( ) , true , » Abstract Theme Resolver « . » ORIGINAL _ DEFAULT _ THEME _ NAME « ) ; }
@Test { » internal Test « ( new » Session Theme Resolver « ( ) , true , » Abstract Theme Resolver « . » ORIGINAL _ DEFAULT _ THEME _ NAME « ) ; }
@Test { » Session Theme Resolver « tr = new » Session Theme Resolver « ( ) ; tr . » set Default Theme Name « ( » DEFAULT _ TEST _ THEME _ NAME « ) ; » internal Test « ( tr , true , » DEFAULT _ TEST _ THEME _ NAME « ) ; }
@Test { request . » add Header « ( " Accept " , " application " ) ; » View Resolver « » view Resolver Mock « = mock ( » View Resolver « . class ) ; » view Resolver « . » set View Resolvers « ( Collections . » singleton List « ( » view Resolver Mock « ) ) ; » view Resolver « . » after Properties Set « ( ) ; View result = » view Resolver « . » resolve View Name « ( " test " , Locale . ENGLISH ) ; » assert That « ( result ) . » is Null « ( ) ; }
@Test { » Redirect View « rv = new » Redirect View « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( rv :: » after Properties Set « ) ; }
@Test { » Redirect View « rv = new » Redirect View « ( ) ; rv . » set Url « ( " https : » // url . somewhere . com « " ) ; rv . » set Http 10 Compatible « ( false ) ; rv . render ( new » Hash Map « < > ( ) , request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 303 ) ; » assert That « ( response . » get Header « ( " Location " ) ) . » is Equal To « ( " https : » // url . somewhere . com « " ) ; }
@Test { » Redirect View « rv = new » Redirect View « ( ) ; rv . » set Url « ( " https : » // url . somewhere . com « " ) ; rv . » set Status Code « ( » Http Status « . » MOVED _ PERMANENTLY « ) ; rv . render ( new » Hash Map « < > ( ) , request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 301 ) ; » assert That « ( response . » get Header « ( " Location " ) ) . » is Equal To « ( " https : » // url . somewhere . com « " ) ; }
@Test { » Redirect View « rv = new » Redirect View « ( ) ; rv . » set Url « ( " https : » // url . somewhere . com « " ) ; request . » set Attribute « ( View . » RESPONSE _ STATUS _ ATTRIBUTE « , » Http Status « . CREATED ) ; rv . render ( new » Hash Map « < > ( ) , request , response ) ; » assert That « ( response . » get Status « ( ) ) . » is Equal To « ( 201 ) ; » assert That « ( response . » get Header « ( " Location " ) ) . » is Equal To « ( " https : » // url . somewhere . com « " ) ; }
@Test { String url = " / » my Url « " ; this . request . » set Context Path « ( " » // context « " ) ; this . response = new » Mock Http Servlet Response « ( ) ; » do Test « ( new » Hash Map « < > ( ) , url , true , " / context " + url ) ; this . request . » set Context Path « ( " » /// context « " ) ; this . response = new » Mock Http Servlet Response « ( ) ; » do Test « ( new » Hash Map « < > ( ) , url , true , " / context " + url ) ; }
@Test { String url = " / » my Url « " ; » do Test « ( new » Hash Map « < > ( ) , url , false , url ) ; }
@Test { String url = " / » my Url « " ; » do Test « ( new » Hash Map « < > ( ) , url , true , " / context " + url ) ; }
@Test { String url = " https : » // url . somewhere . com « " ; String key = " foo " ; String val = " bar " ; Map < String , String > model = new » Hash Map « < > ( ) ; model . put ( key , val ) ; String » expected Url For Encoding « = url + " ? " + key + " = " + val ; » do Test « ( model , url , false , » expected Url For Encoding « ) ; }
@Test { String url = " https : » // url . somewhere . com « " ; Map < String , String > model = Collections . » singleton Map « ( " foo " , " bar " ) ; » Test Redirect View « rv = new » Test Redirect View « ( url , false , model ) ; rv . » set Expose Model Attributes « ( false ) ; rv . render ( model , request , response ) ; » assert That « ( this . response . » get Redirected Url « ( ) ) . » is Equal To « ( url ) ; }
@Test { String url = " https : » // url . somewhere . com / test . htm « # » my Anchor « " ; String key = " foo " ; String val = " bar " ; Map < String , String > model = new » Hash Map « < > ( ) ; model . put ( key , val ) ; String » expected Url For Encoding « = " https : » // url . somewhere . com / test . htm « " + " ? " + key + " = " + val + " # » my Anchor « " ; » do Test « ( model , url , false , » expected Url For Encoding « ) ; }
@Test { String url = " / test . html ? id = 1 " ; » do Test « ( new » Hash Map « < > ( ) , url , true , " / context " + url ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , " bar " ) ; String » base Url « = " https : » // url . somewhere . com « " ; » Redirect View « » redirect View « = new » Redirect View « ( » base Url « + " / { foo } " ) ; » redirect View « . » render Merged Output Model « ( model , this . request , this . response ) ; » assert That « ( this . response . » get Redirected Url « ( ) ) . » is Equal To « ( ( » base Url « + " / bar " ) ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , new Long ( 611 ) ) ; » Redirect View « » redirect View « = new » Redirect View « ( " / foo / { foo } " ) ; » redirect View « . » render Merged Output Model « ( model , this . request , this . response ) ; » assert That « ( this . response . » get Redirected Url « ( ) ) . » is Equal To « ( " / foo / 611 " ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Redirect View « ( " / { foo } " ) . » render Merged Output Model « ( new » Model Map « ( ) , this . request , this . response ) ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; » Redirect View « » redirect View « = new » Redirect View « ( " " ) ; » redirect View « . » render Merged Output Model « ( model , this . request , this . response ) ; » assert That « ( this . response . » get Redirected Url « ( ) ) . » is Equal To « ( " " ) ; }
@Test { String url = " » / test « # { » ' one « ' , » ' abc « ' } " ; » Redirect View « » redirect View « = new » Redirect View « ( url , true ) ; » redirect View « . » set Expand Uri Template Variables « ( false ) ; » redirect View « . » render Merged Output Model « ( new » Model Map « ( ) , this . request , this . response ) ; » assert That « ( this . response . » get Redirected Url « ( ) ) . » is Equal To « ( url ) ; }
@Test { » assert That Exception Of Type « ( » Bean Is Abstract Exception « . class ) . » is Thrown By « ( ( ) -> rb . » resolve View Name « ( " debug . Parent " , Locale . ENGLISH ) ) ; » assert That Exception Of Type « ( » Bean Is Abstract Exception « . class ) . » is Thrown By « ( ( ) -> rb . » resolve View Name « ( " » test Parent « " , Locale . ENGLISH ) ) ; }
@Test { » assume True « ( rb . » is Cache « ( ) ) ; View » v 1 « = rb . » resolve View Name « ( " » debug View « " , Locale . ENGLISH ) ; View » v 2 « = rb . » resolve View Name « ( " » debug View « " , Locale . UK ) ; » assert That « ( » v 2 « ) . » is Same As « ( » v 1 « ) ; }
@Test { » assert That « ( ( Object ) rb . » resolve View Name « ( " xxxxxxweorqiwuopeir " , Locale . ENGLISH ) ) . » is Null « ( ) ; }
@Test { rb . » set Basename « ( " weoriwoierqupowiuer " ) ; » assert That Exception Of Type « ( » Missing Resource Exception « . class ) . » is Thrown By « ( ( ) -> rb . » resolve View Name « ( " » debug View « " , Locale . ENGLISH ) ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( view :: » after Properties Set « ) ; }
@Test { given ( request . » get Attribute « ( View . » PATH _ VARIABLES « ) ) . » will Return « ( null ) ; given ( request . » get Request Dispatcher « ( url ) ) . » will Return « ( new » Mock Request Dispatcher « ( url ) ) ; view . » set Url « ( url ) ; view . » set Always Include « ( true ) ; view . render ( model , request , response ) ; » assert That « ( response . » get Included Url « ( ) ) . » is Equal To « ( url ) ; model . » for Each « ( ( key , value ) -> verify ( request ) . » set Attribute « ( key , value ) ) ; }
@Test { » Abstract View « v = new » Concrete View « ( ) ; v . » set Attributes « ( null ) ; » assert That « ( v . » get Static Attributes « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Abstract View « v = new » Concrete View « ( ) ; v . » set Attributes CSV « ( null ) ; » assert That « ( v . » get Static Attributes « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Abstract View « v = new » Concrete View « ( ) ; v . » set Attributes CSV « ( " " ) ; » assert That « ( v . » get Static Attributes « ( ) . size ( ) ) . » is Equal To « ( 0 ) ; }
@Test { » Abstract View « v = new » Concrete View « ( ) ; v . » set Attributes CSV « ( " foo = [ bar ] , king = [ kong ] " ) ; » assert That « ( v . » get Static Attributes « ( ) . size ( ) == 2 ) . » is True « ( ) ; » assert That « ( v . » get Static Attributes « ( ) . get ( " foo " ) . equals ( " bar " ) ) . » is True « ( ) ; » assert That « ( v . » get Static Attributes « ( ) . get ( " king " ) . equals ( " kong " ) ) . » is True « ( ) ; }
@Test { » Abstract View « v = new » Concrete View « ( ) ; v . » set Attributes CSV « ( " foo = [ de ] , " ) ; » assert That « ( v . » get Static Attributes « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + " / " + » VIEW _ NAME « + " / " ) ; this . translator . » set Strip Leading Slash « ( false ) ; » assert View Name « ( " / " + » VIEW _ NAME « ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + " / " + » VIEW _ NAME « + " / " ) ; this . translator . » set Strip Trailing Slash « ( false ) ; » assert View Name « ( » VIEW _ NAME « + " / " ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + " / " + » VIEW _ NAME « + EXTENSION ) ; this . translator . » set Strip Extension « ( false ) ; » assert View Name « ( » VIEW _ NAME « + EXTENSION ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « + EXTENSION ) ; » assert View Name « ( » VIEW _ NAME « ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « + " / fiona " + EXTENSION ) ; this . translator . » set Separator « ( " _ " ) ; » assert View Name « ( » VIEW _ NAME « + " » _ fiona « " ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « ) ; » assert View Name « ( » VIEW _ NAME « ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « + " ; a = A ; b = B " ) ; » assert View Name « ( » VIEW _ NAME « ) ; }
@Test { final String prefix = " » fiona _ « " ; request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « ) ; this . translator . » set Prefix « ( prefix ) ; » assert View Name « ( prefix + » VIEW _ NAME « ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « ) ; this . translator . » set Prefix « ( null ) ; » assert View Name « ( » VIEW _ NAME « ) ; }
@Test { final String suffix = " . fiona " ; request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « ) ; this . translator . » set Suffix « ( suffix ) ; » assert View Name « ( » VIEW _ NAME « + suffix ) ; }
@Test { request . » set Request URI « ( » CONTEXT _ PATH « + » VIEW _ NAME « ) ; this . translator . » set Suffix « ( null ) ; » assert View Name « ( » VIEW _ NAME « ) ; }
@Test { try { this . translator . » set Url Path Helper « ( null ) ; } catch ( » Illegal Argument Exception « expected ) { } }
@Test { » Url Based View Resolver « vr = new » Url Based View Resolver « ( ) ; vr . » set View Class « ( » Jstl View « . class ) ; » do Test Url Based View Resolver Without Prefixes « ( vr ) ; }
@Test { » Url Based View Resolver « vr = new » Url Based View Resolver « ( ) ; vr . » set View Class « ( » Jstl View « . class ) ; » do Test Url Based View Resolver With Prefixes « ( vr ) ; }
@Test { » do Test Url Based View Resolver Without Prefixes « ( new » Internal Resource View Resolver « ( ) ) ; }
@Test { » do Test Url Based View Resolver With Prefixes « ( new » Internal Resource View Resolver « ( ) ) ; }
@Test { » Free Marker View « fv = new » Free Marker View « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> fv . » after Properties Set « ( ) ) . » with Message Containing « ( " url " ) ; }
@Test { » assert That « ( » get Macro Output « ( " NAME " ) ) . » is Equal To « ( " Darren " ) ; }
@Test { » assert That « ( » get Macro Output « ( " AGE " ) ) . » is Equal To « ( " 99 " ) ; }
@Test { » assert That « ( » get Macro Output « ( " MESSAGE " ) ) . » is Equal To « ( " Howdy Mundo " ) ; }
@Test { » assert That « ( » get Macro Output « ( " DEFAULTMESSAGE " ) ) . » is Equal To « ( " hi planet " ) ; }
@Test { » assert That « ( » get Macro Output « ( " MESSAGEARGS " ) ) . » is Equal To « ( " Howdy [ World ] " ) ; }
@Test { » assert That « ( » get Macro Output « ( " MESSAGEARGSWITHDEFAULTMESSAGE " ) ) . » is Equal To « ( " Hi " ) ; }
@Test { » assert That « ( » get Macro Output « ( " THEME " ) ) . » is Equal To « ( " Howdy ! Mundo ! " ) ; }
@Test { » assert That « ( » get Macro Output « ( " DEFAULTTHEME " ) ) . » is Equal To « ( " hi ! planet ! " ) ; }
@Test { » assert That « ( » get Macro Output « ( " THEMEARGS " ) ) . » is Equal To « ( " Howdy ! [ World ] " ) ; }
@Test { » assert That « ( » get Macro Output « ( " THEMEARGSWITHDEFAULTMESSAGE " ) ) . » is Equal To « ( " Hi ! " ) ; }
@Test { » assert That « ( » get Macro Output « ( " URL " ) ) . » is Equal To « ( " / springtest / aftercontext . html " ) ; }
@Test { » assert That « ( » get Macro Output « ( " URLPARAMS " ) ) . » is Equal To « ( " / springtest / aftercontext / bar ? spam = bucket " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 1 « " ) ) . » is Equal To « ( " < input type = \" text \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 2 « " ) ) . » is Equal To « ( " < input type = \" text \" id = \" name \" name = \" name \" value = \" Darren \" class = \" » my Css Class « \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 3 « " ) ) . » is Equal To « ( " < textarea id = \" name \" name = \" name \" > \n Darren < / textarea > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 4 « " ) ) . » is Equal To « ( " < textarea id = \" name \" name = \" name \" rows = 10 cols = 30 > \n Darren < / textarea > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 9 « " ) ) . » is Equal To « ( " < input type = \" password \" id = \" name \" name = \" name \" value = \" \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 10 « " ) ) . » is Equal To « ( " < input type = \" hidden \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 11 « " ) ) . » is Equal To « ( " < input type = \" text \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 12 « " ) ) . » is Equal To « ( " < input type = \" hidden \" id = \" name \" name = \" name \" value = \" Darren \" > " ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 13 « " ) ) . » is Equal To « ( " < input type = \" password \" id = \" name \" name = \" name \" value = \" \" > " ) ; }
@Test { String output = » get Macro Output « ( " » FORM 15 « " ) ; » assert That « ( output . » starts With « ( " < input type = \" hidden \" name = \" » _ name « \" value = \" on \" / > " ) ) . as ( " Wrong output : " + output ) . » is True « ( ) ; » assert That « ( output . contains ( " < input type = \" checkbox \" id = \" name \" name = \" name \" / > " ) ) . as ( " Wrong output : " + output ) . » is True « ( ) ; }
@Test { String output = » get Macro Output « ( " » FORM 16 « " ) ; » assert That « ( output . » starts With « ( " < input type = \" hidden \" name = \" » _ jedi « \" value = \" on \" / > " ) ) . as ( " Wrong output : " + output ) . » is True « ( ) ; » assert That « ( output . contains ( " < input type = \" checkbox \" id = \" jedi \" name = \" jedi \" checked = \" checked \" / > " ) ) . as ( " Wrong output : " + output ) . » is True « ( ) ; }
@Test { » assert That « ( » get Macro Output « ( " » FORM 17 « " ) ) . » is Equal To « ( " < input type = \" text \" id = \" » spouses 0 « . name \" name = \" spouses [ 0 ] . name \" value = \" Fred \" > " ) ; }
@Test { String output = » get Macro Output « ( " » FORM 18 « " ) ; » assert That « ( output . » starts With « ( " < input type = \" hidden \" name = \" » _ spouses « [ 0 ] . jedi \" value = \" on \" / > " ) ) . as ( " Wrong output : " + output ) . » is True « ( ) ; » assert That « ( output . contains ( " < input type = \" checkbox \" id = \" » spouses 0 « . jedi \" name = \" spouses [ 0 ] . jedi \" checked = \" checked \" / > " ) ) . as ( " Wrong output : " + output ) . » is True « ( ) ; }
@Test { this . configurer . » set Application Context « ( this . » application Context « ) ; this . configurer . » set Template Engine « ( new » Test Template Engine « ( ) ) ; this . configurer . » after Properties Set « ( ) ; » Template Engine « engine = this . configurer . » get Template Engine « ( ) ; » assert That « ( engine ) . » is Not Null « ( ) ; » assert That « ( engine . » get Class « ( ) ) . » is Equal To « ( » Test Template Engine « . class ) ; }
@Test { URL url = this . configurer . » resolve Template « ( » get Class « ( ) . » get Class Loader « ( ) , » TEMPLATE _ PREFIX « + " test . tpl " ) ; » assert That « ( url ) . » is Not Null « ( ) ; }
@Test { » Locale Context Holder « . » set Locale « ( Locale . GERMANY ) ; URL url = this . configurer . » resolve Template « ( » get Class « ( ) . » get Class Loader « ( ) , » TEMPLATE _ PREFIX « + " » i 18 n « . tpl " ) ; » assert That « ( url ) . » is Not Null « ( ) ; » assert That « ( url . » get Path « ( ) ) . contains ( " » i 18 n _ de _ DE « . tpl " ) ; }
@Test { » Locale Context Holder « . » set Locale « ( Locale . FRANCE ) ; URL url = this . configurer . » resolve Template « ( » get Class « ( ) . » get Class Loader « ( ) , » TEMPLATE _ PREFIX « + " » i 18 n « . tpl " ) ; » assert That « ( url ) . » is Not Null « ( ) ; » assert That « ( url . » get Path « ( ) ) . contains ( " » i 18 n _ fr « . tpl " ) ; }
@Test { » Locale Context Holder « . » set Locale « ( Locale . US ) ; URL url = this . configurer . » resolve Template « ( » get Class « ( ) . » get Class Loader « ( ) , » TEMPLATE _ PREFIX « + " » i 18 n « . tpl " ) ; » assert That « ( url ) . » is Not Null « ( ) ; » assert That « ( url . » get Path « ( ) ) . contains ( " » i 18 n « . tpl " ) ; }
@Test { » Locale Context Holder « . » set Locale « ( Locale . US ) ; » assert That IO Exception « ( ) . » is Thrown By « ( ( ) -> this . configurer . » resolve Template « ( » get Class « ( ) . » get Class Loader « ( ) , » TEMPLATE _ PREFIX « + " missing . tpl " ) ) ; }
@Test { » Groovy Markup View Resolver « resolver = new » Groovy Markup View Resolver « ( ) ; » assert That « ( resolver . » required View Class « ( ) ) . » is Equal To « ( » Groovy Markup View « . class ) ; » Direct Field Accessor « » view Accessor « = new » Direct Field Accessor « ( resolver ) ; Class < ? > » view Class « = ( Class < ? > ) » view Accessor « . » get Property Value « ( " » view Class « " ) ; » assert That « ( » view Class « ) . » is Equal To « ( » Groovy Markup View « . class ) ; }
@Test { » Groovy Markup View Resolver « resolver = new » Groovy Markup View Resolver « ( ) ; String » cache Key « = ( String ) resolver . » get Cache Key « ( " test " , Locale . US ) ; » assert That « ( » cache Key « ) . » is Not Null « ( ) ; » assert That « ( » cache Key « ) . » is Equal To « ( " » test _ en _ US « " ) ; }
@Test { » Groovy Markup View « view = new » Groovy Markup View « ( ) ; given ( this . » web App Context « . » get Beans Of Type « ( » Groovy Markup Config « . class , true , false ) ) . » will Return « ( new » Hash Map « < > ( ) ) ; view . » set Url « ( " » sample View « " ) ; » assert That Exception Of Type « ( » Application Context Exception « . class ) . » is Thrown By « ( ( ) -> view . » set Application Context « ( this . » web App Context « ) ) . » with Message Containing « ( " » Groovy Markup Config « " ) ; }
@Test { » Groovy Markup View « view = new » Groovy Markup View « ( ) ; view . » set Template Engine « ( new » Test Template Engine « ( ) ) ; view . » set Application Context « ( this . » web App Context « ) ; » Direct Field Accessor « accessor = new » Direct Field Accessor « ( view ) ; » Template Engine « engine = ( » Template Engine « ) accessor . » get Property Value « ( " engine " ) ; » assert That « ( engine ) . » is Not Null « ( ) ; » assert That « ( engine . » get Class « ( ) ) . » is Equal To « ( » Test Template Engine « . class ) ; }
@Test { » Groovy Markup View « view = » create View With Url « ( " test . tpl " ) ; » assert That « ( view . » check Resource « ( Locale . US ) ) . » is True « ( ) ; }
@Test { » Groovy Markup View « view = » create View With Url « ( " missing . tpl " ) ; » assert That « ( view . » check Resource « ( Locale . US ) ) . » is False « ( ) ; }
@Test { » Groovy Markup View « view = » create View With Url « ( " » i 18 n « . tpl " ) ; » assert That « ( view . » check Resource « ( Locale . FRENCH ) ) . » is True « ( ) ; }
@Test { » Groovy Markup View « view = » create View With Url « ( " » i 18 n « . tpl " ) ; » assert That « ( view . » check Resource « ( Locale . CHINESE ) ) . » is True « ( ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " name " , " Spring " ) ; » Mock Http Servlet Response « response = » render View With Model « ( " test . tpl " , model , Locale . US ) ; » assert That « ( response . » get Content As String « ( ) ) . contains ( " < » h 1 « > Hello Spring < / » h 1 « > " ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; » Mock Http Servlet Response « response = » render View With Model « ( " content . tpl " , model , Locale . US ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " < html > < head > < title > Layout example < / title > < / head > < body > < p > This is the body < / p > < / body > < / html > " ) ; }
@Test { » assert That « ( view . » is Expose Path Variables « ( ) ) . as ( " Must not expose path variables " ) . » is Equal To « ( false ) ; }
@Test { view . » set Disable Caching « ( false ) ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " » binding Result « " , mock ( » Binding Result « . class , " » binding _ result « " ) ) ; model . put ( " foo " , " bar " ) ; view . render ( model , request , response ) ; » assert That « ( ( Object ) response . » get Header « ( " Cache - Control " ) ) . » is Null « ( ) ; }
@Test { view . » set Prefix Json « ( true ) ; » render Simple Map « ( ) ; }
@Test { » Model Map « model = new » Model Map « ( " foo " , new » Test Bean Simple « ( ) ) ; view . » set Pretty Print « ( true ) ; view . render ( model , request , response ) ; String result = response . » get Content As String « ( ) . replace ( " \r \n " , " \n " ) ; » assert That « ( result . » starts With « ( " { \n \" foo \" : { \n " ) ) . as ( " Pretty printing not applied : \n " + result ) . » is True « ( ) ; » validate Result « ( ) ; }
@Test { view . » set Prefix Json « ( true ) ; » render Simple Bean « ( ) ; » assert That « ( response . » get Content As String « ( ) . » starts With « ( " ) ] } ' , " ) ) . » is True « ( ) ; }
@Test { view . » set Prefix Json « ( false ) ; » render Simple Bean « ( ) ; » assert That « ( response . » get Content As String « ( ) . » starts With « ( " ) ] } ' , " ) ) . » is False « ( ) ; }
@Test { Object bean = new » Test Bean Simple Annotated « ( ) ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , bean ) ; view . render ( model , request , response ) ; » assert That « ( response . » get Content As String « ( ) . length ( ) > 0 ) . » is True « ( ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " { \" foo \" : { \" » test Bean Simple « \" : \" custom \" } } " ) ; » validate Result « ( ) ; }
@Test { view . » set Extract Value From Single Key Model « ( true ) ; Map < String , Object > model = new » Hash Map « < > ( ) ; » Test Bean Simple « bean = new » Test Bean Simple « ( ) ; model . put ( " foo " , bean ) ; Object actual = view . » filter Model « ( model ) ; » assert That « ( actual ) . » is Same As « ( bean ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , " Foo " ) ; String url = " org / springframework / web / servlet / view / script / kotlin / template . kts " ; » Mock Http Servlet Response « response = render ( url , model , Locale . FRENCH , » Script Templating Configuration « . class ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " < html > < body > \n < p > Bonjour Foo < / p > \n < / body > < / html > " ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , " Foo " ) ; String url = " org / springframework / web / servlet / view / script / kotlin / template . kts " ; » Mock Http Servlet Response « response = render ( url , model , Locale . ENGLISH , » Script Templating Configuration « . class ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( " < html > < body > \n < p > Hello Foo < / p > \n < / body > < / html > " ) ; }
@Test { String url = " org / springframework / web / servlet / view / script / nashorn / template . html " ; » Mock Http Servlet Response « response = render ( url , null , » Script Templating With Url Configuration « . class ) ; » assert That « ( response . » get Content As String « ( ) ) . » is Equal To « ( ( " < html > < head > < title > Check url parameter < / title > < / head > < body > < p > " + url + " < / p > < / body > < / html > " ) ) ; }
@Test { this . view . » set Engine « ( mock ( » Script Engine « . class ) ) ; this . view . » set Application Context « ( this . wac ) ; }
@Test { this . view . » set Engine « ( mock ( » Script Engine « . class ) ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . wac ) ) ; }
@Test { this . view . » set Engine « ( mock ( » Invocable Script Engine « . class ) ) ; this . view . » set Engine Name « ( " test " ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . wac ) ) . » with Message Containing « ( " You should define either 'engine' , 'engineSupplier' or 'engineName' . " ) ; }
@Test { » Script Engine « engine = mock ( » Invocable Script Engine « . class ) ; this . view . » set Engine Supplier « ( ( ) -> engine ) ; this . view . » set Engine « ( engine ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . wac ) ) . » with Message Containing « ( " You should define either 'engine' , 'engineSupplier' or 'engineName' . " ) ; }
@Test { this . view . » set Engine Supplier « ( ( ) -> mock ( » Invocable Script Engine « . class ) ) ; this . view . » set Engine Name « ( " test " ) ; this . view . » set Render Function « ( " render " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . wac ) ) . » with Message Containing « ( " You should define either 'engine' , 'engineSupplier' or 'engineName' . " ) ; }
@Test { this . view . » set Engine « ( mock ( » Invocable Script Engine « . class ) ) ; this . view . » set Render Function « ( " render " ) ; this . view . » set Shared Engine « ( false ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . view . » set Application Context « ( this . wac ) ) . » with Message Containing « ( " » shared Engine « " ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " » model Attribute « " , " » model Value « " ) ; view . render ( model , request , response ) ; » assert That « ( request . » get Attribute « ( " » model Attribute « " ) ) . » is Equal To « ( " » model Value « " ) ; verify ( renderer ) . render ( eq ( » VIEW _ PATH « ) , » is A « ( Request . class ) ) ; }
@Test { view . render ( new » Hash Map « < > ( ) , request , response ) ; » assert That « ( request . » get Attribute « ( » Abstract Request « . » FORCE _ INCLUDE _ ATTRIBUTE _ NAME « ) ) . » is Null « ( ) ; }
@Test { view . » set Always Include « ( true ) ; view . render ( new » Hash Map « < > ( ) , request , response ) ; » assert That « ( ( boolean ) ( Boolean ) request . » get Attribute « ( » Abstract Request « . » FORCE _ INCLUDE _ ATTRIBUTE _ NAME « ) ) . » is True « ( ) ; }
@Test { view . » set Disable Caching « ( false ) ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " » binding Result « " , mock ( » Binding Result « . class , " » binding _ result « " ) ) ; model . put ( " foo " , " bar " ) ; view . render ( model , request , response ) ; » assert That « ( response . » get Header « ( " Cache - Control " ) ) . » is Null « ( ) ; }
@Test { Object bean = new » Test Bean Simple Annotated « ( ) ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " foo " , bean ) ; view . render ( model , request , response ) ; » assert That « ( response . » get Content As String « ( ) . length ( ) > 0 ) . » is True « ( ) ; » assert That « ( response . » get Content As String « ( ) . contains ( " < » test Bean Simple « > custom < / » test Bean Simple « > " ) ) . » is True « ( ) ; » validate Result « ( ) ; }
@Test { Map < String , Object > model = new » Tree Map « < > ( ) ; model . put ( " foo " , " foo " ) ; model . put ( " bar " , " bar " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> view . render ( model , request , response ) ) ; }
@Test { » assert That « ( view . » get Content Type « ( ) ) . as ( " Invalid content type " ) . » is Equal To « ( " application / xml " ) ; }
@Test { » assert That « ( new » Marshalling View « ( ) . » is Expose Path Variables « ( ) ) . as ( " Must not expose path variables " ) . » is Equal To « ( false ) ; }
@Test { String » model Key « = " key " ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( » model Key « , null ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> view . render ( model , request , response ) ) ; » assert That « ( response . » get Content Length « ( ) ) . as ( " Invalid content length " ) . » is Equal To « ( 0 ) ; }
@Test { Object » to Be Marshalled « = new Object ( ) ; String » model Key « = " key " ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( » model Key « , » to Be Marshalled « ) ; » Mock Http Servlet Request « request = new » Mock Http Servlet Request « ( ) ; » Mock Http Servlet Response « response = new » Mock Http Servlet Response « ( ) ; given ( » marshaller Mock « . supports ( Object . class ) ) . » will Return « ( false ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> view . render ( model , request , response ) ) ; }
@Test { final » Xslt View « view = » get Xslt View « ( » HTML _ OUTPUT « ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> view . render ( » empty Map « ( ) , request , response ) ) ; }
@Test { final » Xslt View « view = new » Xslt View « ( ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( view :: » after Properties Set « ) ; }
@Test { Source source = new » Stream Source « ( » get Product Data Resource « ( ) . » get Input Stream « ( ) ) ; » do Test With Model « ( » singleton Map « ( " » some Key « " , source ) ) ; }
@Test { org . » w 3 c « . dom . Document document = » get Dom Document « ( ) ; » do Test With Model « ( » singleton Map « ( " » some Key « " , document ) ) ; }
@Test { org . » w 3 c « . dom . Document document = » get Dom Document « ( ) ; » do Test With Model « ( » singleton Map « ( " » some Key « " , document . » get Document Element « ( ) ) ) ; }
@Test { » do Test With Model « ( » singleton Map « ( " » some Key « " , » get Product Data Resource « ( ) . » get Input Stream « ( ) ) ) ; }
@Test { » do Test With Model « ( » singleton Map « ( " » some Key « " , new » Input Stream Reader « ( » get Product Data Resource « ( ) . » get Input Stream « ( ) ) ) ) ; }
@Test { » do Test With Model « ( » singleton Map « ( " » some Key « " , » get Product Data Resource « ( ) ) ) ; }
@Test { » Xslt View « view = » get Xslt View « ( » HTML _ OUTPUT « ) ; view . » set Source Key « ( " » actual Data « " ) ; Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " » actual Data « " , » get Product Data Resource « ( ) ) ; model . put ( " » other Data « " , new » Class Path Resource « ( " » dummy Data « . xsl " , » get Class « ( ) ) ) ; view . render ( model , this . request , this . response ) ; » assert Html Output « ( this . response . » get Content As String « ( ) ) ; }
@Test { » Xslt View « view = » get Xslt View « ( » HTML _ OUTPUT « ) ; Source source = new » Stream Source « ( » get Product Data Resource « ( ) . » get Input Stream « ( ) ) ; view . render ( » singleton Map « ( " » some Key « " , source ) , this . request , this . response ) ; » assert That « ( this . response . » get Content Type « ( ) . » starts With « ( " text / html " ) ) . » is True « ( ) ; » assert That « ( this . response . » get Character Encoding « ( ) ) . » is Equal To « ( " UTF - 8 " ) ; }
@Test { Map < String , Object > model = new » Hash Map « < > ( ) ; model . put ( " » some Key « " , » get Product Data Resource « ( ) ) ; model . put ( " title " , " Product List " ) ; » do Test With Model « ( model ) ; » assert That « ( this . response . » get Content As String « ( ) . contains ( " Product List " ) ) . » is True « ( ) ; }
@Test { » Nested Servlet Exception « exception = new » Nested Servlet Exception « ( " foo " ) ; » assert That « ( exception . » get Message « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { Throwable cause = new » Runtime Exception « ( ) ; » Nested Servlet Exception « exception = new » Nested Servlet Exception « ( " foo " , cause ) ; » assert That « ( exception . » get Message « ( ) ) . » is Equal To « ( » Nested Exception Utils « . » build Message « ( " foo " , cause ) ) ; » assert That « ( exception . » get Cause « ( ) ) . » is Equal To « ( cause ) ; }
@Test { » Nested Servlet Exception « exception = new » Nested Servlet Exception « ( " foo " , null ) ; » assert That « ( exception . » get Message « ( ) ) . » is Equal To « ( " foo " ) ; }
@Test { String expected = " foo , bar " ; » Text Message « actual = new » Text Message « ( expected ) ; » assert That « ( actual . » get Payload « ( ) ) . » is Equal To « ( expected ) ; » assert That « ( actual . » to String « ( ) ) . contains ( expected ) ; }
@Test { String expected = " あいうえお " ; » Text Message « actual = new » Text Message « ( expected ) ; » assert That « ( actual . » get Payload « ( ) ) . » is Equal To « ( expected ) ; » assert That « ( actual . » to String « ( ) ) . contains ( expected ) ; }
@Test { List < » Web Socket Extension « > extensions = » Web Socket Extension « . » parse Extensions « ( " x - foo - extension , x - bar - extension " ) ; » assert That « ( extensions . stream ( ) . map ( » Web Socket Extension « :: » get Name « ) ) . » contains Exactly « ( " x - foo - extension " , " x - bar - extension " ) ; }
@Test { this . adapter . » on Web Socket Connect « ( this . session ) ; verify ( this . » web Socket Handler « ) . » after Connection Established « ( this . » web Socket Session « ) ; }
@Test { this . adapter . » on Web Socket Close « ( 1000 , " reason " ) ; verify ( this . » web Socket Handler « ) . » after Connection Closed « ( this . » web Socket Session « , » Close Status « . NORMAL . » with Reason « ( " reason " ) ) ; }
@Test { Exception exception = new Exception ( ) ; this . adapter . » on Web Socket Error « ( exception ) ; verify ( this . » web Socket Handler « ) . » handle Transport Error « ( this . » web Socket Session « , exception ) ; }
@Test { » Test Principal « user = new » Test Principal « ( " joe " ) ; » Jetty Web Socket Session « session = new » Jetty Web Socket Session « ( attributes , user ) ; » assert That « ( session . » get Principal « ( ) ) . » is Same As « ( user ) ; }
@Test { this . adapter . » on Close « ( this . session , new » Close Reason « ( » Close Codes « . » NORMAL _ CLOSURE « , " reason " ) ) ; verify ( this . » web Socket Handler « ) . » after Connection Closed « ( this . » web Socket Session « , » Close Status « . NORMAL . » with Reason « ( " reason " ) ) ; }
@Test { Exception exception = new Exception ( ) ; this . adapter . » on Error « ( this . session , exception ) ; verify ( this . » web Socket Handler « ) . » handle Transport Error « ( this . » web Socket Session « , exception ) ; }
@Test { » Test Principal « user = new » Test Principal « ( " joe " ) ; » Standard Web Socket Session « session = new » Standard Web Socket Session « ( this . headers , this . attributes , null , null , user ) ; » assert That « ( session . » get Principal « ( ) ) . » is Same As « ( user ) ; }
@Test { » Test Principal « user = new » Test Principal « ( " joe " ) ; Session » native Session « = Mockito . mock ( Session . class ) ; given ( » native Session « . » get User Principal « ( ) ) . » will Return « ( user ) ; » Standard Web Socket Session « session = new » Standard Web Socket Session « ( this . headers , this . attributes , null , null ) ; session . » initialize Native Session « ( » native Session « ) ; » assert That « ( session . » get Principal « ( ) ) . » is Same As « ( user ) ; }
@Test { Session » native Session « = Mockito . mock ( Session . class ) ; given ( » native Session « . » get User Principal « ( ) ) . » will Return « ( null ) ; » Standard Web Socket Session « session = new » Standard Web Socket Session « ( this . headers , this . attributes , null , null ) ; session . » initialize Native Session « ( » native Session « ) ; reset ( » native Session « ) ; » assert That « ( session . » get Principal « ( ) ) . » is Null « ( ) ; » verify No More Interactions « ( » native Session « ) ; }
@Test { String protocol = " foo " ; Session » native Session « = Mockito . mock ( Session . class ) ; given ( » native Session « . » get Negotiated Subprotocol « ( ) ) . » will Return « ( protocol ) ; » Standard Web Socket Session « session = new » Standard Web Socket Session « ( this . headers , this . attributes , null , null ) ; session . » initialize Native Session « ( » native Session « ) ; reset ( » native Session « ) ; » assert That « ( session . » get Accepted Protocol « ( ) ) . » is Equal To « ( protocol ) ; » verify No More Interactions « ( » native Session « ) ; }
@Test { » assert That « ( new » My Text Encoder « ( ) . encode ( » my Type « ) ) . » is Equal To « ( » CONVERTED _ TEXT « ) ; }
@Test { setup ( » No Converters Config « . class ) ; » assert That Exception Of Type « ( » Encode Exception « . class ) . » is Thrown By « ( ( ) -> new » My Text Encoder « ( ) . encode ( » my Type « ) ) . » with Cause Instance Of « ( » Converter Not Found Exception « . class ) ; }
@Test { » assert That « ( new » My Binary Encoder « ( ) . encode ( » my Type « ) . array ( ) ) . » is Equal To « ( » CONVERTED _ BYTES « . array ( ) ) ; }
@Test { setup ( » No Converters Config « . class ) ; » assert That Exception Of Type « ( » Encode Exception « . class ) . » is Thrown By « ( ( ) -> new » My Binary Encoder « ( ) . encode ( » my Type « ) ) . » with Cause Instance Of « ( » Converter Not Found Exception « . class ) ; }
@Test { Decoder . Text < » My Type « > decoder = new » My Text Decoder « ( ) ; » assert That « ( decoder . » will Decode « ( » CONVERTED _ TEXT « ) ) . » is True « ( ) ; » assert That « ( decoder . decode ( » CONVERTED _ TEXT « ) ) . » is Equal To « ( » my Type « ) ; }
@Test { setup ( » No Converters Config « . class ) ; Decoder . Text < » My Type « > decoder = new » My Text Decoder « ( ) ; » assert That « ( decoder . » will Decode « ( » CONVERTED _ TEXT « ) ) . » is False « ( ) ; » assert That Exception Of Type « ( » Decode Exception « . class ) . » is Thrown By « ( ( ) -> decoder . decode ( » CONVERTED _ TEXT « ) ) . » with Cause Instance Of « ( » Converter Not Found Exception « . class ) ; }
@Test { Decoder . Binary < » My Type « > decoder = new » My Binary Decoder « ( ) ; » assert That « ( decoder . » will Decode « ( » CONVERTED _ BYTES « ) ) . » is True « ( ) ; » assert That « ( decoder . decode ( » CONVERTED _ BYTES « ) ) . » is Equal To « ( » my Type « ) ; }
@Test { setup ( » No Converters Config « . class ) ; Decoder . Binary < » My Type « > decoder = new » My Binary Decoder « ( ) ; » assert That « ( decoder . » will Decode « ( » CONVERTED _ BYTES « ) ) . » is False « ( ) ; » assert That Exception Of Type « ( » Decode Exception « . class ) . » is Thrown By « ( ( ) -> decoder . decode ( » CONVERTED _ BYTES « ) ) . » with Cause Instance Of « ( » Converter Not Found Exception « . class ) ; }
@Test { » My Text Encoder Decoder « » encoder Decoder « = new » My Text Encoder Decoder « ( ) ; String encoded = » encoder Decoder « . encode ( » my Type « ) ; » assert That « ( » encoder Decoder « . decode ( encoded ) ) . » is Equal To « ( » my Type « ) ; }
@Test { » My Binary Encoder Decoder « » encoder Decoder « = new » My Binary Encoder Decoder « ( ) ; » Byte Buffer « encoded = » encoder Decoder « . encode ( » my Type « ) ; » assert That « ( » encoder Decoder « . decode ( encoded ) ) . » is Equal To « ( » my Type « ) ; }
@Test { » With Autowire « » with Autowire « = new » With Autowire « ( ) ; » with Autowire « . init ( null ) ; » assert That « ( » with Autowire « . config ) . » is Equal To « ( » application Context « . » get Bean « ( Config . class ) ) ; }
@Test { » Context Loader Test Utils « . » set Current Web Application Context « ( null ) ; » With Autowire « encoder = new » With Autowire « ( ) ; encoder . init ( null ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> encoder . encode ( » my Type « ) ) . » with Message Containing « ( " Unable to locate the Spring » Application Context « " ) ; }
@Test { setup ( » No Config « . class ) ; » My Binary Encoder « encoder = new » My Binary Encoder « ( ) ; encoder . init ( null ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> encoder . encode ( » my Type « ) ) . » with Message Containing « ( " Unable to find » Conversion Service « " ) ; }
@Test { » Test Lifecycle Web Socket Client « client = new » Test Lifecycle Web Socket Client « ( false ) ; » Web Socket Handler « handler = new » Text Web Socket Handler « ( ) ; » Web Socket Connection Manager « manager = new » Web Socket Connection Manager « ( client , handler , " / a " ) ; manager . » start Internal « ( ) ; » assert That « ( client . » is Running « ( ) ) . » is True « ( ) ; manager . » stop Internal « ( ) ; » assert That « ( client . » is Running « ( ) ) . » is False « ( ) ; }
@Test { URI uri = new URI ( " ws : » // localhost / abc « " ) ; » Web Socket Session « session = this . » ws Client « . » do Handshake « ( this . » ws Handler « , this . headers , uri ) . get ( ) ; » assert That « ( session . » get Local Address « ( ) ) . » is Not Null « ( ) ; » assert That « ( session . » get Local Address « ( ) . » get Port « ( ) ) . » is Equal To « ( 80 ) ; }
@Test { URI uri = new URI ( " wss : » // localhost / abc « " ) ; » Web Socket Session « session = this . » ws Client « . » do Handshake « ( this . » ws Handler « , this . headers , uri ) . get ( ) ; » assert That « ( session . » get Local Address « ( ) ) . » is Not Null « ( ) ; » assert That « ( session . » get Local Address « ( ) . » get Port « ( ) ) . » is Equal To « ( 443 ) ; }
@Test { URI uri = new URI ( " localhost / abc " ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . » ws Client « . » do Handshake « ( this . » ws Handler « , this . headers , uri ) ) ; }
@Test { URI uri = new URI ( " wss : » // localhost / abc « " ) ; » Web Socket Session « session = this . » ws Client « . » do Handshake « ( this . » ws Handler « , this . headers , uri ) . get ( ) ; » assert That « ( session . » get Remote Address « ( ) ) . » is Not Null « ( ) ; » assert That « ( session . » get Remote Address « ( ) . » get Host Name « ( ) ) . » is Equal To « ( " localhost " ) ; » assert That « ( session . » get Local Address « ( ) . » get Port « ( ) ) . » is Equal To « ( 443 ) ; }
@Test { URI uri = new URI ( " ws : » // localhost / abc « " ) ; this . » ws Client « . » set Task Executor « ( new » Simple Async Task Executor « ( ) ) ; » Web Socket Session « session = this . » ws Client « . » do Handshake « ( this . » ws Handler « , this . headers , uri ) . get ( ) ; » assert That « ( session ) . » is Not Null « ( ) ; }
@Test { » load Bean Definitions « ( " websocket - config - broker - customchannels - default - executor . xml " ) ; » test Executor « ( " » client Inbound Channel « " , Runtime . » get Runtime « ( ) . » available Processors « ( ) * 2 , Integer . » MAX _ VALUE « , 60 ) ; » test Executor « ( " » client Outbound Channel « " , Runtime . » get Runtime « ( ) . » available Processors « ( ) * 2 , Integer . » MAX _ VALUE « , 60 ) ; » assert That « ( this . » app Context « . » contains Bean « ( " » broker Channel Executor « " ) ) . » is False « ( ) ; }
@Test { » Bean Creating Handler Provider « < » Simple Echo Handler « > provider = new » Bean Creating Handler Provider « < > ( » Simple Echo Handler « . class ) ; » assert That « ( provider . » get Handler « ( ) ) . » is Not Null « ( ) ; }
@Test { @ » Suppress Warnings « ( " resource " ) » Configurable Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; » Bean Creating Handler Provider « < » Echo Handler « > provider = new » Bean Creating Handler Provider « < > ( » Echo Handler « . class ) ; provider . » set Bean Factory « ( context . » get Bean Factory « ( ) ) ; » assert That « ( provider . » get Handler « ( ) ) . » is Not Null « ( ) ; }
@Test { » Bean Creating Handler Provider « < » Echo Handler « > provider = new » Bean Creating Handler Provider « < > ( » Echo Handler « . class ) ; » assert That Exception Of Type « ( » Bean Instantiation Exception « . class ) . » is Thrown By « ( provider :: » get Handler « ) ; }
@Test { » will Throw « ( new » Illegal State Exception « ( " error " ) ) . given ( this . delegate ) . » after Connection Established « ( this . session ) ; this . decorator . » after Connection Established « ( this . session ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Equal To « ( » Close Status « . » SERVER _ ERROR « ) ; }
@Test { » Text Message « message = new » Text Message « ( " payload " ) ; » will Throw « ( new » Illegal State Exception « ( " error " ) ) . given ( this . delegate ) . » handle Message « ( this . session , message ) ; this . decorator . » handle Message « ( this . session , message ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Equal To « ( » Close Status « . » SERVER _ ERROR « ) ; }
@Test { Exception exception = new Exception ( " transport error " ) ; » will Throw « ( new » Illegal State Exception « ( " error " ) ) . given ( this . delegate ) . » handle Transport Error « ( this . session , exception ) ; this . decorator . » handle Transport Error « ( this . session , exception ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Equal To « ( » Close Status « . » SERVER _ ERROR « ) ; }
@Test { » Close Status « » close Status « = » Close Status « . NORMAL ; » will Throw « ( new » Illegal State Exception « ( " error " ) ) . given ( this . delegate ) . » after Connection Closed « ( this . session , » close Status « ) ; this . decorator . » after Connection Closed « ( this . session , » close Status « ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Null « ( ) ; }
@Test { » Abstract Web Socket Handler « » h 1 « = new » Abstract Web Socket Handler « ( ) { } ; » Web Socket Handler Decorator « » h 2 « = new » Web Socket Handler Decorator « ( » h 1 « ) ; » Web Socket Handler Decorator « » h 3 « = new » Web Socket Handler Decorator « ( » h 2 « ) ; » assert That « ( » h 3 « . » get Last Handler « ( ) ) . » is Same As « ( » h 1 « ) ; }
@Test { List < String > extensions = new » Array List « < > ( ) ; extensions . add ( " x - foo - extension , x - bar - extension " ) ; extensions . add ( " x - test - extension " ) ; this . headers . put ( » Web Socket Http Headers « . » SEC _ WEBSOCKET _ EXTENSIONS « , extensions ) ; List < » Web Socket Extension « > » parsed Extensions « = this . headers . » get Sec Web Socket Extensions « ( ) ; » assert That « ( » parsed Extensions « ) . » has Size « ( 3 ) ; }
@Test { connect ( ) ; » Illegal State Exception « » handshake Failure « = new » Illegal State Exception « ( " simulated exception " ) ; this . » handshake Future « . » set Exception « ( » handshake Failure « ) ; verify ( this . » stomp Session « ) . » after Connect Failure « ( same ( » handshake Failure « ) ) ; }
@Test { connect ( ) . » after Connection Established « ( this . » web Socket Session « ) ; verify ( this . » stomp Session « ) . » after Connected « ( » not Null « ( ) ) ; }
@Test { » Illegal State Exception « exception = new » Illegal State Exception « ( " simulated exception " ) ; connect ( ) . » handle Transport Error « ( this . » web Socket Session « , exception ) ; verify ( this . » stomp Session « ) . » handle Failure « ( same ( exception ) ) ; }
@Test { connect ( ) . » after Connection Closed « ( this . » web Socket Session « , » Close Status « . NORMAL ) ; verify ( this . » stomp Session « ) . » after Connection Closed « ( ) ; }
@Test { connect ( ) . » handle Message « ( this . » web Socket Session « , new » Pong Message « ( ) ) ; » verify No More Interactions « ( this . » stomp Session « ) ; }
@Test { » Web Socket Stomp Client « » stomp Client « = new » Web Socket Stomp Client « ( mock ( » Web Socket Client « . class ) ) ; » assert That « ( » stomp Client « . » get Default Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 0 , 0 } ) ; » Stomp Headers « » connect Headers « = » stomp Client « . » process Connect Headers « ( null ) ; » assert That « ( » connect Headers « . » get Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 0 , 0 } ) ; }
@Test { » Web Socket Stomp Client « » stomp Client « = new » Web Socket Stomp Client « ( mock ( » Web Socket Client « . class ) ) ; » stomp Client « . » set Task Scheduler « ( mock ( » Task Scheduler « . class ) ) ; » assert That « ( » stomp Client « . » get Default Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 10000 , 10000 } ) ; » Stomp Headers « » connect Headers « = » stomp Client « . » process Connect Headers « ( null ) ; » assert That « ( » connect Headers « . » get Heartbeat « ( ) ) . » is Equal To « ( new long [ ] { 10000 , 10000 } ) ; }
@Test { » Web Socket Stomp Client « » stomp Client « = new » Web Socket Stomp Client « ( mock ( » Web Socket Client « . class ) ) ; » stomp Client « . » set Default Heartbeat « ( new long [ ] { 5 , 5 } ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> » stomp Client « . » process Connect Headers « ( null ) ) ; }
@Test { » Tcp Connection « < byte [ ] > » tcp Connection « = » get Tcp Connection « ( ) ; Runnable runnable = mock ( Runnable . class ) ; long delay = 2 ; » tcp Connection « . » on Read Inactivity « ( runnable , delay ) ; » test Inactivity Task Scheduling « ( runnable , delay , 10 ) ; }
@Test { » Tcp Connection « < byte [ ] > » tcp Connection « = » get Tcp Connection « ( ) ; Runnable runnable = mock ( Runnable . class ) ; long delay = 10000 ; » tcp Connection « . » on Read Inactivity « ( runnable , delay ) ; » test Inactivity Task Scheduling « ( runnable , delay , 0 ) ; }
@Test { » Tcp Connection « < byte [ ] > » tcp Connection « = » get Tcp Connection « ( ) ; Runnable runnable = mock ( Runnable . class ) ; long delay = 2 ; » tcp Connection « . » on Write Inactivity « ( runnable , delay ) ; » test Inactivity Task Scheduling « ( runnable , delay , 10 ) ; }
@Test { » Tcp Connection « < byte [ ] > » tcp Connection « = » get Tcp Connection « ( ) ; Runnable runnable = mock ( Runnable . class ) ; long delay = 1000 ; » tcp Connection « . » on Write Inactivity « ( runnable , delay ) ; » test Inactivity Task Scheduling « ( runnable , delay , 0 ) ; }
@Test { this . » web Socket Handler « . » set Default Protocol Handler « ( » stomp Handler « ) ; this . session . » set Accepted Protocol « ( " » v 12 « . » s To Mp « " ) ; this . » web Socket Handler « . » after Connection Established « ( session ) ; verify ( this . » stomp Handler « ) . » after Session Started « ( » is A « ( » Concurrent Web Socket Session Decorator « . class ) , eq ( this . » in Client Channel « ) ) ; }
@Test { this . » web Socket Handler « . » set Default Protocol Handler « ( » default Handler « ) ; this . » web Socket Handler « . » set Protocol Handlers « ( Arrays . » as List « ( » stomp Handler « , » mqtt Handler « ) ) ; this . session . » set Accepted Protocol « ( " wamp " ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » web Socket Handler « . » after Connection Established « ( session ) ) ; }
@Test { this . » web Socket Handler « . » set Default Protocol Handler « ( » default Handler « ) ; this . » web Socket Handler « . » after Connection Established « ( session ) ; verify ( this . » default Handler « ) . » after Session Started « ( » is A « ( » Concurrent Web Socket Session Decorator « . class ) , eq ( this . » in Client Channel « ) ) ; verify ( this . » stomp Handler « , times ( 0 ) ) . » after Session Started « ( session , this . » in Client Channel « ) ; verify ( this . » mqtt Handler « , times ( 0 ) ) . » after Session Started « ( session , this . » in Client Channel « ) ; }
@Test { this . » web Socket Handler « . » set Protocol Handlers « ( Arrays . » as List « ( » stomp Handler « ) ) ; this . » web Socket Handler « . » after Connection Established « ( session ) ; verify ( this . » stomp Handler « ) . » after Session Started « ( » is A « ( » Concurrent Web Socket Session Decorator « . class ) , eq ( this . » in Client Channel « ) ) ; }
@Test { this . » web Socket Handler « . » set Protocol Handlers « ( Arrays . » as List « ( » stomp Handler « , » mqtt Handler « ) ) ; » assert That Illegal State Exception « ( ) . » is Thrown By « ( ( ) -> this . » web Socket Handler « . » after Connection Established « ( session ) ) ; }
@Test { » Default Simp User Registry « registry = new » Default Simp User Registry « ( ) ; » Test Principal « user = new » Test Principal « ( " joe " ) ; Message < byte [ ] > message = » create Message « ( » Simp Message Type « . » CONNECT _ ACK « , " 123 " ) ; » Session Connected Event « event = new » Session Connected Event « ( this , message , user ) ; registry . » on Application Event « ( event ) ; » Simp User « » simp User « = registry . » get User « ( " joe " ) ; » assert That « ( » simp User « . » get Session « ( null ) ) . » is Null « ( ) ; }
@Test { String url = " ws : » // 127 . 0 . 0 . 1 « : " + this . server . » get Port « ( ) + " / stomp " ; » Test Handler « » test Handler « = new » Test Handler « ( " / topic / foo " , " payload " ) ; this . » stomp Client « . connect ( url , » test Handler « ) ; » assert That « ( » test Handler « . » await For Message Count « ( 1 , 5000 ) ) . » is True « ( ) ; » assert That « ( » test Handler « . » get Received « ( ) ) . » contains Exactly « ( " payload " ) ; }
@Test { » Per Connection Echo Endpoint « endpoint = this . configurator . » get Endpoint Instance « ( » Per Connection Echo Endpoint « . class ) ; » assert That « ( endpoint ) . » is Not Null « ( ) ; }
@Test { » Echo Endpoint « expected = this . » web App Context « . » get Bean « ( » Echo Endpoint « . class ) ; » Echo Endpoint « actual = this . configurator . » get Endpoint Instance « ( » Echo Endpoint « . class ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { » Component Echo Endpoint « expected = this . » web App Context « . » get Bean « ( » Component Echo Endpoint « . class ) ; » Component Echo Endpoint « actual = this . configurator . » get Endpoint Instance « ( » Component Echo Endpoint « . class ) ; » assert That « ( actual ) . » is Same As « ( expected ) ; }
@Test { this . exporter . » set Annotated Endpoint Classes « ( » Annotated Dummy Endpoint « . class ) ; this . exporter . » set Application Context « ( this . » web App Context « ) ; this . exporter . » after Properties Set « ( ) ; this . exporter . » after Singletons Instantiated « ( ) ; verify ( this . » server Container « ) . » add Endpoint « ( » Annotated Dummy Endpoint « . class ) ; verify ( this . » server Container « ) . » add Endpoint « ( » Annotated Dummy Endpoint Bean « . class ) ; }
@Test { this . exporter . » set Annotated Endpoint Classes « ( » Annotated Dummy Endpoint « . class , » Annotated Dummy Endpoint Bean « . class ) ; this . exporter . » set Servlet Context « ( this . » servlet Context « ) ; this . exporter . » after Properties Set « ( ) ; this . exporter . » after Singletons Instantiated « ( ) ; verify ( this . » server Container « ) . » add Endpoint « ( » Annotated Dummy Endpoint « . class ) ; verify ( this . » server Container « ) . » add Endpoint « ( » Annotated Dummy Endpoint Bean « . class ) ; }
@Test { this . exporter . » set Annotated Endpoint Classes « ( » Annotated Dummy Endpoint « . class , » Annotated Dummy Endpoint Bean « . class ) ; this . exporter . » set Server Container « ( this . » server Container « ) ; this . exporter . » after Properties Set « ( ) ; this . exporter . » after Singletons Instantiated « ( ) ; verify ( this . » server Container « ) . » add Endpoint « ( » Annotated Dummy Endpoint « . class ) ; verify ( this . » server Container « ) . » add Endpoint « ( » Annotated Dummy Endpoint Bean « . class ) ; }
@Test { » Server Endpoint Registration « » endpoint Registration « = new » Server Endpoint Registration « ( " / dummy " , new » Dummy Endpoint « ( ) ) ; this . » web App Context « . » get Bean Factory « ( ) . » register Singleton « ( " » dummy Endpoint « " , » endpoint Registration « ) ; this . exporter . » set Application Context « ( this . » web App Context « ) ; this . exporter . » after Properties Set « ( ) ; this . exporter . » after Singletons Instantiated « ( ) ; verify ( this . » server Container « ) . » add Endpoint « ( » endpoint Registration « ) ; }
@Test { » Server Endpoint Registration « » endpoint Registration « = new » Server Endpoint Registration « ( " / dummy " , new » Dummy Endpoint « ( ) ) ; this . » web App Context « . » get Bean Factory « ( ) . » register Singleton « ( " » dummy Endpoint « " , » endpoint Registration « ) ; this . exporter . » set Servlet Context « ( this . » servlet Context « ) ; this . exporter . » set Application Context « ( this . » web App Context « ) ; this . exporter . » after Properties Set « ( ) ; this . exporter . » after Singletons Instantiated « ( ) ; verify ( this . » server Container « ) . » add Endpoint « ( » endpoint Registration « ) ; }
@Test { @ » Suppress Warnings « ( " resource " ) » Configurable Application Context « context = new » Annotation Config Application Context « ( Config . class ) ; » Server Endpoint Registration « registration = new » Server Endpoint Registration « ( " / path " , » Echo Endpoint « . class ) ; registration . » set Bean Factory « ( context . » get Bean Factory « ( ) ) ; » Echo Endpoint « endpoint = registration . » get Configurator « ( ) . » get Endpoint Instance « ( » Echo Endpoint « . class ) ; » assert That « ( endpoint ) . » is Not Null « ( ) ; }
@Test { » Echo Endpoint « endpoint = new » Echo Endpoint « ( new » Echo Service « ( ) ) ; » Server Endpoint Registration « registration = new » Server Endpoint Registration « ( " / path " , endpoint ) ; » Echo Endpoint « actual = registration . » get Configurator « ( ) . » get Endpoint Instance « ( » Echo Endpoint « . class ) ; » assert That « ( actual ) . » is Same As « ( endpoint ) ; }
@Test { » Handshake Interceptor Chain « chain = new » Handshake Interceptor Chain « ( interceptors , » ws Handler « ) ; chain . » apply After Handshake « ( request , response , null ) ; » verify No More Interactions « ( » i 1 « , » i 2 « , » i 3 « ) ; }
@Test { » Http Session Handshake Interceptor « interceptor = new » Http Session Handshake Interceptor « ( ) ; interceptor . » before Handshake « ( this . request , this . response , » ws Handler « , attributes ) ; » assert That « ( this . » servlet Request « . » get Session « ( false ) ) . » is Null « ( ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Origin Handshake Interceptor « ( null ) ) ; }
@Test { this . » servlet Request « . » add Header « ( » Http Headers « . ORIGIN , " https : » // mydomain 1 . example « " ) ; List < String > allowed = Collections . » singleton List « ( " https : » // mydomain 1 . example « " ) ; » Origin Handshake Interceptor « interceptor = new » Origin Handshake Interceptor « ( allowed ) ; » assert That « ( interceptor . » before Handshake « ( request , response , » ws Handler « , attributes ) ) . » is True « ( ) ; » assert That « ( » Http Status « . FORBIDDEN . value ( ) ) . » is Not Equal To « ( ( long ) » servlet Response « . » get Status « ( ) ) ; }
@Test { this . » servlet Request « . » add Header « ( » Http Headers « . ORIGIN , " https : » // mydomain 1 . example « " ) ; List < String > allowed = Collections . » singleton List « ( " https : » // mydomain 2 . example « " ) ; » Origin Handshake Interceptor « interceptor = new » Origin Handshake Interceptor « ( allowed ) ; » assert That « ( interceptor . » before Handshake « ( request , response , » ws Handler « , attributes ) ) . » is False « ( ) ; » assert That « ( » Http Status « . FORBIDDEN . value ( ) ) . » is Equal To « ( » servlet Response « . » get Status « ( ) ) ; }
@Test { this . » servlet Request « . » add Header « ( » Http Headers « . ORIGIN , " https : » // mydomain 1 . example « " ) ; » Origin Handshake Interceptor « interceptor = new » Origin Handshake Interceptor « ( ) ; interceptor . » set Allowed Origins « ( Collections . » singleton List « ( " * " ) ) ; » assert That « ( interceptor . » before Handshake « ( request , response , » ws Handler « , attributes ) ) . » is True « ( ) ; » assert That « ( » Http Status « . FORBIDDEN . value ( ) ) . » is Not Equal To « ( ( long ) » servlet Response « . » get Status « ( ) ) ; }
@Test { this . » servlet Request « . » add Header « ( » Http Headers « . ORIGIN , " http : » // mydomain 3 . example « " ) ; this . » servlet Request « . » set Server Name « ( " » mydomain 2 « . example " ) ; » Origin Handshake Interceptor « interceptor = new » Origin Handshake Interceptor « ( Collections . » empty List « ( ) ) ; » assert That « ( interceptor . » before Handshake « ( request , response , » ws Handler « , attributes ) ) . » is False « ( ) ; » assert That « ( » Http Status « . FORBIDDEN . value ( ) ) . » is Equal To « ( » servlet Response « . » get Status « ( ) ) ; }
@Test { » Test Interceptor « interceptor = new » Test Interceptor « ( true ) ; this . » request Handler « . » set Handshake Interceptors « ( Collections . » singleton List « ( interceptor ) ) ; this . » request Handler « . » handle Request « ( new » Mock Http Servlet Request « ( ) , this . response ) ; verify ( this . » handshake Handler « ) . » do Handshake « ( any ( ) , any ( ) , any ( ) , any ( ) ) ; » assert That « ( this . response . » get Header « ( " » header Name « " ) ) . » is Equal To « ( " » header Value « " ) ; }
@Test { » Test Interceptor « interceptor = new » Test Interceptor « ( false ) ; this . » request Handler « . » set Handshake Interceptors « ( Collections . » singleton List « ( interceptor ) ) ; this . » request Handler « . » handle Request « ( new » Mock Http Servlet Request « ( ) , this . response ) ; » verify No More Interactions « ( this . » handshake Handler « ) ; » assert That « ( this . response . » get Header « ( " » header Name « " ) ) . » is Equal To « ( " » header Value « " ) ; }
@Test { » Test Xhr Transport « transport = new » Test Xhr Transport « ( ) ; transport . » info Response To Return « = new » Response Entity « < > ( " body " , » Http Status « . OK ) ; » assert That « ( transport . » execute Info Request « ( new URI ( " https : » // example . com / info « " ) , null ) ) . » is Equal To « ( " body " ) ; }
@Test { » Test Xhr Transport « transport = new » Test Xhr Transport « ( ) ; transport . » info Response To Return « = new » Response Entity « < > ( " body " , » Http Status « . » BAD _ REQUEST « ) ; » assert That Exception Of Type « ( » Http Server Error Exception « . class ) . » is Thrown By « ( ( ) -> transport . » execute Info Request « ( new URI ( " https : » // example . com / info « " ) , null ) ) ; }
@Test { » Test Xhr Transport « transport = new » Test Xhr Transport « ( ) ; transport . » send Message Response To Return « = new » Response Entity « < > ( » Http Status « . » BAD _ REQUEST « ) ; URI url = new URI ( " https : » // example . com « " ) ; » assert That Exception Of Type « ( » Http Server Error Exception « . class ) . » is Thrown By « ( ( ) -> transport . » execute Send Request « ( url , new » Http Headers « ( ) , new » Text Message « ( " payload " ) ) ) ; }
@Test { » test Echo « ( 100 , » create Web Socket Transport « ( ) , null ) ; }
@Test { » test Echo « ( 100 , » create Xhr Transport « ( ) , null ) ; }
@Test { » Abstract Xhr Transport « » xhr Transport « = » create Xhr Transport « ( ) ; » xhr Transport « . » set Xhr Streaming Disabled « ( true ) ; » test Echo « ( 100 , » xhr Transport « , null ) ; }
@Test { » test Receive One Message « ( » create Web Socket Transport « ( ) , null ) ; }
@Test { » test Receive One Message « ( » create Xhr Transport « ( ) , null ) ; }
@Test { » Abstract Xhr Transport « » xhr Transport « = » create Xhr Transport « ( ) ; » xhr Transport « . » set Xhr Streaming Disabled « ( true ) ; » test Receive One Message « ( » xhr Transport « , null ) ; }
@Test { » Default Transport Request « request = » create Transport Request « ( this . » web Socket Transport « , » Transport Type « . WEBSOCKET ) ; request . connect ( null , this . » connect Future « ) ; » Web Socket Session « session = mock ( » Web Socket Session « . class ) ; this . » web Socket Transport « . » get Connect Callback « ( ) . » on Success « ( session ) ; » assert That « ( this . » connect Future « . get ( ) ) . » is Same As « ( session ) ; }
@Test { » setup Info Request « ( true ) ; this . » sock Js Client « . » do Handshake « ( handler , URL ) . » add Callback « ( this . » connect Callback « ) ; » assert That « ( this . » web Socket Transport « . invoked ( ) ) . » is True « ( ) ; » Web Socket Session « session = mock ( » Web Socket Session « . class ) ; this . » web Socket Transport « . » get Connect Callback « ( ) . » on Success « ( session ) ; verify ( this . » connect Callback « ) . » on Success « ( session ) ; » verify No More Interactions « ( this . » connect Callback « ) ; }
@Test { » setup Info Request « ( false ) ; this . » sock Js Client « . » do Handshake « ( handler , URL ) ; » assert That « ( this . » web Socket Transport « . invoked ( ) ) . » is False « ( ) ; » assert That « ( this . » xhr Transport « . invoked ( ) ) . » is True « ( ) ; » assert That « ( this . » xhr Transport « . » get Request « ( ) . » get Transport Url « ( ) . » to String « ( ) . » ends With « ( " » xhr _ streaming « " ) ) . » is True « ( ) ; }
@Test { » setup Info Request « ( true ) ; this . » sock Js Client « . » do Handshake « ( handler , URL ) ; verify ( this . » info Receiver « , times ( 1 ) ) . » execute Info Request « ( any ( ) , any ( ) ) ; }
@Test { » setup Info Request « ( true ) ; this . » sock Js Client « . » do Handshake « ( handler , URL ) ; this . » sock Js Client « . » do Handshake « ( handler , URL ) ; this . » sock Js Client « . » do Handshake « ( handler , URL ) ; verify ( this . » info Receiver « , times ( 1 ) ) . » execute Info Request « ( any ( ) , any ( ) ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; » assert That « ( this . session . » is Open « ( ) ) . » is True « ( ) ; this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; » assert That « ( this . session . » disconnect Status « ) . » is Equal To « ( new » Close Status « ( 1006 , " Server lost session " ) ) ; }
@Test { » will Throw « ( new » Illegal State Exception « ( " Fake error " ) ) . given ( this . handler ) . » after Connection Established « ( this . session ) ; this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; » assert That « ( this . session . » is Open « ( ) ) . » is True « ( ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; this . session . close ( ) ; reset ( this . handler ) ; this . session . » handle Frame « ( » Sock Js Frame « . » message Frame « ( CODEC , " foo " , " bar " ) . » get Content « ( ) ) ; » verify No More Interactions « ( this . handler ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; this . session . » handle Frame « ( " a [ » ' bad « data " ) ; » assert That « ( this . session . » is Open « ( ) ) . » is Equal To « ( false ) ; » assert That « ( this . session . » disconnect Status « ) . » is Equal To « ( » Close Status « . » BAD _ DATA « ) ; verify ( this . handler ) . » after Connection Established « ( this . session ) ; » verify No More Interactions « ( this . handler ) ; }
@Test { final » Illegal State Exception « ex = new » Illegal State Exception « ( " Fake error " ) ; this . session . » handle Transport Error « ( ex ) ; verify ( this . handler ) . » handle Transport Error « ( this . session , ex ) ; » verify No More Interactions « ( this . handler ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; this . session . » after Transport Closed « ( » Close Status « . » SERVER _ ERROR « ) ; » assert That « ( this . session . » is Open « ( ) ) . » is Equal To « ( false ) ; verify ( this . handler ) . » after Connection Established « ( this . session ) ; verify ( this . handler ) . » after Connection Closed « ( this . session , » Close Status « . » SERVER _ ERROR « ) ; » verify No More Interactions « ( this . handler ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; this . session . close ( ) ; » assert That « ( this . session . » is Open « ( ) ) . » is Equal To « ( false ) ; » assert That « ( this . session . » disconnect Status « ) . » is Equal To « ( » Close Status « . NORMAL ) ; verify ( this . handler ) . » after Connection Established « ( this . session ) ; » verify No More Interactions « ( this . handler ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; this . session . close ( new » Close Status « ( 3000 , " reason " ) ) ; » assert That « ( this . session . » disconnect Status « ) . » is Equal To « ( new » Close Status « ( 3000 , " reason " ) ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . session . close ( null ) ) . » with Message Containing « ( " Invalid close status " ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . session . close ( new » Close Status « ( 2999 , " reason " ) ) ) . » with Message Containing « ( " Invalid close status " ) ; }
@Test { this . session . » get Timeout Task « ( ) . run ( ) ; » assert That « ( this . session . » disconnect Status « ) . » is Equal To « ( new » Close Status « ( 2007 , " Transport timed out " ) ) ; }
@Test { this . session . » handle Frame « ( » Sock Js Frame « . » open Frame « ( ) . » get Content « ( ) ) ; this . session . » send Message « ( new » Text Message « ( " foo " ) ) ; » assert That « ( this . session . » sent Message « ) . » is Equal To « ( new » Text Message « ( " [ \" foo \" ] " ) ) ; }
@Test { connect ( response ( » Http Status « . OK , " o \n " ) , response ( » Http Status « . » INTERNAL _ SERVER _ ERROR « , " Oops " ) ) ; verify ( this . » web Socket Handler « ) . » after Connection Established « ( any ( ) ) ; verify ( this . » web Socket Handler « ) . » handle Transport Error « ( any ( ) , any ( ) ) ; verify ( this . » web Socket Handler « ) . » after Connection Closed « ( any ( ) , any ( ) ) ; » verify No More Interactions « ( this . » web Socket Handler « ) ; }
@Test { String body = " o \n " + " c [ 3000 , \" Go away ! \" ] \n " + " a [ \" foo \" ] \n " ; » Client Http Response « response = response ( » Http Status « . OK , body ) ; connect ( response ) ; verify ( this . » web Socket Handler « ) . » after Connection Established « ( any ( ) ) ; verify ( this . » web Socket Handler « ) . » after Connection Closed « ( any ( ) , any ( ) ) ; » verify No More Interactions « ( this . » web Socket Handler « ) ; verify ( response ) . close ( ) ; }
@Test { » Sock Js Url Info « info = new » Sock Js Url Info « ( new URI ( " https : » // example . com « " ) ) ; int » server Id « = Integer . » value Of « ( info . » get Server Id « ( ) ) ; » assert That « ( » server Id « >= 0 && » server Id « < 1000 ) . as ( " Invalid » server Id « : " + » server Id « ) . » is True « ( ) ; }
@Test { » Sock Js Url Info « info = new » Sock Js Url Info « ( new URI ( " https : » // example . com « " ) ) ; » assert That « ( info . » get Session Id « ( ) . length ( ) ) . as ( " Invalid » session Id « : " + info . » get Session Id « ( ) ) . » is Equal To « ( 32 ) ; }
@Test { » test Info Url « ( " http " , " http " ) ; » test Info Url « ( " http " , " http " ) ; » test Info Url « ( " https " , " https " ) ; » test Info Url « ( " https " , " https " ) ; » test Info Url « ( " ws " , " http " ) ; » test Info Url « ( " ws " , " http " ) ; » test Info Url « ( " wss " , " https " ) ; » test Info Url « ( " wss " , " https " ) ; }
@Test { » Sock Js Frame « frame = » Sock Js Frame « . » open Frame « ( ) ; » assert That « ( frame . » get Content « ( ) ) . » is Equal To « ( " o " ) ; » assert That « ( frame . » get Type « ( ) ) . » is Equal To « ( » Sock Js Frame Type « . OPEN ) ; » assert That « ( frame . » get Frame Data « ( ) ) . » is Null « ( ) ; }
@Test { » Sock Js Frame « frame = » Sock Js Frame « . » heartbeat Frame « ( ) ; » assert That « ( frame . » get Content « ( ) ) . » is Equal To « ( " h " ) ; » assert That « ( frame . » get Type « ( ) ) . » is Equal To « ( » Sock Js Frame Type « . HEARTBEAT ) ; » assert That « ( frame . » get Frame Data « ( ) ) . » is Null « ( ) ; }
@Test { » Sock Js Frame « frame = » Sock Js Frame « . » close Frame « ( 3000 , " Go Away ! " ) ; » assert That « ( frame . » get Content « ( ) ) . » is Equal To « ( " c [ 3000 , \" Go Away ! \" ] " ) ; » assert That « ( frame . » get Type « ( ) ) . » is Equal To « ( » Sock Js Frame Type « . CLOSE ) ; » assert That « ( frame . » get Frame Data « ( ) ) . » is Equal To « ( " [ 3000 , \" Go Away ! \" ] " ) ; }
@Test { this . » servlet Response « . » set Header « ( » Http Headers « . » ACCESS _ CONTROL _ ALLOW _ ORIGIN « , " foobar : 123 " ) ; » handle Request « ( " GET " , " / echo / info " , » Http Status « . OK ) ; » assert That « ( this . » servlet Response « . » get Header « ( » Http Headers « . » ACCESS _ CONTROL _ ALLOW _ ORIGIN « ) ) . » is Equal To « ( " foobar : 123 " ) ; }
@Test { this . » servlet Request « . » add Header « ( " If - None - Match " , " \" 00 96 » cbd 37 f 2 a 5218 c 33 bb 0826 a 7 c 74 cbf « \" " ) ; » reset Response And Handle Request « ( " GET " , " / echo / iframe . html " , » Http Status « . » NOT _ MODIFIED « ) ; }
@Test { this . » servlet Request « . » set Content Type « ( " " ) ; » reset Response And Handle Request « ( " GET " , " / echo / info " , » Http Status « . OK ) ; » assert That « ( this . » servlet Response « . » get Status « ( ) ) . as ( " Invalid / empty content should have been ignored " ) . » is Equal To « ( 200 ) ; }
@Test { » Xhr Receiving Transport Handler « » xhr Handler « = new » Xhr Receiving Transport Handler « ( ) ; » Default Sock Js Service « service = new » Default Sock Js Service « ( mock ( » Task Scheduler « . class ) , » xhr Handler « ) ; Map < » Transport Type « , » Transport Handler « > handlers = service . » get Transport Handlers « ( ) ; » assert That « ( handlers . size ( ) ) . » is Equal To « ( 6 ) ; » assert That « ( handlers . get ( » xhr Handler « . » get Transport Type « ( ) ) ) . » is Same As « ( » xhr Handler « ) ; }
@Test { » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> this . service . » set Allowed Origins « ( null ) ) ; }
@Test { » Transport Handling Sock Js Service « service = new » Transport Handling Sock Js Service « ( mock ( » Task Scheduler « . class ) , new » Xhr Polling Transport Handler « ( ) , new » Xhr Receiving Transport Handler « ( ) ) ; Map < » Transport Type « , » Transport Handler « > » actual Handlers « = service . » get Transport Handlers « ( ) ; » assert That « ( » actual Handlers « . size ( ) ) . » is Equal To « ( 2 ) ; }
@Test { String » sock Js Path « = » session Url Prefix « + " eventsource " ; » set Request « ( " POST " , » sock Js Prefix « + » sock Js Path « ) ; this . service . » handle Request « ( this . request , this . response , » sock Js Path « , this . » ws Handler « ) ; » assert That « ( this . » servlet Response « . » get Status « ( ) ) . » is Equal To « ( 404 ) ; }
@Test { this . » servlet Request « . » set Content « ( " [ \" x \" ] " . » get Bytes « ( " UTF - 8 " ) ) ; » handle Request « ( new » Xhr Receiving Transport Handler « ( ) ) ; » assert That « ( this . » servlet Response « . » get Status « ( ) ) . » is Equal To « ( 204 ) ; }
@Test { this . » servlet Request « . » set Content « ( " " . » get Bytes « ( " UTF - 8 " ) ) ; » handle Request And Expect Failure « ( ) ; this . » servlet Request « . » set Content « ( " [ \" x ] " . » get Bytes « ( " UTF - 8 " ) ) ; » handle Request And Expect Failure « ( ) ; }
@Test { » Web Socket Handler « » web Socket Handler « = mock ( » Web Socket Handler « . class ) ; » assert That Illegal Argument Exception « ( ) . » is Thrown By « ( ( ) -> new » Xhr Receiving Transport Handler « ( ) . » handle Request « ( this . request , this . response , » web Socket Handler « , null ) ) ; }
@Test { this . session . » handle Initial Request « ( this . request , this . response , this . » frame Format « ) ; » assert That « ( this . » servlet Response « . » get Content As String « ( ) ) . » is Equal To « ( " hhh \n o " ) ; » assert That « ( this . » servlet Request « . » is Async Started « ( ) ) . » is True « ( ) ; verify ( this . » web Socket Handler « ) . » after Connection Established « ( this . session ) ; }
@Test { » assert That « ( this . session . » is Active « ( ) ) . » is False « ( ) ; this . session . » initialize Delegate Session « ( this . » web Socket Session « ) ; » assert That « ( this . session . » is Active « ( ) ) . » is True « ( ) ; this . » web Socket Session « . » set Open « ( false ) ; » assert That « ( this . session . » is Active « ( ) ) . » is False « ( ) ; }
@Test { this . session . » initialize Delegate Session « ( this . » web Socket Session « ) ; » assert That « ( this . » web Socket Session « . » get Sent Messages « ( ) ) . » is Equal To « ( Collections . » singleton List « ( new » Text Message « ( " o " ) ) ) ; » assert That « ( this . session . » heartbeat Scheduling Events « ) . » is Equal To « ( Arrays . » as List « ( " schedule " ) ) ; verify ( this . » web Socket Handler « ) . » after Connection Established « ( this . session ) ; » verify No More Interactions « ( this . » task Scheduler « , this . » web Socket Handler « ) ; }
@Test { this . session . » handle Message « ( new » Text Message « ( " " ) , this . » web Socket Session « ) ; » verify No More Interactions « ( this . » web Socket Handler « ) ; }
@Test { » Text Message « message = new » Text Message « ( " [ \" x \" ] " ) ; this . session . » handle Message « ( message , this . » web Socket Session « ) ; verify ( this . » web Socket Handler « ) . » handle Message « ( this . session , new » Text Message « ( " x " ) ) ; » verify No More Interactions « ( this . » web Socket Handler « ) ; }
@Test { » Text Message « message = new » Text Message « ( " [ \" x ] " ) ; this . session . » handle Message « ( message , this . » web Socket Session « ) ; this . session . » is Closed « ( ) ; verify ( this . » web Socket Handler « ) . » handle Transport Error « ( same ( this . session ) , any ( » IO Exception « . class ) ) ; » verify No More Interactions « ( this . » web Socket Handler « ) ; }
@Test { this . session . » initialize Delegate Session « ( this . » web Socket Session « ) ; this . session . » send Message Internal « ( " x " ) ; » assert That « ( this . » web Socket Session « . » get Sent Messages « ( ) ) . » is Equal To « ( Arrays . » as List « ( new » Text Message « ( " o " ) , new » Text Message « ( " a [ \" x \" ] " ) ) ) ; » assert That « ( this . session . » heartbeat Scheduling Events « ) . » is Equal To « ( Arrays . » as List « ( " schedule " , " cancel " , " schedule " ) ) ; }
@Test { this . session . » initialize Delegate Session « ( this . » web Socket Session « ) ; this . session . close ( » Close Status « . » NOT _ ACCEPTABLE « ) ; » assert That « ( this . » web Socket Session « . » get Close Status « ( ) ) . » is Equal To « ( » Close Status « . » NOT _ ACCEPTABLE « ) ; }
@Test { » assert New « ( ) ; this . session . » delegate Connection Established « ( ) ; » assert Open « ( ) ; verify ( this . » web Socket Handler « ) . » after Connection Established « ( this . session ) ; }
@Test { Exception ex = new Exception ( ) ; this . session . » delegate Error « ( ex ) ; verify ( this . » web Socket Handler « ) . » handle Transport Error « ( this . session , ex ) ; }
@Test { String » msg 1 « = " message 1 " ; String » msg 2 « = " message 2 " ; this . session . » delegate Messages « ( » msg 1 « , » msg 2 « ) ; verify ( this . » web Socket Handler « ) . » handle Message « ( this . session , new » Text Message « ( » msg 1 « ) ) ; verify ( this . » web Socket Handler « ) . » handle Message « ( this . session , new » Text Message « ( » msg 2 « ) ) ; » verify No More Interactions « ( this . » web Socket Handler « ) ; }
@Test { this . session . » delegate Connection Established « ( ) ; this . session . » delegate Connection Closed « ( » Close Status « . » GOING _ AWAY « ) ; » assert Closed « ( ) ; » assert That « ( this . session . » get Number Of Last Active Time Updates « ( ) ) . » is Equal To « ( 1 ) ; verify ( this . » web Socket Handler « ) . » after Connection Closed « ( this . session , » Close Status « . » GOING _ AWAY « ) ; }
@Test { this . session . » delegate Connection Established « ( ) ; » assert Open « ( ) ; this . session . » set Active « ( false ) ; this . session . close ( ) ; » assert That « ( this . session . » get Sock Js Frames Written « ( ) ) . » is Equal To « ( Collections . » empty List « ( ) ) ; }
@Test { this . session . » set Exception On Write « ( new » IO Exception « ( ) ) ; this . session . » delegate Connection Established « ( ) ; this . session . » set Active « ( true ) ; this . session . close ( ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Equal To « ( new » Close Status « ( 3000 , " Go away ! " ) ) ; » assert Closed « ( ) ; }
@Test { » will Throw « ( new Exception ( ) ) . given ( this . » web Socket Handler « ) . » after Connection Closed « ( this . session , » Close Status « . NORMAL ) ; this . session . » delegate Connection Established « ( ) ; this . session . » set Active « ( true ) ; this . session . close ( » Close Status « . NORMAL ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Equal To « ( » Close Status « . NORMAL ) ; » assert Closed « ( ) ; }
@Test { this . session . » delegate Connection Established « ( ) ; this . session . » set Active « ( true ) ; this . session . » try Close With Sock Js Transport Error « ( new Exception ( ) , » Close Status « . » BAD _ DATA « ) ; » assert That « ( this . session . » get Close Status « ( ) ) . » is Equal To « ( » Close Status « . » BAD _ DATA « ) ; » assert Closed « ( ) ; }
@Test { this . session . » write Frame « ( » Sock Js Frame « . » open Frame « ( ) ) ; » assert That « ( this . session . » get Sock Js Frames Written « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . session . » get Sock Js Frames Written « ( ) . get ( 0 ) ) . » is Equal To « ( » Sock Js Frame « . » open Frame « ( ) ) ; }
@Test { this . session . » set Active « ( true ) ; this . session . » send Heartbeat « ( ) ; » assert That « ( this . session . » get Sock Js Frames Written « ( ) . size ( ) ) . » is Equal To « ( 1 ) ; » assert That « ( this . session . » get Sock Js Frames Written « ( ) . get ( 0 ) ) . » is Equal To « ( » Sock Js Frame « . » heartbeat Frame « ( ) ) ; verify ( this . » task Scheduler « ) . schedule ( any ( Runnable . class ) , any ( Date . class ) ) ; » verify No More Interactions « ( this . » task Scheduler « ) ; }
@Test { this . session . » set Active « ( false ) ; this . session . » schedule Heartbeat « ( ) ; » verify No More Interactions « ( this . » task Scheduler « ) ; }
@Test { this . session . » disable Heartbeat « ( ) ; this . session . » set Active « ( true ) ; this . session . » send Heartbeat « ( ) ; » assert That « ( this . session . » get Sock Js Frames Written « ( ) ) . » is Equal To « ( Collections . » empty List « ( ) ) ; }
